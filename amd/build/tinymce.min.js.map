{"version":3,"file":"tinymce.min.js","sources":["../src/tinymce.js"],"sourcesContent":["/**\n * TinyMCE version 6.8.3 (2024-02-08)\n */\n/* eslint-disable */\n(function () {\n    'use strict';\n\n    var typeOf$1 = function (x) {\n      if (x === null) {\n        return 'null';\n      }\n      if (x === undefined) {\n        return 'undefined';\n      }\n      var t = typeof x;\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\n        return 'array';\n      }\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\n        return 'string';\n      }\n      return t;\n    };\n    var isEquatableType = function (x) {\n      return [\n        'undefined',\n        'boolean',\n        'number',\n        'string',\n        'function',\n        'xml',\n        'null'\n      ].indexOf(x) !== -1;\n    };\n\n    var sort$1 = function (xs, compareFn) {\n      var clone = Array.prototype.slice.call(xs);\n      return clone.sort(compareFn);\n    };\n\n    var contramap = function (eqa, f) {\n      return eq$2(function (x, y) {\n        return eqa.eq(f(x), f(y));\n      });\n    };\n    var eq$2 = function (f) {\n      return { eq: f };\n    };\n    var tripleEq = eq$2(function (x, y) {\n      return x === y;\n    });\n    var eqString = tripleEq;\n    var eqArray = function (eqa) {\n      return eq$2(function (x, y) {\n        if (x.length !== y.length) {\n          return false;\n        }\n        var len = x.length;\n        for (var i = 0; i < len; i++) {\n          if (!eqa.eq(x[i], y[i])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqSortedArray = function (eqa, compareFn) {\n      return contramap(eqArray(eqa), function (xs) {\n        return sort$1(xs, compareFn);\n      });\n    };\n    var eqRecord = function (eqa) {\n      return eq$2(function (x, y) {\n        var kx = Object.keys(x);\n        var ky = Object.keys(y);\n        if (!eqSortedArray(eqString).eq(kx, ky)) {\n          return false;\n        }\n        var len = kx.length;\n        for (var i = 0; i < len; i++) {\n          var q = kx[i];\n          if (!eqa.eq(x[q], y[q])) {\n            return false;\n          }\n        }\n        return true;\n      });\n    };\n    var eqAny = eq$2(function (x, y) {\n      if (x === y) {\n        return true;\n      }\n      var tx = typeOf$1(x);\n      var ty = typeOf$1(y);\n      if (tx !== ty) {\n        return false;\n      }\n      if (isEquatableType(tx)) {\n        return x === y;\n      } else if (tx === 'array') {\n        return eqArray(eqAny).eq(x, y);\n      } else if (tx === 'object') {\n        return eqRecord(eqAny).eq(x, y);\n      }\n      return false;\n    });\n\n    const getPrototypeOf$2 = Object.getPrototypeOf;\n    const hasProto = (v, constructor, predicate) => {\n      var _a;\n      if (predicate(v, constructor.prototype)) {\n        return true;\n      } else {\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\n      }\n    };\n    const typeOf = x => {\n      const t = typeof x;\n      if (x === null) {\n        return 'null';\n      } else if (t === 'object' && Array.isArray(x)) {\n        return 'array';\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\n        return 'string';\n      } else {\n        return t;\n      }\n    };\n    const isType$1 = type => value => typeOf(value) === type;\n    const isSimpleType = type => value => typeof value === type;\n    const eq$1 = t => a => t === a;\n    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);\n    const isString = isType$1('string');\n    const isObject = isType$1('object');\n    const isPlainObject = value => is$4(value, Object);\n    const isArray$1 = isType$1('array');\n    const isNull = eq$1(null);\n    const isBoolean = isSimpleType('boolean');\n    const isUndefined = eq$1(undefined);\n    const isNullable = a => a === null || a === undefined;\n    const isNonNullable = a => !isNullable(a);\n    const isFunction = isSimpleType('function');\n    const isNumber = isSimpleType('number');\n    const isArrayOf = (value, pred) => {\n      if (isArray$1(value)) {\n        for (let i = 0, len = value.length; i < len; ++i) {\n          if (!pred(value[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    };\n\n    const noop = () => {\n    };\n    const compose = (fa, fb) => {\n      return (...args) => {\n        return fa(fb.apply(null, args));\n      };\n    };\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\n    const constant = value => {\n      return () => {\n        return value;\n      };\n    };\n    const identity = x => {\n      return x;\n    };\n    const tripleEquals = (a, b) => {\n      return a === b;\n    };\n    function curry(fn, ...initialArgs) {\n      return (...restArgs) => {\n        const all = initialArgs.concat(restArgs);\n        return fn.apply(null, all);\n      };\n    }\n    const not = f => t => !f(t);\n    const die = msg => {\n      return () => {\n        throw new Error(msg);\n      };\n    };\n    const apply$1 = f => {\n      return f();\n    };\n    const call = f => {\n      f();\n    };\n    const never = constant(false);\n    const always = constant(true);\n\n    class Optional {\n      constructor(tag, value) {\n        this.tag = tag;\n        this.value = value;\n      }\n      static some(value) {\n        return new Optional(true, value);\n      }\n      static none() {\n        return Optional.singletonNone;\n      }\n      fold(onNone, onSome) {\n        if (this.tag) {\n          return onSome(this.value);\n        } else {\n          return onNone();\n        }\n      }\n      isSome() {\n        return this.tag;\n      }\n      isNone() {\n        return !this.tag;\n      }\n      map(mapper) {\n        if (this.tag) {\n          return Optional.some(mapper(this.value));\n        } else {\n          return Optional.none();\n        }\n      }\n      bind(binder) {\n        if (this.tag) {\n          return binder(this.value);\n        } else {\n          return Optional.none();\n        }\n      }\n      exists(predicate) {\n        return this.tag && predicate(this.value);\n      }\n      forall(predicate) {\n        return !this.tag || predicate(this.value);\n      }\n      filter(predicate) {\n        if (!this.tag || predicate(this.value)) {\n          return this;\n        } else {\n          return Optional.none();\n        }\n      }\n      getOr(replacement) {\n        return this.tag ? this.value : replacement;\n      }\n      or(replacement) {\n        return this.tag ? this : replacement;\n      }\n      getOrThunk(thunk) {\n        return this.tag ? this.value : thunk();\n      }\n      orThunk(thunk) {\n        return this.tag ? this : thunk();\n      }\n      getOrDie(message) {\n        if (!this.tag) {\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\n        } else {\n          return this.value;\n        }\n      }\n      static from(value) {\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\n      }\n      getOrNull() {\n        return this.tag ? this.value : null;\n      }\n      getOrUndefined() {\n        return this.value;\n      }\n      each(worker) {\n        if (this.tag) {\n          worker(this.value);\n        }\n      }\n      toArray() {\n        return this.tag ? [this.value] : [];\n      }\n      toString() {\n        return this.tag ? `some(${ this.value })` : 'none()';\n      }\n    }\n    Optional.singletonNone = new Optional(false);\n\n    const nativeSlice = Array.prototype.slice;\n    const nativeIndexOf = Array.prototype.indexOf;\n    const nativePush = Array.prototype.push;\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\n    const indexOf$1 = (xs, x) => {\n      const r = rawIndexOf(xs, x);\n      return r === -1 ? Optional.none() : Optional.some(r);\n    };\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\n    const exists = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const map$3 = (xs, f) => {\n      const len = xs.length;\n      const r = new Array(len);\n      for (let i = 0; i < len; i++) {\n        const x = xs[i];\n        r[i] = f(x, i);\n      }\n      return r;\n    };\n    const each$e = (xs, f) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const eachr = (xs, f) => {\n      for (let i = xs.length - 1; i >= 0; i--) {\n        const x = xs[i];\n        f(x, i);\n      }\n    };\n    const partition$2 = (xs, pred) => {\n      const pass = [];\n      const fail = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        const arr = pred(x, i) ? pass : fail;\n        arr.push(x);\n      }\n      return {\n        pass,\n        fail\n      };\n    };\n    const filter$5 = (xs, pred) => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n    const foldr = (xs, f, acc) => {\n      eachr(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const foldl = (xs, f, acc) => {\n      each$e(xs, (x, i) => {\n        acc = f(acc, x, i);\n      });\n      return acc;\n    };\n    const findUntil$1 = (xs, pred, until) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(x);\n        } else if (until(x, i)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const find$2 = (xs, pred) => {\n      return findUntil$1(xs, pred, never);\n    };\n    const findIndex$2 = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (pred(x, i)) {\n          return Optional.some(i);\n        }\n      }\n      return Optional.none();\n    };\n    const flatten = xs => {\n      const r = [];\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        if (!isArray$1(xs[i])) {\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\n        }\n        nativePush.apply(r, xs[i]);\n      }\n      return r;\n    };\n    const bind$3 = (xs, f) => flatten(map$3(xs, f));\n    const forall = (xs, pred) => {\n      for (let i = 0, len = xs.length; i < len; ++i) {\n        const x = xs[i];\n        if (pred(x, i) !== true) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const reverse = xs => {\n      const r = nativeSlice.call(xs, 0);\n      r.reverse();\n      return r;\n    };\n    const difference = (a1, a2) => filter$5(a1, x => !contains$2(a2, x));\n    const mapToObject = (xs, f) => {\n      const r = {};\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        r[String(x)] = f(x, i);\n      }\n      return r;\n    };\n    const sort = (xs, comparator) => {\n      const copy = nativeSlice.call(xs, 0);\n      copy.sort(comparator);\n      return copy;\n    };\n    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\n    const head = xs => get$b(xs, 0);\n    const last$3 = xs => get$b(xs, xs.length - 1);\n    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\n    const findMap = (arr, f) => {\n      for (let i = 0; i < arr.length; i++) {\n        const r = f(arr[i], i);\n        if (r.isSome()) {\n          return r;\n        }\n      }\n      return Optional.none();\n    };\n    const unique$1 = (xs, comparator) => {\n      const r = [];\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\n      for (let i = 0, len = xs.length; i < len; i++) {\n        const x = xs[i];\n        if (!isDuplicated(x)) {\n          r.push(x);\n        }\n      }\n      return r;\n    };\n\n    const keys = Object.keys;\n    const hasOwnProperty$1 = Object.hasOwnProperty;\n    const each$d = (obj, f) => {\n      const props = keys(obj);\n      for (let k = 0, len = props.length; k < len; k++) {\n        const i = props[k];\n        const x = obj[i];\n        f(x, i);\n      }\n    };\n    const map$2 = (obj, f) => {\n      return tupleMap(obj, (x, i) => ({\n        k: i,\n        v: f(x, i)\n      }));\n    };\n    const tupleMap = (obj, f) => {\n      const r = {};\n      each$d(obj, (x, i) => {\n        const tuple = f(x, i);\n        r[tuple.k] = tuple.v;\n      });\n      return r;\n    };\n    const objAcc = r => (x, i) => {\n      r[i] = x;\n    };\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\n      each$d(obj, (x, i) => {\n        (pred(x, i) ? onTrue : onFalse)(x, i);\n      });\n    };\n    const bifilter = (obj, pred) => {\n      const t = {};\n      const f = {};\n      internalFilter(obj, pred, objAcc(t), objAcc(f));\n      return {\n        t,\n        f\n      };\n    };\n    const filter$4 = (obj, pred) => {\n      const t = {};\n      internalFilter(obj, pred, objAcc(t), noop);\n      return t;\n    };\n    const mapToArray = (obj, f) => {\n      const r = [];\n      each$d(obj, (value, name) => {\n        r.push(f(value, name));\n      });\n      return r;\n    };\n    const values = obj => {\n      return mapToArray(obj, identity);\n    };\n    const get$a = (obj, key) => {\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\n    };\n    const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);\n    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\n    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);\n\n    const stringArray = a => {\n      const all = {};\n      each$e(a, key => {\n        all[key] = {};\n      });\n      return keys(all);\n    };\n\n    const isArrayLike = o => o.length !== undefined;\n    const isArray = Array.isArray;\n    const toArray$1 = obj => {\n      if (!isArray(obj)) {\n        const array = [];\n        for (let i = 0, l = obj.length; i < l; i++) {\n          array[i] = obj[i];\n        }\n        return array;\n      } else {\n        return obj;\n      }\n    };\n    const each$c = (o, cb, s) => {\n      if (!o) {\n        return false;\n      }\n      s = s || o;\n      if (isArrayLike(o)) {\n        for (let n = 0, l = o.length; n < l; n++) {\n          if (cb.call(s, o[n], n, o) === false) {\n            return false;\n          }\n        }\n      } else {\n        for (const n in o) {\n          if (has$2(o, n)) {\n            if (cb.call(s, o[n], n, o) === false) {\n              return false;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const map$1 = (array, callback) => {\n      const out = [];\n      each$c(array, (item, index) => {\n        out.push(callback(item, index, array));\n      });\n      return out;\n    };\n    const filter$3 = (a, f) => {\n      const o = [];\n      each$c(a, (v, index) => {\n        if (!f || f(v, index, a)) {\n          o.push(v);\n        }\n      });\n      return o;\n    };\n    const indexOf = (a, v) => {\n      if (a) {\n        for (let i = 0, l = a.length; i < l; i++) {\n          if (a[i] === v) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const reduce = (collection, iteratee, accumulator, thisArg) => {\n      let acc = isUndefined(accumulator) ? collection[0] : accumulator;\n      for (let i = 0; i < collection.length; i++) {\n        acc = iteratee.call(thisArg, acc, collection[i], i);\n      }\n      return acc;\n    };\n    const findIndex$1 = (array, predicate, thisArg) => {\n      for (let i = 0, l = array.length; i < l; i++) {\n        if (predicate.call(thisArg, array[i], i, array)) {\n          return i;\n        }\n      }\n      return -1;\n    };\n    const last$2 = collection => collection[collection.length - 1];\n\n    const cached = f => {\n      let called = false;\n      let r;\n      return (...args) => {\n        if (!called) {\n          called = true;\n          r = f.apply(null, args);\n        }\n        return r;\n      };\n    };\n\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\n      const isiPhone = os.isiOS() && !isiPad;\n      const isMobile = os.isiOS() || os.isAndroid();\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\n      const isPhone = isiPhone || isMobile && !isTablet;\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\n      return {\n        isiPad: constant(isiPad),\n        isiPhone: constant(isiPhone),\n        isTablet: constant(isTablet),\n        isPhone: constant(isPhone),\n        isTouch: constant(isTouch),\n        isAndroid: os.isAndroid,\n        isiOS: os.isiOS,\n        isWebView: constant(iOSwebview),\n        isDesktop: constant(isDesktop)\n      };\n    };\n\n    const firstMatch = (regexes, s) => {\n      for (let i = 0; i < regexes.length; i++) {\n        const x = regexes[i];\n        if (x.test(s)) {\n          return x;\n        }\n      }\n      return undefined;\n    };\n    const find$1 = (regexes, agent) => {\n      const r = firstMatch(regexes, agent);\n      if (!r) {\n        return {\n          major: 0,\n          minor: 0\n        };\n      }\n      const group = i => {\n        return Number(agent.replace(r, '$' + i));\n      };\n      return nu$3(group(1), group(2));\n    };\n    const detect$5 = (versionRegexes, agent) => {\n      const cleanedAgent = String(agent).toLowerCase();\n      if (versionRegexes.length === 0) {\n        return unknown$2();\n      }\n      return find$1(versionRegexes, cleanedAgent);\n    };\n    const unknown$2 = () => {\n      return nu$3(0, 0);\n    };\n    const nu$3 = (major, minor) => {\n      return {\n        major,\n        minor\n      };\n    };\n    const Version = {\n      nu: nu$3,\n      detect: detect$5,\n      unknown: unknown$2\n    };\n\n    const detectBrowser$1 = (browsers, userAgentData) => {\n      return findMap(userAgentData.brands, uaBrand => {\n        const lcBrand = uaBrand.brand.toLowerCase();\n        return find$2(browsers, browser => {\n          var _a;\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\n        }).map(info => ({\n          current: info.name,\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\n        }));\n      });\n    };\n\n    const detect$4 = (candidates, userAgent) => {\n      const agent = String(userAgent).toLowerCase();\n      return find$2(candidates, candidate => {\n        return candidate.search(agent);\n      });\n    };\n    const detectBrowser = (browsers, userAgent) => {\n      return detect$4(browsers, userAgent).map(browser => {\n        const version = Version.detect(browser.versionRegexes, userAgent);\n        return {\n          current: browser.name,\n          version\n        };\n      });\n    };\n    const detectOs = (oses, userAgent) => {\n      return detect$4(oses, userAgent).map(os => {\n        const version = Version.detect(os.versionRegexes, userAgent);\n        return {\n          current: os.name,\n          version\n        };\n      });\n    };\n\n    const removeFromStart = (str, numChars) => {\n      return str.substring(numChars);\n    };\n\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\n    const removeLeading = (str, prefix) => {\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\n    };\n    const contains$1 = (str, substr, start = 0, end) => {\n      const idx = str.indexOf(substr, start);\n      if (idx !== -1) {\n        return isUndefined(end) ? true : idx + substr.length <= end;\n      } else {\n        return false;\n      }\n    };\n    const startsWith = (str, prefix) => {\n      return checkRange(str, prefix, 0);\n    };\n    const endsWith = (str, suffix) => {\n      return checkRange(str, suffix, str.length - suffix.length);\n    };\n    const blank = r => s => s.replace(r, '');\n    const trim$4 = blank(/^\\s+|\\s+$/g);\n    const lTrim = blank(/^\\s+/g);\n    const rTrim = blank(/\\s+$/g);\n    const isNotEmpty = s => s.length > 0;\n    const isEmpty$3 = s => !isNotEmpty(s);\n    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\n    const toInt = (value, radix = 10) => {\n      const num = parseInt(value, radix);\n      return isNaN(num) ? Optional.none() : Optional.some(num);\n    };\n\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\n    const checkContains = target => {\n      return uastring => {\n        return contains$1(uastring, target);\n      };\n    };\n    const browsers = [\n      {\n        name: 'Edge',\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\n        search: uastring => {\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\n        }\n      },\n      {\n        name: 'Chromium',\n        brand: 'Chromium',\n        versionRegexes: [\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\n          normalVersionRegex\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\n        }\n      },\n      {\n        name: 'IE',\n        versionRegexes: [\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\n        ],\n        search: uastring => {\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\n        }\n      },\n      {\n        name: 'Opera',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\n        ],\n        search: checkContains('opera')\n      },\n      {\n        name: 'Firefox',\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\n        search: checkContains('firefox')\n      },\n      {\n        name: 'Safari',\n        versionRegexes: [\n          normalVersionRegex,\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\n        ],\n        search: uastring => {\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\n        }\n      }\n    ];\n    const oses = [\n      {\n        name: 'Windows',\n        search: checkContains('win'),\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'iOS',\n        search: uastring => {\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\n        },\n        versionRegexes: [\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\n        ]\n      },\n      {\n        name: 'Android',\n        search: checkContains('android'),\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\n      },\n      {\n        name: 'macOS',\n        search: checkContains('mac os x'),\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\n      },\n      {\n        name: 'Linux',\n        search: checkContains('linux'),\n        versionRegexes: []\n      },\n      {\n        name: 'Solaris',\n        search: checkContains('sunos'),\n        versionRegexes: []\n      },\n      {\n        name: 'FreeBSD',\n        search: checkContains('freebsd'),\n        versionRegexes: []\n      },\n      {\n        name: 'ChromeOS',\n        search: checkContains('cros'),\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\n      }\n    ];\n    const PlatformInfo = {\n      browsers: constant(browsers),\n      oses: constant(oses)\n    };\n\n    const edge = 'Edge';\n    const chromium = 'Chromium';\n    const ie = 'IE';\n    const opera = 'Opera';\n    const firefox = 'Firefox';\n    const safari = 'Safari';\n    const unknown$1 = () => {\n      return nu$2({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$2 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isBrowser = name => () => current === name;\n      return {\n        current,\n        version,\n        isEdge: isBrowser(edge),\n        isChromium: isBrowser(chromium),\n        isIE: isBrowser(ie),\n        isOpera: isBrowser(opera),\n        isFirefox: isBrowser(firefox),\n        isSafari: isBrowser(safari)\n      };\n    };\n    const Browser = {\n      unknown: unknown$1,\n      nu: nu$2,\n      edge: constant(edge),\n      chromium: constant(chromium),\n      ie: constant(ie),\n      opera: constant(opera),\n      firefox: constant(firefox),\n      safari: constant(safari)\n    };\n\n    const windows = 'Windows';\n    const ios = 'iOS';\n    const android = 'Android';\n    const linux = 'Linux';\n    const macos = 'macOS';\n    const solaris = 'Solaris';\n    const freebsd = 'FreeBSD';\n    const chromeos = 'ChromeOS';\n    const unknown = () => {\n      return nu$1({\n        current: undefined,\n        version: Version.unknown()\n      });\n    };\n    const nu$1 = info => {\n      const current = info.current;\n      const version = info.version;\n      const isOS = name => () => current === name;\n      return {\n        current,\n        version,\n        isWindows: isOS(windows),\n        isiOS: isOS(ios),\n        isAndroid: isOS(android),\n        isMacOS: isOS(macos),\n        isLinux: isOS(linux),\n        isSolaris: isOS(solaris),\n        isFreeBSD: isOS(freebsd),\n        isChromeOS: isOS(chromeos)\n      };\n    };\n    const OperatingSystem = {\n      unknown,\n      nu: nu$1,\n      windows: constant(windows),\n      ios: constant(ios),\n      android: constant(android),\n      linux: constant(linux),\n      macos: constant(macos),\n      solaris: constant(solaris),\n      freebsd: constant(freebsd),\n      chromeos: constant(chromeos)\n    };\n\n    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\n      const browsers = PlatformInfo.browsers();\n      const oses = PlatformInfo.oses();\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\n      return {\n        browser,\n        os,\n        deviceType\n      };\n    };\n    const PlatformDetection = { detect: detect$3 };\n\n    const mediaMatch = query => window.matchMedia(query).matches;\n    let platform$4 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\n    const detect$2 = () => platform$4();\n\n    const userAgent = navigator.userAgent;\n    const platform$3 = detect$2();\n    const browser$3 = platform$3.browser;\n    const os$1 = platform$3.os;\n    const deviceType = platform$3.deviceType;\n    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\n    const Env = {\n      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\n      documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,\n      cacheSuffix: null,\n      container: null,\n      canHaveCSP: !browser$3.isIE(),\n      windowsPhone,\n      browser: {\n        current: browser$3.current,\n        version: browser$3.version,\n        isChromium: browser$3.isChromium,\n        isEdge: browser$3.isEdge,\n        isFirefox: browser$3.isFirefox,\n        isIE: browser$3.isIE,\n        isOpera: browser$3.isOpera,\n        isSafari: browser$3.isSafari\n      },\n      os: {\n        current: os$1.current,\n        version: os$1.version,\n        isAndroid: os$1.isAndroid,\n        isChromeOS: os$1.isChromeOS,\n        isFreeBSD: os$1.isFreeBSD,\n        isiOS: os$1.isiOS,\n        isLinux: os$1.isLinux,\n        isMacOS: os$1.isMacOS,\n        isSolaris: os$1.isSolaris,\n        isWindows: os$1.isWindows\n      },\n      deviceType: {\n        isDesktop: deviceType.isDesktop,\n        isiPad: deviceType.isiPad,\n        isiPhone: deviceType.isiPhone,\n        isPhone: deviceType.isPhone,\n        isTablet: deviceType.isTablet,\n        isTouch: deviceType.isTouch,\n        isWebView: deviceType.isWebView\n      }\n    };\n\n    const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\n    const trim$3 = str => {\n      return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\n    };\n    const is$3 = (obj, type) => {\n      if (!type) {\n        return obj !== undefined;\n      }\n      if (type === 'array' && isArray(obj)) {\n        return true;\n      }\n      return typeof obj === type;\n    };\n    const makeMap$4 = (items, delim, map = {}) => {\n      const resolvedItems = isString(items) ? items.split(delim || ',') : items || [];\n      let i = resolvedItems.length;\n      while (i--) {\n        map[resolvedItems[i]] = {};\n      }\n      return map;\n    };\n    const hasOwnProperty = has$2;\n    const extend$3 = (obj, ...exts) => {\n      for (let i = 0; i < exts.length; i++) {\n        const ext = exts[i];\n        for (const name in ext) {\n          if (has$2(ext, name)) {\n            const value = ext[name];\n            if (value !== undefined) {\n              obj[name] = value;\n            }\n          }\n        }\n      }\n      return obj;\n    };\n    const walk$4 = function (o, f, n, s) {\n      s = s || this;\n      if (o) {\n        if (n) {\n          o = o[n];\n        }\n        each$c(o, (o, i) => {\n          if (f.call(s, o, i, n) === false) {\n            return false;\n          } else {\n            walk$4(o, f, n, s);\n            return true;\n          }\n        });\n      }\n    };\n    const resolve$3 = (n, o = window) => {\n      const path = n.split('.');\n      for (let i = 0, l = path.length; i < l; i++) {\n        o = o[path[i]];\n        if (!o) {\n          break;\n        }\n      }\n      return o;\n    };\n    const explode$3 = (s, d) => {\n      if (isArray$1(s)) {\n        return s;\n      } else if (s === '') {\n        return [];\n      } else {\n        return map$1(s.split(d || ','), trim$3);\n      }\n    };\n    const _addCacheSuffix = url => {\n      const cacheSuffix = Env.cacheSuffix;\n      if (cacheSuffix) {\n        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\n      }\n      return url;\n    };\n    const Tools = {\n      trim: trim$3,\n      isArray: isArray,\n      is: is$3,\n      toArray: toArray$1,\n      makeMap: makeMap$4,\n      each: each$c,\n      map: map$1,\n      grep: filter$3,\n      inArray: indexOf,\n      hasOwn: hasOwnProperty,\n      extend: extend$3,\n      walk: walk$4,\n      resolve: resolve$3,\n      explode: explode$3,\n      _addCacheSuffix\n    };\n\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\n    const cat = arr => {\n      const r = [];\n      const push = x => {\n        r.push(x);\n      };\n      for (let i = 0; i < arr.length; i++) {\n        arr[i].each(push);\n      }\n      return r;\n    };\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\n    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\n\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\n\n    const path = (parts, scope) => {\n      let o = scope !== undefined && scope !== null ? scope : Global;\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\n        o = o[parts[i]];\n      }\n      return o;\n    };\n    const resolve$2 = (p, scope) => {\n      const parts = p.split('.');\n      return path(parts, scope);\n    };\n\n    const unsafe = (name, scope) => {\n      return resolve$2(name, scope);\n    };\n    const getOrDie = (name, scope) => {\n      const actual = unsafe(name, scope);\n      if (actual === undefined || actual === null) {\n        throw new Error(name + ' not available on this browser');\n      }\n      return actual;\n    };\n\n    const getPrototypeOf$1 = Object.getPrototypeOf;\n    const sandHTMLElement = scope => {\n      return getOrDie('HTMLElement', scope);\n    };\n    const isPrototypeOf = x => {\n      const scope = resolve$2('ownerDocument.defaultView', x);\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf$1(x).constructor.name));\n    };\n\n    const COMMENT = 8;\n    const DOCUMENT = 9;\n    const DOCUMENT_FRAGMENT = 11;\n    const ELEMENT = 1;\n    const TEXT = 3;\n\n    const name = element => {\n      const r = element.dom.nodeName;\n      return r.toLowerCase();\n    };\n    const type$1 = element => element.dom.nodeType;\n    const isType = t => element => type$1(element) === t;\n    const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\n    const isHTMLElement$1 = element => isElement$7(element) && isPrototypeOf(element.dom);\n    const isElement$7 = isType(ELEMENT);\n    const isText$b = isType(TEXT);\n    const isDocument$2 = isType(DOCUMENT);\n    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\n    const isTag = tag => e => isElement$7(e) && name(e) === tag;\n\n    const rawSet = (dom, key, value) => {\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\n        dom.setAttribute(key, value + '');\n      } else {\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\n        throw new Error('Attribute value was not simple');\n      }\n    };\n    const set$3 = (element, key, value) => {\n      rawSet(element.dom, key, value);\n    };\n    const setAll$1 = (element, attrs) => {\n      const dom = element.dom;\n      each$d(attrs, (v, k) => {\n        rawSet(dom, k, v);\n      });\n    };\n    const get$9 = (element, key) => {\n      const v = element.dom.getAttribute(key);\n      return v === null ? undefined : v;\n    };\n    const getOpt = (element, key) => Optional.from(get$9(element, key));\n    const has$1 = (element, key) => {\n      const dom = element.dom;\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\n    };\n    const remove$a = (element, key) => {\n      element.dom.removeAttribute(key);\n    };\n    const hasNone = element => {\n      const attrs = element.dom.attributes;\n      return attrs === undefined || attrs === null || attrs.length === 0;\n    };\n    const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\n      acc[attr.name] = attr.value;\n      return acc;\n    }, {});\n\n    const read$4 = (element, attr) => {\n      const value = get$9(element, attr);\n      return value === undefined || value === '' ? [] : value.split(' ');\n    };\n    const add$4 = (element, attr, id) => {\n      const old = read$4(element, attr);\n      const nu = old.concat([id]);\n      set$3(element, attr, nu.join(' '));\n      return true;\n    };\n    const remove$9 = (element, attr, id) => {\n      const nu = filter$5(read$4(element, attr), v => v !== id);\n      if (nu.length > 0) {\n        set$3(element, attr, nu.join(' '));\n      } else {\n        remove$a(element, attr);\n      }\n      return false;\n    };\n\n    const supports = element => element.dom.classList !== undefined;\n    const get$8 = element => read$4(element, 'class');\n    const add$3 = (element, clazz) => add$4(element, 'class', clazz);\n    const remove$8 = (element, clazz) => remove$9(element, 'class', clazz);\n    const toggle$2 = (element, clazz) => {\n      if (contains$2(get$8(element), clazz)) {\n        return remove$8(element, clazz);\n      } else {\n        return add$3(element, clazz);\n      }\n    };\n\n    const add$2 = (element, clazz) => {\n      if (supports(element)) {\n        element.dom.classList.add(clazz);\n      } else {\n        add$3(element, clazz);\n      }\n    };\n    const cleanClass = element => {\n      const classList = supports(element) ? element.dom.classList : get$8(element);\n      if (classList.length === 0) {\n        remove$a(element, 'class');\n      }\n    };\n    const remove$7 = (element, clazz) => {\n      if (supports(element)) {\n        const classList = element.dom.classList;\n        classList.remove(clazz);\n      } else {\n        remove$8(element, clazz);\n      }\n      cleanClass(element);\n    };\n    const toggle$1 = (element, clazz) => {\n      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\n      cleanClass(element);\n      return result;\n    };\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\n\n    const fromHtml$1 = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\n        const message = 'HTML does not have a single root node';\n        console.error(message, html);\n        throw new Error(message);\n      }\n      return fromDom$2(div.childNodes[0]);\n    };\n    const fromTag = (tag, scope) => {\n      const doc = scope || document;\n      const node = doc.createElement(tag);\n      return fromDom$2(node);\n    };\n    const fromText = (text, scope) => {\n      const doc = scope || document;\n      const node = doc.createTextNode(text);\n      return fromDom$2(node);\n    };\n    const fromDom$2 = node => {\n      if (node === null || node === undefined) {\n        throw new Error('Node cannot be null or undefined');\n      }\n      return { dom: node };\n    };\n    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\n    const SugarElement = {\n      fromHtml: fromHtml$1,\n      fromTag,\n      fromText,\n      fromDom: fromDom$2,\n      fromPoint: fromPoint$2\n    };\n\n    const toArray = (target, f) => {\n      const r = [];\n      const recurse = e => {\n        r.push(e);\n        return f(e);\n      };\n      let cur = f(target);\n      do {\n        cur = cur.bind(recurse);\n      } while (cur.isSome());\n      return r;\n    };\n\n    const is$1 = (element, selector) => {\n      const dom = element.dom;\n      if (dom.nodeType !== ELEMENT) {\n        return false;\n      } else {\n        const elem = dom;\n        if (elem.matches !== undefined) {\n          return elem.matches(selector);\n        } else if (elem.msMatchesSelector !== undefined) {\n          return elem.msMatchesSelector(selector);\n        } else if (elem.webkitMatchesSelector !== undefined) {\n          return elem.webkitMatchesSelector(selector);\n        } else if (elem.mozMatchesSelector !== undefined) {\n          return elem.mozMatchesSelector(selector);\n        } else {\n          throw new Error('Browser lacks native selectors');\n        }\n      }\n    };\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\n    const all = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\n    };\n    const one = (selector, scope) => {\n      const base = scope === undefined ? document : scope.dom;\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\n    };\n\n    const eq = (e1, e2) => e1.dom === e2.dom;\n    const contains = (e1, e2) => {\n      const d1 = e1.dom;\n      const d2 = e2.dom;\n      return d1 === d2 ? false : d1.contains(d2);\n    };\n\n    const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\n    const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\n    const parents$1 = (element, isRoot) => {\n      const stop = isFunction(isRoot) ? isRoot : never;\n      let dom = element.dom;\n      const ret = [];\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\n        const rawParent = dom.parentNode;\n        const p = SugarElement.fromDom(rawParent);\n        ret.push(p);\n        if (stop(p) === true) {\n          break;\n        } else {\n          dom = rawParent;\n        }\n      }\n      return ret;\n    };\n    const siblings = element => {\n      const filterSelf = elements => filter$5(elements, x => !eq(element, x));\n      return parent(element).map(children$1).map(filterSelf).getOr([]);\n    };\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\n    const prevSiblings = element => reverse(toArray(element, prevSibling));\n    const nextSiblings = element => toArray(element, nextSibling);\n    const children$1 = element => map$3(element.dom.childNodes, SugarElement.fromDom);\n    const child$1 = (element, index) => {\n      const cs = element.dom.childNodes;\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\n    };\n    const firstChild = element => child$1(element, 0);\n    const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\n    const childNodesCount = element => element.dom.childNodes.length;\n    const hasChildNodes = element => element.dom.hasChildNodes();\n\n    const getHead = doc => {\n      const b = doc.dom.head;\n      if (b === null || b === undefined) {\n        throw new Error('Head is not available yet');\n      }\n      return SugarElement.fromDom(b);\n    };\n\n    const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\n    const isSupported$1 = constant(supported);\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\n    const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\n    const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\n    const getShadowRoot = e => {\n      const r = getRootNode(e);\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\n    };\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\n    const getOriginalEventTarget = event => {\n      if (isSupported$1() && isNonNullable(event.target)) {\n        const el = SugarElement.fromDom(event.target);\n        if (isElement$7(el) && isOpenShadowHost(el)) {\n          if (event.composed && event.composedPath) {\n            const composedPath = event.composedPath();\n            if (composedPath) {\n              return head(composedPath);\n            }\n          }\n        }\n      }\n      return Optional.from(event.target);\n    };\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\n\n    const inBody = element => {\n      const dom = isText$b(element) ? element.dom.parentNode : element.dom;\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\n        return false;\n      }\n      const doc = dom.ownerDocument;\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\n    };\n\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\n      if (is(scope, a)) {\n        return Optional.some(scope);\n      } else if (isFunction(isRoot) && isRoot(scope)) {\n        return Optional.none();\n      } else {\n        return ancestor(scope, a, isRoot);\n      }\n    };\n\n    const ancestor$4 = (scope, predicate, isRoot) => {\n      let element = scope.dom;\n      const stop = isFunction(isRoot) ? isRoot : never;\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        if (predicate(el)) {\n          return Optional.some(el);\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$4 = (scope, predicate, isRoot) => {\n      const is = (s, test) => test(s);\n      return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);\n    };\n    const sibling$1 = (scope, predicate) => {\n      const element = scope.dom;\n      if (!element.parentNode) {\n        return Optional.none();\n      }\n      return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\n    };\n    const child = (scope, predicate) => {\n      const pred = node => predicate(SugarElement.fromDom(node));\n      const result = find$2(scope.dom.childNodes, pred);\n      return result.map(SugarElement.fromDom);\n    };\n    const descendant$2 = (scope, predicate) => {\n      const descend = node => {\n        for (let i = 0; i < node.childNodes.length; i++) {\n          const child = SugarElement.fromDom(node.childNodes[i]);\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(node.childNodes[i]);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope.dom);\n    };\n\n    const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, e => is$1(e, selector), isRoot);\n    const descendant$1 = (scope, selector) => one(selector, scope);\n    const closest$3 = (scope, selector, isRoot) => {\n      const is = (element, selector) => is$1(element, selector);\n      return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);\n    };\n\n    const closest$2 = target => closest$3(target, '[contenteditable]');\n    const isEditable$2 = (element, assumeEditable = false) => {\n      if (inBody(element)) {\n        return element.dom.isContentEditable;\n      } else {\n        return closest$2(element).fold(constant(assumeEditable), editable => getRaw$1(editable) === 'true');\n      }\n    };\n    const getRaw$1 = element => element.dom.contentEditable;\n\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\n\n    const internalSet = (dom, property, value) => {\n      if (!isString(value)) {\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\n        throw new Error('CSS value must be a string: ' + value);\n      }\n      if (isSupported(dom)) {\n        dom.style.setProperty(property, value);\n      }\n    };\n    const internalRemove = (dom, property) => {\n      if (isSupported(dom)) {\n        dom.style.removeProperty(property);\n      }\n    };\n    const set$2 = (element, property, value) => {\n      const dom = element.dom;\n      internalSet(dom, property, value);\n    };\n    const setAll = (element, css) => {\n      const dom = element.dom;\n      each$d(css, (v, k) => {\n        internalSet(dom, k, v);\n      });\n    };\n    const get$7 = (element, property) => {\n      const dom = element.dom;\n      const styles = window.getComputedStyle(dom);\n      const r = styles.getPropertyValue(property);\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\n    };\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\n    const getRaw = (element, property) => {\n      const dom = element.dom;\n      const raw = getUnsafeProperty(dom, property);\n      return Optional.from(raw).filter(r => r.length > 0);\n    };\n    const getAllRaw = element => {\n      const css = {};\n      const dom = element.dom;\n      if (isSupported(dom)) {\n        for (let i = 0; i < dom.style.length; i++) {\n          const ruleName = dom.style.item(i);\n          css[ruleName] = dom.style[ruleName];\n        }\n      }\n      return css;\n    };\n    const remove$6 = (element, property) => {\n      const dom = element.dom;\n      internalRemove(dom, property);\n      if (is$2(getOpt(element, 'style').map(trim$4), '')) {\n        remove$a(element, 'style');\n      }\n    };\n    const reflow = e => e.dom.offsetWidth;\n\n    const before$3 = (marker, element) => {\n      const parent$1 = parent(marker);\n      parent$1.each(v => {\n        v.dom.insertBefore(element.dom, marker.dom);\n      });\n    };\n    const after$4 = (marker, element) => {\n      const sibling = nextSibling(marker);\n      sibling.fold(() => {\n        const parent$1 = parent(marker);\n        parent$1.each(v => {\n          append$1(v, element);\n        });\n      }, v => {\n        before$3(v, element);\n      });\n    };\n    const prepend = (parent, element) => {\n      const firstChild$1 = firstChild(parent);\n      firstChild$1.fold(() => {\n        append$1(parent, element);\n      }, v => {\n        parent.dom.insertBefore(element.dom, v.dom);\n      });\n    };\n    const append$1 = (parent, element) => {\n      parent.dom.appendChild(element.dom);\n    };\n    const wrap$2 = (element, wrapper) => {\n      before$3(element, wrapper);\n      append$1(wrapper, element);\n    };\n\n    const after$3 = (marker, elements) => {\n      each$e(elements, (x, i) => {\n        const e = i === 0 ? marker : elements[i - 1];\n        after$4(e, x);\n      });\n    };\n    const append = (parent, elements) => {\n      each$e(elements, x => {\n        append$1(parent, x);\n      });\n    };\n\n    const empty = element => {\n      element.dom.textContent = '';\n      each$e(children$1(element), rogue => {\n        remove$5(rogue);\n      });\n    };\n    const remove$5 = element => {\n      const dom = element.dom;\n      if (dom.parentNode !== null) {\n        dom.parentNode.removeChild(dom);\n      }\n    };\n    const unwrap = wrapper => {\n      const children = children$1(wrapper);\n      if (children.length > 0) {\n        after$3(wrapper, children);\n      }\n      remove$5(wrapper);\n    };\n\n    const fromHtml = (html, scope) => {\n      const doc = scope || document;\n      const div = doc.createElement('div');\n      div.innerHTML = html;\n      return children$1(SugarElement.fromDom(div));\n    };\n    const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\n\n    const get$6 = element => element.dom.innerHTML;\n    const set$1 = (element, content) => {\n      const owner = owner$1(element);\n      const docDom = owner.dom;\n      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\n      const contentElements = fromHtml(content, docDom);\n      append(fragment, contentElements);\n      empty(element);\n      append$1(element, fragment);\n    };\n    const getOuter = element => {\n      const container = SugarElement.fromTag('div');\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\n      append$1(container, clone);\n      return get$6(container);\n    };\n\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\n      target,\n      x,\n      y,\n      stop,\n      prevent,\n      kill,\n      raw\n    });\n    const fromRawEvent = rawEvent => {\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\n      const stop = () => rawEvent.stopPropagation();\n      const prevent = () => rawEvent.preventDefault();\n      const kill = compose(prevent, stop);\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\n    };\n    const handle$1 = (filter, handler) => rawEvent => {\n      if (filter(rawEvent)) {\n        handler(fromRawEvent(rawEvent));\n      }\n    };\n    const binder = (element, event, filter, handler, useCapture) => {\n      const wrapped = handle$1(filter, handler);\n      element.dom.addEventListener(event, wrapped, useCapture);\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\n    };\n    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\n    const unbind = (element, event, handler, useCapture) => {\n      element.dom.removeEventListener(event, handler, useCapture);\n    };\n\n    const r = (left, top) => {\n      const translate = (x, y) => r(left + x, top + y);\n      return {\n        left,\n        top,\n        translate\n      };\n    };\n    const SugarPosition = r;\n\n    const boxPosition = dom => {\n      const box = dom.getBoundingClientRect();\n      return SugarPosition(box.left, box.top);\n    };\n    const firstDefinedOrZero = (a, b) => {\n      if (a !== undefined) {\n        return a;\n      } else {\n        return b !== undefined ? b : 0;\n      }\n    };\n    const absolute = element => {\n      const doc = element.dom.ownerDocument;\n      const body = doc.body;\n      const win = doc.defaultView;\n      const html = doc.documentElement;\n      if (body === element.dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\n    };\n    const viewport = element => {\n      const dom = element.dom;\n      const doc = dom.ownerDocument;\n      const body = doc.body;\n      if (body === dom) {\n        return SugarPosition(body.offsetLeft, body.offsetTop);\n      }\n      if (!inBody(element)) {\n        return SugarPosition(0, 0);\n      }\n      return boxPosition(dom);\n    };\n\n    const get$5 = _DOC => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\n      return SugarPosition(x, y);\n    };\n    const to = (x, y, _DOC) => {\n      const doc = _DOC !== undefined ? _DOC.dom : document;\n      const win = doc.defaultView;\n      if (win) {\n        win.scrollTo(x, y);\n      }\n    };\n    const intoView = (element, alignToTop) => {\n      const isSafari = detect$2().browser.isSafari();\n      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\n        element.dom.scrollIntoViewIfNeeded(false);\n      } else {\n        element.dom.scrollIntoView(alignToTop);\n      }\n    };\n\n    const get$4 = _win => {\n      const win = _win === undefined ? window : _win;\n      if (detect$2().browser.isFirefox()) {\n        return Optional.none();\n      } else {\n        return Optional.from(win.visualViewport);\n      }\n    };\n    const bounds = (x, y, width, height) => ({\n      x,\n      y,\n      width,\n      height,\n      right: x + width,\n      bottom: y + height\n    });\n    const getBounds = _win => {\n      const win = _win === undefined ? window : _win;\n      const doc = win.document;\n      const scroll = get$5(SugarElement.fromDom(doc));\n      return get$4(win).fold(() => {\n        const html = win.document.documentElement;\n        const width = html.clientWidth;\n        const height = html.clientHeight;\n        return bounds(scroll.left, scroll.top, width, height);\n      }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\n    };\n\n    const children = (scope, predicate) => filter$5(children$1(scope), predicate);\n    const descendants$1 = (scope, predicate) => {\n      let result = [];\n      each$e(children$1(scope), x => {\n        if (predicate(x)) {\n          result = result.concat([x]);\n        }\n        result = result.concat(descendants$1(x, predicate));\n      });\n      return result;\n    };\n\n    const descendants = (scope, selector) => all(selector, scope);\n\n    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();\n\n    class DomTreeWalker {\n      constructor(startNode, rootNode) {\n        this.node = startNode;\n        this.rootNode = rootNode;\n        this.current = this.current.bind(this);\n        this.next = this.next.bind(this);\n        this.prev = this.prev.bind(this);\n        this.prev2 = this.prev2.bind(this);\n      }\n      current() {\n        return this.node;\n      }\n      next(shallow) {\n        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\n        return this.node;\n      }\n      prev(shallow) {\n        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\n        return this.node;\n      }\n      prev2(shallow) {\n        this.node = this.findPreviousNode(this.node, shallow);\n        return this.node;\n      }\n      findSibling(node, startName, siblingName, shallow) {\n        if (node) {\n          if (!shallow && node[startName]) {\n            return node[startName];\n          }\n          if (node !== this.rootNode) {\n            let sibling = node[siblingName];\n            if (sibling) {\n              return sibling;\n            }\n            for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\n              sibling = parent[siblingName];\n              if (sibling) {\n                return sibling;\n              }\n            }\n          }\n        }\n        return undefined;\n      }\n      findPreviousNode(node, shallow) {\n        if (node) {\n          const sibling = node.previousSibling;\n          if (this.rootNode && sibling === this.rootNode) {\n            return;\n          }\n          if (sibling) {\n            if (!shallow) {\n              for (let child = sibling.lastChild; child; child = child.lastChild) {\n                if (!child.lastChild) {\n                  return child;\n                }\n              }\n            }\n            return sibling;\n          }\n          const parent = node.parentNode;\n          if (parent && parent !== this.rootNode) {\n            return parent;\n          }\n        }\n        return undefined;\n      }\n    }\n\n    const isNodeType = type => {\n      return node => {\n        return !!node && node.nodeType === type;\n      };\n    };\n    const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\n    const isElement$6 = isNodeType(1);\n    const isHTMLElement = node => isElement$6(node) && isHTMLElement$1(SugarElement.fromDom(node));\n    const isSVGElement = node => isElement$6(node) && node.namespaceURI === 'http://www.w3.org/2000/svg';\n    const matchNodeName = name => {\n      const lowerCasedName = name.toLowerCase();\n      return node => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;\n    };\n    const matchNodeNames = names => {\n      const lowerCasedNames = names.map(s => s.toLowerCase());\n      return node => {\n        if (node && node.nodeName) {\n          const nodeName = node.nodeName.toLowerCase();\n          return contains$2(lowerCasedNames, nodeName);\n        }\n        return false;\n      };\n    };\n    const matchStyleValues = (name, values) => {\n      const items = values.toLowerCase().split(' ');\n      return node => {\n        if (isElement$6(node)) {\n          const win = node.ownerDocument.defaultView;\n          if (win) {\n            for (let i = 0; i < items.length; i++) {\n              const computed = win.getComputedStyle(node, null);\n              const cssValue = computed ? computed.getPropertyValue(name) : null;\n              if (cssValue === items[i]) {\n                return true;\n              }\n            }\n          }\n        }\n        return false;\n      };\n    };\n    const hasAttribute = attrName => {\n      return node => {\n        return isElement$6(node) && node.hasAttribute(attrName);\n      };\n    };\n    const hasAttributeValue = (attrName, attrValue) => {\n      return node => {\n        return isElement$6(node) && node.getAttribute(attrName) === attrValue;\n      };\n    };\n    const isBogus$2 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\n    const isBogusAll$1 = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\n    const isTable$2 = node => isElement$6(node) && node.tagName === 'TABLE';\n    const hasContentEditableState = value => {\n      return node => {\n        if (isHTMLElement(node)) {\n          if (node.contentEditable === value) {\n            return true;\n          }\n          if (node.getAttribute('data-mce-contenteditable') === value) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const isTextareaOrInput = matchNodeNames([\n      'textarea',\n      'input'\n    ]);\n    const isText$a = isNodeType(3);\n    const isCData = isNodeType(4);\n    const isPi = isNodeType(7);\n    const isComment = isNodeType(8);\n    const isDocument$1 = isNodeType(9);\n    const isDocumentFragment = isNodeType(11);\n    const isBr$6 = matchNodeName('br');\n    const isImg = matchNodeName('img');\n    const isContentEditableTrue$3 = hasContentEditableState('true');\n    const isContentEditableFalse$b = hasContentEditableState('false');\n    const isTableCell$3 = matchNodeNames([\n      'td',\n      'th'\n    ]);\n    const isTableCellOrCaption = matchNodeNames([\n      'td',\n      'th',\n      'caption'\n    ]);\n    const isMedia$2 = matchNodeNames([\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isListItem$2 = matchNodeName('li');\n    const isDetails = matchNodeName('details');\n    const isSummary$1 = matchNodeName('summary');\n\n    const zeroWidth = '\\uFEFF';\n    const nbsp = '\\xA0';\n    const isZwsp$2 = char => char === zeroWidth;\n    const removeZwsp = s => s.replace(/\\uFEFF/g, '');\n\n    const NodeValue = (is, name) => {\n      const get = element => {\n        if (!is(element)) {\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\n        }\n        return getOption(element).getOr('');\n      };\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\n      const set = (element, value) => {\n        if (!is(element)) {\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\n        }\n        element.dom.nodeValue = value;\n      };\n      return {\n        get,\n        getOption,\n        set\n      };\n    };\n\n    const api$1 = NodeValue(isText$b, 'text');\n    const get$3 = element => api$1.get(element);\n    const getOption = element => api$1.getOption(element);\n    const set = (element, value) => api$1.set(element, value);\n\n    const tableCells = [\n      'td',\n      'th'\n    ];\n    const tableSections = [\n      'thead',\n      'tbody',\n      'tfoot'\n    ];\n    const textBlocks = [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'p',\n      'div',\n      'address',\n      'pre',\n      'form',\n      'blockquote',\n      'center',\n      'dir',\n      'fieldset',\n      'header',\n      'footer',\n      'article',\n      'section',\n      'hgroup',\n      'aside',\n      'nav',\n      'figure'\n    ];\n    const listItems$1 = [\n      'li',\n      'dd',\n      'dt'\n    ];\n    const lists = [\n      'ul',\n      'ol',\n      'dl'\n    ];\n    const wsElements = [\n      'pre',\n      'script',\n      'textarea',\n      'style'\n    ];\n    const lazyLookup = items => {\n      let lookup;\n      return node => {\n        lookup = lookup ? lookup : mapToObject(items, always);\n        return has$2(lookup, name(node));\n      };\n    };\n    const isTable$1 = node => name(node) === 'table';\n    const isBr$5 = node => isElement$7(node) && name(node) === 'br';\n    const isTextBlock$2 = lazyLookup(textBlocks);\n    const isList = lazyLookup(lists);\n    const isListItem$1 = lazyLookup(listItems$1);\n    const isTableSection = lazyLookup(tableSections);\n    const isTableCell$2 = lazyLookup(tableCells);\n    const isWsPreserveElement = lazyLookup(wsElements);\n\n    const getLastChildren$1 = elm => {\n      const children = [];\n      let rawNode = elm.dom;\n      while (rawNode) {\n        children.push(SugarElement.fromDom(rawNode));\n        rawNode = rawNode.lastChild;\n      }\n      return children;\n    };\n    const removeTrailingBr = elm => {\n      const allBrs = descendants(elm, 'br');\n      const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);\n      if (allBrs.length === brs.length) {\n        each$e(brs, remove$5);\n      }\n    };\n    const createPaddingBr = () => {\n      const br = SugarElement.fromTag('br');\n      set$3(br, 'data-mce-bogus', '1');\n      return br;\n    };\n    const fillWithPaddingBr = elm => {\n      empty(elm);\n      append$1(elm, createPaddingBr());\n    };\n    const trimBlockTrailingBr = (elm, schema) => {\n      lastChild(elm).each(lastChild => {\n        prevSibling(lastChild).each(lastChildPrevSibling => {\n          if (schema.isBlock(name(elm)) && isBr$5(lastChild) && schema.isBlock(name(lastChildPrevSibling))) {\n            remove$5(lastChild);\n          }\n        });\n      });\n    };\n\n    const ZWSP$1 = zeroWidth;\n    const isZwsp$1 = isZwsp$2;\n    const trim$2 = removeZwsp;\n    const insert$5 = editor => editor.insertContent(ZWSP$1, { preserve_zwsp: true });\n\n    const isElement$5 = isElement$6;\n    const isText$9 = isText$a;\n    const isCaretContainerBlock$1 = node => {\n      if (isText$9(node)) {\n        node = node.parentNode;\n      }\n      return isElement$5(node) && node.hasAttribute('data-mce-caret');\n    };\n    const isCaretContainerInline = node => isText$9(node) && isZwsp$1(node.data);\n    const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\n    const hasContent = node => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);\n    const insertInline$1 = (node, before) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const textNode = doc.createTextNode(ZWSP$1);\n      const parentNode = node.parentNode;\n      if (!before) {\n        const sibling = node.nextSibling;\n        if (isText$9(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (startsWithCaretContainer$1(sibling)) {\n            sibling.splitText(1);\n            return sibling;\n          }\n        }\n        if (node.nextSibling) {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);\n        } else {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);\n        }\n      } else {\n        const sibling = node.previousSibling;\n        if (isText$9(sibling)) {\n          if (isCaretContainer$2(sibling)) {\n            return sibling;\n          }\n          if (endsWithCaretContainer$1(sibling)) {\n            return sibling.splitText(sibling.data.length - 1);\n          }\n        }\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);\n      }\n      return textNode;\n    };\n    const isBeforeInline = pos => {\n      const container = pos.container();\n      if (!isText$a(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\n    };\n    const isAfterInline = pos => {\n      const container = pos.container();\n      if (!isText$a(container)) {\n        return false;\n      }\n      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\n    };\n    const insertBlock = (blockName, node, before) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const blockNode = doc.createElement(blockName);\n      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\n      blockNode.setAttribute('data-mce-bogus', 'all');\n      blockNode.appendChild(createPaddingBr().dom);\n      const parentNode = node.parentNode;\n      if (!before) {\n        if (node.nextSibling) {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);\n        } else {\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);\n        }\n      } else {\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);\n      }\n      return blockNode;\n    };\n    const startsWithCaretContainer$1 = node => isText$9(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer$1 = node => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const trimBogusBr = elm => {\n      var _a;\n      const brs = elm.getElementsByTagName('br');\n      const lastBr = brs[brs.length - 1];\n      if (isBogus$2(lastBr)) {\n        (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);\n      }\n    };\n    const showCaretContainerBlock = caretContainer => {\n      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\n        trimBogusBr(caretContainer);\n        caretContainer.removeAttribute('data-mce-caret');\n        caretContainer.removeAttribute('data-mce-bogus');\n        caretContainer.removeAttribute('style');\n        caretContainer.removeAttribute('data-mce-style');\n        caretContainer.removeAttribute('_moz_abspos');\n        return caretContainer;\n      }\n      return null;\n    };\n    const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\n\n    const isContentEditableTrue$2 = isContentEditableTrue$3;\n    const isContentEditableFalse$a = isContentEditableFalse$b;\n    const isBr$4 = isBr$6;\n    const isText$8 = isText$a;\n    const isInvalidTextElement = matchNodeNames([\n      'script',\n      'style',\n      'textarea'\n    ]);\n    const isAtomicInline = matchNodeNames([\n      'img',\n      'input',\n      'textarea',\n      'hr',\n      'iframe',\n      'video',\n      'audio',\n      'object',\n      'embed'\n    ]);\n    const isTable = matchNodeNames(['table']);\n    const isCaretContainer$1 = isCaretContainer$2;\n    const isCaretCandidate$3 = node => {\n      if (isCaretContainer$1(node)) {\n        return false;\n      }\n      if (isText$8(node)) {\n        return !isInvalidTextElement(node.parentNode);\n      }\n      return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);\n    };\n    const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\n    const isNonUiContentEditableFalse = node => !isUnselectable(node) && isContentEditableFalse$a(node);\n    const isInEditable = (node, root) => {\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        if (isNonUiContentEditableFalse(tempNode)) {\n          return false;\n        }\n        if (isContentEditableTrue$2(tempNode)) {\n          return true;\n        }\n      }\n      return true;\n    };\n    const isAtomicContentEditableFalse = node => {\n      if (!isNonUiContentEditableFalse(node)) {\n        return false;\n      }\n      return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {\n        return result || isContentEditableTrue$2(elm);\n      }, false);\n    };\n    const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\n    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\n\n    const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\n    const isWhitespaceText = text => whiteSpaceRegExp.test(text);\n    const isZwsp = text => {\n      for (const c of text) {\n        if (!isZwsp$2(c)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\n    const isNewLineChar = c => c === '\\n' || c === '\\r';\n    const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\n    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {\n      const tabSpace = repeat(' ', tabSpaces);\n      const normalizedText = text.replace(/\\t/g, tabSpace);\n      const result = foldl(normalizedText, (acc, c) => {\n        if (isCollapsibleWhitespace$1(c) || c === nbsp) {\n          if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\n            return {\n              pcIsSpace: false,\n              str: acc.str + nbsp\n            };\n          } else {\n            return {\n              pcIsSpace: true,\n              str: acc.str + ' '\n            };\n          }\n        } else {\n          return {\n            pcIsSpace: isNewLineChar(c),\n            str: acc.str + c\n          };\n        }\n      }, {\n        pcIsSpace: false,\n        str: ''\n      });\n      return result.str;\n    };\n\n    const hasWhitespacePreserveParent = (node, rootNode) => {\n      const rootElement = SugarElement.fromDom(rootNode);\n      const startNode = SugarElement.fromDom(node);\n      return ancestor$2(startNode, 'pre,code', curry(eq, rootElement));\n    };\n    const isWhitespace$1 = (node, rootNode) => {\n      return isText$a(node) && isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode);\n    };\n    const isNamedAnchor = node => {\n      return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\n    };\n    const isContent$1 = (node, rootNode) => {\n      return isCaretCandidate$3(node) && !isWhitespace$1(node, rootNode) || isNamedAnchor(node) || isBookmark(node);\n    };\n    const isBookmark = hasAttribute('data-mce-bookmark');\n    const isBogus$1 = hasAttribute('data-mce-bogus');\n    const isBogusAll = hasAttributeValue('data-mce-bogus', 'all');\n    const hasNonEditableParent = node => parentElement(SugarElement.fromDom(node)).exists(parent => !isEditable$2(parent));\n    const isEmptyNode = (targetNode, skipBogus) => {\n      let brCount = 0;\n      if (isContent$1(targetNode, targetNode)) {\n        return false;\n      } else {\n        let node = targetNode.firstChild;\n        if (!node) {\n          return true;\n        }\n        const walker = new DomTreeWalker(node, targetNode);\n        do {\n          if (skipBogus) {\n            if (isBogusAll(node)) {\n              node = walker.next(true);\n              continue;\n            }\n            if (isBogus$1(node)) {\n              node = walker.next();\n              continue;\n            }\n          }\n          if (isContentEditableTrue$3(node) && hasNonEditableParent(node)) {\n            return false;\n          }\n          if (isBr$6(node)) {\n            brCount++;\n            node = walker.next();\n            continue;\n          }\n          if (isContent$1(node, targetNode)) {\n            return false;\n          }\n          node = walker.next();\n        } while (node);\n        return brCount <= 1;\n      }\n    };\n    const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);\n\n    const isNonHtmlElementRootName = name => name.toLowerCase() === 'svg';\n    const isNonHtmlElementRoot = node => isNonHtmlElementRootName(node.nodeName);\n    const toScopeType = node => (node === null || node === void 0 ? void 0 : node.nodeName) === 'svg' ? 'svg' : 'html';\n    const namespaceElements = ['svg'];\n    const createNamespaceTracker = () => {\n      let scopes = [];\n      const peek = () => scopes[scopes.length - 1];\n      const track = node => {\n        if (isNonHtmlElementRoot(node)) {\n          scopes.push(node);\n        }\n        let currentScope = peek();\n        if (currentScope && !currentScope.contains(node)) {\n          scopes.pop();\n          currentScope = peek();\n        }\n        return toScopeType(currentScope);\n      };\n      const current = () => toScopeType(peek());\n      const reset = () => {\n        scopes = [];\n      };\n      return {\n        track,\n        current,\n        reset\n      };\n    };\n\n    const transparentBlockAttr = 'data-mce-block';\n    const elementNames = map => filter$5(keys(map), key => !/[A-Z]/.test(key));\n    const makeSelectorFromSchemaMap = map => map$3(elementNames(map), name => {\n      return `${ name }:` + map$3(namespaceElements, ns => `not(${ ns } ${ name })`).join(':');\n    }).join(',');\n    const updateTransparent = (blocksSelector, transparent) => {\n      if (isNonNullable(transparent.querySelector(blocksSelector))) {\n        transparent.setAttribute(transparentBlockAttr, 'true');\n        if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {\n          transparent.removeAttribute('data-mce-selected');\n        }\n        return true;\n      } else {\n        transparent.removeAttribute(transparentBlockAttr);\n        return false;\n      }\n    };\n    const updateBlockStateOnChildren = (schema, scope) => {\n      const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());\n      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n      return filter$5(scope.querySelectorAll(transparentSelector), transparent => updateTransparent(blocksSelector, transparent));\n    };\n    const trimEdge = (el, leftSide) => {\n      var _a;\n      const childPropertyName = leftSide ? 'lastChild' : 'firstChild';\n      for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {\n        if (isEmpty$2(SugarElement.fromDom(child))) {\n          (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);\n          return;\n        }\n      }\n    };\n    const split$2 = (parentElm, splitElm) => {\n      const range = document.createRange();\n      const parentNode = parentElm.parentNode;\n      if (parentNode) {\n        range.setStartBefore(parentElm);\n        range.setEndBefore(splitElm);\n        const beforeFragment = range.extractContents();\n        trimEdge(beforeFragment, true);\n        range.setStartAfter(splitElm);\n        range.setEndAfter(parentElm);\n        const afterFragment = range.extractContents();\n        trimEdge(afterFragment, false);\n        if (!isEmpty$2(SugarElement.fromDom(beforeFragment))) {\n          parentNode.insertBefore(beforeFragment, parentElm);\n        }\n        if (!isEmpty$2(SugarElement.fromDom(splitElm))) {\n          parentNode.insertBefore(splitElm, parentElm);\n        }\n        if (!isEmpty$2(SugarElement.fromDom(afterFragment))) {\n          parentNode.insertBefore(afterFragment, parentElm);\n        }\n        parentNode.removeChild(parentElm);\n      }\n    };\n    const splitInvalidChildren = (schema, scope, transparentBlocks) => {\n      const blocksElements = schema.getBlockElements();\n      const rootNode = SugarElement.fromDom(scope);\n      const isBlock = el => name(el) in blocksElements;\n      const isRoot = el => eq(el, rootNode);\n      each$e(fromDom$1(transparentBlocks), transparentBlock => {\n        ancestor$4(transparentBlock, isBlock, isRoot).each(parentBlock => {\n          const invalidChildren = children(transparentBlock, el => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));\n          if (invalidChildren.length > 0) {\n            const stateScope = parentElement(parentBlock);\n            each$e(invalidChildren, child => {\n              ancestor$4(child, isBlock, isRoot).each(parentBlock => {\n                split$2(parentBlock.dom, child.dom);\n              });\n            });\n            stateScope.each(scope => updateBlockStateOnChildren(schema, scope.dom));\n          }\n        });\n      });\n    };\n    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {\n      each$e([\n        ...transparentBlocks,\n        ...isTransparentBlock(schema, scope) ? [scope] : []\n      ], block => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), elm => {\n        if (isTransparentInline(schema, elm.dom)) {\n          unwrap(elm);\n        }\n      }));\n    };\n    const updateChildren = (schema, scope) => {\n      const transparentBlocks = updateBlockStateOnChildren(schema, scope);\n      splitInvalidChildren(schema, scope, transparentBlocks);\n      unwrapInvalidChildren(schema, scope, transparentBlocks);\n    };\n    const updateElement = (schema, target) => {\n      if (isTransparentElement(schema, target)) {\n        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\n        updateTransparent(blocksSelector, target);\n      }\n    };\n    const updateCaret = (schema, root, caretParent) => {\n      const isRoot = el => eq(el, SugarElement.fromDom(root));\n      const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);\n      get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), scope => updateChildren(schema, scope.dom));\n    };\n    const hasBlockAttr = el => el.hasAttribute(transparentBlockAttr);\n    const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);\n    const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);\n    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);\n    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);\n    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));\n\n    const browser$2 = detect$2().browser;\n    const firstElement = nodes => find$2(nodes, isElement$7);\n    const getTableCaptionDeltaY = elm => {\n      if (browser$2.isFirefox() && name(elm) === 'table') {\n        return firstElement(children$1(elm)).filter(elm => {\n          return name(elm) === 'caption';\n        }).bind(caption => {\n          return firstElement(nextSiblings(caption)).map(body => {\n            const bodyTop = body.dom.offsetTop;\n            const captionTop = caption.dom.offsetTop;\n            const captionHeight = caption.dom.offsetHeight;\n            return bodyTop <= captionTop ? -captionHeight : 0;\n          });\n        }).getOr(0);\n      } else {\n        return 0;\n      }\n    };\n    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\n    const getPos = (body, elm, rootElm) => {\n      let x = 0, y = 0;\n      const doc = body.ownerDocument;\n      rootElm = rootElm ? rootElm : body;\n      if (elm) {\n        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\n          const pos = elm.getBoundingClientRect();\n          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\n          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\n          return {\n            x,\n            y\n          };\n        }\n        let offsetParent = elm;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          const castOffsetParent = offsetParent;\n          x += castOffsetParent.offsetLeft || 0;\n          y += castOffsetParent.offsetTop || 0;\n          offsetParent = castOffsetParent.offsetParent;\n        }\n        offsetParent = elm.parentNode;\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\n          x -= offsetParent.scrollLeft || 0;\n          y -= offsetParent.scrollTop || 0;\n          offsetParent = offsetParent.parentNode;\n        }\n        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\n      }\n      return {\n        x,\n        y\n      };\n    };\n\n    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {\n      let idCount = 0;\n      const loadedStates = {};\n      const edos = SugarElement.fromDom(documentOrShadowRoot);\n      const doc = documentOrOwner(edos);\n      const _setReferrerPolicy = referrerPolicy => {\n        settings.referrerPolicy = referrerPolicy;\n      };\n      const _setContentCssCors = contentCssCors => {\n        settings.contentCssCors = contentCssCors;\n      };\n      const addStyle = element => {\n        append$1(getStyleContainer(edos), element);\n      };\n      const removeStyle = id => {\n        const styleContainer = getStyleContainer(edos);\n        descendant$1(styleContainer, '#' + id).each(remove$5);\n      };\n      const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\n        id: 'mce-u' + idCount++,\n        passed: [],\n        failed: [],\n        count: 0\n      }));\n      const load = url => new Promise((success, failure) => {\n        let link;\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        const state = getOrCreateState(urlWithSuffix);\n        loadedStates[urlWithSuffix] = state;\n        state.count++;\n        const resolve = (callbacks, status) => {\n          each$e(callbacks, call);\n          state.status = status;\n          state.passed = [];\n          state.failed = [];\n          if (link) {\n            link.onload = null;\n            link.onerror = null;\n            link = null;\n          }\n        };\n        const passed = () => resolve(state.passed, 2);\n        const failed = () => resolve(state.failed, 3);\n        if (success) {\n          state.passed.push(success);\n        }\n        if (failure) {\n          state.failed.push(failure);\n        }\n        if (state.status === 1) {\n          return;\n        }\n        if (state.status === 2) {\n          passed();\n          return;\n        }\n        if (state.status === 3) {\n          failed();\n          return;\n        }\n        state.status = 1;\n        const linkElem = SugarElement.fromTag('link', doc.dom);\n        setAll$1(linkElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        if (settings.contentCssCors) {\n          set$3(linkElem, 'crossOrigin', 'anonymous');\n        }\n        if (settings.referrerPolicy) {\n          set$3(linkElem, 'referrerpolicy', settings.referrerPolicy);\n        }\n        link = linkElem.dom;\n        link.onload = passed;\n        link.onerror = failed;\n        addStyle(linkElem);\n        set$3(linkElem, 'href', urlWithSuffix);\n      });\n      const loadRawCss = (key, css) => {\n        const state = getOrCreateState(key);\n        loadedStates[key] = state;\n        state.count++;\n        const styleElem = SugarElement.fromTag('style', doc.dom);\n        setAll$1(styleElem, {\n          rel: 'stylesheet',\n          type: 'text/css',\n          id: state.id\n        });\n        styleElem.dom.innerHTML = css;\n        addStyle(styleElem);\n      };\n      const loadAll = urls => {\n        const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\n        return loadedUrls.then(results => {\n          const parts = partition$2(results, r => r.status === 'fulfilled');\n          if (parts.fail.length > 0) {\n            return Promise.reject(map$3(parts.fail, result => result.reason));\n          } else {\n            return map$3(parts.pass, result => result.value);\n          }\n        });\n      };\n      const unload = url => {\n        const urlWithSuffix = Tools._addCacheSuffix(url);\n        get$a(loadedStates, urlWithSuffix).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[urlWithSuffix];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadRawCss = key => {\n        get$a(loadedStates, key).each(state => {\n          const count = --state.count;\n          if (count === 0) {\n            delete loadedStates[key];\n            removeStyle(state.id);\n          }\n        });\n      };\n      const unloadAll = urls => {\n        each$e(urls, url => {\n          unload(url);\n        });\n      };\n      return {\n        load,\n        loadRawCss,\n        loadAll,\n        unload,\n        unloadRawCss,\n        unloadAll,\n        _setReferrerPolicy,\n        _setContentCssCors\n      };\n    };\n\n    const create$d = () => {\n      const map = new WeakMap();\n      const forElement = (referenceElement, settings) => {\n        const root = getRootNode(referenceElement);\n        const rootDom = root.dom;\n        return Optional.from(map.get(rootDom)).getOrThunk(() => {\n          const sl = StyleSheetLoader(rootDom, settings);\n          map.set(rootDom, sl);\n          return sl;\n        });\n      };\n      return { forElement };\n    };\n    const instance = create$d();\n\n    const isSpan = node => node.nodeName.toLowerCase() === 'span';\n    const isInlineContent = (node, root, schema) => isNonNullable(node) && (isContent$1(node, root) || schema.isInline(node.nodeName.toLowerCase()));\n    const surroundedByInlineContent = (node, root, schema) => {\n      const prev = new DomTreeWalker(node, root).prev(false);\n      const next = new DomTreeWalker(node, root).next(false);\n      const prevIsInline = isUndefined(prev) || isInlineContent(prev, root, schema);\n      const nextIsInline = isUndefined(next) || isInlineContent(next, root, schema);\n      return prevIsInline && nextIsInline;\n    };\n    const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\n    const isKeepTextNode = (node, root, schema) => isText$a(node) && node.data.length > 0 && surroundedByInlineContent(node, root, schema);\n    const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\n    const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\n    const trimNode = (dom, node, schema, root) => {\n      var _a;\n      const rootNode = root || node;\n      if (isElement$6(node) && isBookmarkNode$2(node)) {\n        return node;\n      }\n      const children = node.childNodes;\n      for (let i = children.length - 1; i >= 0; i--) {\n        trimNode(dom, children[i], schema, rootNode);\n      }\n      if (isElement$6(node)) {\n        const currentChildren = node.childNodes;\n        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);\n        }\n      }\n      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode, schema)) {\n        dom.remove(node);\n      }\n      return node;\n    };\n\n    const makeMap$3 = Tools.makeMap;\n    const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n    const rawCharsRegExp = /[<>&\\\"\\']/g;\n    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\n    const asciiMap = {\n      128: '\\u20AC',\n      130: '\\u201A',\n      131: '\\u0192',\n      132: '\\u201E',\n      133: '\\u2026',\n      134: '\\u2020',\n      135: '\\u2021',\n      136: '\\u02c6',\n      137: '\\u2030',\n      138: '\\u0160',\n      139: '\\u2039',\n      140: '\\u0152',\n      142: '\\u017d',\n      145: '\\u2018',\n      146: '\\u2019',\n      147: '\\u201C',\n      148: '\\u201D',\n      149: '\\u2022',\n      150: '\\u2013',\n      151: '\\u2014',\n      152: '\\u02DC',\n      153: '\\u2122',\n      154: '\\u0161',\n      155: '\\u203A',\n      156: '\\u0153',\n      158: '\\u017e',\n      159: '\\u0178'\n    };\n    const baseEntities = {\n      '\"': '&quot;',\n      '\\'': '&#39;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '&': '&amp;',\n      '`': '&#96;'\n    };\n    const reverseEntities = {\n      '&lt;': '<',\n      '&gt;': '>',\n      '&amp;': '&',\n      '&quot;': '\"',\n      '&apos;': `'`\n    };\n    const nativeDecode = text => {\n      const elm = SugarElement.fromTag('div').dom;\n      elm.innerHTML = text;\n      return elm.textContent || elm.innerText || text;\n    };\n    const buildEntitiesLookup = (items, radix) => {\n      const lookup = {};\n      if (items) {\n        const itemList = items.split(',');\n        radix = radix || 10;\n        for (let i = 0; i < itemList.length; i += 2) {\n          const chr = String.fromCharCode(parseInt(itemList[i], radix));\n          if (!baseEntities[chr]) {\n            const entity = '&' + itemList[i + 1] + ';';\n            lookup[chr] = entity;\n            lookup[entity] = chr;\n          }\n        }\n        return lookup;\n      } else {\n        return undefined;\n      }\n    };\n    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\n    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\n      return baseEntities[chr] || chr;\n    });\n    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n      if (chr.length > 1) {\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n      }\n      return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\n    });\n    const encodeNamed = (text, attr, entities) => {\n      const resolveEntities = entities || namedEntities;\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        return baseEntities[chr] || resolveEntities[chr] || chr;\n      });\n    };\n    const getEncodeFunc = (name, entities) => {\n      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\n      const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\n        if (baseEntities[chr] !== undefined) {\n          return baseEntities[chr];\n        }\n        if (entitiesMap[chr] !== undefined) {\n          return entitiesMap[chr];\n        }\n        if (chr.length > 1) {\n          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\n        }\n        return '&#' + chr.charCodeAt(0) + ';';\n      });\n      const encodeCustomNamed = (text, attr) => {\n        return encodeNamed(text, attr, entitiesMap);\n      };\n      const nameMap = makeMap$3(name.replace(/\\+/g, ','));\n      if (nameMap.named && nameMap.numeric) {\n        return encodeNamedAndNumeric;\n      }\n      if (nameMap.named) {\n        if (entities) {\n          return encodeCustomNamed;\n        }\n        return encodeNamed;\n      }\n      if (nameMap.numeric) {\n        return encodeNumeric;\n      }\n      return encodeRaw;\n    };\n    const decode = text => text.replace(entityRegExp, (all, numeric) => {\n      if (numeric) {\n        if (numeric.charAt(0).toLowerCase() === 'x') {\n          numeric = parseInt(numeric.substr(1), 16);\n        } else {\n          numeric = parseInt(numeric, 10);\n        }\n        if (numeric > 65535) {\n          numeric -= 65536;\n          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\n        }\n        return asciiMap[numeric] || String.fromCharCode(numeric);\n      }\n      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\n    });\n    const Entities = {\n      encodeRaw,\n      encodeAllRaw,\n      encodeNumeric,\n      encodeNamed,\n      getEncodeFunc,\n      decode\n    };\n\n    const split$1 = (items, delim) => {\n      items = Tools.trim(items);\n      return items ? items.split(delim || ' ') : [];\n    };\n    const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\n\n    const parseCustomElementsRules = value => {\n      const customElementRegExp = /^(~)?(.+)$/;\n      return bind$3(split$1(value, ','), rule => {\n        const matches = customElementRegExp.exec(rule);\n        if (matches) {\n          const inline = matches[1] === '~';\n          const cloneName = inline ? 'span' : 'div';\n          const name = matches[2];\n          return [{\n              inline,\n              cloneName,\n              name\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const getElementSetsAsStrings = type => {\n      let globalAttributes, blockContent;\n      let phrasingContent;\n      globalAttributes = 'id accesskey class dir lang style tabindex title role';\n      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\n      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\n      if (type !== 'html4') {\n        const transparentContent = 'a ins del canvas map';\n        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';\n        blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;\n        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen svg';\n      }\n      if (type !== 'html5-strict') {\n        globalAttributes += ' xml:lang';\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        phrasingContent = [\n          phrasingContent,\n          html4PhrasingContent\n        ].join(' ');\n        const html4BlockContent = 'center dir isindex noframes';\n        blockContent = [\n          blockContent,\n          html4BlockContent\n        ].join(' ');\n      }\n      const flowContent = [\n        blockContent,\n        phrasingContent\n      ].join(' ');\n      return {\n        globalAttributes,\n        blockContent,\n        phrasingContent,\n        flowContent\n      };\n    };\n\n    const makeSchema = type => {\n      const {globalAttributes, phrasingContent, flowContent} = getElementSetsAsStrings(type);\n      const schema = {};\n      const addElement = (name, attributes, children) => {\n        schema[name] = {\n          attributes: mapToObject(attributes, constant({})),\n          attributesOrder: attributes,\n          children: mapToObject(children, constant({}))\n        };\n      };\n      const add = (name, attributes = '', children = '') => {\n        const childNames = split$1(children);\n        const names = split$1(name);\n        let ni = names.length;\n        const allAttributes = split$1([\n          globalAttributes,\n          attributes\n        ].join(' '));\n        while (ni--) {\n          addElement(names[ni], allAttributes.slice(), childNames);\n        }\n      };\n      const addAttrs = (name, attributes) => {\n        const names = split$1(name);\n        const attrs = split$1(attributes);\n        let ni = names.length;\n        while (ni--) {\n          const schemaItem = schema[names[ni]];\n          for (let i = 0, l = attrs.length; i < l; i++) {\n            schemaItem.attributes[attrs[i]] = {};\n            schemaItem.attributesOrder.push(attrs[i]);\n          }\n        }\n      };\n      if (type !== 'html5-strict') {\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\n        each$e(split$1(html4PhrasingContent), name => {\n          add(name, '', phrasingContent);\n        });\n        const html4BlockContent = 'center dir isindex noframes';\n        each$e(split$1(html4BlockContent), name => {\n          add(name, '', flowContent);\n        });\n      }\n      add('html', 'manifest', 'head body');\n      add('head', '', 'base command link meta noscript script style title');\n      add('title hr noscript br');\n      add('base', 'href target');\n      add('link', 'href rel media hreflang type sizes hreflang');\n      add('meta', 'name http-equiv content charset');\n      add('style', 'media type scoped');\n      add('script', 'src async defer type charset');\n      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\n      add('dd div', '', flowContent);\n      add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);\n      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\n      add('blockquote', 'cite', flowContent);\n      add('ol', 'reversed start type', 'li');\n      add('ul', '', 'li');\n      add('li', 'value', flowContent);\n      add('dl', '', 'dt dd');\n      add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);\n      add('q', 'cite', phrasingContent);\n      add('ins del', 'cite datetime', flowContent);\n      add('img', 'src sizes srcset alt usemap ismap width height');\n      add('iframe', 'src name width height', flowContent);\n      add('embed', 'src type width height');\n      add('object', 'data type typemustmatch name usemap form width height', [\n        flowContent,\n        'param'\n      ].join(' '));\n      add('param', 'name value');\n      add('map', 'name', [\n        flowContent,\n        'area'\n      ].join(' '));\n      add('area', 'alt coords shape href target rel media hreflang type');\n      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\n      add('colgroup', 'span', 'col');\n      add('col', 'span');\n      add('tbody thead tfoot', '', 'tr');\n      add('tr', '', 'td th');\n      add('td', 'colspan rowspan headers', flowContent);\n      add('th', 'colspan rowspan headers scope abbr', flowContent);\n      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\n      add('fieldset', 'disabled form name', [\n        flowContent,\n        'legend'\n      ].join(' '));\n      add('label', 'form for', phrasingContent);\n      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\n      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\n      add('select', 'disabled form multiple name required size', 'option optgroup');\n      add('optgroup', 'disabled label', 'option');\n      add('option', 'disabled label selected value');\n      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\n      add('menu', 'type label', [\n        flowContent,\n        'li'\n      ].join(' '));\n      add('noscript', '', flowContent);\n      if (type !== 'html4') {\n        add('wbr');\n        add('ruby', '', [\n          phrasingContent,\n          'rt rp'\n        ].join(' '));\n        add('figcaption', '', flowContent);\n        add('mark rt rp bdi', '', phrasingContent);\n        add('summary', '', [\n          phrasingContent,\n          'h1 h2 h3 h4 h5 h6'\n        ].join(' '));\n        add('canvas', 'width height', flowContent);\n        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [\n          flowContent,\n          'track source'\n        ].join(' '));\n        add('picture', '', 'img source');\n        add('source', 'src srcset type media sizes');\n        add('track', 'kind src srclang label default');\n        add('datalist', '', [\n          phrasingContent,\n          'option'\n        ].join(' '));\n        add('article section nav aside main header footer', '', flowContent);\n        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\n        add('figure', '', [\n          flowContent,\n          'figcaption'\n        ].join(' '));\n        add('time', 'datetime', phrasingContent);\n        add('dialog', 'open', flowContent);\n        add('command', 'type label icon disabled checked radiogroup command');\n        add('output', 'for form name', phrasingContent);\n        add('progress', 'value max', phrasingContent);\n        add('meter', 'value min max low high optimum', phrasingContent);\n        add('details', 'open', [\n          flowContent,\n          'summary'\n        ].join(' '));\n        add('keygen', 'autofocus challenge disabled form keytype name');\n        addElement('svg', 'id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform'.split(' '), []);\n      }\n      if (type !== 'html5-strict') {\n        addAttrs('script', 'language xml:space');\n        addAttrs('style', 'xml:space');\n        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\n        addAttrs('embed', 'align name hspace vspace');\n        addAttrs('param', 'valuetype type');\n        addAttrs('a', 'charset name rev shape coords');\n        addAttrs('br', 'clear');\n        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\n        addAttrs('img', 'name longdesc align border hspace vspace');\n        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\n        addAttrs('font basefont', 'size color face');\n        addAttrs('input', 'usemap align');\n        addAttrs('select');\n        addAttrs('textarea');\n        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\n        addAttrs('ul', 'type compact');\n        addAttrs('li', 'type');\n        addAttrs('ol dl menu dir', 'compact');\n        addAttrs('pre', 'width xml:space');\n        addAttrs('hr', 'align noshade size width');\n        addAttrs('isindex', 'prompt');\n        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\n        addAttrs('col', 'width align char charoff valign');\n        addAttrs('colgroup', 'width align char charoff valign');\n        addAttrs('thead', 'align char charoff valign');\n        addAttrs('tr', 'align char charoff valign bgcolor');\n        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\n        addAttrs('form', 'accept');\n        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\n        addAttrs('tfoot', 'align char charoff valign');\n        addAttrs('tbody', 'align char charoff valign');\n        addAttrs('area', 'nohref');\n        addAttrs('body', 'background bgcolor text link vlink alink');\n      }\n      if (type !== 'html4') {\n        addAttrs('input button select textarea', 'autofocus');\n        addAttrs('input textarea', 'placeholder');\n        addAttrs('a', 'download');\n        addAttrs('link script img', 'crossorigin');\n        addAttrs('img', 'loading');\n        addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading');\n      }\n      if (type !== 'html4') {\n        each$e([\n          schema.video,\n          schema.audio\n        ], item => {\n          delete item.children.audio;\n          delete item.children.video;\n        });\n      }\n      each$e(split$1('a form meter progress dfn'), name => {\n        if (schema[name]) {\n          delete schema[name].children[name];\n        }\n      });\n      delete schema.caption.children.table;\n      delete schema.script;\n      return schema;\n    };\n\n    const prefixToOperation = prefix => prefix === '-' ? 'remove' : 'add';\n    const parseValidChildrenRules = value => {\n      const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\n      return bind$3(split$1(value, ','), rule => {\n        const matches = childRuleRegExp.exec(rule);\n        if (matches) {\n          const prefix = matches[1];\n          const operation = prefix ? prefixToOperation(prefix) : 'replace';\n          const name = matches[2];\n          const validChildren = split$1(matches[3], '|');\n          return [{\n              operation,\n              name,\n              validChildren\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {\n      const attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/;\n      const hasPatternsRegExp = /[*?+]/;\n      const {attributes, attributesOrder} = targetElement;\n      return each$e(split$1(attrData, '|'), rule => {\n        const matches = attrRuleRegExp.exec(rule);\n        if (matches) {\n          const attr = {};\n          const attrType = matches[1];\n          const attrName = matches[2].replace(/[\\\\:]:/g, ':');\n          const attrPrefix = matches[3];\n          const value = matches[4];\n          if (attrType === '!') {\n            targetElement.attributesRequired = targetElement.attributesRequired || [];\n            targetElement.attributesRequired.push(attrName);\n            attr.required = true;\n          }\n          if (attrType === '-') {\n            delete attributes[attrName];\n            attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);\n            return;\n          }\n          if (attrPrefix) {\n            if (attrPrefix === '=') {\n              targetElement.attributesDefault = targetElement.attributesDefault || [];\n              targetElement.attributesDefault.push({\n                name: attrName,\n                value\n              });\n              attr.defaultValue = value;\n            } else if (attrPrefix === '~') {\n              targetElement.attributesForced = targetElement.attributesForced || [];\n              targetElement.attributesForced.push({\n                name: attrName,\n                value\n              });\n              attr.forcedValue = value;\n            } else if (attrPrefix === '<') {\n              attr.validValues = Tools.makeMap(value, '?');\n            }\n          }\n          if (hasPatternsRegExp.test(attrName)) {\n            const attrPattern = attr;\n            targetElement.attributePatterns = targetElement.attributePatterns || [];\n            attrPattern.pattern = patternToRegExp(attrName);\n            targetElement.attributePatterns.push(attrPattern);\n          } else {\n            if (!attributes[attrName]) {\n              attributesOrder.push(attrName);\n            }\n            attributes[attrName] = attr;\n          }\n        }\n      });\n    };\n    const cloneAttributesInto = (from, to) => {\n      each$d(from.attributes, (value, key) => {\n        to.attributes[key] = value;\n      });\n      to.attributesOrder.push(...from.attributesOrder);\n    };\n    const parseValidElementsRules = (globalElement, validElements) => {\n      const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/;\n      return bind$3(split$1(validElements, ','), rule => {\n        const matches = elementRuleRegExp.exec(rule);\n        if (matches) {\n          const prefix = matches[1];\n          const elementName = matches[2];\n          const outputName = matches[3];\n          const attrsPrefix = matches[4];\n          const attrData = matches[5];\n          const element = {\n            attributes: {},\n            attributesOrder: []\n          };\n          globalElement.each(el => cloneAttributesInto(el, element));\n          if (prefix === '#') {\n            element.paddEmpty = true;\n          } else if (prefix === '-') {\n            element.removeEmpty = true;\n          }\n          if (attrsPrefix === '!') {\n            element.removeEmptyAttrs = true;\n          }\n          if (attrData) {\n            parseValidElementsAttrDataIntoElement(attrData, element);\n          }\n          if (outputName) {\n            element.outputName = elementName;\n          }\n          if (elementName === '@') {\n            if (globalElement.isNone()) {\n              globalElement = Optional.some(element);\n            } else {\n              return [];\n            }\n          }\n          return [outputName ? {\n              name: elementName,\n              element,\n              aliasName: outputName\n            } : {\n              name: elementName,\n              element\n            }];\n        } else {\n          return [];\n        }\n      });\n    };\n\n    const mapCache = {};\n    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode;\n    const createMap = (defaultValue, extendWith = {}) => {\n      const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\n      return extend$2(value, extendWith);\n    };\n    const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());\n    const compileElementMap = (value, mode) => {\n      if (value) {\n        const styles = {};\n        if (isString(value)) {\n          value = { '*': value };\n        }\n        each$b(value, (value, key) => {\n          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\n        });\n        return styles;\n      } else {\n        return undefined;\n      }\n    };\n    const Schema = (settings = {}) => {\n      var _a;\n      const elements = {};\n      const children = {};\n      let patternElements = [];\n      const customElementsMap = {};\n      const specialElements = {};\n      const createLookupTable = (option, defaultValue, extendWith) => {\n        const value = settings[option];\n        if (!value) {\n          let newValue = mapCache[option];\n          if (!newValue) {\n            newValue = createMap(defaultValue, extendWith);\n            mapCache[option] = newValue;\n          }\n          return newValue;\n        } else {\n          return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\n        }\n      };\n      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\n      const schemaItems = makeSchema(schemaType);\n      if (settings.verify_html === false) {\n        settings.valid_elements = '*[*]';\n      }\n      const validStyles = compileElementMap(settings.valid_styles);\n      const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\n      const validClasses = compileElementMap(settings.valid_classes, 'map');\n      const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\n      const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\n      const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\n      const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\n      const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\n      const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre svg', voidElementsMap);\n      const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\n      const headings = 'h1 h2 h3 h4 h5 h6';\n      const textBlockElementsMap = createLookupTable('text_block_elements', headings + ' p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\n      const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary html body multicol listing', textBlockElementsMap);\n      const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');\n      const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');\n      const wrapBlockElementsMap = createLookupTable('wrap_block_elements', 'pre ' + headings);\n      each$b('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\n        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\n      });\n      const addValidElements = validElements => {\n        const globalElement = Optional.from(elements['@']);\n        const hasPatternsRegExp = /[*?+]/;\n        each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({name, element, aliasName}) => {\n          if (aliasName) {\n            elements[aliasName] = element;\n          }\n          if (hasPatternsRegExp.test(name)) {\n            const patternElement = element;\n            patternElement.pattern = patternToRegExp(name);\n            patternElements.push(patternElement);\n          } else {\n            elements[name] = element;\n          }\n        });\n      };\n      const setValidElements = validElements => {\n        patternElements = [];\n        each$e(keys(elements), name => {\n          delete elements[name];\n        });\n        addValidElements(validElements);\n      };\n      const addCustomElements = customElements => {\n        delete mapCache.text_block_elements;\n        delete mapCache.block_elements;\n        each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({inline, name, cloneName}) => {\n          children[name] = children[cloneName];\n          customElementsMap[name] = cloneName;\n          nonEmptyElementsMap[name.toUpperCase()] = {};\n          nonEmptyElementsMap[name] = {};\n          if (!inline) {\n            blockElementsMap[name.toUpperCase()] = {};\n            blockElementsMap[name] = {};\n          }\n          if (!elements[name]) {\n            let customRule = elements[cloneName];\n            customRule = extend$2({}, customRule);\n            delete customRule.removeEmptyAttrs;\n            delete customRule.removeEmpty;\n            elements[name] = customRule;\n          }\n          each$d(children, (element, elmName) => {\n            if (element[cloneName]) {\n              children[elmName] = element = extend$2({}, children[elmName]);\n              element[name] = element[cloneName];\n            }\n          });\n        });\n      };\n      const addValidChildren = validChildren => {\n        each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({operation, name, validChildren}) => {\n          const parent = operation === 'replace' ? { '#comment': {} } : children[name];\n          each$e(validChildren, child => {\n            if (operation === 'remove') {\n              delete parent[child];\n            } else {\n              parent[child] = {};\n            }\n          });\n          children[name] = parent;\n        });\n      };\n      const getElementRule = name => {\n        const element = elements[name];\n        if (element) {\n          return element;\n        }\n        let i = patternElements.length;\n        while (i--) {\n          const patternElement = patternElements[i];\n          if (patternElement.pattern.test(name)) {\n            return patternElement;\n          }\n        }\n        return undefined;\n      };\n      if (!settings.valid_elements) {\n        each$b(schemaItems, (element, name) => {\n          elements[name] = {\n            attributes: element.attributes,\n            attributesOrder: element.attributesOrder\n          };\n          children[name] = element.children;\n        });\n        each$b(split$1('strong/b em/i'), item => {\n          const items = split$1(item, '/');\n          elements[items[1]].outputName = items[0];\n        });\n        each$b(textInlineElementsMap, (_val, name) => {\n          if (elements[name]) {\n            if (settings.padd_empty_block_inline_children) {\n              elements[name].paddInEmptyBlock = true;\n            }\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$b(split$1('ol ul blockquote a table tbody'), name => {\n          if (elements[name]) {\n            elements[name].removeEmpty = true;\n          }\n        });\n        each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), name => {\n          if (elements[name]) {\n            elements[name].paddEmpty = true;\n          }\n        });\n        each$b(split$1('span'), name => {\n          elements[name].removeEmptyAttrs = true;\n        });\n      } else {\n        setValidElements(settings.valid_elements);\n        each$b(schemaItems, (element, name) => {\n          children[name] = element.children;\n        });\n      }\n      delete elements.svg;\n      addCustomElements(settings.custom_elements);\n      addValidChildren(settings.valid_children);\n      addValidElements(settings.extended_valid_elements);\n      addValidChildren('+ol[ul|ol],+ul[ul|ol]');\n      each$b({\n        dd: 'dl',\n        dt: 'dl',\n        li: 'ul ol',\n        td: 'tr',\n        th: 'tr',\n        tr: 'tbody thead tfoot',\n        tbody: 'table',\n        thead: 'table',\n        tfoot: 'table',\n        legend: 'fieldset',\n        area: 'map',\n        param: 'video audio object'\n      }, (parents, item) => {\n        if (elements[item]) {\n          elements[item].parentsRequired = split$1(parents);\n        }\n      });\n      if (settings.invalid_elements) {\n        each$b(explode$2(settings.invalid_elements), item => {\n          if (elements[item]) {\n            delete elements[item];\n          }\n        });\n      }\n      if (!getElementRule('span')) {\n        addValidElements('span[!data-mce-type|*]');\n      }\n      const getValidStyles = constant(validStyles);\n      const getInvalidStyles = constant(invalidStyles);\n      const getValidClasses = constant(validClasses);\n      const getBoolAttrs = constant(boolAttrMap);\n      const getBlockElements = constant(blockElementsMap);\n      const getTextBlockElements = constant(textBlockElementsMap);\n      const getTextInlineElements = constant(textInlineElementsMap);\n      const getVoidElements = constant(Object.seal(voidElementsMap));\n      const getSelfClosingElements = constant(selfClosingElementsMap);\n      const getNonEmptyElements = constant(nonEmptyElementsMap);\n      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\n      const getWhitespaceElements = constant(whitespaceElementsMap);\n      const getTransparentElements = constant(transparentElementsMap);\n      const getWrapBlockElements = constant(wrapBlockElementsMap);\n      const getSpecialElements = constant(Object.seal(specialElements));\n      const isValidChild = (name, child) => {\n        const parent = children[name.toLowerCase()];\n        return !!(parent && parent[child.toLowerCase()]);\n      };\n      const isValid = (name, attr) => {\n        const rule = getElementRule(name);\n        if (rule) {\n          if (attr) {\n            if (rule.attributes[attr]) {\n              return true;\n            }\n            const attrPatterns = rule.attributePatterns;\n            if (attrPatterns) {\n              let i = attrPatterns.length;\n              while (i--) {\n                if (attrPatterns[i].pattern.test(attr)) {\n                  return true;\n                }\n              }\n            }\n          } else {\n            return true;\n          }\n        }\n        return false;\n      };\n      const isBlock = name => has$2(getBlockElements(), name);\n      const isInline = name => !startsWith(name, '#') && isValid(name) && !isBlock(name);\n      const isWrapper = name => has$2(getWrapBlockElements(), name) || isInline(name);\n      const getCustomElements = constant(customElementsMap);\n      return {\n        type: schemaType,\n        children,\n        elements,\n        getValidStyles,\n        getValidClasses,\n        getBlockElements,\n        getInvalidStyles,\n        getVoidElements,\n        getTextBlockElements,\n        getTextInlineElements,\n        getBoolAttrs,\n        getElementRule,\n        getSelfClosingElements,\n        getNonEmptyElements,\n        getMoveCaretBeforeOnEnterElements,\n        getWhitespaceElements,\n        getTransparentElements,\n        getSpecialElements,\n        isValidChild,\n        isValid,\n        isBlock,\n        isInline,\n        isWrapper,\n        getCustomElements,\n        addValidElements,\n        setValidElements,\n        addCustomElements,\n        addValidChildren\n      };\n    };\n\n    const hexColour = value => ({ value: normalizeHex(value) });\n    const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();\n    const toHex = component => {\n      const hex = component.toString(16);\n      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\n    };\n    const fromRgba = rgbaColour => {\n      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\n      return hexColour(value);\n    };\n\n    const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*$/i;\n    const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)\\s*$/i;\n    const rgbaColour = (red, green, blue, alpha) => ({\n      red,\n      green,\n      blue,\n      alpha\n    });\n    const fromStringValues = (red, green, blue, alpha) => {\n      const r = parseInt(red, 10);\n      const g = parseInt(green, 10);\n      const b = parseInt(blue, 10);\n      const a = parseFloat(alpha);\n      return rgbaColour(r, g, b, a);\n    };\n    const fromString = rgbaString => {\n      if (rgbaString === 'transparent') {\n        return Optional.some(rgbaColour(0, 0, 0, 0));\n      }\n      const rgbMatch = rgbRegex.exec(rgbaString);\n      if (rgbMatch !== null) {\n        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\n      }\n      const rgbaMatch = rgbaRegex.exec(rgbaString);\n      if (rgbaMatch !== null) {\n        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\n      }\n      return Optional.none();\n    };\n    const toString = rgba => `rgba(${ rgba.red },${ rgba.green },${ rgba.blue },${ rgba.alpha })`;\n\n    const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\n\n    const Styles = (settings = {}, schema) => {\n      const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\n      const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\n      const trimRightRegExp = /\\s+$/;\n      const encodingLookup = {};\n      let validStyles;\n      let invalidStyles;\n      const invisibleChar = zeroWidth;\n      if (schema) {\n        validStyles = schema.getValidStyles();\n        invalidStyles = schema.getInvalidStyles();\n      }\n      const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\n      for (let i = 0; i < encodingItems.length; i++) {\n        encodingLookup[encodingItems[i]] = invisibleChar + i;\n        encodingLookup[invisibleChar + i] = encodingItems[i];\n      }\n      const self = {\n        parse: css => {\n          const styles = {};\n          let isEncoded = false;\n          const urlConverter = settings.url_converter;\n          const urlConverterScope = settings.url_converter_scope || self;\n          const compress = (prefix, suffix, noJoin) => {\n            const top = styles[prefix + '-top' + suffix];\n            if (!top) {\n              return;\n            }\n            const right = styles[prefix + '-right' + suffix];\n            if (!right) {\n              return;\n            }\n            const bottom = styles[prefix + '-bottom' + suffix];\n            if (!bottom) {\n              return;\n            }\n            const left = styles[prefix + '-left' + suffix];\n            if (!left) {\n              return;\n            }\n            const box = [\n              top,\n              right,\n              bottom,\n              left\n            ];\n            let i = box.length - 1;\n            while (i--) {\n              if (box[i] !== box[i + 1]) {\n                break;\n              }\n            }\n            if (i > -1 && noJoin) {\n              return;\n            }\n            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\n            delete styles[prefix + '-top' + suffix];\n            delete styles[prefix + '-right' + suffix];\n            delete styles[prefix + '-bottom' + suffix];\n            delete styles[prefix + '-left' + suffix];\n          };\n          const canCompress = key => {\n            const value = styles[key];\n            if (!value) {\n              return;\n            }\n            const values = value.indexOf(',') > -1 ? [value] : value.split(' ');\n            let i = values.length;\n            while (i--) {\n              if (values[i] !== values[0]) {\n                return false;\n              }\n            }\n            styles[key] = values[0];\n            return true;\n          };\n          const compress2 = (target, a, b, c) => {\n            if (!canCompress(a)) {\n              return;\n            }\n            if (!canCompress(b)) {\n              return;\n            }\n            if (!canCompress(c)) {\n              return;\n            }\n            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\n            delete styles[a];\n            delete styles[b];\n            delete styles[c];\n          };\n          const encode = str => {\n            isEncoded = true;\n            return encodingLookup[str];\n          };\n          const decode = (str, keepSlashes) => {\n            if (isEncoded) {\n              str = str.replace(/\\uFEFF[0-9]/g, str => {\n                return encodingLookup[str];\n              });\n            }\n            if (!keepSlashes) {\n              str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\n            }\n            return str;\n          };\n          const decodeSingleHexSequence = escSeq => {\n            return String.fromCharCode(parseInt(escSeq.slice(1), 16));\n          };\n          const decodeHexSequences = value => {\n            return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\n          };\n          const processUrl = (match, url, url2, url3, str, str2) => {\n            str = str || str2;\n            if (str) {\n              str = decode(str);\n              return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\n            }\n            url = decode(url || url2 || url3 || '');\n            if (!settings.allow_script_urls) {\n              const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\n              if (/(java|vb)script:/i.test(scriptUrl)) {\n                return '';\n              }\n              if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\n                return '';\n              }\n            }\n            if (urlConverter) {\n              url = urlConverter.call(urlConverterScope, url, 'style');\n            }\n            return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\n          };\n          if (css) {\n            css = css.replace(/[\\u0000-\\u001F]/g, '');\n            css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\n              return str.replace(/[;:]/g, encode);\n            });\n            let matches;\n            while (matches = styleRegExp.exec(css)) {\n              styleRegExp.lastIndex = matches.index + matches[0].length;\n              let name = matches[1].replace(trimRightRegExp, '').toLowerCase();\n              let value = matches[2].replace(trimRightRegExp, '');\n              if (name && value) {\n                name = decodeHexSequences(name);\n                value = decodeHexSequences(value);\n                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\n                  continue;\n                }\n                if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\n                  continue;\n                }\n                if (name === 'font-weight' && value === '700') {\n                  value = 'bold';\n                } else if (name === 'color' || name === 'background-color') {\n                  value = value.toLowerCase();\n                }\n                if (isString(settings.force_hex_color) && settings.force_hex_color !== 'off') {\n                  fromString(value).each(rgba => {\n                    if (settings.force_hex_color === 'always' || rgba.alpha === 1) {\n                      value = rgbaToHexString(toString(rgba));\n                    }\n                  });\n                }\n                value = value.replace(urlOrStrRegExp, processUrl);\n                styles[name] = isEncoded ? decode(value, true) : value;\n              }\n            }\n            compress('border', '', true);\n            compress('border', '-width');\n            compress('border', '-color');\n            compress('border', '-style');\n            compress('padding', '');\n            compress('margin', '');\n            compress2('border', 'border-width', 'border-style', 'border-color');\n            if (styles.border === 'medium none') {\n              delete styles.border;\n            }\n            if (styles['border-image'] === 'none') {\n              delete styles['border-image'];\n            }\n          }\n          return styles;\n        },\n        serialize: (styles, elementName) => {\n          let css = '';\n          const serializeStyles = (elemName, validStyleList) => {\n            const styleList = validStyleList[elemName];\n            if (styleList) {\n              for (let i = 0, l = styleList.length; i < l; i++) {\n                const name = styleList[i];\n                const value = styles[name];\n                if (value) {\n                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n                }\n              }\n            }\n          };\n          const isValid = (name, elemName) => {\n            if (!invalidStyles || !elemName) {\n              return true;\n            }\n            let styleMap = invalidStyles['*'];\n            if (styleMap && styleMap[name]) {\n              return false;\n            }\n            styleMap = invalidStyles[elemName];\n            return !(styleMap && styleMap[name]);\n          };\n          if (elementName && validStyles) {\n            serializeStyles('*', validStyles);\n            serializeStyles(elementName, validStyles);\n          } else {\n            each$d(styles, (value, name) => {\n              if (value && isValid(name, elementName)) {\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\n              }\n            });\n          }\n          return css;\n        }\n      };\n      return self;\n    };\n\n    const deprecated = {\n      keyLocation: true,\n      layerX: true,\n      layerY: true,\n      returnValue: true,\n      webkitMovementX: true,\n      webkitMovementY: true,\n      keyIdentifier: true,\n      mozPressure: true\n    };\n    const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\n    const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\n    const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\n    const clone$3 = (originalEvent, data) => {\n      const event = data !== null && data !== void 0 ? data : {};\n      for (const name in originalEvent) {\n        if (!has$2(deprecated, name)) {\n          event[name] = originalEvent[name];\n        }\n      }\n      if (isNonNullable(originalEvent.composedPath)) {\n        event.composedPath = () => originalEvent.composedPath();\n      }\n      if (isNonNullable(originalEvent.getModifierState)) {\n        event.getModifierState = keyArg => originalEvent.getModifierState(keyArg);\n      }\n      if (isNonNullable(originalEvent.getTargetRanges)) {\n        event.getTargetRanges = () => originalEvent.getTargetRanges();\n      }\n      return event;\n    };\n    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\n      var _a;\n      const event = clone$3(originalEvent, data);\n      event.type = type;\n      if (isNullable(event.target)) {\n        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\n      }\n      if (needsNormalizing(originalEvent)) {\n        event.preventDefault = () => {\n          event.defaultPrevented = true;\n          event.isDefaultPrevented = always;\n          if (isFunction(originalEvent.preventDefault)) {\n            originalEvent.preventDefault();\n          }\n        };\n        event.stopPropagation = () => {\n          event.cancelBubble = true;\n          event.isPropagationStopped = always;\n          if (isFunction(originalEvent.stopPropagation)) {\n            originalEvent.stopPropagation();\n          }\n        };\n        event.stopImmediatePropagation = () => {\n          event.isImmediatePropagationStopped = always;\n          event.stopPropagation();\n        };\n        if (!hasIsDefaultPrevented(event)) {\n          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\n          event.isPropagationStopped = event.cancelBubble === true ? always : never;\n          event.isImmediatePropagationStopped = never;\n        }\n      }\n      return event;\n    };\n\n    const eventExpandoPrefix = 'mce-data-';\n    const mouseEventRe = /^(?:mouse|contextmenu)|click/;\n    const addEvent = (target, name, callback, capture) => {\n      target.addEventListener(name, callback, capture || false);\n    };\n    const removeEvent = (target, name, callback, capture) => {\n      target.removeEventListener(name, callback, capture || false);\n    };\n    const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\n    const fix = (originalEvent, data) => {\n      const event = normalize$3(originalEvent.type, originalEvent, document, data);\n      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\n        const eventDoc = event.target.ownerDocument || document;\n        const doc = eventDoc.documentElement;\n        const body = eventDoc.body;\n        const mouseEvent = event;\n        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\n        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\n      }\n      return event;\n    };\n    const bindOnReady = (win, callback, eventUtils) => {\n      const doc = win.document, event = { type: 'ready' };\n      if (eventUtils.domLoaded) {\n        callback(event);\n        return;\n      }\n      const isDocReady = () => {\n        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\n      };\n      const readyHandler = () => {\n        removeEvent(win, 'DOMContentLoaded', readyHandler);\n        removeEvent(win, 'load', readyHandler);\n        if (!eventUtils.domLoaded) {\n          eventUtils.domLoaded = true;\n          callback(event);\n        }\n        win = null;\n      };\n      if (isDocReady()) {\n        readyHandler();\n      } else {\n        addEvent(win, 'DOMContentLoaded', readyHandler);\n      }\n      if (!eventUtils.domLoaded) {\n        addEvent(win, 'load', readyHandler);\n      }\n    };\n    class EventUtils {\n      constructor() {\n        this.domLoaded = false;\n        this.events = {};\n        this.count = 1;\n        this.expando = eventExpandoPrefix + (+new Date()).toString(32);\n        this.hasFocusIn = 'onfocusin' in document.documentElement;\n        this.count = 1;\n      }\n      bind(target, names, callback, scope) {\n        const self = this;\n        let callbackList;\n        const win = window;\n        const defaultNativeHandler = evt => {\n          self.executeHandlers(fix(evt || win.event), id);\n        };\n        if (!target || isText$a(target) || isComment(target)) {\n          return callback;\n        }\n        let id;\n        if (!target[self.expando]) {\n          id = self.count++;\n          target[self.expando] = id;\n          self.events[id] = {};\n        } else {\n          id = target[self.expando];\n        }\n        scope = scope || target;\n        const namesList = names.split(' ');\n        let i = namesList.length;\n        while (i--) {\n          let name = namesList[i];\n          let nativeHandler = defaultNativeHandler;\n          let capture = false;\n          let fakeName = false;\n          if (name === 'DOMContentLoaded') {\n            name = 'ready';\n          }\n          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\n            callback.call(scope, fix({ type: name }));\n            continue;\n          }\n          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\n            capture = true;\n            fakeName = name === 'focusin' ? 'focus' : 'blur';\n            nativeHandler = evt => {\n              const event = fix(evt || win.event);\n              event.type = event.type === 'focus' ? 'focusin' : 'focusout';\n              self.executeHandlers(event, id);\n            };\n          }\n          callbackList = self.events[id][name];\n          if (!callbackList) {\n            self.events[id][name] = callbackList = [{\n                func: callback,\n                scope\n              }];\n            callbackList.fakeName = fakeName;\n            callbackList.capture = capture;\n            callbackList.nativeHandler = nativeHandler;\n            if (name === 'ready') {\n              bindOnReady(target, nativeHandler, self);\n            } else {\n              addEvent(target, fakeName || name, nativeHandler, capture);\n            }\n          } else {\n            if (name === 'ready' && self.domLoaded) {\n              callback(fix({ type: name }));\n            } else {\n              callbackList.push({\n                func: callback,\n                scope\n              });\n            }\n          }\n        }\n        target = callbackList = null;\n        return callback;\n      }\n      unbind(target, names, callback) {\n        if (!target || isText$a(target) || isComment(target)) {\n          return this;\n        }\n        const id = target[this.expando];\n        if (id) {\n          let eventMap = this.events[id];\n          if (names) {\n            const namesList = names.split(' ');\n            let i = namesList.length;\n            while (i--) {\n              const name = namesList[i];\n              const callbackList = eventMap[name];\n              if (callbackList) {\n                if (callback) {\n                  let ci = callbackList.length;\n                  while (ci--) {\n                    if (callbackList[ci].func === callback) {\n                      const nativeHandler = callbackList.nativeHandler;\n                      const fakeName = callbackList.fakeName, capture = callbackList.capture;\n                      const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\n                      newCallbackList.nativeHandler = nativeHandler;\n                      newCallbackList.fakeName = fakeName;\n                      newCallbackList.capture = capture;\n                      eventMap[name] = newCallbackList;\n                    }\n                  }\n                }\n                if (!callback || callbackList.length === 0) {\n                  delete eventMap[name];\n                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n                }\n              }\n            }\n          } else {\n            each$d(eventMap, (callbackList, name) => {\n              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\n            });\n            eventMap = {};\n          }\n          for (const name in eventMap) {\n            if (has$2(eventMap, name)) {\n              return this;\n            }\n          }\n          delete this.events[id];\n          try {\n            delete target[this.expando];\n          } catch (ex) {\n            target[this.expando] = null;\n          }\n        }\n        return this;\n      }\n      fire(target, name, args) {\n        return this.dispatch(target, name, args);\n      }\n      dispatch(target, name, args) {\n        if (!target || isText$a(target) || isComment(target)) {\n          return this;\n        }\n        const event = fix({\n          type: name,\n          target\n        }, args);\n        do {\n          const id = target[this.expando];\n          if (id) {\n            this.executeHandlers(event, id);\n          }\n          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\n        } while (target && !event.isPropagationStopped());\n        return this;\n      }\n      clean(target) {\n        if (!target || isText$a(target) || isComment(target)) {\n          return this;\n        }\n        if (target[this.expando]) {\n          this.unbind(target);\n        }\n        if (!target.getElementsByTagName) {\n          target = target.document;\n        }\n        if (target && target.getElementsByTagName) {\n          this.unbind(target);\n          const children = target.getElementsByTagName('*');\n          let i = children.length;\n          while (i--) {\n            target = children[i];\n            if (target[this.expando]) {\n              this.unbind(target);\n            }\n          }\n        }\n        return this;\n      }\n      destroy() {\n        this.events = {};\n      }\n      cancel(e) {\n        if (e) {\n          e.preventDefault();\n          e.stopImmediatePropagation();\n        }\n        return false;\n      }\n      executeHandlers(evt, id) {\n        const container = this.events[id];\n        const callbackList = container && container[evt.type];\n        if (callbackList) {\n          for (let i = 0, l = callbackList.length; i < l; i++) {\n            const callback = callbackList[i];\n            if (callback && callback.func.call(callback.scope, evt) === false) {\n              evt.preventDefault();\n            }\n            if (evt.isImmediatePropagationStopped()) {\n              return;\n            }\n          }\n        }\n      }\n    }\n    EventUtils.Event = new EventUtils();\n\n    const each$a = Tools.each;\n    const grep = Tools.grep;\n    const internalStyleName = 'data-mce-style';\n    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\n    const legacySetAttribute = (elm, name, value) => {\n      if (isNullable(value) || value === '') {\n        remove$a(elm, name);\n      } else {\n        set$3(elm, name, value);\n      }\n    };\n    const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\n    const findNodeIndex = (node, normalized) => {\n      let idx = 0;\n      if (node) {\n        for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {\n          const nodeType = tempNode.nodeType;\n          if (normalized && isText$a(tempNode)) {\n            if (nodeType === lastNodeType || !tempNode.data.length) {\n              continue;\n            }\n          }\n          idx++;\n          lastNodeType = nodeType;\n        }\n      }\n      return idx;\n    };\n    const updateInternalStyleAttr = (styles, elm) => {\n      const rawValue = get$9(elm, 'style');\n      const value = styles.serialize(styles.parse(rawValue), name(elm));\n      legacySetAttribute(elm, internalStyleName, value);\n    };\n    const convertStyleToString = (cssValue, cssName) => {\n      if (isNumber(cssValue)) {\n        return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\n      } else {\n        return cssValue;\n      }\n    };\n    const applyStyle$1 = ($elm, cssName, cssValue) => {\n      const normalizedName = camelCaseToHyphens(cssName);\n      if (isNullable(cssValue) || cssValue === '') {\n        remove$6($elm, normalizedName);\n      } else {\n        set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\n      }\n    };\n    const setupAttrHooks = (styles, settings, getContext) => {\n      const keepValues = settings.keep_values;\n      const keepUrlHook = {\n        set: (elm, value, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          if (isFunction(settings.url_converter) && isNonNullable(value)) {\n            value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);\n          }\n          const internalName = 'data-mce-' + name;\n          legacySetAttribute(sugarElm, internalName, value);\n          legacySetAttribute(sugarElm, name, value);\n        },\n        get: (elm, name) => {\n          const sugarElm = SugarElement.fromDom(elm);\n          return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\n        }\n      };\n      const attrHooks = {\n        style: {\n          set: (elm, value) => {\n            const sugarElm = SugarElement.fromDom(elm);\n            if (keepValues) {\n              legacySetAttribute(sugarElm, internalStyleName, value);\n            }\n            remove$a(sugarElm, 'style');\n            if (isString(value)) {\n              setAll(sugarElm, styles.parse(value));\n            }\n          },\n          get: elm => {\n            const sugarElm = SugarElement.fromDom(elm);\n            const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\n            return styles.serialize(styles.parse(value), name(sugarElm));\n          }\n        }\n      };\n      if (keepValues) {\n        attrHooks.href = attrHooks.src = keepUrlHook;\n      }\n      return attrHooks;\n    };\n    const DOMUtils = (doc, settings = {}) => {\n      const addedStyles = {};\n      const win = window;\n      const files = {};\n      let counter = 0;\n      const stdMode = true;\n      const boxModel = true;\n      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\n        contentCssCors: settings.contentCssCors,\n        referrerPolicy: settings.referrerPolicy\n      });\n      const boundEvents = [];\n      const schema = settings.schema ? settings.schema : Schema({});\n      const styles = Styles({\n        url_converter: settings.url_converter,\n        url_converter_scope: settings.url_converter_scope,\n        force_hex_color: settings.force_hex_color\n      }, settings.schema);\n      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\n      const blockElementsMap = schema.getBlockElements();\n      const isBlock = node => {\n        if (isString(node)) {\n          return has$2(blockElementsMap, node);\n        } else {\n          return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));\n        }\n      };\n      const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\n      const _get = elm => {\n        const value = get(elm);\n        return isNonNullable(value) ? SugarElement.fromDom(value) : null;\n      };\n      const getAttrib = (elm, name, defaultVal = '') => {\n        let value;\n        const $elm = _get(elm);\n        if (isNonNullable($elm) && isElement$7($elm)) {\n          const hook = attrHooks[name];\n          if (hook && hook.get) {\n            value = hook.get($elm.dom, name);\n          } else {\n            value = get$9($elm, name);\n          }\n        }\n        return isNonNullable(value) ? value : defaultVal;\n      };\n      const getAttribs = elm => {\n        const node = get(elm);\n        return isNullable(node) ? [] : node.attributes;\n      };\n      const setAttrib = (elm, name, value) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const val = value === '' ? null : value;\n            const originalValue = get$9($elm, name);\n            const hook = attrHooks[name];\n            if (hook && hook.set) {\n              hook.set($elm.dom, val, name);\n            } else {\n              legacySetAttribute($elm, name, val);\n            }\n            if (originalValue !== val && settings.onSetAttrib) {\n              settings.onSetAttrib({\n                attrElm: $elm.dom,\n                attrName: name,\n                attrValue: val\n              });\n            }\n          }\n        });\n      };\n      const clone = (node, deep) => {\n        return node.cloneNode(deep);\n      };\n      const getRoot = () => settings.root_element || doc.body;\n      const getViewPort = argWin => {\n        const vp = getBounds(argWin);\n        return {\n          x: vp.x,\n          y: vp.y,\n          w: vp.width,\n          h: vp.height\n        };\n      };\n      const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\n      const setStyle = (elm, name, value) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          applyStyle$1($elm, name, value);\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const setStyles = (elm, stylesArg) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          each$d(stylesArg, (v, n) => {\n            applyStyle$1($elm, n, v);\n          });\n          if (settings.update_styles) {\n            updateInternalStyleAttr(styles, $elm);\n          }\n        });\n      };\n      const getStyle = (elm, name, computed) => {\n        const $elm = get(elm);\n        if (isNullable($elm) || !isHTMLElement($elm) && !isSVGElement($elm)) {\n          return undefined;\n        }\n        if (computed) {\n          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\n        } else {\n          name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\n          if (name === 'float') {\n            name = 'cssFloat';\n          }\n          return $elm.style ? $elm.style[name] : undefined;\n        }\n      };\n      const getSize = elm => {\n        const $elm = get(elm);\n        if (!$elm) {\n          return {\n            w: 0,\n            h: 0\n          };\n        }\n        let w = getStyle($elm, 'width');\n        let h = getStyle($elm, 'height');\n        if (!w || w.indexOf('px') === -1) {\n          w = '0';\n        }\n        if (!h || h.indexOf('px') === -1) {\n          h = '0';\n        }\n        return {\n          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\n          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\n        };\n      };\n      const getRect = elm => {\n        const $elm = get(elm);\n        const pos = getPos$1($elm);\n        const size = getSize($elm);\n        return {\n          x: pos.x,\n          y: pos.y,\n          w: size.w,\n          h: size.h\n        };\n      };\n      const is = (elm, selector) => {\n        if (!elm) {\n          return false;\n        }\n        const elms = isArray$1(elm) ? elm : [elm];\n        return exists(elms, e => {\n          return is$1(SugarElement.fromDom(e), selector);\n        });\n      };\n      const getParents = (elm, selector, root, collect) => {\n        const result = [];\n        let node = get(elm);\n        collect = collect === undefined;\n        const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\n        if (isString(selector)) {\n          if (selector === '*') {\n            selector = isElement$6;\n          } else {\n            const selectorVal = selector;\n            selector = node => is(node, selectorVal);\n          }\n        }\n        while (node) {\n          if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\n            break;\n          }\n          if (!selector || selector(node)) {\n            if (collect) {\n              result.push(node);\n            } else {\n              return [node];\n            }\n          }\n          node = node.parentNode;\n        }\n        return collect ? result : null;\n      };\n      const getParent = (node, selector, root) => {\n        const parents = getParents(node, selector, root, false);\n        return parents && parents.length > 0 ? parents[0] : null;\n      };\n      const _findSib = (node, selector, name) => {\n        let func = selector;\n        if (node) {\n          if (isString(selector)) {\n            func = node => {\n              return is(node, selector);\n            };\n          }\n          for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {\n            if (isFunction(func) && func(tempNode)) {\n              return tempNode;\n            }\n          }\n        }\n        return null;\n      };\n      const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\n      const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\n      const isParentNode = node => isFunction(node.querySelectorAll);\n      const select = (selector, scope) => {\n        var _a, _b;\n        const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\n        return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];\n      };\n      const run = function (elm, func, scope) {\n        const context = scope !== null && scope !== void 0 ? scope : this;\n        if (isArray$1(elm)) {\n          const result = [];\n          each$a(elm, (e, i) => {\n            const node = get(e);\n            if (node) {\n              result.push(func.call(context, node, i));\n            }\n          });\n          return result;\n        } else {\n          const node = get(elm);\n          return !node ? false : func.call(context, node);\n        }\n      };\n      const setAttribs = (elm, attrs) => {\n        run(elm, $elm => {\n          each$d(attrs, (value, name) => {\n            setAttrib($elm, name, value);\n          });\n        });\n      };\n      const setHTML = (elm, html) => {\n        run(elm, e => {\n          const $elm = SugarElement.fromDom(e);\n          set$1($elm, html);\n        });\n      };\n      const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\n        const newElm = isString(name) ? doc.createElement(name) : name;\n        if (isNonNullable(attrs)) {\n          setAttribs(newElm, attrs);\n        }\n        if (html) {\n          if (!isString(html) && html.nodeType) {\n            newElm.appendChild(html);\n          } else if (isString(html)) {\n            setHTML(newElm, html);\n          }\n        }\n        return !create ? parentElm.appendChild(newElm) : newElm;\n      });\n      const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\n      const decode = Entities.decode;\n      const encode = Entities.encodeAllRaw;\n      const createHTML = (name, attrs, html = '') => {\n        let outHtml = '<' + name;\n        for (const key in attrs) {\n          if (hasNonNullableKey(attrs, key)) {\n            outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\n          }\n        }\n        if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\n          return outHtml + ' />';\n        } else {\n          return outHtml + '>' + html + '</' + name + '>';\n        }\n      };\n      const createFragment = html => {\n        const container = doc.createElement('div');\n        const frag = doc.createDocumentFragment();\n        frag.appendChild(container);\n        if (html) {\n          container.innerHTML = html;\n        }\n        let node;\n        while (node = container.firstChild) {\n          frag.appendChild(node);\n        }\n        frag.removeChild(container);\n        return frag;\n      };\n      const remove = (node, keepChildren) => {\n        return run(node, n => {\n          const $node = SugarElement.fromDom(n);\n          if (keepChildren) {\n            each$e(children$1($node), child => {\n              if (isText$b(child) && child.dom.length === 0) {\n                remove$5(child);\n              } else {\n                before$3($node, child);\n              }\n            });\n          }\n          remove$5($node);\n          return $node.dom;\n        });\n      };\n      const removeAllAttribs = e => run(e, e => {\n        const attrs = e.attributes;\n        for (let i = attrs.length - 1; i >= 0; i--) {\n          e.removeAttributeNode(attrs.item(i));\n        }\n      });\n      const parseStyle = cssText => styles.parse(cssText);\n      const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\n      const addStyle = cssText => {\n        if (self !== DOMUtils.DOM && doc === document) {\n          if (addedStyles[cssText]) {\n            return;\n          }\n          addedStyles[cssText] = true;\n        }\n        let styleElm = doc.getElementById('mceDefaultStyles');\n        if (!styleElm) {\n          styleElm = doc.createElement('style');\n          styleElm.id = 'mceDefaultStyles';\n          styleElm.type = 'text/css';\n          const head = doc.head;\n          if (head.firstChild) {\n            head.insertBefore(styleElm, head.firstChild);\n          } else {\n            head.appendChild(styleElm);\n          }\n        }\n        if (styleElm.styleSheet) {\n          styleElm.styleSheet.cssText += cssText;\n        } else {\n          styleElm.appendChild(doc.createTextNode(cssText));\n        }\n      };\n      const loadCSS = urls => {\n        if (!urls) {\n          urls = '';\n        }\n        each$e(urls.split(','), url => {\n          files[url] = true;\n          styleSheetLoader.load(url).catch(noop);\n        });\n      };\n      const toggleClass = (elm, cls, state) => {\n        run(elm, e => {\n          if (isElement$6(e)) {\n            const $elm = SugarElement.fromDom(e);\n            const classes = cls.split(' ');\n            each$e(classes, c => {\n              if (isNonNullable(state)) {\n                const fn = state ? add$2 : remove$7;\n                fn($elm, c);\n              } else {\n                toggle$1($elm, c);\n              }\n            });\n          }\n        });\n      };\n      const addClass = (elm, cls) => {\n        toggleClass(elm, cls, true);\n      };\n      const removeClass = (elm, cls) => {\n        toggleClass(elm, cls, false);\n      };\n      const hasClass = (elm, cls) => {\n        const $elm = _get(elm);\n        const classes = cls.split(' ');\n        return isNonNullable($elm) && forall(classes, c => has($elm, c));\n      };\n      const show = elm => {\n        run(elm, e => remove$6(SugarElement.fromDom(e), 'display'));\n      };\n      const hide = elm => {\n        run(elm, e => set$2(SugarElement.fromDom(e), 'display', 'none'));\n      };\n      const isHidden = elm => {\n        const $elm = _get(elm);\n        return isNonNullable($elm) && is$2(getRaw($elm, 'display'), 'none');\n      };\n      const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\n      const getOuterHTML = elm => {\n        const $elm = _get(elm);\n        if (isNonNullable($elm)) {\n          return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\n        } else {\n          return '';\n        }\n      };\n      const setOuterHTML = (elm, html) => {\n        run(elm, $elm => {\n          if (isElement$6($elm)) {\n            $elm.outerHTML = html;\n          }\n        });\n      };\n      const insertAfter = (node, reference) => {\n        const referenceNode = get(reference);\n        return run(node, node => {\n          const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;\n          const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;\n          if (parent) {\n            if (nextSibling) {\n              parent.insertBefore(node, nextSibling);\n            } else {\n              parent.appendChild(node);\n            }\n          }\n          return node;\n        });\n      };\n      const replace = (newElm, oldElm, keepChildren) => run(oldElm, elm => {\n        var _a;\n        const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;\n        if (keepChildren) {\n          each$a(grep(elm.childNodes), node => {\n            replacee.appendChild(node);\n          });\n        }\n        (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);\n        return elm;\n      });\n      const rename = (elm, name) => {\n        if (elm.nodeName !== name.toUpperCase()) {\n          const newElm = create(name);\n          each$a(getAttribs(elm), attrNode => {\n            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\n          });\n          replace(newElm, elm, true);\n          return newElm;\n        } else {\n          return elm;\n        }\n      };\n      const findCommonAncestor = (a, b) => {\n        let ps = a;\n        while (ps) {\n          let pe = b;\n          while (pe && ps !== pe) {\n            pe = pe.parentNode;\n          }\n          if (ps === pe) {\n            break;\n          }\n          ps = ps.parentNode;\n        }\n        if (!ps && a.ownerDocument) {\n          return a.ownerDocument.documentElement;\n        } else {\n          return ps;\n        }\n      };\n      const isNonEmptyElement = node => {\n        if (isElement$6(node)) {\n          const isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');\n          if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {\n            return true;\n          }\n        }\n        return false;\n      };\n      const isEmpty = (node, elements, options) => {\n        let brCount = 0;\n        if (isNonEmptyElement(node)) {\n          return false;\n        }\n        const firstChild = node.firstChild;\n        if (firstChild) {\n          const walker = new DomTreeWalker(firstChild, node);\n          const whitespaceElements = schema ? schema.getWhitespaceElements() : {};\n          const nonEmptyElements = elements || (schema ? schema.getNonEmptyElements() : null);\n          let tempNode = firstChild;\n          do {\n            if (isElement$6(tempNode)) {\n              const bogusVal = tempNode.getAttribute('data-mce-bogus');\n              if (bogusVal) {\n                tempNode = walker.next(bogusVal === 'all');\n                continue;\n              }\n              const name = tempNode.nodeName.toLowerCase();\n              if (nonEmptyElements && nonEmptyElements[name]) {\n                if (name === 'br') {\n                  brCount++;\n                  tempNode = walker.next();\n                  continue;\n                }\n                return false;\n              }\n              if (isNonEmptyElement(tempNode)) {\n                return false;\n              }\n            }\n            if (isComment(tempNode)) {\n              return false;\n            }\n            if (isText$a(tempNode) && !isWhitespaceText(tempNode.data) && (!(options === null || options === void 0 ? void 0 : options.includeZwsp) || !isZwsp(tempNode.data))) {\n              return false;\n            }\n            if (isText$a(tempNode) && tempNode.parentNode && whitespaceElements[tempNode.parentNode.nodeName] && isWhitespaceText(tempNode.data)) {\n              return false;\n            }\n            tempNode = walker.next();\n          } while (tempNode);\n        }\n        return brCount <= 1;\n      };\n      const createRng = () => doc.createRange();\n      const split = (parentElm, splitElm, replacementElm) => {\n        let range = createRng();\n        let beforeFragment;\n        let afterFragment;\n        if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {\n          const parentNode = parentElm.parentNode;\n          range.setStart(parentNode, findNodeIndex(parentElm));\n          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\n          beforeFragment = range.extractContents();\n          range = createRng();\n          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\n          range.setEnd(parentNode, findNodeIndex(parentElm) + 1);\n          afterFragment = range.extractContents();\n          parentNode.insertBefore(trimNode(self, beforeFragment, schema), parentElm);\n          if (replacementElm) {\n            parentNode.insertBefore(replacementElm, parentElm);\n          } else {\n            parentNode.insertBefore(splitElm, parentElm);\n          }\n          parentNode.insertBefore(trimNode(self, afterFragment, schema), parentElm);\n          remove(parentElm);\n          return replacementElm || splitElm;\n        } else {\n          return undefined;\n        }\n      };\n      const bind = (target, name, func, scope) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = bind(target[i], name, func, scope);\n          }\n          return rv;\n        } else {\n          if (settings.collect && (target === doc || target === win)) {\n            boundEvents.push([\n              target,\n              name,\n              func,\n              scope\n            ]);\n          }\n          return events.bind(target, name, func, scope || self);\n        }\n      };\n      const unbind = (target, name, func) => {\n        if (isArray$1(target)) {\n          let i = target.length;\n          const rv = [];\n          while (i--) {\n            rv[i] = unbind(target[i], name, func);\n          }\n          return rv;\n        } else {\n          if (boundEvents.length > 0 && (target === doc || target === win)) {\n            let i = boundEvents.length;\n            while (i--) {\n              const [boundTarget, boundName, boundFunc] = boundEvents[i];\n              if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {\n                events.unbind(boundTarget, boundName, boundFunc);\n              }\n            }\n          }\n          return events.unbind(target, name, func);\n        }\n      };\n      const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\n      const fire = (target, name, evt) => events.dispatch(target, name, evt);\n      const getContentEditable = node => {\n        if (node && isHTMLElement(node)) {\n          const contentEditable = node.getAttribute('data-mce-contenteditable');\n          if (contentEditable && contentEditable !== 'inherit') {\n            return contentEditable;\n          }\n          return node.contentEditable !== 'inherit' ? node.contentEditable : null;\n        } else {\n          return null;\n        }\n      };\n      const getContentEditableParent = node => {\n        const root = getRoot();\n        let state = null;\n        for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n          state = getContentEditable(tempNode);\n          if (state !== null) {\n            break;\n          }\n        }\n        return state;\n      };\n      const isEditable = node => {\n        if (isNonNullable(node)) {\n          const scope = isElement$6(node) ? node : node.parentElement;\n          return isNonNullable(scope) && isHTMLElement(scope) && isEditable$2(SugarElement.fromDom(scope));\n        } else {\n          return false;\n        }\n      };\n      const destroy = () => {\n        if (boundEvents.length > 0) {\n          let i = boundEvents.length;\n          while (i--) {\n            const [boundTarget, boundName, boundFunc] = boundEvents[i];\n            events.unbind(boundTarget, boundName, boundFunc);\n          }\n        }\n        each$d(files, (_, url) => {\n          styleSheetLoader.unload(url);\n          delete files[url];\n        });\n      };\n      const isChildOf = (node, parent) => {\n        return node === parent || parent.contains(node);\n      };\n      const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\n      const self = {\n        doc,\n        settings,\n        win,\n        files,\n        stdMode,\n        boxModel,\n        styleSheetLoader,\n        boundEvents,\n        styles,\n        schema,\n        events,\n        isBlock: isBlock,\n        root: null,\n        clone,\n        getRoot,\n        getViewPort,\n        getRect,\n        getSize,\n        getParent,\n        getParents: getParents,\n        get,\n        getNext,\n        getPrev,\n        select,\n        is,\n        add,\n        create,\n        createHTML,\n        createFragment,\n        remove,\n        setStyle,\n        getStyle: getStyle,\n        setStyles,\n        removeAllAttribs,\n        setAttrib,\n        setAttribs,\n        getAttrib,\n        getPos: getPos$1,\n        parseStyle,\n        serializeStyle,\n        addStyle,\n        loadCSS,\n        addClass,\n        removeClass,\n        hasClass,\n        toggleClass,\n        show,\n        hide,\n        isHidden,\n        uniqueId,\n        setHTML,\n        getOuterHTML,\n        setOuterHTML,\n        decode,\n        encode,\n        insertAfter,\n        replace,\n        rename,\n        findCommonAncestor,\n        run,\n        getAttribs,\n        isEmpty,\n        createRng,\n        nodeIndex: findNodeIndex,\n        split,\n        bind: bind,\n        unbind: unbind,\n        fire,\n        dispatch,\n        getContentEditable,\n        getContentEditableParent,\n        isEditable,\n        destroy,\n        isChildOf,\n        dumpRng\n      };\n      const attrHooks = setupAttrHooks(styles, settings, constant(self));\n      return self;\n    };\n    DOMUtils.DOM = DOMUtils(document);\n    DOMUtils.nodeIndex = findNodeIndex;\n\n    const DOM$b = DOMUtils.DOM;\n    const QUEUED = 0;\n    const LOADING = 1;\n    const LOADED = 2;\n    const FAILED = 3;\n    class ScriptLoader {\n      constructor(settings = {}) {\n        this.states = {};\n        this.queue = [];\n        this.scriptLoadedCallbacks = {};\n        this.queueLoadedCallbacks = [];\n        this.loading = false;\n        this.settings = settings;\n      }\n      _setReferrerPolicy(referrerPolicy) {\n        this.settings.referrerPolicy = referrerPolicy;\n      }\n      loadScript(url) {\n        return new Promise((resolve, reject) => {\n          const dom = DOM$b;\n          let elm;\n          const cleanup = () => {\n            dom.remove(id);\n            if (elm) {\n              elm.onerror = elm.onload = elm = null;\n            }\n          };\n          const done = () => {\n            cleanup();\n            resolve();\n          };\n          const error = () => {\n            cleanup();\n            reject('Failed to load script: ' + url);\n          };\n          const id = dom.uniqueId();\n          elm = document.createElement('script');\n          elm.id = id;\n          elm.type = 'text/javascript';\n          elm.src = Tools._addCacheSuffix(url);\n          if (this.settings.referrerPolicy) {\n            dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\n          }\n          elm.onload = done;\n          elm.onerror = error;\n          (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\n        });\n      }\n      isDone(url) {\n        return this.states[url] === LOADED;\n      }\n      markDone(url) {\n        this.states[url] = LOADED;\n      }\n      add(url) {\n        const self = this;\n        self.queue.push(url);\n        const state = self.states[url];\n        if (state === undefined) {\n          self.states[url] = QUEUED;\n        }\n        return new Promise((resolve, reject) => {\n          if (!self.scriptLoadedCallbacks[url]) {\n            self.scriptLoadedCallbacks[url] = [];\n          }\n          self.scriptLoadedCallbacks[url].push({\n            resolve,\n            reject\n          });\n        });\n      }\n      load(url) {\n        return this.add(url);\n      }\n      remove(url) {\n        delete this.states[url];\n        delete this.scriptLoadedCallbacks[url];\n      }\n      loadQueue() {\n        const queue = this.queue;\n        this.queue = [];\n        return this.loadScripts(queue);\n      }\n      loadScripts(scripts) {\n        const self = this;\n        const execCallbacks = (name, url) => {\n          get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\n            each$e(callbacks, callback => callback[name](url));\n          });\n          delete self.scriptLoadedCallbacks[url];\n        };\n        const processResults = results => {\n          const failures = filter$5(results, result => result.status === 'rejected');\n          if (failures.length > 0) {\n            return Promise.reject(bind$3(failures, ({reason}) => isArray$1(reason) ? reason : [reason]));\n          } else {\n            return Promise.resolve();\n          }\n        };\n        const load = urls => Promise.allSettled(map$3(urls, url => {\n          if (self.states[url] === LOADED) {\n            execCallbacks('resolve', url);\n            return Promise.resolve();\n          } else if (self.states[url] === FAILED) {\n            execCallbacks('reject', url);\n            return Promise.reject(url);\n          } else {\n            self.states[url] = LOADING;\n            return self.loadScript(url).then(() => {\n              self.states[url] = LOADED;\n              execCallbacks('resolve', url);\n              const queue = self.queue;\n              if (queue.length > 0) {\n                self.queue = [];\n                return load(queue).then(processResults);\n              } else {\n                return Promise.resolve();\n              }\n            }, () => {\n              self.states[url] = FAILED;\n              execCallbacks('reject', url);\n              return Promise.reject(url);\n            });\n          }\n        }));\n        const processQueue = urls => {\n          self.loading = true;\n          return load(urls).then(results => {\n            self.loading = false;\n            const nextQueuedItem = self.queueLoadedCallbacks.shift();\n            Optional.from(nextQueuedItem).each(call);\n            return processResults(results);\n          });\n        };\n        const uniqueScripts = stringArray(scripts);\n        if (self.loading) {\n          return new Promise((resolve, reject) => {\n            self.queueLoadedCallbacks.push(() => {\n              processQueue(uniqueScripts).then(resolve, reject);\n            });\n          });\n        } else {\n          return processQueue(uniqueScripts);\n        }\n      }\n    }\n    ScriptLoader.ScriptLoader = new ScriptLoader();\n\n    const Cell = initial => {\n      let value = initial;\n      const get = () => {\n        return value;\n      };\n      const set = v => {\n        value = v;\n      };\n      return {\n        get,\n        set\n      };\n    };\n\n    const isDuplicated = (items, item) => {\n      const firstIndex = items.indexOf(item);\n      return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;\n    };\n    const isRaw = str => isObject(str) && has$2(str, 'raw');\n    const isTokenised = str => isArray$1(str) && str.length > 1;\n    const data = {};\n    const currentCode = Cell('en');\n    const getLanguageData = () => get$a(data, currentCode.get());\n    const getData$1 = () => map$2(data, value => ({ ...value }));\n    const setCode = newCode => {\n      if (newCode) {\n        currentCode.set(newCode);\n      }\n    };\n    const getCode = () => currentCode.get();\n    const add$1 = (code, items) => {\n      let langData = data[code];\n      if (!langData) {\n        data[code] = langData = {};\n      }\n      const lcNames = map$3(keys(items), name => name.toLowerCase());\n      each$d(items, (translation, name) => {\n        const lcName = name.toLowerCase();\n        if (lcName !== name && isDuplicated(lcNames, lcName)) {\n          if (!has$2(items, lcName)) {\n            langData[lcName] = translation;\n          }\n          langData[name] = translation;\n        } else {\n          langData[lcName] = translation;\n        }\n      });\n    };\n    const translate = text => {\n      const langData = getLanguageData().getOr({});\n      const toString = obj => {\n        if (isFunction(obj)) {\n          return Object.prototype.toString.call(obj);\n        }\n        return !isEmpty(obj) ? '' + obj : '';\n      };\n      const isEmpty = text => text === '' || text === null || text === undefined;\n      const getLangData = text => {\n        const textStr = toString(text);\n        return has$2(langData, textStr) ? toString(langData[textStr]) : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);\n      };\n      const removeContext = str => str.replace(/{context:\\w+}$/, '');\n      if (isEmpty(text)) {\n        return '';\n      }\n      if (isRaw(text)) {\n        return toString(text.raw);\n      }\n      if (isTokenised(text)) {\n        const values = text.slice(1);\n        const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\n        return removeContext(substitued);\n      }\n      return removeContext(getLangData(text));\n    };\n    const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\n    const hasCode = code => has$2(data, code);\n    const I18n = {\n      getData: getData$1,\n      setCode,\n      getCode,\n      add: add$1,\n      translate,\n      isRtl: isRtl$1,\n      hasCode\n    };\n\n    const AddOnManager = () => {\n      const items = [];\n      const urls = {};\n      const lookup = {};\n      const _listeners = [];\n      const runListeners = (name, state) => {\n        const matchedListeners = filter$5(_listeners, listener => listener.name === name && listener.state === state);\n        each$e(matchedListeners, listener => listener.resolve());\n      };\n      const isLoaded = name => has$2(urls, name);\n      const isAdded = name => has$2(lookup, name);\n      const get = name => {\n        if (lookup[name]) {\n          return lookup[name].instance;\n        }\n        return undefined;\n      };\n      const loadLanguagePack = (name, languages) => {\n        const language = I18n.getCode();\n        const wrappedLanguages = ',' + (languages || '') + ',';\n        if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\n          return;\n        }\n        ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\n      };\n      const requireLangPack = (name, languages) => {\n        if (AddOnManager.languageLoad !== false) {\n          if (isLoaded(name)) {\n            loadLanguagePack(name, languages);\n          } else {\n            waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\n          }\n        }\n      };\n      const add = (id, addOn) => {\n        items.push(addOn);\n        lookup[id] = { instance: addOn };\n        runListeners(id, 'added');\n        return addOn;\n      };\n      const remove = name => {\n        delete urls[name];\n        delete lookup[name];\n      };\n      const createUrl = (baseUrl, dep) => {\n        if (isString(dep)) {\n          return isString(baseUrl) ? {\n            prefix: '',\n            resource: dep,\n            suffix: ''\n          } : {\n            prefix: baseUrl.prefix,\n            resource: dep,\n            suffix: baseUrl.suffix\n          };\n        } else {\n          return dep;\n        }\n      };\n      const load = (name, addOnUrl) => {\n        if (urls[name]) {\n          return Promise.resolve();\n        }\n        let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\n        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\n          urlString = AddOnManager.baseURL + '/' + urlString;\n        }\n        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\n        const done = () => {\n          runListeners(name, 'loaded');\n          return Promise.resolve();\n        };\n        if (lookup[name]) {\n          return done();\n        } else {\n          return ScriptLoader.ScriptLoader.add(urlString).then(done);\n        }\n      };\n      const waitFor = (name, state = 'added') => {\n        if (state === 'added' && isAdded(name)) {\n          return Promise.resolve();\n        } else if (state === 'loaded' && isLoaded(name)) {\n          return Promise.resolve();\n        } else {\n          return new Promise(resolve => {\n            _listeners.push({\n              name,\n              state,\n              resolve\n            });\n          });\n        }\n      };\n      return {\n        items,\n        urls,\n        lookup,\n        get,\n        requireLangPack,\n        add,\n        remove,\n        createUrl,\n        load,\n        waitFor\n      };\n    };\n    AddOnManager.languageLoad = true;\n    AddOnManager.baseURL = '';\n    AddOnManager.PluginManager = AddOnManager();\n    AddOnManager.ThemeManager = AddOnManager();\n    AddOnManager.ModelManager = AddOnManager();\n\n    const singleton = doRevoke => {\n      const subject = Cell(Optional.none());\n      const revoke = () => subject.get().each(doRevoke);\n      const clear = () => {\n        revoke();\n        subject.set(Optional.none());\n      };\n      const isSet = () => subject.get().isSome();\n      const get = () => subject.get();\n      const set = s => {\n        revoke();\n        subject.set(Optional.some(s));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const repeatable = delay => {\n      const intervalId = Cell(Optional.none());\n      const revoke = () => intervalId.get().each(id => clearInterval(id));\n      const clear = () => {\n        revoke();\n        intervalId.set(Optional.none());\n      };\n      const isSet = () => intervalId.get().isSome();\n      const get = () => intervalId.get();\n      const set = functionToRepeat => {\n        revoke();\n        intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));\n      };\n      return {\n        clear,\n        isSet,\n        get,\n        set\n      };\n    };\n    const value$2 = () => {\n      const subject = singleton(noop);\n      const on = f => subject.get().each(f);\n      return {\n        ...subject,\n        on\n      };\n    };\n\n    const first$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        if (isNull(timer)) {\n          timer = setTimeout(() => {\n            timer = null;\n            fn.apply(null, args);\n          }, rate);\n        }\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n    const last$1 = (fn, rate) => {\n      let timer = null;\n      const cancel = () => {\n        if (!isNull(timer)) {\n          clearTimeout(timer);\n          timer = null;\n        }\n      };\n      const throttle = (...args) => {\n        cancel();\n        timer = setTimeout(() => {\n          timer = null;\n          fn.apply(null, args);\n        }, rate);\n      };\n      return {\n        cancel,\n        throttle\n      };\n    };\n\n    const annotation = constant('mce-annotation');\n    const dataAnnotation = constant('data-mce-annotation');\n    const dataAnnotationId = constant('data-mce-annotation-uid');\n    const dataAnnotationActive = constant('data-mce-annotation-active');\n    const dataAnnotationClasses = constant('data-mce-annotation-classes');\n    const dataAnnotationAttributes = constant('data-mce-annotation-attrs');\n\n    const isRoot$1 = root => node => eq(node, root);\n    const identify = (editor, annotationName) => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const root = SugarElement.fromDom(editor.getBody());\n      const selector = annotationName.fold(() => '.' + annotation(), an => `[${ dataAnnotation() }=\"${ an }\"]`);\n      const newStart = child$1(start, rng.startOffset).getOr(start);\n      const closest = closest$3(newStart, selector, isRoot$1(root));\n      return closest.bind(c => getOpt(c, `${ dataAnnotationId() }`).bind(uid => getOpt(c, `${ dataAnnotation() }`).map(name => {\n        const elements = findMarkers(editor, uid);\n        return {\n          uid,\n          name,\n          elements\n        };\n      })));\n    };\n    const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\n    const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$2(elem, '[data-mce-bogus=\"all\"]', isRoot$1(root));\n    const findMarkers = (editor, uid) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const descendants$1 = descendants(body, `[${ dataAnnotationId() }=\"${ uid }\"]`);\n      return filter$5(descendants$1, descendant => !isBogusElement(descendant, body));\n    };\n    const findAll = (editor, name) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const markers = descendants(body, `[${ dataAnnotation() }=\"${ name }\"]`);\n      const directory = {};\n      each$e(markers, m => {\n        if (!isBogusElement(m, body)) {\n          const uid = get$9(m, dataAnnotationId());\n          const nodesAlready = get$a(directory, uid).getOr([]);\n          directory[uid] = nodesAlready.concat([m]);\n        }\n      });\n      return directory;\n    };\n\n    const setup$y = (editor, registry) => {\n      const changeCallbacks = Cell({});\n      const initData = () => ({\n        listeners: [],\n        previous: value$2()\n      });\n      const withCallbacks = (name, f) => {\n        updateCallbacks(name, data => {\n          f(data);\n          return data;\n        });\n      };\n      const updateCallbacks = (name, f) => {\n        const callbackMap = changeCallbacks.get();\n        const data = get$a(callbackMap, name).getOrThunk(initData);\n        const outputData = f(data);\n        callbackMap[name] = outputData;\n        changeCallbacks.set(callbackMap);\n      };\n      const fireCallbacks = (name, uid, elements) => {\n        withCallbacks(name, data => {\n          each$e(data.listeners, f => f(true, name, {\n            uid,\n            nodes: map$3(elements, elem => elem.dom)\n          }));\n        });\n      };\n      const fireNoAnnotation = name => {\n        withCallbacks(name, data => {\n          each$e(data.listeners, f => f(false, name));\n        });\n      };\n      const toggleActiveAttr = (uid, state) => {\n        each$e(findMarkers(editor, uid), elem => {\n          if (state) {\n            set$3(elem, dataAnnotationActive(), 'true');\n          } else {\n            remove$a(elem, dataAnnotationActive());\n          }\n        });\n      };\n      const onNodeChange = last$1(() => {\n        const annotations = sort(registry.getNames());\n        each$e(annotations, name => {\n          updateCallbacks(name, data => {\n            const prev = data.previous.get();\n            identify(editor, Optional.some(name)).fold(() => {\n              prev.each(uid => {\n                fireNoAnnotation(name);\n                data.previous.clear();\n                toggleActiveAttr(uid, false);\n              });\n            }, ({uid, name, elements}) => {\n              if (!is$2(prev, uid)) {\n                prev.each(uid => toggleActiveAttr(uid, false));\n                fireCallbacks(name, uid, elements);\n                data.previous.set(uid);\n                toggleActiveAttr(uid, true);\n              }\n            });\n            return {\n              previous: data.previous,\n              listeners: data.listeners\n            };\n          });\n        });\n      }, 30);\n      editor.on('remove', () => {\n        onNodeChange.cancel();\n      });\n      editor.on('NodeChange', () => {\n        onNodeChange.throttle();\n      });\n      const addListener = (name, f) => {\n        updateCallbacks(name, data => ({\n          previous: data.previous,\n          listeners: data.listeners.concat([f])\n        }));\n      };\n      return { addListener };\n    };\n\n    const setup$x = (editor, registry) => {\n      const dataAnnotation$1 = dataAnnotation();\n      const identifyParserNode = node => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);\n      const removeDirectAnnotation = node => {\n        var _a, _b;\n        node.attr(dataAnnotationId(), null);\n        node.attr(dataAnnotation(), null);\n        node.attr(dataAnnotationActive(), null);\n        const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map(names => names.split(',')).getOr([]);\n        const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map(names => names.split(',')).getOr([]);\n        each$e(customAttrNames, name => node.attr(name, null));\n        const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];\n        const newClassList = difference(classList, [annotation()].concat(customClasses));\n        node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);\n        node.attr(dataAnnotationClasses(), null);\n        node.attr(dataAnnotationAttributes(), null);\n      };\n      editor.serializer.addTempAttr(dataAnnotationActive());\n      editor.serializer.addAttributeFilter(dataAnnotation$1, nodes => {\n        for (const node of nodes) {\n          identifyParserNode(node).each(settings => {\n            if (settings.persistent === false) {\n              if (node.name === 'span') {\n                node.unwrap();\n              } else {\n                removeDirectAnnotation(node);\n              }\n            }\n          });\n        }\n      });\n    };\n\n    const create$c = () => {\n      const annotations = {};\n      const register = (name, settings) => {\n        annotations[name] = {\n          name,\n          settings\n        };\n      };\n      const lookup = name => get$a(annotations, name).map(a => a.settings);\n      const getNames = () => keys(annotations);\n      return {\n        register,\n        lookup,\n        getNames\n      };\n    };\n\n    let unique = 0;\n    const generate$1 = prefix => {\n      const date = new Date();\n      const time = date.getTime();\n      const random = Math.floor(Math.random() * 1000000000);\n      unique++;\n      return prefix + '_' + random + unique + String(time);\n    };\n\n    const add = (element, classes) => {\n      each$e(classes, x => {\n        add$2(element, x);\n      });\n    };\n    const remove$4 = (element, classes) => {\n      each$e(classes, x => {\n        remove$7(element, x);\n      });\n    };\n\n    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\n    const shallow$1 = original => clone$2(original, false);\n    const deep$1 = original => clone$2(original, true);\n    const shallowAs = (original, tag) => {\n      const nu = SugarElement.fromTag(tag);\n      const attributes = clone$4(original);\n      setAll$1(nu, attributes);\n      return nu;\n    };\n    const mutate = (original, tag) => {\n      const nu = shallowAs(original, tag);\n      after$4(original, nu);\n      const children = children$1(original);\n      append(nu, children);\n      remove$5(original);\n      return nu;\n    };\n\n    const TextWalker = (startNode, rootNode, isBoundary = never) => {\n      const walker = new DomTreeWalker(startNode, rootNode);\n      const walk = direction => {\n        let next;\n        do {\n          next = walker[direction]();\n        } while (next && !isText$a(next) && !isBoundary(next));\n        return Optional.from(next).filter(isText$a);\n      };\n      return {\n        current: () => Optional.from(walker.current()).filter(isText$a),\n        next: () => walk('next'),\n        prev: () => walk('prev'),\n        prev2: () => walk('prev2')\n      };\n    };\n\n    const TextSeeker = (dom, isBoundary) => {\n      const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);\n      const walk = (node, offset, walker, process) => {\n        if (isText$a(node)) {\n          const newOffset = process(node, offset, node.data);\n          if (newOffset !== -1) {\n            return Optional.some({\n              container: node,\n              offset: newOffset\n            });\n          }\n        }\n        return walker().bind(next => walk(next.container, next.offset, walker, process));\n      };\n      const backwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n        return walk(node, offset, () => walker.prev().map(prev => ({\n          container: prev,\n          offset: prev.length\n        })), process).getOrNull();\n      };\n      const forwards = (node, offset, process, root) => {\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\n        return walk(node, offset, () => walker.next().map(next => ({\n          container: next,\n          offset: 0\n        })), process).getOrNull();\n      };\n      return {\n        backwards,\n        forwards\n      };\n    };\n\n    const round$2 = Math.round;\n    const clone$1 = rect => {\n      if (!rect) {\n        return {\n          left: 0,\n          top: 0,\n          bottom: 0,\n          right: 0,\n          width: 0,\n          height: 0\n        };\n      }\n      return {\n        left: round$2(rect.left),\n        top: round$2(rect.top),\n        bottom: round$2(rect.bottom),\n        right: round$2(rect.right),\n        width: round$2(rect.width),\n        height: round$2(rect.height)\n      };\n    };\n    const collapse = (rect, toStart) => {\n      rect = clone$1(rect);\n      if (toStart) {\n        rect.right = rect.left;\n      } else {\n        rect.left = rect.left + rect.width;\n        rect.right = rect.left;\n      }\n      rect.width = 0;\n      return rect;\n    };\n    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\n    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\n    const isAbove$1 = (rect1, rect2) => {\n      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\n      if (rect1.bottom - halfHeight < rect2.top) {\n        return true;\n      }\n      if (rect1.top > rect2.bottom) {\n        return false;\n      }\n      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\n    };\n    const isBelow$1 = (rect1, rect2) => {\n      if (rect1.top > rect2.bottom) {\n        return true;\n      }\n      if (rect1.bottom < rect2.top) {\n        return false;\n      }\n      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\n    };\n    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\n    const boundingClientRectFromRects = rects => {\n      return foldl(rects, (acc, rect) => {\n        return acc.fold(() => Optional.some(rect), prevRect => {\n          const left = Math.min(rect.left, prevRect.left);\n          const top = Math.min(rect.top, prevRect.top);\n          const right = Math.max(rect.right, prevRect.right);\n          const bottom = Math.max(rect.bottom, prevRect.bottom);\n          return Optional.some({\n            top,\n            right,\n            bottom,\n            left,\n            width: right - left,\n            height: bottom - top\n          });\n        });\n      }, Optional.none());\n    };\n    const distanceToRectEdgeFromXY = (rect, x, y) => {\n      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\n      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\n      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\n    };\n    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\n\n    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\n\n    const getSelectedNode = range => {\n      const startContainer = range.startContainer, startOffset = range.startOffset;\n      if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\n        return startContainer.childNodes[startOffset];\n      }\n      return null;\n    };\n    const getNode$1 = (container, offset) => {\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const childNodes = container.childNodes;\n        const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\n        return childNodes[safeOffset];\n      } else {\n        return container;\n      }\n    };\n    const getNodeUnsafe = (container, offset) => {\n      if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\n        return undefined;\n      } else {\n        return getNode$1(container, offset);\n      }\n    };\n\n    const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\n    const isExtendingChar = ch => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\n\n    const or = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (args[i](x)) {\n            return true;\n          }\n        }\n        return false;\n      };\n    };\n    const and = (...args) => {\n      return x => {\n        for (let i = 0; i < args.length; i++) {\n          if (!args[i](x)) {\n            return false;\n          }\n        }\n        return true;\n      };\n    };\n\n    const isElement$4 = isElement$6;\n    const isCaretCandidate$2 = isCaretCandidate$3;\n    const isBlock$2 = matchStyleValues('display', 'block table');\n    const isFloated = matchStyleValues('float', 'left right');\n    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\n    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\n    const isText$7 = isText$a;\n    const isBr$3 = isBr$6;\n    const nodeIndex$1 = DOMUtils.nodeIndex;\n    const resolveIndex$1 = getNodeUnsafe;\n    const createRange$1 = doc => doc ? doc.createRange() : DOMUtils.DOM.createRng();\n    const isWhiteSpace$1 = chr => isString(chr) && /[\\r\\n\\t ]/.test(chr);\n    const isRange = rng => !!rng.setStart && !!rng.setEnd;\n    const isHiddenWhiteSpaceRange = range => {\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$a(container)) {\n        const text = container.data;\n        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const getBrClientRect = brNode => {\n      const doc = brNode.ownerDocument;\n      const rng = createRange$1(doc);\n      const nbsp$1 = doc.createTextNode(nbsp);\n      const parentNode = brNode.parentNode;\n      parentNode.insertBefore(nbsp$1, brNode);\n      rng.setStart(nbsp$1, 0);\n      rng.setEnd(nbsp$1, 1);\n      const clientRect = clone$1(rng.getBoundingClientRect());\n      parentNode.removeChild(nbsp$1);\n      return clientRect;\n    };\n    const getBoundingClientRectWebKitText = rng => {\n      const sc = rng.startContainer;\n      const ec = rng.endContainer;\n      const so = rng.startOffset;\n      const eo = rng.endOffset;\n      if (sc === ec && isText$a(ec) && so === 0 && eo === 1) {\n        const newRng = rng.cloneRange();\n        newRng.setEndAfter(ec);\n        return getBoundingClientRect$1(newRng);\n      } else {\n        return null;\n      }\n    };\n    const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\n    const getBoundingClientRect$1 = item => {\n      var _a;\n      let clientRect;\n      const clientRects = item.getClientRects();\n      if (clientRects.length > 0) {\n        clientRect = clone$1(clientRects[0]);\n      } else {\n        clientRect = clone$1(item.getBoundingClientRect());\n      }\n      if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {\n        return getBrClientRect(item);\n      }\n      if (isZeroRect(clientRect) && isRange(item)) {\n        return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;\n      }\n      return clientRect;\n    };\n    const collapseAndInflateWidth = (clientRect, toStart) => {\n      const newClientRect = collapse(clientRect, toStart);\n      newClientRect.width = 1;\n      newClientRect.right = newClientRect.left + 1;\n      return newClientRect;\n    };\n    const getCaretPositionClientRects = caretPosition => {\n      const clientRects = [];\n      const addUniqueAndValidRect = clientRect => {\n        if (clientRect.height === 0) {\n          return;\n        }\n        if (clientRects.length > 0) {\n          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\n            return;\n          }\n        }\n        clientRects.push(clientRect);\n      };\n      const addCharacterOffset = (container, offset) => {\n        const range = createRange$1(container.ownerDocument);\n        if (offset < container.data.length) {\n          if (isExtendingChar(container.data[offset])) {\n            return;\n          }\n          if (isExtendingChar(container.data[offset - 1])) {\n            range.setStart(container, offset);\n            range.setEnd(container, offset + 1);\n            if (!isHiddenWhiteSpaceRange(range)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n              return;\n            }\n          }\n        }\n        if (offset > 0) {\n          range.setStart(container, offset - 1);\n          range.setEnd(container, offset);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\n          }\n        }\n        if (offset < container.data.length) {\n          range.setStart(container, offset);\n          range.setEnd(container, offset + 1);\n          if (!isHiddenWhiteSpaceRange(range)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\n          }\n        }\n      };\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (isText$7(container)) {\n        addCharacterOffset(container, offset);\n        return clientRects;\n      }\n      if (isElement$4(container)) {\n        if (caretPosition.isAtEnd()) {\n          const node = resolveIndex$1(container, offset);\n          if (isText$7(node)) {\n            addCharacterOffset(node, node.data.length);\n          }\n          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n          }\n        } else {\n          const node = resolveIndex$1(container, offset);\n          if (isText$7(node)) {\n            addCharacterOffset(node, 0);\n          }\n          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\n            return clientRects;\n          }\n          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\n          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {\n            if (isBlock$2(beforeNode) || isBlock$2(node) || !isValidElementCaretCandidate(node)) {\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\n            }\n          }\n          if (isValidElementCaretCandidate(node)) {\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\n          }\n        }\n      }\n      return clientRects;\n    };\n    const CaretPosition = (container, offset, clientRects) => {\n      const isAtStart = () => {\n        if (isText$7(container)) {\n          return offset === 0;\n        }\n        return offset === 0;\n      };\n      const isAtEnd = () => {\n        if (isText$7(container)) {\n          return offset >= container.data.length;\n        }\n        return offset >= container.childNodes.length;\n      };\n      const toRange = () => {\n        const range = createRange$1(container.ownerDocument);\n        range.setStart(container, offset);\n        range.setEnd(container, offset);\n        return range;\n      };\n      const getClientRects = () => {\n        if (!clientRects) {\n          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\n        }\n        return clientRects;\n      };\n      const isVisible = () => getClientRects().length > 0;\n      const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\n      const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\n      return {\n        container: constant(container),\n        offset: constant(offset),\n        toRange,\n        getClientRects,\n        isVisible,\n        isAtStart,\n        isAtEnd,\n        isEqual,\n        getNode\n      };\n    };\n    CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\n    CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\n    CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\n    CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\n    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);\n    CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\n    CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\n    CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\n    CaretPosition.isTextPosition = pos => pos ? isText$a(pos.container()) : false;\n    CaretPosition.isElementPosition = pos => !CaretPosition.isTextPosition(pos);\n\n    const trimEmptyTextNode$1 = (dom, node) => {\n      if (isText$a(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const insertNode = (dom, rng, node) => {\n      rng.insertNode(node);\n      trimEmptyTextNode$1(dom, node.previousSibling);\n      trimEmptyTextNode$1(dom, node.nextSibling);\n    };\n    const insertFragment = (dom, rng, frag) => {\n      const firstChild = Optional.from(frag.firstChild);\n      const lastChild = Optional.from(frag.lastChild);\n      rng.insertNode(frag);\n      firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\n      lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\n    };\n    const rangeInsertNode = (dom, rng, node) => {\n      if (isDocumentFragment(node)) {\n        insertFragment(dom, rng, node);\n      } else {\n        insertNode(dom, rng, node);\n      }\n    };\n\n    const isText$6 = isText$a;\n    const isBogus = isBogus$2;\n    const nodeIndex = DOMUtils.nodeIndex;\n    const normalizedParent = node => {\n      const parentNode = node.parentNode;\n      if (isBogus(parentNode)) {\n        return normalizedParent(parentNode);\n      }\n      return parentNode;\n    };\n    const getChildNodes = node => {\n      if (!node) {\n        return [];\n      }\n      return reduce(node.childNodes, (result, node) => {\n        if (isBogus(node) && node.nodeName !== 'BR') {\n          result = result.concat(getChildNodes(node));\n        } else {\n          result.push(node);\n        }\n        return result;\n      }, []);\n    };\n    const normalizedTextOffset = (node, offset) => {\n      let tempNode = node;\n      while (tempNode = tempNode.previousSibling) {\n        if (!isText$6(tempNode)) {\n          break;\n        }\n        offset += tempNode.data.length;\n      }\n      return offset;\n    };\n    const equal = a => b => a === b;\n    const normalizedNodeIndex = node => {\n      let nodes, index;\n      nodes = getChildNodes(normalizedParent(node));\n      index = findIndex$1(nodes, equal(node), node);\n      nodes = nodes.slice(0, index + 1);\n      const numTextFragments = reduce(nodes, (result, node, i) => {\n        if (isText$6(node) && isText$6(nodes[i - 1])) {\n          result++;\n        }\n        return result;\n      }, 0);\n      nodes = filter$3(nodes, matchNodeNames([node.nodeName]));\n      index = findIndex$1(nodes, equal(node), node);\n      return index - numTextFragments;\n    };\n    const createPathItem = node => {\n      const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();\n      return name + '[' + normalizedNodeIndex(node) + ']';\n    };\n    const parentsUntil$1 = (root, node, predicate) => {\n      const parents = [];\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\n        if (predicate && predicate(tempNode)) {\n          break;\n        }\n        parents.push(tempNode);\n      }\n      return parents;\n    };\n    const create$b = (root, caretPosition) => {\n      let path = [];\n      let container = caretPosition.container();\n      let offset = caretPosition.offset();\n      let outputOffset;\n      if (isText$6(container)) {\n        outputOffset = normalizedTextOffset(container, offset);\n      } else {\n        const childNodes = container.childNodes;\n        if (offset >= childNodes.length) {\n          outputOffset = 'after';\n          offset = childNodes.length - 1;\n        } else {\n          outputOffset = 'before';\n        }\n        container = childNodes[offset];\n      }\n      path.push(createPathItem(container));\n      let parents = parentsUntil$1(root, container);\n      parents = filter$3(parents, not(isBogus$2));\n      path = path.concat(map$1(parents, node => {\n        return createPathItem(node);\n      }));\n      return path.reverse().join('/') + ',' + outputOffset;\n    };\n    const resolvePathItem = (node, name, index) => {\n      let nodes = getChildNodes(node);\n      nodes = filter$3(nodes, (node, index) => {\n        return !isText$6(node) || !isText$6(nodes[index - 1]);\n      });\n      nodes = filter$3(nodes, matchNodeNames([name]));\n      return nodes[index];\n    };\n    const findTextPosition = (container, offset) => {\n      let node = container;\n      let targetOffset = 0;\n      while (isText$6(node)) {\n        const dataLen = node.data.length;\n        if (offset >= targetOffset && offset <= targetOffset + dataLen) {\n          container = node;\n          offset = offset - targetOffset;\n          break;\n        }\n        if (!isText$6(node.nextSibling)) {\n          container = node;\n          offset = dataLen;\n          break;\n        }\n        targetOffset += dataLen;\n        node = node.nextSibling;\n      }\n      if (isText$6(container) && offset > container.data.length) {\n        offset = container.data.length;\n      }\n      return CaretPosition(container, offset);\n    };\n    const resolve$1 = (root, path) => {\n      if (!path) {\n        return null;\n      }\n      const parts = path.split(',');\n      const paths = parts[0].split('/');\n      const offset = parts.length > 1 ? parts[1] : 'before';\n      const container = reduce(paths, (result, value) => {\n        const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\n        if (!match) {\n          return null;\n        }\n        if (match[1] === 'text()') {\n          match[1] = '#text';\n        }\n        return resolvePathItem(result, match[1], parseInt(match[2], 10));\n      }, root);\n      if (!container) {\n        return null;\n      }\n      if (!isText$6(container) && container.parentNode) {\n        let nodeOffset;\n        if (offset === 'after') {\n          nodeOffset = nodeIndex(container) + 1;\n        } else {\n          nodeOffset = nodeIndex(container);\n        }\n        return CaretPosition(container.parentNode, nodeOffset);\n      }\n      return findTextPosition(container, parseInt(offset, 10));\n    };\n\n    const isContentEditableFalse$9 = isContentEditableFalse$b;\n    const getNormalizedTextOffset$1 = (trim, container, offset) => {\n      let trimmedOffset = trim(container.data.slice(0, offset)).length;\n      for (let node = container.previousSibling; node && isText$a(node); node = node.previousSibling) {\n        trimmedOffset += trim(node.data).length;\n      }\n      return trimmedOffset;\n    };\n    const getPoint = (dom, trim, normalized, rng, start) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      const point = [];\n      const root = dom.getRoot();\n      if (isText$a(container)) {\n        point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);\n      } else {\n        let after = 0;\n        const childNodes = container.childNodes;\n        if (offset >= childNodes.length && childNodes.length) {\n          after = 1;\n          offset = Math.max(0, childNodes.length - 1);\n        }\n        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\n      }\n      for (let node = container; node && node !== root; node = node.parentNode) {\n        point.push(dom.nodeIndex(node, normalized));\n      }\n      return point;\n    };\n    const getLocation = (trim, selection, normalized, rng) => {\n      const dom = selection.dom;\n      const start = getPoint(dom, trim, normalized, rng, true);\n      const forward = selection.isForward();\n      const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};\n      if (!selection.isCollapsed()) {\n        const end = getPoint(dom, trim, normalized, rng, false);\n        return {\n          start,\n          end,\n          forward,\n          ...fakeCaret\n        };\n      } else {\n        return {\n          start,\n          forward,\n          ...fakeCaret\n        };\n      }\n    };\n    const findIndex = (dom, name, element) => {\n      let count = 0;\n      Tools.each(dom.select(name), node => {\n        if (node.getAttribute('data-mce-bogus') === 'all') {\n          return;\n        } else if (node === element) {\n          return false;\n        } else {\n          count++;\n          return;\n        }\n      });\n      return count;\n    };\n    const moveEndPoint$1 = (rng, start) => {\n      let container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      if (isElement$6(container) && container.nodeName === 'TR') {\n        const childNodes = container.childNodes;\n        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\n        if (container) {\n          offset = start ? 0 : container.childNodes.length;\n          if (start) {\n            rng.setStart(container, offset);\n          } else {\n            rng.setEnd(container, offset);\n          }\n        }\n      }\n    };\n    const normalizeTableCellSelection = rng => {\n      moveEndPoint$1(rng, true);\n      moveEndPoint$1(rng, false);\n      return rng;\n    };\n    const findSibling = (node, offset) => {\n      if (isElement$6(node)) {\n        node = getNode$1(node, offset);\n        if (isContentEditableFalse$9(node)) {\n          return node;\n        }\n      }\n      if (isCaretContainer$2(node)) {\n        if (isText$a(node) && isCaretContainerBlock$1(node)) {\n          node = node.parentNode;\n        }\n        let sibling = node.previousSibling;\n        if (isContentEditableFalse$9(sibling)) {\n          return sibling;\n        }\n        sibling = node.nextSibling;\n        if (isContentEditableFalse$9(sibling)) {\n          return sibling;\n        }\n      }\n      return undefined;\n    };\n    const findAdjacentContentEditableFalseElm = rng => {\n      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\n    };\n    const getOffsetBookmark = (trim, normalized, selection) => {\n      const element = selection.getNode();\n      const rng = selection.getRng();\n      if (element.nodeName === 'IMG' || isContentEditableFalse$9(element)) {\n        const name = element.nodeName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, element)\n        };\n      }\n      const sibling = findAdjacentContentEditableFalseElm(rng);\n      if (sibling) {\n        const name = sibling.tagName;\n        return {\n          name,\n          index: findIndex(selection.dom, name, sibling)\n        };\n      }\n      return getLocation(trim, selection, normalized, rng);\n    };\n    const getCaretBookmark = selection => {\n      const rng = selection.getRng();\n      return {\n        start: create$b(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\n        end: create$b(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),\n        forward: selection.isForward()\n      };\n    };\n    const getRangeBookmark = selection => {\n      return {\n        rng: selection.getRng(),\n        forward: selection.isForward()\n      };\n    };\n    const createBookmarkSpan = (dom, id, filled) => {\n      const args = {\n        'data-mce-type': 'bookmark',\n        id,\n        'style': 'overflow:hidden;line-height:0px'\n      };\n      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\n    };\n    const getPersistentBookmark = (selection, filled) => {\n      const dom = selection.dom;\n      let rng = selection.getRng();\n      const id = dom.uniqueId();\n      const collapsed = selection.isCollapsed();\n      const element = selection.getNode();\n      const name = element.nodeName;\n      const forward = selection.isForward();\n      if (name === 'IMG') {\n        return {\n          name,\n          index: findIndex(dom, name, element)\n        };\n      }\n      const rng2 = normalizeTableCellSelection(rng.cloneRange());\n      if (!collapsed) {\n        rng2.collapse(false);\n        const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\n        rangeInsertNode(dom, rng2, endBookmarkNode);\n      }\n      rng = normalizeTableCellSelection(rng);\n      rng.collapse(true);\n      const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\n      rangeInsertNode(dom, rng, startBookmarkNode);\n      selection.moveToBookmark({\n        id,\n        keep: true,\n        forward\n      });\n      return {\n        id,\n        forward\n      };\n    };\n    const getBookmark$2 = (selection, type, normalized = false) => {\n      if (type === 2) {\n        return getOffsetBookmark(trim$2, normalized, selection);\n      } else if (type === 3) {\n        return getCaretBookmark(selection);\n      } else if (type) {\n        return getRangeBookmark(selection);\n      } else {\n        return getPersistentBookmark(selection, false);\n      }\n    };\n    const getUndoBookmark = curry(getOffsetBookmark, identity, true);\n\n    const value$1 = value => {\n      const applyHelper = fn => fn(value);\n      const constHelper = constant(value);\n      const outputHelper = () => output;\n      const output = {\n        tag: true,\n        inner: value,\n        fold: (_onError, onValue) => onValue(value),\n        isValue: always,\n        isError: never,\n        map: mapper => Result.value(mapper(value)),\n        mapError: outputHelper,\n        bind: applyHelper,\n        exists: applyHelper,\n        forall: applyHelper,\n        getOr: constHelper,\n        or: outputHelper,\n        getOrThunk: constHelper,\n        orThunk: outputHelper,\n        getOrDie: constHelper,\n        each: fn => {\n          fn(value);\n        },\n        toOptional: () => Optional.some(value)\n      };\n      return output;\n    };\n    const error = error => {\n      const outputHelper = () => output;\n      const output = {\n        tag: false,\n        inner: error,\n        fold: (onError, _onValue) => onError(error),\n        isValue: never,\n        isError: always,\n        map: outputHelper,\n        mapError: mapper => Result.error(mapper(error)),\n        bind: outputHelper,\n        exists: never,\n        forall: always,\n        getOr: identity,\n        or: identity,\n        getOrThunk: apply$1,\n        orThunk: apply$1,\n        getOrDie: die(String(error)),\n        each: noop,\n        toOptional: Optional.none\n      };\n      return output;\n    };\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\n    const Result = {\n      value: value$1,\n      error,\n      fromOption\n    };\n\n    const generate = cases => {\n      if (!isArray$1(cases)) {\n        throw new Error('cases must be an array');\n      }\n      if (cases.length === 0) {\n        throw new Error('there must be at least one case');\n      }\n      const constructors = [];\n      const adt = {};\n      each$e(cases, (acase, count) => {\n        const keys$1 = keys(acase);\n        if (keys$1.length !== 1) {\n          throw new Error('one and only one name per case');\n        }\n        const key = keys$1[0];\n        const value = acase[key];\n        if (adt[key] !== undefined) {\n          throw new Error('duplicate key detected:' + key);\n        } else if (key === 'cata') {\n          throw new Error('cannot have a case named cata (sorry)');\n        } else if (!isArray$1(value)) {\n          throw new Error('case arguments must be an array');\n        }\n        constructors.push(key);\n        adt[key] = (...args) => {\n          const argLength = args.length;\n          if (argLength !== value.length) {\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\n          }\n          const match = branches => {\n            const branchKeys = keys(branches);\n            if (constructors.length !== branchKeys.length) {\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\n            }\n            const allReqd = forall(constructors, reqKey => {\n              return contains$2(branchKeys, reqKey);\n            });\n            if (!allReqd) {\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\n            }\n            return branches[key].apply(null, args);\n          };\n          return {\n            fold: (...foldArgs) => {\n              if (foldArgs.length !== cases.length) {\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\n              }\n              const target = foldArgs[count];\n              return target.apply(null, args);\n            },\n            match,\n            log: label => {\n              console.log(label, {\n                constructors,\n                constructor: key,\n                params: args\n              });\n            }\n          };\n        };\n      });\n      return adt;\n    };\n    const Adt = { generate };\n\n    Adt.generate([\n      {\n        bothErrors: [\n          'error1',\n          'error2'\n        ]\n      },\n      {\n        firstError: [\n          'error1',\n          'value2'\n        ]\n      },\n      {\n        secondError: [\n          'value1',\n          'error2'\n        ]\n      },\n      {\n        bothValues: [\n          'value1',\n          'value2'\n        ]\n      }\n    ]);\n    const partition$1 = results => {\n      const errors = [];\n      const values = [];\n      each$e(results, result => {\n        result.fold(err => {\n          errors.push(err);\n        }, value => {\n          values.push(value);\n        });\n      });\n      return {\n        errors,\n        values\n      };\n    };\n\n    const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\n    const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\n    const normalizePattern = pattern => {\n      const err = message => Result.error({\n        message,\n        pattern\n      });\n      const formatOrCmd = (name, onFormat, onCommand) => {\n        if (pattern.format !== undefined) {\n          let formats;\n          if (isArray$1(pattern.format)) {\n            if (!forall(pattern.format, isString)) {\n              return err(name + ' pattern has non-string items in the `format` array');\n            }\n            formats = pattern.format;\n          } else if (isString(pattern.format)) {\n            formats = [pattern.format];\n          } else {\n            return err(name + ' pattern has non-string `format` parameter');\n          }\n          return Result.value(onFormat(formats));\n        } else if (pattern.cmd !== undefined) {\n          if (!isString(pattern.cmd)) {\n            return err(name + ' pattern has non-string `cmd` parameter');\n          }\n          return Result.value(onCommand(pattern.cmd, pattern.value));\n        } else {\n          return err(name + ' pattern is missing both `format` and `cmd` parameters');\n        }\n      };\n      if (!isObject(pattern)) {\n        return err('Raw pattern is not an object');\n      }\n      if (!isString(pattern.start)) {\n        return err('Raw pattern is missing `start` parameter');\n      }\n      if (pattern.end !== undefined) {\n        if (!isString(pattern.end)) {\n          return err('Inline pattern has non-string `end` parameter');\n        }\n        if (pattern.start.length === 0 && pattern.end.length === 0) {\n          return err('Inline pattern has empty `start` and `end` parameters');\n        }\n        let start = pattern.start;\n        let end = pattern.end;\n        if (end.length === 0) {\n          end = start;\n          start = '';\n        }\n        return formatOrCmd('Inline', format => ({\n          type: 'inline-format',\n          start,\n          end,\n          format\n        }), (cmd, value) => ({\n          type: 'inline-command',\n          start,\n          end,\n          cmd,\n          value\n        }));\n      } else if (pattern.replacement !== undefined) {\n        if (!isString(pattern.replacement)) {\n          return err('Replacement pattern has non-string `replacement` parameter');\n        }\n        if (pattern.start.length === 0) {\n          return err('Replacement pattern has empty `start` parameter');\n        }\n        return Result.value({\n          type: 'inline-command',\n          start: '',\n          end: pattern.start,\n          cmd: 'mceInsertContent',\n          value: pattern.replacement\n        });\n      } else {\n        if (pattern.start.length === 0) {\n          return err('Block pattern has empty `start` parameter');\n        }\n        return formatOrCmd('Block', formats => ({\n          type: 'block-format',\n          start: pattern.start,\n          format: formats[0]\n        }), (command, commandValue) => ({\n          type: 'block-command',\n          start: pattern.start,\n          cmd: command,\n          value: commandValue\n        }));\n      }\n    };\n    const getBlockPatterns = patterns => filter$5(patterns, isBlockPattern);\n    const getInlinePatterns = patterns => filter$5(patterns, isInlinePattern);\n    const createPatternSet = (patterns, dynamicPatternsLookup) => ({\n      inlinePatterns: getInlinePatterns(patterns),\n      blockPatterns: getBlockPatterns(patterns),\n      dynamicPatternsLookup\n    });\n    const fromRawPatterns = patterns => {\n      const normalized = partition$1(map$3(patterns, normalizePattern));\n      each$e(normalized.errors, err => console.error(err.message, err.pattern));\n      return normalized.values;\n    };\n    const fromRawPatternsLookup = lookupFn => {\n      return ctx => {\n        const rawPatterns = lookupFn(ctx);\n        return fromRawPatterns(rawPatterns);\n      };\n    };\n\n    const deviceDetection$1 = detect$2().deviceType;\n    const isTouch = deviceDetection$1.isTouch();\n    const DOM$a = DOMUtils.DOM;\n    const getHash = value => {\n      const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\n      return foldl(items, (output, item) => {\n        const arr = item.split('=');\n        const key = arr[0];\n        const val = arr.length > 1 ? arr[1] : key;\n        output[trim$4(key)] = trim$4(val);\n        return output;\n      }, {});\n    };\n    const isRegExp = x => is$4(x, RegExp);\n    const option = name => editor => editor.options.get(name);\n    const stringOrObjectProcessor = value => isString(value) || isObject(value);\n    const bodyOptionProcessor = (editor, defaultValue = '') => value => {\n      const valid = isString(value);\n      if (valid) {\n        if (value.indexOf('=') !== -1) {\n          const bodyObj = getHash(value);\n          return {\n            value: get$a(bodyObj, editor.id).getOr(defaultValue),\n            valid\n          };\n        } else {\n          return {\n            value,\n            valid\n          };\n        }\n      } else {\n        return {\n          valid: false,\n          message: 'Must be a string.'\n        };\n      }\n    };\n    const register$7 = editor => {\n      const registerOption = editor.options.register;\n      registerOption('id', {\n        processor: 'string',\n        default: editor.id\n      });\n      registerOption('selector', { processor: 'string' });\n      registerOption('target', { processor: 'object' });\n      registerOption('suffix', { processor: 'string' });\n      registerOption('cache_suffix', { processor: 'string' });\n      registerOption('base_url', { processor: 'string' });\n      registerOption('referrer_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('language_load', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('iframe_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('doctype', {\n        processor: 'string',\n        default: '<!DOCTYPE html>'\n      });\n      registerOption('document_base_url', {\n        processor: 'string',\n        default: editor.documentBaseUrl\n      });\n      registerOption('body_id', {\n        processor: bodyOptionProcessor(editor, 'tinymce'),\n        default: 'tinymce'\n      });\n      registerOption('body_class', {\n        processor: bodyOptionProcessor(editor),\n        default: ''\n      });\n      registerOption('content_security_policy', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('br_in_pre', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('forced_root_block', {\n        processor: value => {\n          const valid = isString(value) && isNotEmpty(value);\n          if (valid) {\n            return {\n              value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a non-empty string.'\n            };\n          }\n        },\n        default: 'p'\n      });\n      registerOption('forced_root_block_attrs', {\n        processor: 'object',\n        default: {}\n      });\n      registerOption('newline_behavior', {\n        processor: value => {\n          const valid = contains$2([\n            'block',\n            'linebreak',\n            'invert',\n            'default'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: block, linebreak, invert or default.'\n          };\n        },\n        default: 'default'\n      });\n      registerOption('br_newline_selector', {\n        processor: 'string',\n        default: '.mce-toc h2,figcaption,caption'\n      });\n      registerOption('no_newline_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('keep_styles', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('end_container_on_empty_block', {\n        processor: value => {\n          if (isBoolean(value)) {\n            return {\n              valid: true,\n              value\n            };\n          } else if (isString(value)) {\n            return {\n              valid: true,\n              value\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: 'blockquote'\n      });\n      registerOption('font_size_style_values', {\n        processor: 'string',\n        default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\n      });\n      registerOption('font_size_legacy_values', {\n        processor: 'string',\n        default: 'xx-small,small,medium,large,x-large,xx-large,300%'\n      });\n      registerOption('font_size_classes', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('automatic_uploads', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('images_reuse_filename', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_replace_blob_uris', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('icons', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('icons_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_base_path', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('images_upload_credentials', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('images_upload_handler', { processor: 'function' });\n      registerOption('language', {\n        processor: 'string',\n        default: 'en'\n      });\n      registerOption('language_url', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('entity_encoding', {\n        processor: 'string',\n        default: 'named'\n      });\n      registerOption('indent', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('indent_before', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_after', {\n        processor: 'string',\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\n      });\n      registerOption('indent_use_margin', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('indentation', {\n        processor: 'string',\n        default: '40px'\n      });\n      registerOption('content_css', {\n        processor: value => {\n          const valid = value === false || isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            if (isString(value)) {\n              return {\n                value: map$3(value.split(','), trim$4),\n                valid\n              };\n            } else if (isArray$1(value)) {\n              return {\n                value,\n                valid\n              };\n            } else if (value === false) {\n              return {\n                value: [],\n                valid\n              };\n            } else {\n              return {\n                value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false, a string or an array of strings.'\n            };\n          }\n        },\n        default: isInline$1(editor) ? [] : ['default']\n      });\n      registerOption('content_style', { processor: 'string' });\n      registerOption('content_css_cors', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('font_css', {\n        processor: value => {\n          const valid = isString(value) || isArrayOf(value, isString);\n          if (valid) {\n            const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$4);\n            return {\n              value: newValue,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a string or an array of strings.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('inline_boundaries', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('inline_boundaries_selector', {\n        processor: 'string',\n        default: 'a[href],code,span.mce-annotation'\n      });\n      registerOption('object_resizing', {\n        processor: value => {\n          const valid = isBoolean(value) || isString(value);\n          if (valid) {\n            if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\n              return {\n                value: '',\n                valid\n              };\n            } else {\n              return {\n                value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\n                valid\n              };\n            }\n          } else {\n            return {\n              valid: false,\n              message: 'Must be boolean or a string'\n            };\n          }\n        },\n        default: !isTouch\n      });\n      registerOption('resize_img_proportional', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('event_root', { processor: 'object' });\n      registerOption('service_message', { processor: 'string' });\n      registerOption('theme', {\n        processor: value => value === false || isString(value) || isFunction(value),\n        default: 'silver'\n      });\n      registerOption('theme_url', { processor: 'string' });\n      registerOption('formats', { processor: 'object' });\n      registerOption('format_empty_lines', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('format_noneditable_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('preview_styles', {\n        processor: value => {\n          const valid = value === false || isString(value);\n          if (valid) {\n            return {\n              value: value === false ? '' : value,\n              valid\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be false or a string'\n            };\n          }\n        },\n        default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\n      });\n      registerOption('custom_ui_selector', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('hidden_input', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('submit_patch', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('encoding', { processor: 'string' });\n      registerOption('add_form_submit_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('add_unload_trigger', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_undo_redo_levels', {\n        processor: 'number',\n        default: 0\n      });\n      registerOption('disable_nodechange', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('readonly', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('editable_root', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('plugins', {\n        processor: 'string[]',\n        default: []\n      });\n      registerOption('external_plugins', { processor: 'object' });\n      registerOption('forced_plugins', { processor: 'string[]' });\n      registerOption('model', {\n        processor: 'string',\n        default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\n      });\n      registerOption('model_url', { processor: 'string' });\n      registerOption('block_unsupported_drop', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('visual_table_class', {\n        processor: 'string',\n        default: 'mce-item-table'\n      });\n      registerOption('visual_anchor_class', {\n        processor: 'string',\n        default: 'mce-item-anchor'\n      });\n      registerOption('iframe_aria_text', {\n        processor: 'string',\n        default: 'Rich Text Area. Press ALT-0 for help.'\n      });\n      registerOption('setup', { processor: 'function' });\n      registerOption('init_instance_callback', { processor: 'function' });\n      registerOption('url_converter', {\n        processor: 'function',\n        default: editor.convertURL\n      });\n      registerOption('url_converter_scope', {\n        processor: 'object',\n        default: editor\n      });\n      registerOption('urlconverter_callback', { processor: 'function' });\n      registerOption('allow_conditional_comments', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_html_data_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_svg_data_urls', { processor: 'boolean' });\n      registerOption('allow_html_in_named_anchor', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_script_urls', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('allow_unsafe_link_target', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('convert_fonts_to_spans', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('fix_list_elements', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('preserve_cdata', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('remove_trailing_brs', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('pad_empty_with_br', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('inline_styles', {\n        processor: 'boolean',\n        default: true,\n        deprecated: true\n      });\n      registerOption('element_format', {\n        processor: 'string',\n        default: 'html'\n      });\n      registerOption('entities', { processor: 'string' });\n      registerOption('schema', {\n        processor: 'string',\n        default: 'html5'\n      });\n      registerOption('convert_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('relative_urls', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('remove_script_host', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('custom_elements', { processor: 'string' });\n      registerOption('extended_valid_elements', { processor: 'string' });\n      registerOption('invalid_elements', { processor: 'string' });\n      registerOption('invalid_styles', { processor: stringOrObjectProcessor });\n      registerOption('valid_children', { processor: 'string' });\n      registerOption('valid_classes', { processor: stringOrObjectProcessor });\n      registerOption('valid_elements', { processor: 'string' });\n      registerOption('valid_styles', { processor: stringOrObjectProcessor });\n      registerOption('verify_html', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('auto_focus', { processor: value => isString(value) || value === true });\n      registerOption('browser_spellcheck', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('protect', { processor: 'array' });\n      registerOption('images_file_types', {\n        processor: 'string',\n        default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\n      });\n      registerOption('deprecation_warnings', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('a11y_advanced_options', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('api_key', { processor: 'string' });\n      registerOption('paste_block_drop', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_data_images', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_preprocess', { processor: 'function' });\n      registerOption('paste_postprocess', { processor: 'function' });\n      registerOption('paste_webkit_styles', {\n        processor: 'string',\n        default: 'none'\n      });\n      registerOption('paste_remove_styles_if_webkit', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_merge_formats', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('smart_paste', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('paste_as_text', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('paste_tab_spaces', {\n        processor: 'number',\n        default: 4\n      });\n      registerOption('text_patterns', {\n        processor: value => {\n          if (isArrayOf(value, isObject) || value === false) {\n            const patterns = value === false ? [] : value;\n            return {\n              value: fromRawPatterns(patterns),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be an array of objects or false.'\n            };\n          }\n        },\n        default: [\n          {\n            start: '*',\n            end: '*',\n            format: 'italic'\n          },\n          {\n            start: '**',\n            end: '**',\n            format: 'bold'\n          },\n          {\n            start: '#',\n            format: 'h1'\n          },\n          {\n            start: '##',\n            format: 'h2'\n          },\n          {\n            start: '###',\n            format: 'h3'\n          },\n          {\n            start: '####',\n            format: 'h4'\n          },\n          {\n            start: '#####',\n            format: 'h5'\n          },\n          {\n            start: '######',\n            format: 'h6'\n          },\n          {\n            start: '1. ',\n            cmd: 'InsertOrderedList'\n          },\n          {\n            start: '* ',\n            cmd: 'InsertUnorderedList'\n          },\n          {\n            start: '- ',\n            cmd: 'InsertUnorderedList'\n          }\n        ]\n      });\n      registerOption('text_patterns_lookup', {\n        processor: value => {\n          if (isFunction(value)) {\n            return {\n              value: fromRawPatternsLookup(value),\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a single function'\n            };\n          }\n        },\n        default: _ctx => []\n      });\n      registerOption('noneditable_class', {\n        processor: 'string',\n        default: 'mceNonEditable'\n      });\n      registerOption('editable_class', {\n        processor: 'string',\n        default: 'mceEditable'\n      });\n      registerOption('noneditable_regexp', {\n        processor: value => {\n          if (isArrayOf(value, isRegExp)) {\n            return {\n              value,\n              valid: true\n            };\n          } else if (isRegExp(value)) {\n            return {\n              value: [value],\n              valid: true\n            };\n          } else {\n            return {\n              valid: false,\n              message: 'Must be a RegExp or an array of RegExp.'\n            };\n          }\n        },\n        default: []\n      });\n      registerOption('table_tab_navigation', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('highlight_on_focus', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('xss_sanitization', {\n        processor: 'boolean',\n        default: true\n      });\n      registerOption('details_initial_state', {\n        processor: value => {\n          const valid = contains$2([\n            'inherited',\n            'collapsed',\n            'expanded'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: inherited, collapsed, or expanded.'\n          };\n        },\n        default: 'inherited'\n      });\n      registerOption('details_serialized_state', {\n        processor: value => {\n          const valid = contains$2([\n            'inherited',\n            'collapsed',\n            'expanded'\n          ], value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: 'Must be one of: inherited, collapsed, or expanded.'\n          };\n        },\n        default: 'inherited'\n      });\n      registerOption('init_content_sync', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('newdocument_content', {\n        processor: 'string',\n        default: ''\n      });\n      registerOption('force_hex_color', {\n        processor: value => {\n          const options = [\n            'always',\n            'rgb_only',\n            'off'\n          ];\n          const valid = contains$2(options, value);\n          return valid ? {\n            value,\n            valid\n          } : {\n            valid: false,\n            message: `Must be one of: ${ options.join(', ') }.`\n          };\n        },\n        default: 'off'\n      });\n      registerOption('sandbox_iframes', {\n        processor: 'boolean',\n        default: false\n      });\n      registerOption('convert_unsafe_embeds', {\n        processor: 'boolean',\n        default: false\n      });\n      editor.on('ScriptsLoaded', () => {\n        registerOption('directionality', {\n          processor: 'string',\n          default: I18n.isRtl() ? 'rtl' : undefined\n        });\n        registerOption('placeholder', {\n          processor: 'string',\n          default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\n        });\n      });\n    };\n    const getIframeAttrs = option('iframe_attrs');\n    const getDocType = option('doctype');\n    const getDocumentBaseUrl = option('document_base_url');\n    const getBodyId = option('body_id');\n    const getBodyClass = option('body_class');\n    const getContentSecurityPolicy = option('content_security_policy');\n    const shouldPutBrInPre$1 = option('br_in_pre');\n    const getForcedRootBlock = option('forced_root_block');\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\n    const getNewlineBehavior = option('newline_behavior');\n    const getBrNewLineSelector = option('br_newline_selector');\n    const getNoNewLineSelector = option('no_newline_selector');\n    const shouldKeepStyles = option('keep_styles');\n    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\n    const isAutomaticUploadsEnabled = option('automatic_uploads');\n    const shouldReuseFileName = option('images_reuse_filename');\n    const shouldReplaceBlobUris = option('images_replace_blob_uris');\n    const getIconPackName = option('icons');\n    const getIconsUrl = option('icons_url');\n    const getImageUploadUrl = option('images_upload_url');\n    const getImageUploadBasePath = option('images_upload_base_path');\n    const getImagesUploadCredentials = option('images_upload_credentials');\n    const getImagesUploadHandler = option('images_upload_handler');\n    const shouldUseContentCssCors = option('content_css_cors');\n    const getReferrerPolicy = option('referrer_policy');\n    const getLanguageCode = option('language');\n    const getLanguageUrl = option('language_url');\n    const shouldIndentUseMargin = option('indent_use_margin');\n    const getIndentation = option('indentation');\n    const getContentCss = option('content_css');\n    const getContentStyle = option('content_style');\n    const getFontCss = option('font_css');\n    const getDirectionality = option('directionality');\n    const getInlineBoundarySelector = option('inline_boundaries_selector');\n    const getObjectResizing = option('object_resizing');\n    const getResizeImgProportional = option('resize_img_proportional');\n    const getPlaceholder = option('placeholder');\n    const getEventRoot = option('event_root');\n    const getServiceMessage = option('service_message');\n    const getTheme = option('theme');\n    const getThemeUrl = option('theme_url');\n    const getModel = option('model');\n    const getModelUrl = option('model_url');\n    const isInlineBoundariesEnabled = option('inline_boundaries');\n    const getFormats = option('formats');\n    const getPreviewStyles = option('preview_styles');\n    const canFormatEmptyLines = option('format_empty_lines');\n    const getFormatNoneditableSelector = option('format_noneditable_selector');\n    const getCustomUiSelector = option('custom_ui_selector');\n    const isInline$1 = option('inline');\n    const hasHiddenInput = option('hidden_input');\n    const shouldPatchSubmit = option('submit_patch');\n    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\n    const shouldAddUnloadTrigger = option('add_unload_trigger');\n    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\n    const shouldDisableNodeChange = option('disable_nodechange');\n    const isReadOnly$1 = option('readonly');\n    const hasEditableRoot$1 = option('editable_root');\n    const hasContentCssCors = option('content_css_cors');\n    const getPlugins = option('plugins');\n    const getExternalPlugins$1 = option('external_plugins');\n    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\n    const isVisualAidsEnabled = option('visual');\n    const getVisualAidsTableClass = option('visual_table_class');\n    const getVisualAidsAnchorClass = option('visual_anchor_class');\n    const getIframeAriaText = option('iframe_aria_text');\n    const getSetupCallback = option('setup');\n    const getInitInstanceCallback = option('init_instance_callback');\n    const getUrlConverterCallback = option('urlconverter_callback');\n    const getAutoFocus = option('auto_focus');\n    const shouldBrowserSpellcheck = option('browser_spellcheck');\n    const getProtect = option('protect');\n    const shouldPasteBlockDrop = option('paste_block_drop');\n    const shouldPasteDataImages = option('paste_data_images');\n    const getPastePreProcess = option('paste_preprocess');\n    const getPastePostProcess = option('paste_postprocess');\n    const getNewDocumentContent = option('newdocument_content');\n    const getPasteWebkitStyles = option('paste_webkit_styles');\n    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\n    const shouldPasteMergeFormats = option('paste_merge_formats');\n    const isSmartPasteEnabled = option('smart_paste');\n    const isPasteAsTextEnabled = option('paste_as_text');\n    const getPasteTabSpaces = option('paste_tab_spaces');\n    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\n    const getTextPatterns = option('text_patterns');\n    const getTextPatternsLookup = option('text_patterns_lookup');\n    const getNonEditableClass = option('noneditable_class');\n    const getEditableClass = option('editable_class');\n    const getNonEditableRegExps = option('noneditable_regexp');\n    const shouldPreserveCData = option('preserve_cdata');\n    const shouldHighlightOnFocus = option('highlight_on_focus');\n    const shouldSanitizeXss = option('xss_sanitization');\n    const shouldUseDocumentWrite = option('init_content_sync');\n    const hasTextPatternsLookup = editor => editor.options.isSet('text_patterns_lookup');\n    const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\n    const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\n    const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\n    const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\n    const hasTableTabNavigation = option('table_tab_navigation');\n    const getDetailsInitialState = option('details_initial_state');\n    const getDetailsSerializedState = option('details_serialized_state');\n    const shouldForceHexColor = option('force_hex_color');\n    const shouldSandboxIframes = option('sandbox_iframes');\n\n    const isElement$3 = isElement$6;\n    const isText$5 = isText$a;\n    const removeNode$1 = node => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        parentNode.removeChild(node);\n      }\n    };\n    const trimCount = text => {\n      const trimmedText = trim$2(text);\n      return {\n        count: text.length - trimmedText.length,\n        text: trimmedText\n      };\n    };\n    const deleteZwspChars = caretContainer => {\n      let idx;\n      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\n        caretContainer.deleteData(idx, 1);\n      }\n    };\n    const removeUnchanged = (caretContainer, pos) => {\n      remove$3(caretContainer);\n      return pos;\n    };\n    const removeTextAndReposition = (caretContainer, pos) => {\n      const before = trimCount(caretContainer.data.substr(0, pos.offset()));\n      const after = trimCount(caretContainer.data.substr(pos.offset()));\n      const text = before.text + after.text;\n      if (text.length > 0) {\n        deleteZwspChars(caretContainer);\n        return CaretPosition(caretContainer, pos.offset() - before.count);\n      } else {\n        return pos;\n      }\n    };\n    const removeElementAndReposition = (caretContainer, pos) => {\n      const parentNode = pos.container();\n      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\n        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\n      }).getOr(pos);\n      remove$3(caretContainer);\n      return newPosition;\n    };\n    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\n    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\n    const remove$3 = caretContainerNode => {\n      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\n        if (hasContent(caretContainerNode)) {\n          caretContainerNode.removeAttribute('data-mce-caret');\n        } else {\n          removeNode$1(caretContainerNode);\n        }\n      }\n      if (isText$5(caretContainerNode)) {\n        deleteZwspChars(caretContainerNode);\n        if (caretContainerNode.data.length === 0) {\n          removeNode$1(caretContainerNode);\n        }\n      }\n    };\n\n    const isContentEditableFalse$8 = isContentEditableFalse$b;\n    const isMedia$1 = isMedia$2;\n    const isTableCell$1 = isTableCell$3;\n    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\n    const getAbsoluteClientRect = (root, element, before) => {\n      const clientRect = collapse(element.getBoundingClientRect(), before);\n      let scrollX;\n      let scrollY;\n      if (root.tagName === 'BODY') {\n        const docElm = root.ownerDocument.documentElement;\n        scrollX = root.scrollLeft || docElm.scrollLeft;\n        scrollY = root.scrollTop || docElm.scrollTop;\n      } else {\n        const rootRect = root.getBoundingClientRect();\n        scrollX = root.scrollLeft - rootRect.left;\n        scrollY = root.scrollTop - rootRect.top;\n      }\n      clientRect.left += scrollX;\n      clientRect.right += scrollX;\n      clientRect.top += scrollY;\n      clientRect.bottom += scrollY;\n      clientRect.width = 1;\n      let margin = element.offsetWidth - element.clientWidth;\n      if (margin > 0) {\n        if (before) {\n          margin *= -1;\n        }\n        clientRect.left += margin;\n        clientRect.right += margin;\n      }\n      return clientRect;\n    };\n    const trimInlineCaretContainers = root => {\n      var _a, _b;\n      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\n      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\n        const node = fakeCaretTargetNodes[i].dom;\n        let sibling = node.previousSibling;\n        if (endsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);\n          } else {\n            sibling.deleteData(data.length - 1, 1);\n          }\n        }\n        sibling = node.nextSibling;\n        if (startsWithCaretContainer$1(sibling)) {\n          const data = sibling.data;\n          if (data.length === 1) {\n            (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);\n          } else {\n            sibling.deleteData(0, 1);\n          }\n        }\n      }\n    };\n    const FakeCaret = (editor, root, isBlock, hasFocus) => {\n      const lastVisualCaret = value$2();\n      let cursorInterval;\n      let caretContainerNode;\n      const caretBlock = getForcedRootBlock(editor);\n      const dom = editor.dom;\n      const show = (before, element) => {\n        let rng;\n        hide();\n        if (isTableCell$1(element)) {\n          return null;\n        }\n        if (isBlock(element)) {\n          const caretContainer = insertBlock(caretBlock, element, before);\n          const clientRect = getAbsoluteClientRect(root, element, before);\n          dom.setStyle(caretContainer, 'top', clientRect.top);\n          caretContainerNode = caretContainer;\n          const caret = dom.create('div', {\n            'class': 'mce-visual-caret',\n            'data-mce-bogus': 'all'\n          });\n          dom.setStyles(caret, { ...clientRect });\n          dom.add(root, caret);\n          lastVisualCaret.set({\n            caret,\n            element,\n            before\n          });\n          if (before) {\n            dom.addClass(caret, 'mce-visual-caret-before');\n          }\n          startBlink();\n          rng = element.ownerDocument.createRange();\n          rng.setStart(caretContainer, 0);\n          rng.setEnd(caretContainer, 0);\n        } else {\n          caretContainerNode = insertInline$1(element, before);\n          rng = element.ownerDocument.createRange();\n          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\n            rng.setStart(caretContainerNode, 0);\n            rng.setEnd(caretContainerNode, 0);\n          } else {\n            rng.setStart(caretContainerNode, 1);\n            rng.setEnd(caretContainerNode, 1);\n          }\n          return rng;\n        }\n        return rng;\n      };\n      const hide = () => {\n        trimInlineCaretContainers(root);\n        if (caretContainerNode) {\n          remove$3(caretContainerNode);\n          caretContainerNode = null;\n        }\n        lastVisualCaret.on(caretState => {\n          dom.remove(caretState.caret);\n          lastVisualCaret.clear();\n        });\n        if (cursorInterval) {\n          clearInterval(cursorInterval);\n          cursorInterval = undefined;\n        }\n      };\n      const startBlink = () => {\n        cursorInterval = setInterval(() => {\n          lastVisualCaret.on(caretState => {\n            if (hasFocus()) {\n              dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\n            } else {\n              dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\n            }\n          });\n        }, 500);\n      };\n      const reposition = () => {\n        lastVisualCaret.on(caretState => {\n          const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\n          dom.setStyles(caretState.caret, { ...clientRect });\n        });\n      };\n      const destroy = () => clearInterval(cursorInterval);\n      const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\n      return {\n        show,\n        hide,\n        getCss,\n        reposition,\n        destroy\n      };\n    };\n    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\n    const isInlineFakeCaretTarget = node => isContentEditableFalse$8(node) || isMedia$1(node);\n    const isFakeCaretTarget = node => {\n      const isTarget = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();\n      return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2);\n    };\n\n    const isContentEditableTrue$1 = isContentEditableTrue$3;\n    const isContentEditableFalse$7 = isContentEditableFalse$b;\n    const isMedia = isMedia$2;\n    const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');\n    const isCaretContainer = isCaretContainer$2;\n    const isCaretContainerBlock = isCaretContainerBlock$1;\n    const isElement$2 = isElement$6;\n    const isText$4 = isText$a;\n    const isCaretCandidate$1 = isCaretCandidate$3;\n    const isForwards = direction => direction > 0;\n    const isBackwards = direction => direction < 0;\n    const skipCaretContainers = (walk, shallow) => {\n      let node;\n      while (node = walk(shallow)) {\n        if (!isCaretContainerBlock(node)) {\n          return node;\n        }\n      }\n      return null;\n    };\n    const findNode = (node, direction, predicateFn, rootNode, shallow) => {\n      const walker = new DomTreeWalker(node, rootNode);\n      const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);\n      let tempNode;\n      if (isBackwards(direction)) {\n        if (isCefOrCaretContainer) {\n          tempNode = skipCaretContainers(walker.prev.bind(walker), true);\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n        while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow)) {\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      if (isForwards(direction)) {\n        if (isCefOrCaretContainer) {\n          tempNode = skipCaretContainers(walker.next.bind(walker), true);\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n        while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow)) {\n          if (predicateFn(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const getEditingHost = (node, rootNode) => {\n      const isCETrue = node => isContentEditableTrue$1(node.dom);\n      const isRoot = node => node.dom === rootNode;\n      return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\n    };\n    const getParentBlock$3 = (node, rootNode) => {\n      while (node && node !== rootNode) {\n        if (isBlockLike(node)) {\n          return node;\n        }\n        node = node.parentNode;\n      }\n      return null;\n    };\n    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\n    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\n      if (!caretPosition) {\n        return Optional.none();\n      }\n      const container = caretPosition.container();\n      const offset = caretPosition.offset();\n      if (!isElement$2(container)) {\n        return Optional.none();\n      }\n      return Optional.from(container.childNodes[offset + relativeOffset]);\n    };\n    const beforeAfter = (before, node) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const range = doc.createRange();\n      if (before) {\n        range.setStartBefore(node);\n        range.setEndBefore(node);\n      } else {\n        range.setStartAfter(node);\n        range.setEndAfter(node);\n      }\n      return range;\n    };\n    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\n    const lean = (left, root, node) => {\n      const siblingName = left ? 'previousSibling' : 'nextSibling';\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        let sibling = tempNode[siblingName];\n        if (sibling && isCaretContainer(sibling)) {\n          sibling = sibling[siblingName];\n        }\n        if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {\n          if (isNodesInSameBlock(root, sibling, tempNode)) {\n            return sibling;\n          }\n          break;\n        }\n        if (isCaretCandidate$1(sibling)) {\n          break;\n        }\n        tempNode = tempNode.parentNode;\n      }\n      return null;\n    };\n    const before$2 = curry(beforeAfter, true);\n    const after$2 = curry(beforeAfter, false);\n    const normalizeRange = (direction, root, range) => {\n      let node;\n      const leanLeft = curry(lean, true, root);\n      const leanRight = curry(lean, false, root);\n      const container = range.startContainer;\n      const offset = range.startOffset;\n      if (isCaretContainerBlock$1(container)) {\n        const block = isText$4(container) ? container.parentNode : container;\n        const location = block.getAttribute('data-mce-caret');\n        if (location === 'before') {\n          node = block.nextSibling;\n          if (isFakeCaretTarget(node)) {\n            return before$2(node);\n          }\n        }\n        if (location === 'after') {\n          node = block.previousSibling;\n          if (isFakeCaretTarget(node)) {\n            return after$2(node);\n          }\n        }\n      }\n      if (!range.collapsed) {\n        return range;\n      }\n      if (isText$a(container)) {\n        if (isCaretContainer(container)) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\n          if (direction === 1) {\n            node = leanRight(container);\n            if (node) {\n              return before$2(node);\n            }\n          }\n          return range;\n        }\n        if (startsWithCaretContainer$1(container) && offset <= 1) {\n          if (direction === -1) {\n            node = leanLeft(container);\n            if (node) {\n              return after$2(node);\n            }\n          }\n          return range;\n        }\n        if (offset === container.data.length) {\n          node = leanRight(container);\n          if (node) {\n            return before$2(node);\n          }\n          return range;\n        }\n        if (offset === 0) {\n          node = leanLeft(container);\n          if (node) {\n            return after$2(node);\n          }\n          return range;\n        }\n      }\n      return range;\n    };\n    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);\n    const getNormalizedRangeEndPoint = (direction, root, range) => {\n      const normalizedRange = normalizeRange(direction, root, range);\n      return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);\n    };\n    const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\n    const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\n    const getVisualCaretPosition = (walkFn, caretPosition) => {\n      let pos = caretPosition;\n      while (pos = walkFn(pos)) {\n        if (pos.isVisible()) {\n          return pos;\n        }\n      }\n      return pos;\n    };\n    const isMoveInsideSameBlock = (from, to) => {\n      const inSameBlock = isInSameBlock(from, to);\n      if (!inSameBlock && isBr$6(from.getNode())) {\n        return true;\n      }\n      return inSameBlock;\n    };\n\n    var HDirection;\n    (function (HDirection) {\n      HDirection[HDirection['Backwards'] = -1] = 'Backwards';\n      HDirection[HDirection['Forwards'] = 1] = 'Forwards';\n    }(HDirection || (HDirection = {})));\n    const isContentEditableFalse$6 = isContentEditableFalse$b;\n    const isText$3 = isText$a;\n    const isElement$1 = isElement$6;\n    const isBr$2 = isBr$6;\n    const isCaretCandidate = isCaretCandidate$3;\n    const isAtomic = isAtomic$1;\n    const isEditableCaretCandidate = isEditableCaretCandidate$1;\n    const getParents$3 = (node, root) => {\n      const parents = [];\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        parents.push(tempNode);\n        tempNode = tempNode.parentNode;\n      }\n      return parents;\n    };\n    const nodeAtIndex = (container, offset) => {\n      if (container.hasChildNodes() && offset < container.childNodes.length) {\n        return container.childNodes[offset];\n      }\n      return null;\n    };\n    const getCaretCandidatePosition = (direction, node) => {\n      if (isForwards(direction)) {\n        if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {\n          return CaretPosition.before(node);\n        }\n        if (isText$3(node)) {\n          return CaretPosition(node, 0);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {\n          return CaretPosition.after(node);\n        }\n        if (isText$3(node)) {\n          return CaretPosition(node, node.data.length);\n        }\n      }\n      if (isBackwards(direction)) {\n        if (isBr$2(node)) {\n          return CaretPosition.before(node);\n        }\n        return CaretPosition.after(node);\n      }\n      return CaretPosition.before(node);\n    };\n    const moveForwardFromBr = (root, nextNode) => {\n      const nextSibling = nextNode.nextSibling;\n      if (nextSibling && isCaretCandidate(nextSibling)) {\n        if (isText$3(nextSibling)) {\n          return CaretPosition(nextSibling, 0);\n        } else {\n          return CaretPosition.before(nextSibling);\n        }\n      } else {\n        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\n      }\n    };\n    const findCaretPosition$1 = (direction, startPos, root) => {\n      let node;\n      let nextNode;\n      let innerNode;\n      let caretPosition;\n      if (!isElement$1(root) || !startPos) {\n        return null;\n      }\n      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\n        caretPosition = CaretPosition.after(root.lastChild);\n        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\n          return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\n        }\n      } else {\n        caretPosition = startPos;\n      }\n      const container = caretPosition.container();\n      let offset = caretPosition.offset();\n      if (isText$3(container)) {\n        if (isBackwards(direction) && offset > 0) {\n          return CaretPosition(container, --offset);\n        }\n        if (isForwards(direction) && offset < container.length) {\n          return CaretPosition(container, ++offset);\n        }\n        node = container;\n      } else {\n        if (isBackwards(direction) && offset > 0) {\n          nextNode = nodeAtIndex(container, offset - 1);\n          if (isCaretCandidate(nextNode)) {\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$3(innerNode)) {\n                  return CaretPosition(innerNode, innerNode.data.length);\n                }\n                return CaretPosition.after(innerNode);\n              }\n            }\n            if (isText$3(nextNode)) {\n              return CaretPosition(nextNode, nextNode.data.length);\n            }\n            return CaretPosition.before(nextNode);\n          }\n        }\n        if (isForwards(direction) && offset < container.childNodes.length) {\n          nextNode = nodeAtIndex(container, offset);\n          if (isCaretCandidate(nextNode)) {\n            if (isBr$2(nextNode)) {\n              return moveForwardFromBr(root, nextNode);\n            }\n            if (!isAtomic(nextNode)) {\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\n              if (innerNode) {\n                if (isText$3(innerNode)) {\n                  return CaretPosition(innerNode, 0);\n                }\n                return CaretPosition.before(innerNode);\n              }\n            }\n            if (isText$3(nextNode)) {\n              return CaretPosition(nextNode, 0);\n            }\n            return CaretPosition.after(nextNode);\n          }\n        }\n        node = nextNode ? nextNode : caretPosition.getNode();\n      }\n      if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {\n        node = findNode(node, direction, always, root, true);\n        if (isEditableCaretCandidate(node, root)) {\n          return getCaretCandidatePosition(direction, node);\n        }\n      }\n      nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;\n      const rootContentEditableFalseElm = last$2(filter$5(getParents$3(container, root), isContentEditableFalse$6));\n      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\n        if (isForwards(direction)) {\n          caretPosition = CaretPosition.after(rootContentEditableFalseElm);\n        } else {\n          caretPosition = CaretPosition.before(rootContentEditableFalseElm);\n        }\n        return caretPosition;\n      }\n      if (nextNode) {\n        return getCaretCandidatePosition(direction, nextNode);\n      }\n      return null;\n    };\n    const CaretWalker = root => ({\n      next: caretPosition => {\n        return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\n      },\n      prev: caretPosition => {\n        return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\n      }\n    });\n\n    const walkToPositionIn = (forward, root, start) => {\n      const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\n      return fromPosition(forward, root, position);\n    };\n    const afterElement = node => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);\n    const isBeforeOrStart = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        return position.offset() === 0;\n      } else {\n        return isCaretCandidate$3(position.getNode());\n      }\n    };\n    const isAfterOrEnd = position => {\n      if (CaretPosition.isTextPosition(position)) {\n        const container = position.container();\n        return position.offset() === container.data.length;\n      } else {\n        return isCaretCandidate$3(position.getNode(true));\n      }\n    };\n    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\n    const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());\n    const shouldSkipPosition = (forward, from, to) => {\n      if (forward) {\n        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\n      } else {\n        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\n      }\n    };\n    const fromPosition = (forward, root, pos) => {\n      const walker = CaretWalker(root);\n      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\n    };\n    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\n      if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\n        return fromPosition(forward, root, to);\n      } else {\n        return Optional.some(to);\n      }\n    });\n    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\n    const positionIn = (forward, element) => {\n      const startNode = forward ? element.firstChild : element.lastChild;\n      if (isText$a(startNode)) {\n        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\n      } else if (startNode) {\n        if (isCaretCandidate$3(startNode)) {\n          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\n        } else {\n          return walkToPositionIn(forward, element, startNode);\n        }\n      } else {\n        return Optional.none();\n      }\n    };\n    const nextPosition = curry(fromPosition, true);\n    const prevPosition = curry(fromPosition, false);\n    const firstPositionIn = curry(positionIn, true);\n    const lastPositionIn = curry(positionIn, false);\n\n    const CARET_ID = '_mce_caret';\n    const isCaretNode = node => isElement$6(node) && node.id === CARET_ID;\n    const getParentCaretContainer = (body, node) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== body) {\n        if (isCaretNode(currentNode)) {\n          return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return null;\n    };\n\n    const isStringPathBookmark = bookmark => isString(bookmark.start);\n    const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\n    const isIdBookmark = bookmark => has$2(bookmark, 'id');\n    const isIndexBookmark = bookmark => has$2(bookmark, 'name');\n    const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\n\n    const isForwardBookmark = bookmark => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;\n    const addBogus = (dom, node) => {\n      if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\n        node.innerHTML = '<br data-mce-bogus=\"1\" />';\n      }\n      return node;\n    };\n    const resolveCaretPositionBookmark = (dom, bookmark) => {\n      const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));\n      const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));\n      return lift2(startPos, endPos, (start, end) => {\n        const range = dom.createRng();\n        range.setStart(start.container(), start.offset());\n        range.setEnd(end.container(), end.offset());\n        return {\n          range,\n          forward: isForwardBookmark(bookmark)\n        };\n      });\n    };\n    const insertZwsp = (node, rng) => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      const textNode = doc.createTextNode(ZWSP$1);\n      node.appendChild(textNode);\n      rng.setStart(textNode, 0);\n      rng.setEnd(textNode, 0);\n    };\n    const isEmpty$1 = node => !node.hasChildNodes();\n    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      return true;\n    });\n    const padEmptyCaretContainer = (root, node, rng) => {\n      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\n        insertZwsp(node, rng);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const setEndPoint = (dom, start, bookmark, rng) => {\n      const point = bookmark[start ? 'start' : 'end'];\n      const root = dom.getRoot();\n      if (point) {\n        let node = root;\n        let offset = point[0];\n        for (let i = point.length - 1; node && i >= 1; i--) {\n          const children = node.childNodes;\n          if (padEmptyCaretContainer(root, node, rng)) {\n            return true;\n          }\n          if (point[i] > children.length - 1) {\n            if (padEmptyCaretContainer(root, node, rng)) {\n              return true;\n            }\n            return tryFindRangePosition(node, rng);\n          }\n          node = children[point[i]];\n        }\n        if (isText$a(node)) {\n          offset = Math.min(point[0], node.data.length);\n        }\n        if (isElement$6(node)) {\n          offset = Math.min(point[0], node.childNodes.length);\n        }\n        if (start) {\n          rng.setStart(node, offset);\n        } else {\n          rng.setEnd(node, offset);\n        }\n      }\n      return true;\n    };\n    const isValidTextNode = node => isText$a(node) && node.data.length > 0;\n    const restoreEndPoint = (dom, suffix, bookmark) => {\n      const marker = dom.get(bookmark.id + '_' + suffix);\n      const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;\n      const keep = bookmark.keep;\n      if (marker && markerParent) {\n        let container;\n        let offset;\n        if (suffix === 'start') {\n          if (!keep) {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              container = marker.firstChild;\n              offset = 1;\n            } else if (isValidTextNode(marker.nextSibling)) {\n              container = marker.nextSibling;\n              offset = 0;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              container = marker.previousSibling;\n              offset = marker.previousSibling.data.length;\n            } else {\n              container = markerParent;\n              offset = dom.nodeIndex(marker) + 1;\n            }\n          }\n        } else {\n          if (!keep) {\n            container = markerParent;\n            offset = dom.nodeIndex(marker);\n          } else {\n            if (marker.hasChildNodes()) {\n              container = marker.firstChild;\n              offset = 1;\n            } else if (isValidTextNode(marker.previousSibling)) {\n              container = marker.previousSibling;\n              offset = marker.previousSibling.data.length;\n            } else {\n              container = markerParent;\n              offset = dom.nodeIndex(marker);\n            }\n          }\n        }\n        if (!keep) {\n          const prev = marker.previousSibling;\n          const next = marker.nextSibling;\n          Tools.each(Tools.grep(marker.childNodes), node => {\n            if (isText$a(node)) {\n              node.data = node.data.replace(/\\uFEFF/g, '');\n            }\n          });\n          let otherMarker;\n          while (otherMarker = dom.get(bookmark.id + '_' + suffix)) {\n            dom.remove(otherMarker, true);\n          }\n          if (isText$a(next) && isText$a(prev) && !Env.browser.isOpera()) {\n            const idx = prev.data.length;\n            prev.appendData(next.data);\n            dom.remove(next);\n            container = prev;\n            offset = idx;\n          }\n        }\n        return Optional.some(CaretPosition(container, offset));\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolvePaths = (dom, bookmark) => {\n      const range = dom.createRng();\n      if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {\n        return Optional.some({\n          range,\n          forward: isForwardBookmark(bookmark)\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const resolveId = (dom, bookmark) => {\n      const startPos = restoreEndPoint(dom, 'start', bookmark);\n      const endPos = restoreEndPoint(dom, 'end', bookmark);\n      return lift2(startPos, endPos.or(startPos), (spos, epos) => {\n        const range = dom.createRng();\n        range.setStart(addBogus(dom, spos.container()), spos.offset());\n        range.setEnd(addBogus(dom, epos.container()), epos.offset());\n        return {\n          range,\n          forward: isForwardBookmark(bookmark)\n        };\n      });\n    };\n    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\n      const range = dom.createRng();\n      range.selectNode(elm);\n      return {\n        range,\n        forward: true\n      };\n    });\n    const resolve = (selection, bookmark) => {\n      const dom = selection.dom;\n      if (bookmark) {\n        if (isPathBookmark(bookmark)) {\n          return resolvePaths(dom, bookmark);\n        } else if (isStringPathBookmark(bookmark)) {\n          return resolveCaretPositionBookmark(dom, bookmark);\n        } else if (isIdBookmark(bookmark)) {\n          return resolveId(dom, bookmark);\n        } else if (isIndexBookmark(bookmark)) {\n          return resolveIndex(dom, bookmark);\n        } else if (isRangeBookmark(bookmark)) {\n          return Optional.some({\n            range: bookmark.rng,\n            forward: isForwardBookmark(bookmark)\n          });\n        }\n      }\n      return Optional.none();\n    };\n\n    const getBookmark$1 = (selection, type, normalized) => {\n      return getBookmark$2(selection, type, normalized);\n    };\n    const moveToBookmark = (selection, bookmark) => {\n      resolve(selection, bookmark).each(({range, forward}) => {\n        selection.setRng(range, forward);\n      });\n    };\n    const isBookmarkNode$1 = node => {\n      return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\n    };\n\n    const is = expected => actual => expected === actual;\n    const isNbsp = is(nbsp);\n    const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n    const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);\n\n    const getRanges$1 = selection => {\n      const ranges = [];\n      if (selection) {\n        for (let i = 0; i < selection.rangeCount; i++) {\n          ranges.push(selection.getRangeAt(i));\n        }\n      }\n      return ranges;\n    };\n    const getSelectedNodes = ranges => {\n      return bind$3(ranges, range => {\n        const node = getSelectedNode(range);\n        return node ? [SugarElement.fromDom(node)] : [];\n      });\n    };\n    const hasMultipleRanges = selection => {\n      return getRanges$1(selection).length > 1;\n    };\n\n    const getCellsFromRanges = ranges => filter$5(getSelectedNodes(ranges), isTableCell$2);\n    const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\n    const getCellsFromElementOrRanges = (ranges, element) => {\n      const selectedCells = getCellsFromElement(element);\n      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\n    };\n    const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\n    const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);\n\n    const getStartNode = rng => {\n      const sc = rng.startContainer, so = rng.startOffset;\n      if (isText$a(sc)) {\n        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\n      } else {\n        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\n      }\n    };\n    const getEndNode = rng => {\n      const ec = rng.endContainer, eo = rng.endOffset;\n      if (isText$a(ec)) {\n        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\n      } else {\n        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\n      }\n    };\n    const getFirstChildren = node => {\n      return firstChild(node).fold(constant([node]), child => {\n        return [node].concat(getFirstChildren(child));\n      });\n    };\n    const getLastChildren = node => {\n      return lastChild(node).fold(constant([node]), child => {\n        if (name(child) === 'br') {\n          return prevSibling(child).map(sibling => {\n            return [node].concat(getLastChildren(sibling));\n          }).getOr([]);\n        } else {\n          return [node].concat(getLastChildren(child));\n        }\n      });\n    };\n    const hasAllContentsSelected = (elm, rng) => {\n      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\n        const start = find$2(getFirstChildren(elm), curry(eq, startNode));\n        const end = find$2(getLastChildren(elm), curry(eq, endNode));\n        return start.isSome() && end.isSome();\n      }).getOr(false);\n    };\n    const moveEndPoint = (dom, rng, node, start) => {\n      const root = node;\n      const walker = new DomTreeWalker(node, root);\n      const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2([\n        'td',\n        'th',\n        'table'\n      ], name.toLowerCase()));\n      let currentNode = node;\n      do {\n        if (isText$a(currentNode) && Tools.trim(currentNode.data).length !== 0) {\n          if (start) {\n            rng.setStart(currentNode, 0);\n          } else {\n            rng.setEnd(currentNode, currentNode.data.length);\n          }\n          return;\n        }\n        if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {\n          if (start) {\n            rng.setStartBefore(currentNode);\n          } else {\n            if (currentNode.nodeName === 'BR') {\n              rng.setEndBefore(currentNode);\n            } else {\n              rng.setEndAfter(currentNode);\n            }\n          }\n          return;\n        }\n      } while (currentNode = start ? walker.next() : walker.prev());\n      if (root.nodeName === 'BODY') {\n        if (start) {\n          rng.setStart(root, 0);\n        } else {\n          rng.setEnd(root, root.childNodes.length);\n        }\n      }\n    };\n    const hasAnyRanges = editor => {\n      const sel = editor.selection.getSel();\n      return isNonNullable(sel) && sel.rangeCount > 0;\n    };\n    const runOnRanges = (editor, executor) => {\n      const fakeSelectionNodes = getCellsFromEditor(editor);\n      if (fakeSelectionNodes.length > 0) {\n        each$e(fakeSelectionNodes, elem => {\n          const node = elem.dom;\n          const fakeNodeRng = editor.dom.createRng();\n          fakeNodeRng.setStartBefore(node);\n          fakeNodeRng.setEndAfter(node);\n          executor(fakeNodeRng, true);\n        });\n      } else {\n        executor(editor.selection.getRng(), false);\n      }\n    };\n    const preserve = (selection, fillBookmark, executor) => {\n      const bookmark = getPersistentBookmark(selection, fillBookmark);\n      executor(bookmark);\n      selection.moveToBookmark(bookmark);\n    };\n\n    const isNode = node => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);\n    const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n    const isElementDirectlySelected = (dom, node) => {\n      if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {\n        const selectedAttr = dom.getAttrib(node, 'data-mce-selected');\n        const value = parseInt(selectedAttr, 10);\n        return !isNaN(value) && value > 0;\n      } else {\n        return false;\n      }\n    };\n    const preserveSelection = (editor, action, shouldMoveStart) => {\n      const {selection, dom} = editor;\n      const selectedNodeBeforeAction = selection.getNode();\n      const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);\n      preserve(selection, true, () => {\n        action();\n      });\n      const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);\n      if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {\n        editor.selection.select(selectedNodeBeforeAction);\n      } else if (shouldMoveStart(selection.getStart())) {\n        moveStartToNearestText(dom, selection);\n      }\n    };\n    const moveStartToNearestText = (dom, selection) => {\n      var _a, _b;\n      const rng = selection.getRng();\n      const {startContainer, startOffset} = rng;\n      const selectedNode = selection.getNode();\n      if (isElementDirectlySelected(dom, selectedNode)) {\n        return;\n      }\n      if (isElement$6(startContainer)) {\n        const nodes = startContainer.childNodes;\n        const root = dom.getRoot();\n        let walker;\n        if (startOffset < nodes.length) {\n          const startNode = nodes[startOffset];\n          walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);\n        } else {\n          const startNode = nodes[nodes.length - 1];\n          walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);\n          walker.next(true);\n        }\n        for (let node = walker.current(); node; node = walker.next()) {\n          if (dom.getContentEditable(node) === 'false') {\n            return;\n          } else if (isText$a(node) && !isWhiteSpaceNode$1(node)) {\n            rng.setStart(node, 0);\n            selection.setRng(rng);\n            return;\n          }\n        }\n      }\n    };\n    const getNonWhiteSpaceSibling = (node, next, inc) => {\n      if (node) {\n        const nextName = next ? 'nextSibling' : 'previousSibling';\n        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\n          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\n            return node;\n          }\n        }\n      }\n      return undefined;\n    };\n    const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);\n    const isValid = (ed, parent, child) => {\n      return ed.schema.isValidChild(parent, child);\n    };\n    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {\n      if (isNonNullable(node) && isText$a(node)) {\n        const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\n        return isWhitespaceText(data);\n      } else {\n        return false;\n      }\n    };\n    const isEmptyTextNode$1 = node => {\n      return isNonNullable(node) && isText$a(node) && node.length === 0;\n    };\n    const isWrapNoneditableTarget = (editor, node) => {\n      const baseDataSelector = '[data-mce-cef-wrappable]';\n      const formatNoneditableSelector = getFormatNoneditableSelector(editor);\n      const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${ baseDataSelector },${ formatNoneditableSelector }`;\n      return is$1(SugarElement.fromDom(node), selector);\n    };\n    const isWrappableNoneditable = (editor, node) => {\n      const dom = editor.dom;\n      return isElementNode$1(node) && dom.getContentEditable(node) === 'false' && isWrapNoneditableTarget(editor, node) && dom.select('[contenteditable=\"true\"]', node).length === 0;\n    };\n    const replaceVars = (value, vars) => {\n      if (isFunction(value)) {\n        return value(vars);\n      } else if (isNonNullable(vars)) {\n        value = value.replace(/%(\\w+)/g, (str, name) => {\n          return vars[name] || str;\n        });\n      }\n      return value;\n    };\n    const isEq$5 = (str1, str2) => {\n      str1 = str1 || '';\n      str2 = str2 || '';\n      str1 = '' + (str1.nodeName || str1);\n      str2 = '' + (str2.nodeName || str2);\n      return str1.toLowerCase() === str2.toLowerCase();\n    };\n    const normalizeStyleValue = (value, name) => {\n      if (isNullable(value)) {\n        return null;\n      } else {\n        let strValue = String(value);\n        if (name === 'color' || name === 'backgroundColor') {\n          strValue = rgbaToHexString(strValue);\n        }\n        if (name === 'fontWeight' && value === 700) {\n          strValue = 'bold';\n        }\n        if (name === 'fontFamily') {\n          strValue = strValue.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\n        }\n        return strValue;\n      }\n    };\n    const getStyle = (dom, node, name) => {\n      const style = dom.getStyle(node, name);\n      return normalizeStyleValue(style, name);\n    };\n    const getTextDecoration = (dom, node) => {\n      let decoration;\n      dom.getParent(node, n => {\n        if (isElement$6(n)) {\n          decoration = dom.getStyle(n, 'text-decoration');\n          return !!decoration && decoration !== 'none';\n        } else {\n          return false;\n        }\n      });\n      return decoration;\n    };\n    const getParents$2 = (dom, node, selector) => {\n      return dom.getParents(node, selector, dom.getRoot());\n    };\n    const isFormatPredicate = (editor, formatName, predicate) => {\n      const formats = editor.formatter.get(formatName);\n      return isNonNullable(formats) && exists(formats, predicate);\n    };\n    const isVariableFormatName = (editor, formatName) => {\n      const hasVariableValues = format => {\n        const isVariableValue = val => isFunction(val) || val.length > 1 && val.charAt(0) === '%';\n        return exists([\n          'styles',\n          'attributes'\n        ], key => get$a(format, key).exists(field => {\n          const fieldValues = isArray$1(field) ? field : values(field);\n          return exists(fieldValues, isVariableValue);\n        }));\n      };\n      return isFormatPredicate(editor, formatName, hasVariableValues);\n    };\n    const areSimilarFormats = (editor, formatName, otherFormatName) => {\n      const validKeys = [\n        'inline',\n        'block',\n        'selector',\n        'attributes',\n        'styles',\n        'classes'\n      ];\n      const filterObj = format => filter$4(format, (_, key) => exists(validKeys, validKey => validKey === key));\n      return isFormatPredicate(editor, formatName, fmt1 => {\n        const filteredFmt1 = filterObj(fmt1);\n        return isFormatPredicate(editor, otherFormatName, fmt2 => {\n          const filteredFmt2 = filterObj(fmt2);\n          return equal$1(filteredFmt1, filteredFmt2);\n        });\n      });\n    };\n    const isBlockFormat = format => hasNonNullableKey(format, 'block');\n    const isWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper === true;\n    const isNonWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper !== true;\n    const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\n    const isInlineFormat = format => hasNonNullableKey(format, 'inline');\n    const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\n    const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\n    const getEmptyCaretContainers = node => {\n      const nodes = [];\n      let tempNode = node;\n      while (tempNode) {\n        if (isText$a(tempNode) && tempNode.data !== ZWSP$1 || tempNode.childNodes.length > 1) {\n          return [];\n        }\n        if (isElement$6(tempNode)) {\n          nodes.push(tempNode);\n        }\n        tempNode = tempNode.firstChild;\n      }\n      return nodes;\n    };\n    const isCaretContainerEmpty = node => {\n      return getEmptyCaretContainers(node).length > 0;\n    };\n    const isEmptyCaretFormatElement = element => {\n      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\n    };\n\n    const isBookmarkNode = isBookmarkNode$1;\n    const getParents$1 = getParents$2;\n    const isWhiteSpaceNode = isWhiteSpaceNode$1;\n    const isTextBlock = isTextBlock$1;\n    const isBogusBr = node => {\n      return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\n    };\n    const findParentContentEditable = (dom, node) => {\n      let parent = node;\n      while (parent) {\n        if (isElement$6(parent) && dom.getContentEditable(parent)) {\n          return dom.getContentEditable(parent) === 'false' ? parent : node;\n        }\n        parent = parent.parentNode;\n      }\n      return node;\n    };\n    const walkText = (start, node, offset, predicate) => {\n      const str = node.data;\n      if (start) {\n        for (let i = offset; i > 0; i--) {\n          if (predicate(str.charAt(i - 1))) {\n            return i;\n          }\n        }\n      } else {\n        for (let i = offset; i < str.length; i++) {\n          if (predicate(str.charAt(i))) {\n            return i;\n          }\n        }\n      }\n      return -1;\n    };\n    const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\n    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\n    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\n      let lastTextNode;\n      const rootNode = dom.getParent(container, dom.isBlock) || body;\n      const walk = (container, offset, pred) => {\n        const textSeeker = TextSeeker(dom);\n        const walker = start ? textSeeker.backwards : textSeeker.forwards;\n        return Optional.from(walker(container, offset, (text, textOffset) => {\n          if (isBookmarkNode(text.parentNode)) {\n            return -1;\n          } else {\n            lastTextNode = text;\n            return pred(start, text, textOffset);\n          }\n        }, rootNode));\n      };\n      const spaceResult = walk(container, offset, findSpace);\n      return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\n        container: lastTextNode,\n        offset: start ? 0 : lastTextNode.length\n      }) : Optional.none());\n    };\n    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\n      const sibling = container[siblingName];\n      if (isText$a(container) && isEmpty$3(container.data) && sibling) {\n        container = sibling;\n      }\n      const parents = getParents$1(dom, container);\n      for (let i = 0; i < parents.length; i++) {\n        for (let y = 0; y < formatList.length; y++) {\n          const curFormat = formatList[y];\n          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\n            continue;\n          }\n          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\n            return parents[i];\n          }\n        }\n      }\n      return container;\n    };\n    const findBlockEndPoint = (dom, formatList, container, siblingName) => {\n      var _a;\n      let node = container;\n      const root = dom.getRoot();\n      const format = formatList[0];\n      if (isBlockFormat(format)) {\n        node = format.wrapper ? null : dom.getParent(container, format.block, root);\n      }\n      if (!node) {\n        const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH,SUMMARY')) !== null && _a !== void 0 ? _a : root;\n        node = dom.getParent(isText$a(container) ? container.parentNode : container, node => node !== root && isTextBlock(dom.schema, node), scopeRoot);\n      }\n      if (node && isBlockFormat(format) && format.wrapper) {\n        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\n      }\n      if (!node) {\n        node = container;\n        while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {\n          node = node[siblingName];\n          if (isEq$5(node, 'br')) {\n            break;\n          }\n        }\n      }\n      return node || container;\n    };\n    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\n      const parent = container.parentNode;\n      if (isNonNullable(container[siblingName])) {\n        return false;\n      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\n        return true;\n      } else {\n        return isAtBlockBoundary$1(dom, root, parent, siblingName);\n      }\n    };\n    const findParentContainer = (dom, formatList, container, offset, start) => {\n      let parent = container;\n      const siblingName = start ? 'previousSibling' : 'nextSibling';\n      const root = dom.getRoot();\n      if (isText$a(container) && !isWhiteSpaceNode(container)) {\n        if (start ? offset > 0 : offset < container.data.length) {\n          return container;\n        }\n      }\n      while (parent) {\n        if (!formatList[0].block_expand && dom.isBlock(parent)) {\n          return parent;\n        }\n        for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\n          const allowSpaces = isText$a(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\n          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\n            return parent;\n          }\n        }\n        if (parent === root || parent.parentNode === root) {\n          container = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return container;\n    };\n    const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\n    const expandRng = (dom, rng, formatList, includeTrailingSpace = false) => {\n      let {startContainer, startOffset, endContainer, endOffset} = rng;\n      const format = formatList[0];\n      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\n        startContainer = getNode$1(startContainer, startOffset);\n        if (isText$a(startContainer)) {\n          startOffset = 0;\n        }\n      }\n      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\n        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\n        if (isText$a(endContainer)) {\n          endOffset = endContainer.data.length;\n        }\n      }\n      startContainer = findParentContentEditable(dom, startContainer);\n      endContainer = findParentContentEditable(dom, endContainer);\n      if (isSelfOrParentBookmark(startContainer)) {\n        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\n        if (rng.collapsed) {\n          startContainer = startContainer.previousSibling || startContainer;\n        } else {\n          startContainer = startContainer.nextSibling || startContainer;\n        }\n        if (isText$a(startContainer)) {\n          startOffset = rng.collapsed ? startContainer.length : 0;\n        }\n      }\n      if (isSelfOrParentBookmark(endContainer)) {\n        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\n        if (rng.collapsed) {\n          endContainer = endContainer.nextSibling || endContainer;\n        } else {\n          endContainer = endContainer.previousSibling || endContainer;\n        }\n        if (isText$a(endContainer)) {\n          endOffset = rng.collapsed ? 0 : endContainer.length;\n        }\n      }\n      if (rng.collapsed) {\n        const startPoint = findWordEndPoint(dom, dom.getRoot(), startContainer, startOffset, true, includeTrailingSpace);\n        startPoint.each(({container, offset}) => {\n          startContainer = container;\n          startOffset = offset;\n        });\n        const endPoint = findWordEndPoint(dom, dom.getRoot(), endContainer, endOffset, false, includeTrailingSpace);\n        endPoint.each(({container, offset}) => {\n          endContainer = container;\n          endOffset = offset;\n        });\n      }\n      if (isInlineFormat(format) || format.block_expand) {\n        if (!isInlineFormat(format) || (!isText$a(startContainer) || startOffset === 0)) {\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n        }\n        if (!isInlineFormat(format) || (!isText$a(endContainer) || endOffset === endContainer.data.length)) {\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n        }\n      }\n      if (shouldExpandToSelector(format)) {\n        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\n        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\n      }\n      if (isBlockFormat(format) || isSelectorFormat(format)) {\n        startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');\n        endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');\n        if (isBlockFormat(format)) {\n          if (!dom.isBlock(startContainer)) {\n            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\n          }\n          if (!dom.isBlock(endContainer)) {\n            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\n          }\n        }\n      }\n      if (isElement$6(startContainer) && startContainer.parentNode) {\n        startOffset = dom.nodeIndex(startContainer);\n        startContainer = startContainer.parentNode;\n      }\n      if (isElement$6(endContainer) && endContainer.parentNode) {\n        endOffset = dom.nodeIndex(endContainer) + 1;\n        endContainer = endContainer.parentNode;\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const walk$3 = (dom, rng, callback) => {\n      var _a;\n      const startOffset = rng.startOffset;\n      const startContainer = getNode$1(rng.startContainer, startOffset);\n      const endOffset = rng.endOffset;\n      const endContainer = getNode$1(rng.endContainer, endOffset - 1);\n      const exclude = nodes => {\n        const firstNode = nodes[0];\n        if (isText$a(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\n          nodes.splice(0, 1);\n        }\n        const lastNode = nodes[nodes.length - 1];\n        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$a(lastNode)) {\n          nodes.splice(nodes.length - 1, 1);\n        }\n        return nodes;\n      };\n      const collectSiblings = (node, name, endNode) => {\n        const siblings = [];\n        for (; node && node !== endNode; node = node[name]) {\n          siblings.push(node);\n        }\n        return siblings;\n      };\n      const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\n      const walkBoundary = (startNode, endNode, next) => {\n        const siblingName = next ? 'nextSibling' : 'previousSibling';\n        for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\n          parent = node.parentNode;\n          const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\n          if (siblings.length) {\n            if (!next) {\n              siblings.reverse();\n            }\n            callback(exclude(siblings));\n          }\n        }\n      };\n      if (startContainer === endContainer) {\n        return callback(exclude([startContainer]));\n      }\n      const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      if (dom.isChildOf(startContainer, endContainer)) {\n        return walkBoundary(startContainer, ancestor, true);\n      }\n      if (dom.isChildOf(endContainer, startContainer)) {\n        return walkBoundary(endContainer, ancestor);\n      }\n      const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\n      const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\n      walkBoundary(startContainer, startPoint, true);\n      const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\n      if (siblings.length) {\n        callback(exclude(siblings));\n      }\n      walkBoundary(endContainer, endPoint);\n    };\n\n    const validBlocks = [\n      'pre[class*=language-][contenteditable=\"false\"]',\n      'figure.image',\n      'div[data-ephox-embed-iri]',\n      'div.tiny-pageembed',\n      'div.mce-toc',\n      'div[data-mce-toc]'\n    ];\n    const isZeroWidth = elem => isText$b(elem) && get$3(elem) === ZWSP$1;\n    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\n      if (nodeName === 'br' || isZeroWidth(elem)) {\n        return 'valid';\n      } else if (isAnnotation(elem)) {\n        return 'existing';\n      } else if (isCaretNode(elem.dom)) {\n        return 'caret';\n      } else if (exists(validBlocks, selector => is$1(elem, selector))) {\n        return 'valid-block';\n      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\n        return 'invalid-child';\n      } else {\n        return 'valid';\n      }\n    });\n\n    const applyWordGrab = (editor, rng) => {\n      const r = expandRng(editor.dom, rng, [{ inline: 'span' }]);\n      rng.setStart(r.startContainer, r.startOffset);\n      rng.setEnd(r.endContainer, r.endOffset);\n      editor.selection.setRng(rng);\n    };\n    const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {\n      const {uid = masterUId, ...otherData} = data;\n      add$2(elem, annotation());\n      set$3(elem, `${ dataAnnotationId() }`, uid);\n      set$3(elem, `${ dataAnnotation() }`, annotationName);\n      const {attributes = {}, classes = []} = decorate(uid, otherData);\n      setAll$1(elem, attributes);\n      add(elem, classes);\n      if (directAnnotation) {\n        if (classes.length > 0) {\n          set$3(elem, `${ dataAnnotationClasses() }`, classes.join(','));\n        }\n        const attributeNames = keys(attributes);\n        if (attributeNames.length > 0) {\n          set$3(elem, `${ dataAnnotationAttributes() }`, attributeNames.join(','));\n        }\n      }\n    };\n    const removeDirectAnnotation = elem => {\n      remove$7(elem, annotation());\n      remove$a(elem, `${ dataAnnotationId() }`);\n      remove$a(elem, `${ dataAnnotation() }`);\n      remove$a(elem, `${ dataAnnotationActive() }`);\n      const customAttrNames = getOpt(elem, `${ dataAnnotationAttributes() }`).map(names => names.split(',')).getOr([]);\n      const customClasses = getOpt(elem, `${ dataAnnotationClasses() }`).map(names => names.split(',')).getOr([]);\n      each$e(customAttrNames, name => remove$a(elem, name));\n      remove$4(elem, customClasses);\n      remove$a(elem, `${ dataAnnotationClasses() }`);\n      remove$a(elem, `${ dataAnnotationAttributes() }`);\n    };\n    const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {\n      const master = SugarElement.fromTag('span', eDoc);\n      applyAnnotation(master, uid, data, annotationName, decorate, false);\n      return master;\n    };\n    const annotate = (editor, rng, uid, annotationName, decorate, data) => {\n      const newWrappers = [];\n      const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);\n      const wrapper = value$2();\n      const finishWrapper = () => {\n        wrapper.clear();\n      };\n      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\n        const nu = shallow$1(master);\n        newWrappers.push(nu);\n        wrapper.set(nu);\n        return nu;\n      });\n      const processElements = elems => {\n        each$e(elems, processElement);\n      };\n      const processElement = elem => {\n        const ctx = context(editor, elem, 'span', name(elem));\n        switch (ctx) {\n        case 'invalid-child': {\n            finishWrapper();\n            const children = children$1(elem);\n            processElements(children);\n            finishWrapper();\n            break;\n          }\n        case 'valid-block': {\n            finishWrapper();\n            applyAnnotation(elem, uid, data, annotationName, decorate, true);\n            break;\n          }\n        case 'valid': {\n            const w = getOrOpenWrapper();\n            wrap$2(elem, w);\n            break;\n          }\n        }\n      };\n      const processNodes = nodes => {\n        const elems = map$3(nodes, SugarElement.fromDom);\n        processElements(elems);\n      };\n      walk$3(editor.dom, rng, nodes => {\n        finishWrapper();\n        processNodes(nodes);\n      });\n      return newWrappers;\n    };\n    const annotateWithBookmark = (editor, name, settings, data) => {\n      editor.undoManager.transact(() => {\n        const selection = editor.selection;\n        const initialRng = selection.getRng();\n        const hasFakeSelection = getCellsFromEditor(editor).length > 0;\n        const masterUid = generate$1('mce-annotation');\n        if (initialRng.collapsed && !hasFakeSelection) {\n          applyWordGrab(editor, initialRng);\n        }\n        if (selection.getRng().collapsed && !hasFakeSelection) {\n          const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);\n          set$1(wrapper, nbsp);\n          selection.getRng().insertNode(wrapper.dom);\n          selection.select(wrapper.dom);\n        } else {\n          preserve(selection, false, () => {\n            runOnRanges(editor, selectionRng => {\n              annotate(editor, selectionRng, masterUid, name, settings.decorate, data);\n            });\n          });\n        }\n      });\n    };\n\n    const Annotator = editor => {\n      const registry = create$c();\n      setup$x(editor, registry);\n      const changes = setup$y(editor, registry);\n      const isSpan = isTag('span');\n      const removeAnnotations = elements => {\n        each$e(elements, element => {\n          if (isSpan(element)) {\n            unwrap(element);\n          } else {\n            removeDirectAnnotation(element);\n          }\n        });\n      };\n      return {\n        register: (name, settings) => {\n          registry.register(name, settings);\n        },\n        annotate: (name, data) => {\n          registry.lookup(name).each(settings => {\n            annotateWithBookmark(editor, name, settings, data);\n          });\n        },\n        annotationChanged: (name, callback) => {\n          changes.addListener(name, callback);\n        },\n        remove: name => {\n          identify(editor, Optional.some(name)).each(({elements}) => {\n            const bookmark = editor.selection.getBookmark();\n            removeAnnotations(elements);\n            editor.selection.moveToBookmark(bookmark);\n          });\n        },\n        removeAll: name => {\n          const bookmark = editor.selection.getBookmark();\n          each$d(findAll(editor, name), (elements, _) => {\n            removeAnnotations(elements);\n          });\n          editor.selection.moveToBookmark(bookmark);\n        },\n        getAll: name => {\n          const directory = findAll(editor, name);\n          return map$2(directory, elems => map$3(elems, elem => elem.dom));\n        }\n      };\n    };\n\n    const BookmarkManager = selection => {\n      return {\n        getBookmark: curry(getBookmark$1, selection),\n        moveToBookmark: curry(moveToBookmark, selection)\n      };\n    };\n    BookmarkManager.isBookmarkNode = isBookmarkNode$1;\n\n    const isXYWithinRange = (clientX, clientY, range) => {\n      if (range.collapsed) {\n        return false;\n      } else {\n        return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\n      }\n    };\n\n    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\n    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\n    const fireRemove = editor => {\n      editor.dispatch('remove');\n    };\n    const fireDetach = editor => {\n      editor.dispatch('detach');\n    };\n    const fireSwitchMode = (editor, mode) => {\n      editor.dispatch('SwitchMode', { mode });\n    };\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResizeStart', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const fireObjectResized = (editor, target, width, height, origin) => {\n      editor.dispatch('ObjectResized', {\n        target,\n        width,\n        height,\n        origin\n      });\n    };\n    const firePreInit = editor => {\n      editor.dispatch('PreInit');\n    };\n    const firePostRender = editor => {\n      editor.dispatch('PostRender');\n    };\n    const fireInit = editor => {\n      editor.dispatch('Init');\n    };\n    const firePlaceholderToggle = (editor, state) => {\n      editor.dispatch('PlaceholderToggle', { state });\n    };\n    const fireError = (editor, errorType, error) => {\n      editor.dispatch(errorType, error);\n    };\n    const fireFormatApply = (editor, format, node, vars) => {\n      editor.dispatch('FormatApply', {\n        format,\n        node,\n        vars\n      });\n    };\n    const fireFormatRemove = (editor, format, node, vars) => {\n      editor.dispatch('FormatRemove', {\n        format,\n        node,\n        vars\n      });\n    };\n    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\n    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\n    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\n    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\n    const fireAutocompleterStart = (editor, args) => {\n      editor.dispatch('AutocompleterStart', args);\n    };\n    const fireAutocompleterUpdate = (editor, args) => {\n      editor.dispatch('AutocompleterUpdate', args);\n    };\n    const fireAutocompleterEnd = editor => {\n      editor.dispatch('AutocompleterEnd');\n    };\n    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\n      content: html,\n      internal\n    });\n    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\n      node,\n      internal\n    });\n    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });\n    const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', { state });\n\n    const VK = {\n      BACKSPACE: 8,\n      DELETE: 46,\n      DOWN: 40,\n      ENTER: 13,\n      ESC: 27,\n      LEFT: 37,\n      RIGHT: 39,\n      SPACEBAR: 32,\n      TAB: 9,\n      UP: 38,\n      PAGE_UP: 33,\n      PAGE_DOWN: 34,\n      END: 35,\n      HOME: 36,\n      modifierPressed: e => {\n        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\n      },\n      metaKeyPressed: e => {\n        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n      }\n    };\n\n    const elementSelectionAttr = 'data-mce-selected';\n    const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';\n    const abs = Math.abs;\n    const round$1 = Math.round;\n    const resizeHandles = {\n      nw: [\n        0,\n        0,\n        -1,\n        -1\n      ],\n      ne: [\n        1,\n        0,\n        1,\n        -1\n      ],\n      se: [\n        1,\n        1,\n        1,\n        1\n      ],\n      sw: [\n        0,\n        1,\n        -1,\n        1\n      ]\n    };\n    const isTouchEvent = evt => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;\n    const ControlSelection = (selection, editor) => {\n      const dom = editor.dom;\n      const editableDoc = editor.getDoc();\n      const rootDocument = document;\n      const rootElement = editor.getBody();\n      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\n      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\n      let width;\n      let height;\n      let startScrollWidth;\n      let startScrollHeight;\n      const isImage = elm => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));\n      const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\n      const isEventOnImageOutsideRange = (evt, range) => {\n        if (isTouchEvent(evt)) {\n          const touch = evt.touches[0];\n          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\n        } else {\n          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\n        }\n      };\n      const contextMenuSelectImage = evt => {\n        const target = evt.target;\n        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\n          editor.selection.select(target);\n        }\n      };\n      const getResizeTargets = elm => {\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return [\n            elm,\n            elm.firstElementChild\n          ];\n        } else if (dom.is(elm, 'figure.image')) {\n          return [elm.querySelector('img')];\n        } else {\n          return [elm];\n        }\n      };\n      const isResizable = elm => {\n        const selector = getObjectResizing(editor);\n        if (!selector) {\n          return false;\n        }\n        if (elm.getAttribute('data-mce-resize') === 'false') {\n          return false;\n        }\n        if (elm === editor.getBody()) {\n          return false;\n        }\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\n          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\n        } else {\n          return is$1(SugarElement.fromDom(elm), selector);\n        }\n      };\n      const createGhostElement = elm => {\n        if (isMedia(elm)) {\n          return dom.create('img', { src: Env.transparentSrc });\n        } else {\n          return elm.cloneNode(true);\n        }\n      };\n      const setSizeProp = (element, name, value) => {\n        if (isNonNullable(value)) {\n          const targets = getResizeTargets(element);\n          each$e(targets, target => {\n            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\n              dom.setStyle(target, name, value);\n            } else {\n              dom.setAttrib(target, name, '' + value);\n            }\n          });\n        }\n      };\n      const setGhostElmSize = (ghostElm, width, height) => {\n        setSizeProp(ghostElm, 'width', width);\n        setSizeProp(ghostElm, 'height', height);\n      };\n      const resizeGhostElement = e => {\n        let deltaX, deltaY, proportional;\n        let resizeHelperX, resizeHelperY;\n        deltaX = e.screenX - startX;\n        deltaY = e.screenY - startY;\n        width = deltaX * selectedHandle[2] + startW;\n        height = deltaY * selectedHandle[3] + startH;\n        width = width < 5 ? 5 : width;\n        height = height < 5 ? 5 : height;\n        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\n          proportional = !VK.modifierPressed(e);\n        } else {\n          proportional = VK.modifierPressed(e);\n        }\n        if (proportional) {\n          if (abs(deltaX) > abs(deltaY)) {\n            height = round$1(width * ratio);\n            width = round$1(height / ratio);\n          } else {\n            width = round$1(height / ratio);\n            height = round$1(width * ratio);\n          }\n        }\n        setGhostElmSize(selectedElmGhost, width, height);\n        resizeHelperX = selectedHandle.startPos.x + deltaX;\n        resizeHelperY = selectedHandle.startPos.y + deltaY;\n        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\n        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\n        dom.setStyles(resizeHelper, {\n          left: resizeHelperX,\n          top: resizeHelperY,\n          display: 'block'\n        });\n        resizeHelper.innerHTML = width + ' &times; ' + height;\n        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\n          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\n        }\n        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\n          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\n        }\n        deltaX = rootElement.scrollWidth - startScrollWidth;\n        deltaY = rootElement.scrollHeight - startScrollHeight;\n        if (deltaX + deltaY !== 0) {\n          dom.setStyles(resizeHelper, {\n            left: resizeHelperX - deltaX,\n            top: resizeHelperY - deltaY\n          });\n        }\n        if (!resizeStarted) {\n          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\n          resizeStarted = true;\n        }\n      };\n      const endGhostResize = () => {\n        const wasResizeStarted = resizeStarted;\n        resizeStarted = false;\n        if (wasResizeStarted) {\n          setSizeProp(selectedElm, 'width', width);\n          setSizeProp(selectedElm, 'height', height);\n        }\n        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\n        dom.unbind(editableDoc, 'mouseup', endGhostResize);\n        if (rootDocument !== editableDoc) {\n          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\n          dom.unbind(rootDocument, 'mouseup', endGhostResize);\n        }\n        dom.remove(selectedElmGhost);\n        dom.remove(resizeHelper);\n        dom.remove(resizeBackdrop);\n        showResizeRect(selectedElm);\n        if (wasResizeStarted) {\n          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\n          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\n        }\n        editor.nodeChanged();\n      };\n      const showResizeRect = targetElm => {\n        unbindResizeHandleEvents();\n        const position = dom.getPos(targetElm, rootElement);\n        const selectedElmX = position.x;\n        const selectedElmY = position.y;\n        const rect = targetElm.getBoundingClientRect();\n        const targetWidth = rect.width || rect.right - rect.left;\n        const targetHeight = rect.height || rect.bottom - rect.top;\n        if (selectedElm !== targetElm) {\n          hideResizeRect();\n          selectedElm = targetElm;\n          width = height = 0;\n        }\n        const e = editor.dispatch('ObjectSelected', { target: targetElm });\n        if (isResizable(targetElm) && !e.isDefaultPrevented()) {\n          each$d(resizeHandles, (handle, name) => {\n            const startDrag = e => {\n              const target = getResizeTargets(selectedElm)[0];\n              startX = e.screenX;\n              startY = e.screenY;\n              startW = target.clientWidth;\n              startH = target.clientHeight;\n              ratio = startH / startW;\n              selectedHandle = handle;\n              selectedHandle.name = name;\n              selectedHandle.startPos = {\n                x: targetWidth * handle[0] + selectedElmX,\n                y: targetHeight * handle[1] + selectedElmY\n              };\n              startScrollWidth = rootElement.scrollWidth;\n              startScrollHeight = rootElement.scrollHeight;\n              resizeBackdrop = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-backdrop',\n                'data-mce-bogus': 'all'\n              });\n              dom.setStyles(resizeBackdrop, {\n                position: 'fixed',\n                left: '0',\n                top: '0',\n                width: '100%',\n                height: '100%'\n              });\n              selectedElmGhost = createGhostElement(selectedElm);\n              dom.addClass(selectedElmGhost, 'mce-clonedresizable');\n              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\n              selectedElmGhost.contentEditable = 'false';\n              dom.setStyles(selectedElmGhost, {\n                left: selectedElmX,\n                top: selectedElmY,\n                margin: 0\n              });\n              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\n              selectedElmGhost.removeAttribute(elementSelectionAttr);\n              rootElement.appendChild(selectedElmGhost);\n              dom.bind(editableDoc, 'mousemove', resizeGhostElement);\n              dom.bind(editableDoc, 'mouseup', endGhostResize);\n              if (rootDocument !== editableDoc) {\n                dom.bind(rootDocument, 'mousemove', resizeGhostElement);\n                dom.bind(rootDocument, 'mouseup', endGhostResize);\n              }\n              resizeHelper = dom.add(rootElement, 'div', {\n                'class': 'mce-resize-helper',\n                'data-mce-bogus': 'all'\n              }, startW + ' &times; ' + startH);\n            };\n            let handleElm = dom.get('mceResizeHandle' + name);\n            if (handleElm) {\n              dom.remove(handleElm);\n            }\n            handleElm = dom.add(rootElement, 'div', {\n              'id': 'mceResizeHandle' + name,\n              'data-mce-bogus': 'all',\n              'class': 'mce-resizehandle',\n              'unselectable': true,\n              'style': 'cursor:' + name + '-resize; margin:0; padding:0'\n            });\n            dom.bind(handleElm, 'mousedown', e => {\n              e.stopImmediatePropagation();\n              e.preventDefault();\n              startDrag(e);\n            });\n            handle.elm = handleElm;\n            dom.setStyles(handleElm, {\n              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\n              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\n            });\n          });\n        } else {\n          hideResizeRect(false);\n        }\n      };\n      const throttledShowResizeRect = first$1(showResizeRect, 0);\n      const hideResizeRect = (removeSelected = true) => {\n        throttledShowResizeRect.cancel();\n        unbindResizeHandleEvents();\n        if (selectedElm && removeSelected) {\n          selectedElm.removeAttribute(elementSelectionAttr);\n        }\n        each$d(resizeHandles, (value, name) => {\n          const handleElm = dom.get('mceResizeHandle' + name);\n          if (handleElm) {\n            dom.unbind(handleElm);\n            dom.remove(handleElm);\n          }\n        });\n      };\n      const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);\n      const updateResizeRect = e => {\n        if (resizeStarted || editor.removed || editor.composing) {\n          return;\n        }\n        const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();\n        const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map(e => e.dom).filter(e => dom.isEditable(e.parentElement) || e.nodeName === 'IMG' && dom.isEditable(e)).getOrUndefined();\n        const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';\n        each$e(dom.select(`img[${ elementSelectionAttr }],hr[${ elementSelectionAttr }]`), img => {\n          img.removeAttribute(elementSelectionAttr);\n        });\n        if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {\n          disableGeckoResize();\n          const startElm = selection.getStart(true);\n          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\n            dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);\n            throttledShowResizeRect.throttle(controlElm);\n            return;\n          }\n        }\n        hideResizeRect();\n      };\n      const unbindResizeHandleEvents = () => {\n        each$d(resizeHandles, handle => {\n          if (handle.elm) {\n            dom.unbind(handle.elm);\n            delete handle.elm;\n          }\n        });\n      };\n      const disableGeckoResize = () => {\n        try {\n          editor.getDoc().execCommand('enableObjectResizing', false, 'false');\n        } catch (ex) {\n        }\n      };\n      editor.on('init', () => {\n        disableGeckoResize();\n        editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);\n        editor.on('keyup compositionend', e => {\n          if (selectedElm && selectedElm.nodeName === 'TABLE') {\n            updateResizeRect(e);\n          }\n        });\n        editor.on('hide blur', hideResizeRect);\n        editor.on('contextmenu longpress', contextMenuSelectImage, true);\n      });\n      editor.on('remove', unbindResizeHandleEvents);\n      const destroy = () => {\n        throttledShowResizeRect.cancel();\n        selectedElm = selectedElmGhost = resizeBackdrop = null;\n      };\n      return {\n        isResizable,\n        showResizeRect,\n        hideResizeRect,\n        updateResizeRect,\n        destroy\n      };\n    };\n\n    const setStart = (rng, situ) => {\n      situ.fold(e => {\n        rng.setStartBefore(e.dom);\n      }, (e, o) => {\n        rng.setStart(e.dom, o);\n      }, e => {\n        rng.setStartAfter(e.dom);\n      });\n    };\n    const setFinish = (rng, situ) => {\n      situ.fold(e => {\n        rng.setEndBefore(e.dom);\n      }, (e, o) => {\n        rng.setEnd(e.dom, o);\n      }, e => {\n        rng.setEndAfter(e.dom);\n      });\n    };\n    const relativeToNative = (win, startSitu, finishSitu) => {\n      const range = win.document.createRange();\n      setStart(range, startSitu);\n      setFinish(range, finishSitu);\n      return range;\n    };\n    const exactToNative = (win, start, soffset, finish, foffset) => {\n      const rng = win.document.createRange();\n      rng.setStart(start.dom, soffset);\n      rng.setEnd(finish.dom, foffset);\n      return rng;\n    };\n\n    const adt$3 = Adt.generate([\n      {\n        ltr: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      },\n      {\n        rtl: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\n    const getRanges = (win, selection) => selection.match({\n      domRange: rng => {\n        return {\n          ltr: constant(rng),\n          rtl: Optional.none\n        };\n      },\n      relative: (startSitu, finishSitu) => {\n        return {\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\n        };\n      },\n      exact: (start, soffset, finish, foffset) => {\n        return {\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\n        };\n      }\n    });\n    const doDiagnose = (win, ranges) => {\n      const rng = ranges.ltr();\n      if (rng.collapsed) {\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\n      } else {\n        return fromRange(win, adt$3.ltr, rng);\n      }\n    };\n    const diagnose = (win, selection) => {\n      const ranges = getRanges(win, selection);\n      return doDiagnose(win, ranges);\n    };\n    adt$3.ltr;\n    adt$3.rtl;\n\n    const create$a = (start, soffset, finish, foffset) => ({\n      start,\n      soffset,\n      finish,\n      foffset\n    });\n    const SimRange = { create: create$a };\n\n    const caretPositionFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\n        if (pos.offsetNode === null) {\n          return Optional.none();\n        }\n        const r = doc.dom.createRange();\n        r.setStart(pos.offsetNode, pos.offset);\n        r.collapse();\n        return Optional.some(r);\n      });\n    };\n    const caretRangeFromPoint = (doc, x, y) => {\n      var _a, _b;\n      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\n    };\n    const availableSearch = (() => {\n      if (document.caretPositionFromPoint) {\n        return caretPositionFromPoint;\n      } else if (document.caretRangeFromPoint) {\n        return caretRangeFromPoint;\n      } else {\n        return Optional.none;\n      }\n    })();\n    const fromPoint$1 = (win, x, y) => {\n      const doc = SugarElement.fromDom(win.document);\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\n    };\n\n    const adt$2 = Adt.generate([\n      { before: ['element'] },\n      {\n        on: [\n          'element',\n          'offset'\n        ]\n      },\n      { after: ['element'] }\n    ]);\n    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\n    const getStart$2 = situ => situ.fold(identity, identity, identity);\n    const before$1 = adt$2.before;\n    const on = adt$2.on;\n    const after$1 = adt$2.after;\n    const Situ = {\n      before: before$1,\n      on,\n      after: after$1,\n      cata,\n      getStart: getStart$2\n    };\n\n    const adt$1 = Adt.generate([\n      { domRange: ['rng'] },\n      {\n        relative: [\n          'startSitu',\n          'finishSitu'\n        ]\n      },\n      {\n        exact: [\n          'start',\n          'soffset',\n          'finish',\n          'foffset'\n        ]\n      }\n    ]);\n    const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\n    const getStart$1 = selection => selection.match({\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\n      exact: (start, _soffset, _finish, _foffset) => start\n    });\n    const domRange = adt$1.domRange;\n    const relative = adt$1.relative;\n    const exact = adt$1.exact;\n    const getWin = selection => {\n      const start = getStart$1(selection);\n      return defaultView(start);\n    };\n    const range = SimRange.create;\n    const SimSelection = {\n      domRange,\n      relative,\n      exact,\n      exactFromRange,\n      getWin,\n      range\n    };\n\n    const beforeSpecial = (element, offset) => {\n      const name$1 = name(element);\n      if ('input' === name$1) {\n        return Situ.after(element);\n      } else if (!contains$2([\n          'br',\n          'img'\n        ], name$1)) {\n        return Situ.on(element, offset);\n      } else {\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\n      }\n    };\n    const preprocessRelative = (startSitu, finishSitu) => {\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\n      return SimSelection.relative(start, finish);\n    };\n    const preprocessExact = (start, soffset, finish, foffset) => {\n      const startSitu = beforeSpecial(start, soffset);\n      const finishSitu = beforeSpecial(finish, foffset);\n      return SimSelection.relative(startSitu, finishSitu);\n    };\n    const preprocess = selection => selection.match({\n      domRange: rng => {\n        const start = SugarElement.fromDom(rng.startContainer);\n        const finish = SugarElement.fromDom(rng.endContainer);\n        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\n      },\n      relative: preprocessRelative,\n      exact: preprocessExact\n    });\n\n    const fromElements = (elements, scope) => {\n      const doc = scope || document;\n      const fragment = doc.createDocumentFragment();\n      each$e(elements, element => {\n        fragment.appendChild(element.dom);\n      });\n      return SugarElement.fromDom(fragment);\n    };\n\n    const toNative = selection => {\n      const win = SimSelection.getWin(selection).dom;\n      const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\n      const filtered = preprocess(selection);\n      return diagnose(win, filtered).match({\n        ltr: getDomRange,\n        rtl: getDomRange\n      });\n    };\n    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\n\n    const fromPoint = (clientX, clientY, doc) => {\n      const win = defaultView(SugarElement.fromDom(doc));\n      return getAtPoint(win.dom, clientX, clientY).map(simRange => {\n        const rng = doc.createRange();\n        rng.setStart(simRange.start.dom, simRange.soffset);\n        rng.setEnd(simRange.finish.dom, simRange.foffset);\n        return rng;\n      }).getOrUndefined();\n    };\n\n    const isEq$4 = (rng1, rng2) => {\n      return isNonNullable(rng1) && isNonNullable(rng2) && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);\n    };\n\n    const findParent = (node, rootNode, predicate) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== rootNode) {\n        if (predicate(currentNode)) {\n          return currentNode;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return null;\n    };\n    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\n    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => node.nodeName === name);\n    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);\n    const hasBrBeforeAfter = (dom, node, left) => {\n      const parentNode = node.parentNode;\n      if (parentNode) {\n        const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());\n        let currentNode;\n        while (currentNode = walker[left ? 'prev' : 'next']()) {\n          if (isBr$6(currentNode)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const isPrevNode = (node, name) => {\n      var _a;\n      return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name;\n    };\n    const hasContentEditableFalseParent = (root, node) => {\n      let currentNode = node;\n      while (currentNode && currentNode !== root) {\n        if (isContentEditableFalse$b(currentNode)) {\n          return true;\n        }\n        currentNode = currentNode.parentNode;\n      }\n      return false;\n    };\n    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\n      const body = dom.getRoot();\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      const parentNode = startNode.parentNode;\n      let lastInlineElement;\n      let node;\n      if (!parentNode) {\n        return Optional.none();\n      }\n      const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;\n      if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\n        return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));\n      }\n      const walker = new DomTreeWalker(startNode, parentBlockContainer);\n      while (node = walker[left ? 'prev' : 'next']()) {\n        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\n          return Optional.none();\n        }\n        if (isText$a(node) && node.data.length > 0) {\n          if (!hasParentWithName(node, body, 'A')) {\n            return Optional.some(CaretPosition(node, left ? node.data.length : 0));\n          }\n          return Optional.none();\n        }\n        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\n          return Optional.none();\n        }\n        lastInlineElement = node;\n      }\n      if (isComment(lastInlineElement)) {\n        return Optional.none();\n      }\n      if (collapsed && lastInlineElement) {\n        return Optional.some(CaretPosition(lastInlineElement, 0));\n      }\n      return Optional.none();\n    };\n    const normalizeEndPoint = (dom, collapsed, start, rng) => {\n      const body = dom.getRoot();\n      let node;\n      let normalized = false;\n      let container = start ? rng.startContainer : rng.endContainer;\n      let offset = start ? rng.startOffset : rng.endOffset;\n      const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\n      let directionLeft = start;\n      if (isCaretContainer$2(container)) {\n        return Optional.none();\n      }\n      if (isElement$6(container) && offset > container.childNodes.length - 1) {\n        directionLeft = false;\n      }\n      if (isDocument$1(container)) {\n        container = body;\n        offset = 0;\n      }\n      if (container === body) {\n        if (directionLeft) {\n          node = container.childNodes[offset > 0 ? offset - 1 : 0];\n          if (node) {\n            if (isCaretContainer$2(node)) {\n              return Optional.none();\n            }\n            if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {\n              return Optional.none();\n            }\n          }\n        }\n        if (container.hasChildNodes()) {\n          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\n          container = container.childNodes[offset];\n          offset = isText$a(container) && isAfterNode ? container.data.length : 0;\n          if (!collapsed && container === body.lastChild && isTable$2(container)) {\n            return Optional.none();\n          }\n          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {\n            return Optional.none();\n          }\n          if (isDetails(container)) {\n            return Optional.none();\n          }\n          if (container.hasChildNodes() && !isTable$2(container)) {\n            node = container;\n            const walker = new DomTreeWalker(container, body);\n            do {\n              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {\n                normalized = false;\n                break;\n              }\n              if (isText$a(node) && node.data.length > 0) {\n                offset = directionLeft ? 0 : node.data.length;\n                container = node;\n                normalized = true;\n                break;\n              }\n              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {\n                offset = dom.nodeIndex(node);\n                container = node.parentNode;\n                if (!directionLeft) {\n                  offset++;\n                }\n                normalized = true;\n                break;\n              }\n            } while (node = directionLeft ? walker.next() : walker.prev());\n          }\n        }\n      }\n      if (collapsed) {\n        if (isText$a(container) && offset === 0) {\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\n            container = pos.container();\n            offset = pos.offset();\n            normalized = true;\n          });\n        }\n        if (isElement$6(container)) {\n          node = container.childNodes[offset];\n          if (!node) {\n            node = container.childNodes[offset - 1];\n          }\n          if (node && isBr$6(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\n            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\n              container = pos.container();\n              offset = pos.offset();\n              normalized = true;\n            });\n          }\n        }\n      }\n      if (directionLeft && !collapsed && isText$a(container) && offset === container.data.length) {\n        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\n          container = pos.container();\n          offset = pos.offset();\n          normalized = true;\n        });\n      }\n      return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();\n    };\n    const normalize$2 = (dom, rng) => {\n      const collapsed = rng.collapsed, normRng = rng.cloneRange();\n      const startPos = CaretPosition.fromRangeStart(rng);\n      normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\n        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\n          normRng.setStart(pos.container(), pos.offset());\n        }\n      });\n      if (!collapsed) {\n        normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\n          normRng.setEnd(pos.container(), pos.offset());\n        });\n      }\n      if (collapsed) {\n        normRng.collapse(true);\n      }\n      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\n    };\n\n    const splitText = (node, offset) => {\n      return node.splitText(offset);\n    };\n    const split = rng => {\n      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;\n      if (startContainer === endContainer && isText$a(startContainer)) {\n        if (startOffset > 0 && startOffset < startContainer.data.length) {\n          endContainer = splitText(startContainer, startOffset);\n          startContainer = endContainer.previousSibling;\n          if (endOffset > startOffset) {\n            endOffset = endOffset - startOffset;\n            const newContainer = splitText(endContainer, endOffset).previousSibling;\n            startContainer = endContainer = newContainer;\n            endOffset = newContainer.data.length;\n            startOffset = 0;\n          } else {\n            endOffset = 0;\n          }\n        }\n      } else {\n        if (isText$a(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {\n          startContainer = splitText(startContainer, startOffset);\n          startOffset = 0;\n        }\n        if (isText$a(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {\n          const newContainer = splitText(endContainer, endOffset).previousSibling;\n          endContainer = newContainer;\n          endOffset = newContainer.data.length;\n        }\n      }\n      return {\n        startContainer,\n        startOffset,\n        endContainer,\n        endOffset\n      };\n    };\n\n    const RangeUtils = dom => {\n      const walk = (rng, callback) => {\n        return walk$3(dom, rng, callback);\n      };\n      const split$1 = split;\n      const normalize = rng => {\n        return normalize$2(dom, rng).fold(never, normalizedRng => {\n          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\n          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\n          return true;\n        });\n      };\n      const expand = (rng, options = { type: 'word' }) => {\n        if (options.type === 'word') {\n          const rangeLike = expandRng(dom, rng, [{ inline: 'span' }]);\n          const newRange = dom.createRng();\n          newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);\n          newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);\n          return newRange;\n        }\n        return rng;\n      };\n      return {\n        walk,\n        split: split$1,\n        expand,\n        normalize\n      };\n    };\n    RangeUtils.compareRanges = isEq$4;\n    RangeUtils.getCaretRangeFromPoint = fromPoint;\n    RangeUtils.getSelectedNode = getSelectedNode;\n    RangeUtils.getNode = getNode$1;\n\n    const Dimension = (name, getOffset) => {\n      const set = (element, h) => {\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\n        }\n        const dom = element.dom;\n        if (isSupported(dom)) {\n          dom.style[name] = h + 'px';\n        }\n      };\n      const get = element => {\n        const r = getOffset(element);\n        if (r <= 0 || r === null) {\n          const css = get$7(element, name);\n          return parseFloat(css) || 0;\n        }\n        return r;\n      };\n      const getOuter = get;\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\n        const val = get$7(element, property);\n        const value = val === undefined ? 0 : parseInt(val, 10);\n        return isNaN(value) ? acc : acc + value;\n      }, 0);\n      const max = (element, value, properties) => {\n        const cumulativeInclusions = aggregate(element, properties);\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\n        return absoluteMax;\n      };\n      return {\n        set,\n        get,\n        getOuter,\n        aggregate,\n        max\n      };\n    };\n\n    const api = Dimension('height', element => {\n      const dom = element.dom;\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\n    });\n    const get$2 = element => api.get(element);\n\n    const getDocument = () => SugarElement.fromDom(document);\n\n    const walkUp = (navigation, doc) => {\n      const frame = navigation.view(doc);\n      return frame.fold(constant([]), f => {\n        const parent = navigation.owner(f);\n        const rest = walkUp(navigation, parent);\n        return [f].concat(rest);\n      });\n    };\n    const pathTo = (element, navigation) => {\n      const d = navigation.owner(element);\n      return walkUp(navigation, d);\n    };\n\n    const view = doc => {\n      var _a;\n      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\n      return element.map(SugarElement.fromDom);\n    };\n    const owner = element => documentOrOwner(element);\n\n    var Navigation = /*#__PURE__*/Object.freeze({\n        __proto__: null,\n        view: view,\n        owner: owner\n    });\n\n    const find = element => {\n      const doc = getDocument();\n      const scroll = get$5(doc);\n      const frames = pathTo(element, Navigation);\n      const offset = viewport(element);\n      const r = foldr(frames, (b, a) => {\n        const loc = viewport(a);\n        return {\n          left: b.left + loc.left,\n          top: b.top + loc.top\n        };\n      }, {\n        left: 0,\n        top: 0\n      });\n      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\n    };\n\n    const excludeFromDescend = element => name(element) === 'textarea';\n    const fireScrollIntoViewEvent = (editor, data) => {\n      const scrollEvent = editor.dispatch('ScrollIntoView', data);\n      return scrollEvent.isDefaultPrevented();\n    };\n    const fireAfterScrollIntoViewEvent = (editor, data) => {\n      editor.dispatch('AfterScrollIntoView', data);\n    };\n    const descend = (element, offset) => {\n      const children = children$1(element);\n      if (children.length === 0 || excludeFromDescend(element)) {\n        return {\n          element,\n          offset\n        };\n      } else if (offset < children.length && !excludeFromDescend(children[offset])) {\n        return {\n          element: children[offset],\n          offset: 0\n        };\n      } else {\n        const last = children[children.length - 1];\n        if (excludeFromDescend(last)) {\n          return {\n            element,\n            offset\n          };\n        } else {\n          if (name(last) === 'img') {\n            return {\n              element: last,\n              offset: 1\n            };\n          } else if (isText$b(last)) {\n            return {\n              element: last,\n              offset: get$3(last).length\n            };\n          } else {\n            return {\n              element: last,\n              offset: children$1(last).length\n            };\n          }\n        }\n      }\n    };\n    const markerInfo = (element, cleanupFun) => {\n      const pos = absolute(element);\n      const height = get$2(element);\n      return {\n        element,\n        bottom: pos.top + height,\n        height,\n        pos,\n        cleanup: cleanupFun\n      };\n    };\n    const createMarker$1 = (element, offset) => {\n      const startPoint = descend(element, offset);\n      const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\n      before$3(startPoint.element, span);\n      return markerInfo(span, () => remove$5(span));\n    };\n    const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\n    const withMarker = (editor, f, rng, alignToTop) => {\n      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\n    };\n    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\n      const data = {\n        elm: marker.element.dom,\n        alignToTop\n      };\n      if (fireScrollIntoViewEvent(editor, data)) {\n        return;\n      }\n      const scrollTop = get$5(doc).top;\n      f(editor, doc, scrollTop, marker, alignToTop);\n      fireAfterScrollIntoViewEvent(editor, data);\n    };\n    const applyWithMarker = (editor, f, rng, alignToTop) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const doc = SugarElement.fromDom(editor.getDoc());\n      reflow(body);\n      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\n      withScrollEvents(editor, doc, f, marker, alignToTop);\n      marker.cleanup();\n    };\n    const withElement = (editor, element, f, alignToTop) => {\n      const doc = SugarElement.fromDom(editor.getDoc());\n      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\n    };\n    const preserveWith = (editor, f, rng) => {\n      const startElement = rng.startContainer;\n      const startOffset = rng.startOffset;\n      const endElement = rng.endContainer;\n      const endOffset = rng.endOffset;\n      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\n      const newRng = editor.dom.createRng();\n      newRng.setStart(startElement, startOffset);\n      newRng.setEnd(endElement, endOffset);\n      editor.selection.setRng(rng);\n    };\n    const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {\n      const pos = marker.pos;\n      if (alignToTop) {\n        to(pos.left, pos.top, doc);\n      } else {\n        const y = pos.top - viewHeight + marker.height;\n        to(-editor.getBody().getBoundingClientRect().left, y, doc);\n      }\n    };\n    const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {\n      const viewportBottom = viewHeight + scrollTop;\n      const markerTop = marker.pos.top;\n      const markerBottom = marker.bottom;\n      const largerThanViewport = markerBottom - markerTop >= viewHeight;\n      if (markerTop < scrollTop) {\n        scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);\n      } else if (markerTop > viewportBottom) {\n        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\n        scrollToMarker(editor, marker, viewHeight, align, doc);\n      } else if (markerBottom > viewportBottom && !largerThanViewport) {\n        scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);\n      }\n    };\n    const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {\n      const viewHeight = defaultView(doc).dom.innerHeight;\n      intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);\n    };\n    const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {\n      const frameViewHeight = defaultView(doc).dom.innerHeight;\n      intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);\n      const op = find(marker.element);\n      const viewportBounds = getBounds(window);\n      if (op.top < viewportBounds.y) {\n        intoView(marker.element, alignToTop !== false);\n      } else if (op.top > viewportBounds.bottom) {\n        intoView(marker.element, alignToTop === true);\n      }\n    };\n    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\n    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\n    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\n    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\n    const scrollElementIntoView = (editor, element, alignToTop) => {\n      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\n      scroller(editor, element, alignToTop);\n    };\n    const scrollRangeIntoView = (editor, rng, alignToTop) => {\n      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\n      scroller(editor, rng, alignToTop);\n    };\n\n    const focus$1 = (element, preventScroll = false) => element.dom.focus({ preventScroll });\n    const hasFocus$1 = element => {\n      const root = getRootNode(element).dom;\n      return element.dom === root.activeElement;\n    };\n    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\n    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\n\n    const clamp$1 = (offset, element) => {\n      const max = isText$b(element) ? get$3(element).length : children$1(element).length + 1;\n      if (offset > max) {\n        return max;\n      } else if (offset < 0) {\n        return 0;\n      }\n      return offset;\n    };\n    const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\n    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\n    const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\n    const shouldStore = editor => editor.inline || Env.browser.isFirefox();\n    const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\n    const readRange = win => {\n      const selection = win.getSelection();\n      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\n      return rng.map(nativeRangeToSelectionRange);\n    };\n    const getBookmark = root => {\n      const win = defaultView(root);\n      return readRange(win.dom).filter(isRngInRoot(root));\n    };\n    const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\n    const bookmarkToNativeRng = bookmark => {\n      const rng = document.createRange();\n      try {\n        rng.setStart(bookmark.start.dom, bookmark.soffset);\n        rng.setEnd(bookmark.finish.dom, bookmark.foffset);\n        return Optional.some(rng);\n      } catch (_) {\n        return Optional.none();\n      }\n    };\n    const store = editor => {\n      const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();\n      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\n    };\n    const getRng = editor => {\n      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\n      return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\n    };\n    const restore = editor => {\n      getRng(editor).each(rng => editor.selection.setRng(rng));\n    };\n\n    const isEditorUIElement$1 = elm => {\n      const className = elm.className.toString();\n      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\n    };\n    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };\n\n    const wrappedSetTimeout = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setTimeout(callback, time);\n    };\n    const wrappedSetInterval = (callback, time) => {\n      if (!isNumber(time)) {\n        time = 0;\n      }\n      return setInterval(callback, time);\n    };\n    const Delay = {\n      setEditorTimeout: (editor, callback, time) => {\n        return wrappedSetTimeout(() => {\n          if (!editor.removed) {\n            callback();\n          }\n        }, time);\n      },\n      setEditorInterval: (editor, callback, time) => {\n        const timer = wrappedSetInterval(() => {\n          if (!editor.removed) {\n            callback();\n          } else {\n            clearInterval(timer);\n          }\n        }, time);\n        return timer;\n      }\n    };\n\n    const isManualNodeChange = e => {\n      return e.type === 'nodechange' && e.selectionChange;\n    };\n    const registerPageMouseUp = (editor, throttledStore) => {\n      const mouseUpPage = () => {\n        throttledStore.throttle();\n      };\n      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\n      editor.on('remove', () => {\n        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\n      });\n    };\n    const registerMouseUp = (editor, throttledStore) => {\n      editor.on('mouseup touchend', _e => {\n        throttledStore.throttle();\n      });\n    };\n    const registerEditorEvents = (editor, throttledStore) => {\n      registerMouseUp(editor, throttledStore);\n      editor.on('keyup NodeChange AfterSetSelectionRange', e => {\n        if (!isManualNodeChange(e)) {\n          store(editor);\n        }\n      });\n    };\n    const register$6 = editor => {\n      const throttledStore = first$1(() => {\n        store(editor);\n      }, 0);\n      editor.on('init', () => {\n        if (editor.inline) {\n          registerPageMouseUp(editor, throttledStore);\n        }\n        registerEditorEvents(editor, throttledStore);\n      });\n      editor.on('remove', () => {\n        throttledStore.cancel();\n      });\n    };\n\n    let documentFocusInHandler;\n    const DOM$9 = DOMUtils.DOM;\n    const isEditorUIElement = elm => {\n      return isElement$6(elm) && FocusManager.isEditorUIElement(elm);\n    };\n    const isEditorContentAreaElement = elm => {\n      const classList = elm.classList;\n      if (classList !== undefined) {\n        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\n      } else {\n        return false;\n      }\n    };\n    const isUIElement = (editor, elm) => {\n      const customSelector = getCustomUiSelector(editor);\n      const parent = DOM$9.getParent(elm, elm => {\n        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\n      });\n      return parent !== null;\n    };\n    const getActiveElement = editor => {\n      try {\n        const root = getRootNode(SugarElement.fromDom(editor.getElement()));\n        return active$1(root).fold(() => document.body, x => x.dom);\n      } catch (ex) {\n        return document.body;\n      }\n    };\n    const registerEvents$1 = (editorManager, e) => {\n      const editor = e.editor;\n      register$6(editor);\n      const toggleContentAreaOnFocus = (editor, fn) => {\n        if (shouldHighlightOnFocus(editor) && editor.inline !== true) {\n          const contentArea = SugarElement.fromDom(editor.getContainer());\n          fn(contentArea, 'tox-edit-focus');\n        }\n      };\n      editor.on('focusin', () => {\n        const focusedEditor = editorManager.focusedEditor;\n        if (isEditorContentAreaElement(getActiveElement(editor))) {\n          toggleContentAreaOnFocus(editor, add$2);\n        }\n        if (focusedEditor !== editor) {\n          if (focusedEditor) {\n            focusedEditor.dispatch('blur', { focusedEditor: editor });\n          }\n          editorManager.setActive(editor);\n          editorManager.focusedEditor = editor;\n          editor.dispatch('focus', { blurredEditor: focusedEditor });\n          editor.focus(true);\n        }\n      });\n      editor.on('focusout', () => {\n        Delay.setEditorTimeout(editor, () => {\n          const focusedEditor = editorManager.focusedEditor;\n          if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {\n            toggleContentAreaOnFocus(editor, remove$7);\n          }\n          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\n            editor.dispatch('blur', { focusedEditor: null });\n            editorManager.focusedEditor = null;\n          }\n        });\n      });\n      if (!documentFocusInHandler) {\n        documentFocusInHandler = e => {\n          const activeEditor = editorManager.activeEditor;\n          if (activeEditor) {\n            getOriginalEventTarget(e).each(target => {\n              const elem = target;\n              if (elem.ownerDocument === document) {\n                if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {\n                  activeEditor.dispatch('blur', { focusedEditor: null });\n                  editorManager.focusedEditor = null;\n                }\n              }\n            });\n          }\n        };\n        DOM$9.bind(document, 'focusin', documentFocusInHandler);\n      }\n    };\n    const unregisterDocumentEvents = (editorManager, e) => {\n      if (editorManager.focusedEditor === e.editor) {\n        editorManager.focusedEditor = null;\n      }\n      if (!editorManager.activeEditor && documentFocusInHandler) {\n        DOM$9.unbind(document, 'focusin', documentFocusInHandler);\n        documentFocusInHandler = null;\n      }\n    };\n    const setup$w = editorManager => {\n      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\n      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\n    };\n\n    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\n    const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\n    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\n      if (isTableSection(node)) {\n        return Optional.some(node);\n      } else if (!contains(root, node)) {\n        return Optional.some(root);\n      } else {\n        return Optional.none();\n      }\n    });\n    const normalizeSelection = (editor, rng) => {\n      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\n        return firstPositionIn(elm.dom);\n      }).fold(() => {\n        editor.selection.normalize();\n      }, caretPos => editor.selection.setRng(caretPos.toRange()));\n    };\n    const focusBody = body => {\n      if (body.setActive) {\n        try {\n          body.setActive();\n        } catch (ex) {\n          body.focus();\n        }\n      } else {\n        body.focus();\n      }\n    };\n    const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\n    const hasIframeFocus = editor => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\n    const hasInlineFocus = editor => {\n      const rawBody = editor.getBody();\n      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\n    };\n    const hasUiFocus = editor => {\n      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\n      return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\n    };\n    const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\n    const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\n    const focusEditor = editor => {\n      const selection = editor.selection;\n      const body = editor.getBody();\n      let rng = selection.getRng();\n      editor.quirks.refreshContentEditable();\n      if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n        getRng(editor).each(bookmarkRng => {\n          editor.selection.setRng(bookmarkRng);\n          rng = bookmarkRng;\n        });\n      }\n      const contentEditableHost = getContentEditableHost(editor, selection.getNode());\n      if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {\n        focusBody(contentEditableHost);\n        normalizeSelection(editor, rng);\n        activateEditor(editor);\n        return;\n      }\n      if (!editor.inline) {\n        if (!Env.browser.isOpera()) {\n          focusBody(body);\n        }\n        editor.getWin().focus();\n      }\n      if (Env.browser.isFirefox() || editor.inline) {\n        focusBody(body);\n        normalizeSelection(editor, rng);\n      }\n      activateEditor(editor);\n    };\n    const activateEditor = editor => editor.editorManager.setActive(editor);\n    const focus = (editor, skipFocus) => {\n      if (editor.removed) {\n        return;\n      }\n      if (skipFocus) {\n        activateEditor(editor);\n      } else {\n        focusEditor(editor);\n      }\n    };\n\n    const isEditableRange = (dom, rng) => {\n      if (rng.collapsed) {\n        return dom.isEditable(rng.startContainer);\n      } else {\n        return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);\n      }\n    };\n\n    const getEndpointElement = (root, rng, start, real, resolve) => {\n      const container = start ? rng.startContainer : rng.endContainer;\n      const offset = start ? rng.startOffset : rng.endOffset;\n      return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\n    };\n    const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\n    const getEnd$1 = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\n    const skipEmptyTextNodes = (node, forwards) => {\n      const orig = node;\n      while (node && isText$a(node) && node.length === 0) {\n        node = forwards ? node.nextSibling : node.previousSibling;\n      }\n      return node || orig;\n    };\n    const getNode = (root, rng) => {\n      if (!rng) {\n        return root;\n      }\n      let startContainer = rng.startContainer;\n      let endContainer = rng.endContainer;\n      const startOffset = rng.startOffset;\n      const endOffset = rng.endOffset;\n      let node = rng.commonAncestorContainer;\n      if (!rng.collapsed) {\n        if (startContainer === endContainer) {\n          if (endOffset - startOffset < 2) {\n            if (startContainer.hasChildNodes()) {\n              node = startContainer.childNodes[startOffset];\n            }\n          }\n        }\n        if (isText$a(startContainer) && isText$a(endContainer)) {\n          if (startContainer.length === startOffset) {\n            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\n          } else {\n            startContainer = startContainer.parentNode;\n          }\n          if (endOffset === 0) {\n            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\n          } else {\n            endContainer = endContainer.parentNode;\n          }\n          if (startContainer && startContainer === endContainer) {\n            node = startContainer;\n          }\n        }\n      }\n      const elm = isText$a(node) ? node.parentNode : node;\n      return isHTMLElement(elm) ? elm : root;\n    };\n    const getSelectedBlocks = (dom, rng, startElm, endElm) => {\n      const selectedBlocks = [];\n      const root = dom.getRoot();\n      const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\n      const end = dom.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom.isBlock);\n      if (start && start !== root) {\n        selectedBlocks.push(start);\n      }\n      if (start && end && start !== end) {\n        let node;\n        const walker = new DomTreeWalker(start, root);\n        while ((node = walker.next()) && node !== end) {\n          if (dom.isBlock(node)) {\n            selectedBlocks.push(node);\n          }\n        }\n      }\n      if (end && start !== end && end !== root) {\n        selectedBlocks.push(end);\n      }\n      return selectedBlocks;\n    };\n    const select = (dom, node, content) => Optional.from(node).bind(node => Optional.from(node.parentNode).map(parent => {\n      const idx = dom.nodeIndex(node);\n      const rng = dom.createRng();\n      rng.setStart(parent, idx);\n      rng.setEnd(parent, idx + 1);\n      if (content) {\n        moveEndPoint(dom, rng, node, true);\n        moveEndPoint(dom, rng, node, false);\n      }\n      return rng;\n    }));\n\n    const processRanges = (editor, ranges) => map$3(ranges, range => {\n      const evt = editor.dispatch('GetSelectionRange', { range });\n      return evt.range !== range ? evt.range : range;\n    });\n\n    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children$1(element).length, v => v.length);\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\n    const isContentEditableFalse$5 = elem => isHTMLElement$1(elem) && get$9(elem, 'contenteditable') === 'false';\n    const elementsWithCursorPosition = [\n      'img',\n      'br'\n    ];\n    const isCursorPosition = elem => {\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$5(elem);\n    };\n\n    const first = element => descendant$2(element, isCursorPosition);\n    const last = element => descendantRtl(element, isCursorPosition);\n    const descendantRtl = (scope, predicate) => {\n      const descend = element => {\n        const children = children$1(element);\n        for (let i = children.length - 1; i >= 0; i--) {\n          const child = children[i];\n          if (predicate(child)) {\n            return Optional.some(child);\n          }\n          const res = descend(child);\n          if (res.isSome()) {\n            return res;\n          }\n        }\n        return Optional.none();\n      };\n      return descend(scope);\n    };\n\n    const autocompleteSelector = '[data-mce-autocompleter]';\n    const create$9 = (editor, range) => {\n      if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {\n        const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter=\"1\" data-mce-bogus=\"1\"></span>', editor.getDoc());\n        append$1(wrapper, SugarElement.fromDom(range.extractContents()));\n        range.insertNode(wrapper.dom);\n        parent(wrapper).each(elm => elm.dom.normalize());\n        last(wrapper).map(last => {\n          editor.selection.setCursorLocation(last.dom, getEnd(last));\n        });\n      }\n    };\n    const detect$1 = elm => closest$3(elm, autocompleteSelector);\n    const findIn = elm => descendant$1(elm, autocompleteSelector);\n    const remove$2 = (editor, elm) => findIn(elm).each(wrapper => {\n      const bookmark = editor.selection.getBookmark();\n      unwrap(wrapper);\n      editor.selection.moveToBookmark(bookmark);\n    });\n\n    const typeLookup = {\n      '#text': 3,\n      '#comment': 8,\n      '#cdata': 4,\n      '#pi': 7,\n      '#doctype': 10,\n      '#document-fragment': 11\n    };\n    const walk$2 = (node, root, prev) => {\n      const startName = prev ? 'lastChild' : 'firstChild';\n      const siblingName = prev ? 'prev' : 'next';\n      if (node[startName]) {\n        return node[startName];\n      }\n      if (node !== root) {\n        let sibling = node[siblingName];\n        if (sibling) {\n          return sibling;\n        }\n        for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\n          sibling = parent[siblingName];\n          if (sibling) {\n            return sibling;\n          }\n        }\n      }\n      return undefined;\n    };\n    const isEmptyTextNode = node => {\n      var _a;\n      const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n      if (!isWhitespaceText(text)) {\n        return false;\n      }\n      const parentNode = node.parent;\n      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {\n        return false;\n      }\n      return true;\n    };\n    const isNonEmptyElement = node => {\n      const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\n      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\n    };\n    class AstNode {\n      static create(name, attrs) {\n        const node = new AstNode(name, typeLookup[name] || 1);\n        if (attrs) {\n          each$d(attrs, (value, attrName) => {\n            node.attr(attrName, value);\n          });\n        }\n        return node;\n      }\n      constructor(name, type) {\n        this.name = name;\n        this.type = type;\n        if (type === 1) {\n          this.attributes = [];\n          this.attributes.map = {};\n        }\n      }\n      replace(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        self.insert(node, self);\n        self.remove();\n        return self;\n      }\n      attr(name, value) {\n        const self = this;\n        if (!isString(name)) {\n          if (isNonNullable(name)) {\n            each$d(name, (value, key) => {\n              self.attr(key, value);\n            });\n          }\n          return self;\n        }\n        const attrs = self.attributes;\n        if (attrs) {\n          if (value !== undefined) {\n            if (value === null) {\n              if (name in attrs.map) {\n                delete attrs.map[name];\n                let i = attrs.length;\n                while (i--) {\n                  if (attrs[i].name === name) {\n                    attrs.splice(i, 1);\n                    return self;\n                  }\n                }\n              }\n              return self;\n            }\n            if (name in attrs.map) {\n              let i = attrs.length;\n              while (i--) {\n                if (attrs[i].name === name) {\n                  attrs[i].value = value;\n                  break;\n                }\n              }\n            } else {\n              attrs.push({\n                name,\n                value\n              });\n            }\n            attrs.map[name] = value;\n            return self;\n          }\n          return attrs.map[name];\n        }\n        return undefined;\n      }\n      clone() {\n        const self = this;\n        const clone = new AstNode(self.name, self.type);\n        const selfAttrs = self.attributes;\n        if (selfAttrs) {\n          const cloneAttrs = [];\n          cloneAttrs.map = {};\n          for (let i = 0, l = selfAttrs.length; i < l; i++) {\n            const selfAttr = selfAttrs[i];\n            if (selfAttr.name !== 'id') {\n              cloneAttrs[cloneAttrs.length] = {\n                name: selfAttr.name,\n                value: selfAttr.value\n              };\n              cloneAttrs.map[selfAttr.name] = selfAttr.value;\n            }\n          }\n          clone.attributes = cloneAttrs;\n        }\n        clone.value = self.value;\n        return clone;\n      }\n      wrap(wrapper) {\n        const self = this;\n        if (self.parent) {\n          self.parent.insert(wrapper, self);\n          wrapper.append(self);\n        }\n        return self;\n      }\n      unwrap() {\n        const self = this;\n        for (let node = self.firstChild; node;) {\n          const next = node.next;\n          self.insert(node, self, true);\n          node = next;\n        }\n        self.remove();\n      }\n      remove() {\n        const self = this, parent = self.parent, next = self.next, prev = self.prev;\n        if (parent) {\n          if (parent.firstChild === self) {\n            parent.firstChild = next;\n            if (next) {\n              next.prev = null;\n            }\n          } else if (prev) {\n            prev.next = next;\n          }\n          if (parent.lastChild === self) {\n            parent.lastChild = prev;\n            if (prev) {\n              prev.next = null;\n            }\n          } else if (next) {\n            next.prev = prev;\n          }\n          self.parent = self.next = self.prev = null;\n        }\n        return self;\n      }\n      append(node) {\n        const self = this;\n        if (node.parent) {\n          node.remove();\n        }\n        const last = self.lastChild;\n        if (last) {\n          last.next = node;\n          node.prev = last;\n          self.lastChild = node;\n        } else {\n          self.lastChild = self.firstChild = node;\n        }\n        node.parent = self;\n        return node;\n      }\n      insert(node, refNode, before) {\n        if (node.parent) {\n          node.remove();\n        }\n        const parent = refNode.parent || this;\n        if (before) {\n          if (refNode === parent.firstChild) {\n            parent.firstChild = node;\n          } else if (refNode.prev) {\n            refNode.prev.next = node;\n          }\n          node.prev = refNode.prev;\n          node.next = refNode;\n          refNode.prev = node;\n        } else {\n          if (refNode === parent.lastChild) {\n            parent.lastChild = node;\n          } else if (refNode.next) {\n            refNode.next.prev = node;\n          }\n          node.next = refNode.next;\n          node.prev = refNode;\n          refNode.next = node;\n        }\n        node.parent = parent;\n        return node;\n      }\n      getAll(name) {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\n          if (node.name === name) {\n            collection.push(node);\n          }\n        }\n        return collection;\n      }\n      children() {\n        const self = this;\n        const collection = [];\n        for (let node = self.firstChild; node; node = node.next) {\n          collection.push(node);\n        }\n        return collection;\n      }\n      empty() {\n        const self = this;\n        if (self.firstChild) {\n          const nodes = [];\n          for (let node = self.firstChild; node; node = walk$2(node, self)) {\n            nodes.push(node);\n          }\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\n          }\n        }\n        self.firstChild = self.lastChild = null;\n        return self;\n      }\n      isEmpty(elements, whitespace = {}, predicate) {\n        var _a;\n        const self = this;\n        let node = self.firstChild;\n        if (isNonEmptyElement(self)) {\n          return false;\n        }\n        if (node) {\n          do {\n            if (node.type === 1) {\n              if (node.attr('data-mce-bogus')) {\n                continue;\n              }\n              if (elements[node.name]) {\n                return false;\n              }\n              if (isNonEmptyElement(node)) {\n                return false;\n              }\n            }\n            if (node.type === 8) {\n              return false;\n            }\n            if (node.type === 3 && !isEmptyTextNode(node)) {\n              return false;\n            }\n            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {\n              return false;\n            }\n            if (predicate && predicate(node)) {\n              return false;\n            }\n          } while (node = walk$2(node, self));\n        }\n        return true;\n      }\n      walk(prev) {\n        return walk$2(this, null, prev);\n      }\n    }\n\n    const unescapedTextParents = Tools.makeMap('NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT', ' ');\n    const containsZwsp = node => isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);\n    const getTemporaryNodeSelector = tempAttrs => `${ tempAttrs.length === 0 ? '' : `${ map$3(tempAttrs, attr => `[${ attr }]`).join(',') },` }[data-mce-bogus=\"all\"]`;\n    const getTemporaryNodes = (tempAttrs, body) => body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));\n    const createZwspCommentWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, node => containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\n    const createUnescapedZwspTextWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_TEXT, node => {\n      if (containsZwsp(node)) {\n        const parent = node.parentNode;\n        return parent && has$2(unescapedTextParents, parent.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n      } else {\n        return NodeFilter.FILTER_SKIP;\n      }\n    });\n    const hasZwspComment = body => createZwspCommentWalker(body).nextNode() !== null;\n    const hasUnescapedZwspText = body => createUnescapedZwspTextWalker(body).nextNode() !== null;\n    const hasTemporaryNode = (tempAttrs, body) => body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;\n    const trimTemporaryNodes = (tempAttrs, body) => {\n      each$e(getTemporaryNodes(tempAttrs, body), elm => {\n        const element = SugarElement.fromDom(elm);\n        if (get$9(element, 'data-mce-bogus') === 'all') {\n          remove$5(element);\n        } else {\n          each$e(tempAttrs, attr => {\n            if (has$1(element, attr)) {\n              remove$a(element, attr);\n            }\n          });\n        }\n      });\n    };\n    const emptyAllNodeValuesInWalker = walker => {\n      let curr = walker.nextNode();\n      while (curr !== null) {\n        curr.nodeValue = null;\n        curr = walker.nextNode();\n      }\n    };\n    const emptyZwspComments = compose(emptyAllNodeValuesInWalker, createZwspCommentWalker);\n    const emptyUnescapedZwspTexts = compose(emptyAllNodeValuesInWalker, createUnescapedZwspTextWalker);\n    const trim$1 = (body, tempAttrs) => {\n      const conditionalTrims = [\n        {\n          condition: curry(hasTemporaryNode, tempAttrs),\n          action: curry(trimTemporaryNodes, tempAttrs)\n        },\n        {\n          condition: hasZwspComment,\n          action: emptyZwspComments\n        },\n        {\n          condition: hasUnescapedZwspText,\n          action: emptyUnescapedZwspTexts\n        }\n      ];\n      let trimmed = body;\n      let cloned = false;\n      each$e(conditionalTrims, ({condition, action}) => {\n        if (condition(trimmed)) {\n          if (!cloned) {\n            trimmed = body.cloneNode(true);\n            cloned = true;\n          }\n          action(trimmed);\n        }\n      });\n      return trimmed;\n    };\n\n    const cleanupBogusElements = parent => {\n      const bogusElements = descendants(parent, '[data-mce-bogus]');\n      each$e(bogusElements, elem => {\n        const bogusValue = get$9(elem, 'data-mce-bogus');\n        if (bogusValue === 'all') {\n          remove$5(elem);\n        } else if (isBr$5(elem)) {\n          before$3(elem, SugarElement.fromText(zeroWidth));\n          remove$5(elem);\n        } else {\n          unwrap(elem);\n        }\n      });\n    };\n    const cleanupInputNames = parent => {\n      const inputs = descendants(parent, 'input');\n      each$e(inputs, input => {\n        remove$a(input, 'name');\n      });\n    };\n\n    const trimEmptyContents = (editor, html) => {\n      const blockName = getForcedRootBlock(editor);\n      const emptyRegExp = new RegExp(`^(<${ blockName }[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${ blockName }>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\n      return html.replace(emptyRegExp, '');\n    };\n    const getPlainTextContent = (editor, body) => {\n      const doc = editor.getDoc();\n      const dos = getRootNode(SugarElement.fromDom(editor.getBody()));\n      const offscreenDiv = SugarElement.fromTag('div', doc);\n      set$3(offscreenDiv, 'data-mce-bogus', 'all');\n      setAll(offscreenDiv, {\n        position: 'fixed',\n        left: '-9999999px',\n        top: '0'\n      });\n      set$1(offscreenDiv, body.innerHTML);\n      cleanupBogusElements(offscreenDiv);\n      cleanupInputNames(offscreenDiv);\n      const root = getContentContainer(dos);\n      append$1(root, offscreenDiv);\n      const content = trim$2(offscreenDiv.dom.innerText);\n      remove$5(offscreenDiv);\n      return content;\n    };\n    const getContentFromBody = (editor, args, body) => {\n      let content;\n      if (args.format === 'raw') {\n        content = Tools.trim(trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));\n      } else if (args.format === 'text') {\n        content = getPlainTextContent(editor, body);\n      } else if (args.format === 'tree') {\n        content = editor.serializer.serialize(body, args);\n      } else {\n        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\n      }\n      const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\n      return shouldTrim && isString(content) ? Tools.trim(content) : content;\n    };\n    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\n\n    const makeMap$1 = Tools.makeMap;\n    const Writer = settings => {\n      const html = [];\n      settings = settings || {};\n      const indent = settings.indent;\n      const indentBefore = makeMap$1(settings.indent_before || '');\n      const indentAfter = makeMap$1(settings.indent_after || '');\n      const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\n      const htmlOutput = settings.element_format !== 'xhtml';\n      return {\n        start: (name, attrs, empty) => {\n          if (indent && indentBefore[name] && html.length > 0) {\n            const value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n          html.push('<', name);\n          if (attrs) {\n            for (let i = 0, l = attrs.length; i < l; i++) {\n              const attr = attrs[i];\n              html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\n            }\n          }\n          if (!empty || htmlOutput) {\n            html[html.length] = '>';\n          } else {\n            html[html.length] = ' />';\n          }\n          if (empty && indent && indentAfter[name] && html.length > 0) {\n            const value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        end: name => {\n          let value;\n          html.push('</', name, '>');\n          if (indent && indentAfter[name] && html.length > 0) {\n            value = html[html.length - 1];\n            if (value.length > 0 && value !== '\\n') {\n              html.push('\\n');\n            }\n          }\n        },\n        text: (text, raw) => {\n          if (text.length > 0) {\n            html[html.length] = raw ? text : encode(text);\n          }\n        },\n        cdata: text => {\n          html.push('<![CDATA[', text, ']]>');\n        },\n        comment: text => {\n          html.push('<!--', text, '-->');\n        },\n        pi: (name, text) => {\n          if (text) {\n            html.push('<?', name, ' ', encode(text), '?>');\n          } else {\n            html.push('<?', name, '?>');\n          }\n          if (indent) {\n            html.push('\\n');\n          }\n        },\n        doctype: text => {\n          html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\n        },\n        reset: () => {\n          html.length = 0;\n        },\n        getContent: () => {\n          return html.join('').replace(/\\n$/, '');\n        }\n      };\n    };\n\n    const HtmlSerializer = (settings = {}, schema = Schema()) => {\n      const writer = Writer(settings);\n      settings.validate = 'validate' in settings ? settings.validate : true;\n      const serialize = node => {\n        const validate = settings.validate;\n        const handlers = {\n          3: node => {\n            var _a;\n            writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);\n          },\n          8: node => {\n            var _a;\n            writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          7: node => {\n            writer.pi(node.name, node.value);\n          },\n          10: node => {\n            var _a;\n            writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          4: node => {\n            var _a;\n            writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          },\n          11: node => {\n            let tempNode = node;\n            if (tempNode = tempNode.firstChild) {\n              do {\n                walk(tempNode);\n              } while (tempNode = tempNode.next);\n            }\n          }\n        };\n        writer.reset();\n        const walk = node => {\n          var _a;\n          const handler = handlers[node.type];\n          if (!handler) {\n            const name = node.name;\n            const isEmpty = name in schema.getVoidElements();\n            let attrs = node.attributes;\n            if (validate && attrs && attrs.length > 1) {\n              const sortedAttrs = [];\n              sortedAttrs.map = {};\n              const elementRule = schema.getElementRule(node.name);\n              if (elementRule) {\n                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\n                  const attrName = elementRule.attributesOrder[i];\n                  if (attrName in attrs.map) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                for (let i = 0, l = attrs.length; i < l; i++) {\n                  const attrName = attrs[i].name;\n                  if (!(attrName in sortedAttrs.map)) {\n                    const attrValue = attrs.map[attrName];\n                    sortedAttrs.map[attrName] = attrValue;\n                    sortedAttrs.push({\n                      name: attrName,\n                      value: attrValue\n                    });\n                  }\n                }\n                attrs = sortedAttrs;\n              }\n            }\n            writer.start(name, attrs, isEmpty);\n            if (isNonHtmlElementRootName(name)) {\n              if (isString(node.value)) {\n                writer.text(node.value, true);\n              }\n              writer.end(name);\n            } else {\n              if (!isEmpty) {\n                let child = node.firstChild;\n                if (child) {\n                  if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\\n') {\n                    writer.text('\\n', true);\n                  }\n                  do {\n                    walk(child);\n                  } while (child = child.next);\n                }\n                writer.end(name);\n              }\n            }\n          } else {\n            handler(node);\n          }\n        };\n        if (node.type === 1 && !settings.inner) {\n          walk(node);\n        } else if (node.type === 3) {\n          handlers[3](node);\n        } else {\n          handlers[11](node);\n        }\n        return writer.getContent();\n      };\n      return { serialize };\n    };\n\n    const nonInheritableStyles = new Set();\n    (() => {\n      const nonInheritableStylesArr = [\n        'margin',\n        'margin-left',\n        'margin-right',\n        'margin-top',\n        'margin-bottom',\n        'padding',\n        'padding-left',\n        'padding-right',\n        'padding-top',\n        'padding-bottom',\n        'border',\n        'border-width',\n        'border-style',\n        'border-color',\n        'background',\n        'background-attachment',\n        'background-clip',\n        'background-color',\n        'background-image',\n        'background-origin',\n        'background-position',\n        'background-repeat',\n        'background-size',\n        'float',\n        'position',\n        'left',\n        'right',\n        'top',\n        'bottom',\n        'z-index',\n        'display',\n        'transform',\n        'width',\n        'max-width',\n        'min-width',\n        'height',\n        'max-height',\n        'min-height',\n        'overflow',\n        'overflow-x',\n        'overflow-y',\n        'text-overflow',\n        'vertical-align',\n        'transition',\n        'transition-delay',\n        'transition-duration',\n        'transition-property',\n        'transition-timing-function'\n      ];\n      each$e(nonInheritableStylesArr, style => {\n        nonInheritableStyles.add(style);\n      });\n    })();\n    const shorthandStyleProps = [\n      'font',\n      'text-decoration',\n      'text-emphasis'\n    ];\n    const getStyleProps = (dom, node) => keys(dom.parseStyle(dom.getAttrib(node, 'style')));\n    const isNonInheritableStyle = style => nonInheritableStyles.has(style);\n    const hasInheritableStyles = (dom, node) => forall(getStyleProps(dom, node), style => !isNonInheritableStyle(style));\n    const getLonghandStyleProps = styles => filter$5(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\n    const hasStyleConflict = (dom, node, parentNode) => {\n      const nodeStyleProps = getStyleProps(dom, node);\n      const parentNodeStyleProps = getStyleProps(dom, parentNode);\n      const valueMismatch = prop => {\n        var _a, _b;\n        const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\n        const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\n        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\n      };\n      return exists(nodeStyleProps, nodeStyleProp => {\n        const propExists = props => exists(props, prop => prop === nodeStyleProp);\n        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\n          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\n          return exists(longhandProps, valueMismatch);\n        } else {\n          return valueMismatch(nodeStyleProp);\n        }\n      });\n    };\n\n    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$a).exists(text => {\n      const delta = forward ? 0 : -1;\n      return predicate(text.data.charAt(pos.offset() + delta));\n    });\n    const isBeforeSpace = curry(isChar, true, isWhiteSpace);\n    const isAfterSpace = curry(isChar, false, isWhiteSpace);\n    const isEmptyText = pos => {\n      const container = pos.container();\n      return isText$a(container) && (container.data.length === 0 || isZwsp$1(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\n    };\n    const matchesElementPosition = (before, predicate) => pos => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();\n    const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\n    const isCefNode = node => isContentEditableFalse$b(node) && !isBogusAll$1(node);\n    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\n    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\n    const isBeforeMedia = matchesElementPosition(true, isMedia$2);\n    const isAfterMedia = matchesElementPosition(false, isMedia$2);\n    const isBeforeTable = matchesElementPosition(true, isTable$2);\n    const isAfterTable = matchesElementPosition(false, isTable$2);\n    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\n    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\n\n    const dropLast = xs => xs.slice(0, -1);\n    const parentsUntil = (start, root, predicate) => {\n      if (contains(root, start)) {\n        return dropLast(parents$1(start, elm => {\n          return predicate(elm) || eq(elm, root);\n        }));\n      } else {\n        return [];\n      }\n    };\n    const parents = (start, root) => parentsUntil(start, root, never);\n    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\n\n    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\n    const isBlock$1 = schema => el => schema.isBlock(name(el));\n    const getClosestBlock$1 = (root, pos, schema) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$1(schema));\n    const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos, schema).fold(() => !isInSameBlock(newPos, pos, root.dom), fromBlock => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\n    const isAtBlockBoundary = (forward, root, pos, schema) => getClosestBlock$1(root, pos, schema).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => !isInSameBlock(newPos, pos, root.dom)), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\n    const isAtStartOfBlock = curry(isAtBlockBoundary, false);\n    const isAtEndOfBlock = curry(isAtBlockBoundary, true);\n    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\n    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\n\n    const isBr$1 = pos => getElementFromPosition(pos).exists(isBr$5);\n    const findBr = (forward, root, pos, schema) => {\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n      const scope = head(parentBlocks).getOr(root);\n      return fromPosition(forward, scope.dom, pos).filter(isBr$1);\n    };\n    const isBeforeBr$1 = (root, pos, schema) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos, schema).isSome();\n    const isAfterBr = (root, pos, schema) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos, schema).isSome();\n    const findPreviousBr = curry(findBr, false);\n    const findNextBr = curry(findBr, true);\n\n    const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\n    const getClosestBlock = (root, pos, schema) => {\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\n      return head(parentBlocks).getOr(root);\n    };\n    const hasSpaceBefore = (root, pos, schema) => {\n      if (isInMiddleOfText(pos)) {\n        return isAfterSpace(pos);\n      } else {\n        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isAfterSpace);\n      }\n    };\n    const hasSpaceAfter = (root, pos, schema) => {\n      if (isInMiddleOfText(pos)) {\n        return isBeforeSpace(pos);\n      } else {\n        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isBeforeSpace);\n      }\n    };\n    const isPreValue = value => contains$2([\n      'pre',\n      'pre-wrap'\n    ], value);\n    const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\n    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\n    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\n    const isAtLineBoundary = (root, pos, schema) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos, schema) || isAtEndOfBlock(root, pos, schema) || isAfterBr(root, pos, schema) || isBeforeBr$1(root, pos, schema);\n    const isCefBlock = node => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);\n    const isSiblingCefBlock = (root, direction) => container => {\n      return isCefBlock(new DomTreeWalker(container, root)[direction]());\n    };\n    const isBeforeCefBlock = (root, pos) => {\n      const nextPos = nextPosition(root.dom, pos).getOr(pos);\n      const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');\n      return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));\n    };\n    const isAfterCefBlock = (root, pos) => {\n      const prevPos = prevPosition(root.dom, pos).getOr(pos);\n      const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');\n      return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));\n    };\n    const needsToHaveNbsp = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtLineBoundary(root, pos, schema) || hasSpaceBefore(root, pos, schema) || hasSpaceAfter(root, pos, schema);\n      }\n    };\n    const needsToBeNbspLeft = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtStartOfBlock(root, pos, schema) || isBeforeBlock(root, pos, schema) || isAfterBr(root, pos, schema) || hasSpaceBefore(root, pos, schema) || isAfterCefBlock(root, pos);\n      }\n    };\n    const leanRight = pos => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$a(container) && offset < container.data.length) {\n        return CaretPosition(container, offset + 1);\n      } else {\n        return pos;\n      }\n    };\n    const needsToBeNbspRight = (root, pos, schema) => {\n      if (isInPre(pos)) {\n        return false;\n      } else {\n        return isAtEndOfBlock(root, pos, schema) || isAfterBlock(root, pos, schema) || isBeforeBr$1(root, pos, schema) || hasSpaceAfter(root, pos, schema) || isBeforeCefBlock(root, pos);\n      }\n    };\n    const needsToBeNbsp = (root, pos, schema) => needsToBeNbspLeft(root, pos, schema) || needsToBeNbspRight(root, leanRight(pos), schema);\n    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\n    const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));\n    const hasNbsp = pos => {\n      const container = pos.container();\n      return isText$a(container) && contains$1(container.data, nbsp);\n    };\n    const normalizeNbspMiddle = text => {\n      const chars = text.split('');\n      return map$3(chars, (chr, i) => {\n        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\n          return ' ';\n        } else {\n          return chr;\n        }\n      }).join('');\n    };\n    const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {\n      const text = node.data;\n      const firstPos = CaretPosition(node, 0);\n      if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos, schema)) {\n        node.data = ' ' + text.slice(1);\n        return true;\n      } else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos, schema)) {\n        node.data = nbsp + text.slice(1);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspInMiddleOfTextNode = node => {\n      const text = node.data;\n      const newText = normalizeNbspMiddle(text);\n      if (newText !== text) {\n        node.data = newText;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {\n      const text = node.data;\n      const lastPos = CaretPosition(node, text.length - 1);\n      if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos, schema)) {\n        node.data = text.slice(0, -1) + ' ';\n        return true;\n      } else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos, schema)) {\n        node.data = text.slice(0, -1) + nbsp;\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const normalizeNbsps = (root, pos, schema) => {\n      const container = pos.container();\n      if (!isText$a(container)) {\n        return Optional.none();\n      }\n      if (hasNbsp(pos)) {\n        const normalized = normalizeNbspAtStart(root, container, false, schema) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false, schema);\n        return someIf(normalized, pos);\n      } else if (needsToBeNbsp(root, pos, schema)) {\n        const normalized = normalizeNbspAtStart(root, container, true, schema) || normalizeNbspAtEnd(root, container, true, schema);\n        return someIf(normalized, pos);\n      } else {\n        return Optional.none();\n      }\n    };\n    const normalizeNbspsInEditor = editor => {\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng()), editor.schema).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      }\n    };\n\n    const normalize$1 = (node, offset, count, schema) => {\n      if (count === 0) {\n        return;\n      }\n      const elm = SugarElement.fromDom(node);\n      const root = ancestor$4(elm, el => schema.isBlock(name(el))).getOr(elm);\n      const whitespace = node.data.slice(offset, offset + count);\n      const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);\n      const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);\n      node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\n    };\n    const normalizeWhitespaceAfter = (node, offset, schema) => {\n      const content = node.data.slice(offset);\n      const whitespaceCount = content.length - lTrim(content).length;\n      normalize$1(node, offset, whitespaceCount, schema);\n    };\n    const normalizeWhitespaceBefore = (node, offset, schema) => {\n      const content = node.data.slice(0, offset);\n      const whitespaceCount = content.length - rTrim(content).length;\n      normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);\n    };\n    const mergeTextNodes = (prevNode, nextNode, schema, normalizeWhitespace, mergeToPrev = true) => {\n      const whitespaceOffset = rTrim(prevNode.data).length;\n      const newNode = mergeToPrev ? prevNode : nextNode;\n      const removeNode = mergeToPrev ? nextNode : prevNode;\n      if (mergeToPrev) {\n        newNode.appendData(removeNode.data);\n      } else {\n        newNode.insertData(0, removeNode.data);\n      }\n      remove$5(SugarElement.fromDom(removeNode));\n      if (normalizeWhitespace) {\n        normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);\n      }\n      return newNode;\n    };\n\n    const needsReposition = (pos, elm) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\n    };\n    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\n    const beforeOrStartOf = node => isText$a(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\n    const afterOrEndOf = node => isText$a(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\n    const getPreviousSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.previousSibling)) {\n        return Optional.some(afterOrEndOf(elm.previousSibling));\n      } else {\n        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\n      }\n    };\n    const getNextSiblingCaretPosition = elm => {\n      if (isCaretCandidate$3(elm.nextSibling)) {\n        return Optional.some(beforeOrStartOf(elm.nextSibling));\n      } else {\n        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\n      }\n    };\n    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\n      return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind(node => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));\n    };\n    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));\n    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\n    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\n    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\n    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\n    const setSelection$1 = (editor, forward, pos) => {\n      pos.fold(() => {\n        editor.focus();\n      }, pos => {\n        editor.selection.setRng(pos.toRange(), forward);\n      });\n    };\n    const eqRawNode = rawNode => elm => elm.dom === rawNode;\n    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\n    const paddEmptyBlock = (elm, preserveEmptyCaret) => {\n      if (isEmpty$2(elm)) {\n        const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\n        if (preserveEmptyCaret) {\n          each$e(children$1(elm), node => {\n            if (!isEmptyCaretFormatElement(node)) {\n              remove$5(node);\n            }\n          });\n        } else {\n          empty(elm);\n        }\n        append$1(elm, br);\n        return Optional.some(CaretPosition.before(br.dom));\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteNormalized = (elm, afterDeletePosOpt, schema, normalizeWhitespace) => {\n      const prevTextOpt = prevSibling(elm).filter(isText$b);\n      const nextTextOpt = nextSibling(elm).filter(isText$b);\n      remove$5(elm);\n      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\n        const prevNode = prev.dom, nextNode = next.dom;\n        const offset = prevNode.data.length;\n        mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);\n        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\n      }).orThunk(() => {\n        if (normalizeWhitespace) {\n          prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema));\n          nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0, schema));\n        }\n        return afterDeletePosOpt;\n      });\n    };\n    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\n    const deleteElement$2 = (editor, forward, elm, moveCaret = true, preserveEmptyCaret = false) => {\n      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\n      const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\n      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, editor.schema, isInlineElement(editor, elm));\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      } else {\n        parentBlock.bind(elm => paddEmptyBlock(elm, preserveEmptyCaret)).fold(() => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, normalizedAfterDeletePos);\n          }\n        }, paddPos => {\n          if (moveCaret) {\n            setSelection$1(editor, forward, Optional.some(paddPos));\n          }\n        });\n      }\n    };\n\n    const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\n    const hasStrongRtl = text => strongRtl.test(text);\n\n    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);\n    const isRtl = element => {\n      var _a;\n      return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : '');\n    };\n    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\n    const findRootInline = (isInlineTarget, rootNode, pos) => {\n      const parents = findInlineParents(isInlineTarget, rootNode, pos);\n      return Optional.from(parents[parents.length - 1]);\n    };\n    const hasSameParentBlock = (rootNode, node1, node2) => {\n      const block1 = getParentBlock$3(node1, rootNode);\n      const block2 = getParentBlock$3(node2, rootNode);\n      return isNonNullable(block1) && block1 === block2;\n    };\n    const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\n    const normalizePosition = (forward, pos) => {\n      const container = pos.container(), offset = pos.offset();\n      if (forward) {\n        if (isCaretContainerInline(container)) {\n          if (isText$a(container.nextSibling)) {\n            return CaretPosition(container.nextSibling, 0);\n          } else {\n            return CaretPosition.after(container);\n          }\n        } else {\n          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\n        }\n      } else {\n        if (isCaretContainerInline(container)) {\n          if (isText$a(container.previousSibling)) {\n            return CaretPosition(container.previousSibling, container.previousSibling.data.length);\n          } else {\n            return CaretPosition.before(container);\n          }\n        } else {\n          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\n        }\n      }\n    };\n    const normalizeForwards = curry(normalizePosition, true);\n    const normalizeBackwards = curry(normalizePosition, false);\n\n    const execCommandIgnoreInputEvents = (editor, command) => {\n      const inputBlocker = e => e.stopImmediatePropagation();\n      editor.on('beforeinput input', inputBlocker, true);\n      editor.getDoc().execCommand(command);\n      editor.off('beforeinput input', inputBlocker);\n    };\n    const execEditorDeleteCommand = editor => {\n      editor.execCommand('delete');\n    };\n    const execNativeDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\n    const execNativeForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\n    const isBeforeRoot = rootNode => elm => is$2(parent(elm), rootNode, eq);\n    const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem$1(element);\n    const getParentBlock$2 = (rootNode, elm) => {\n      if (contains(rootNode, elm)) {\n        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\n      } else {\n        return Optional.none();\n      }\n    };\n    const paddEmptyBody = (editor, moveSelection = true) => {\n      if (editor.dom.isEmpty(editor.getBody())) {\n        editor.setContent('', { no_selection: !moveSelection });\n      }\n    };\n    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      const normalizedFromPos = normalizePosition(false, fromPos);\n      if (forward) {\n        return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\n      } else {\n        return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\n      }\n    }).getOr(true);\n    const freefallRtl = root => {\n      const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\n      return child.bind(freefallRtl).orThunk(() => Optional.some(root));\n    };\n    const deleteRangeContents = (editor, rng, root, moveSelection = true) => {\n      var _a;\n      rng.deleteContents();\n      const lastNode = freefallRtl(root).getOr(root);\n      const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);\n      if (lastBlock.dom === editor.getBody()) {\n        paddEmptyBody(editor, moveSelection);\n      } else if (isEmpty$2(lastBlock)) {\n        fillWithPaddingBr(lastBlock);\n        if (moveSelection) {\n          editor.selection.setCursorLocation(lastBlock.dom, 0);\n        }\n      }\n      if (!eq(root, lastBlock)) {\n        const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);\n        each$e(additionalCleanupNodes.concat(children$1(root)), node => {\n          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) {\n            remove$5(node);\n          }\n        });\n      }\n    };\n\n    const ancestor$1 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();\n    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\n    const descendant = (scope, predicate) => descendant$2(scope, predicate).isSome();\n\n    const isRootFromElement = root => cur => eq(root, cur);\n    const getTableCells = table => descendants(table, 'td,th');\n    const getTable$1 = (node, isRoot) => getClosestTable(SugarElement.fromDom(node), isRoot);\n    const selectionInTableWithNestedTable = details => {\n      return lift2(details.startTable, details.endTable, (startTable, endTable) => {\n        const isStartTableParentOfEndTable = descendant(startTable, t => eq(t, endTable));\n        const isEndTableParentOfStartTable = descendant(endTable, t => eq(t, startTable));\n        return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable ? details : {\n          ...details,\n          startTable: isStartTableParentOfEndTable ? Optional.none() : details.startTable,\n          endTable: isEndTableParentOfStartTable ? Optional.none() : details.endTable,\n          isSameTable: false,\n          isMultiTable: false\n        };\n      }).getOr(details);\n    };\n    const adjustQuirksInDetails = details => {\n      return selectionInTableWithNestedTable(details);\n    };\n    const getTableDetailsFromRange = (rng, isRoot) => {\n      const startTable = getTable$1(rng.startContainer, isRoot);\n      const endTable = getTable$1(rng.endContainer, isRoot);\n      const isStartInTable = startTable.isSome();\n      const isEndInTable = endTable.isSome();\n      const isSameTable = lift2(startTable, endTable, eq).getOr(false);\n      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\n      return adjustQuirksInDetails({\n        startTable,\n        endTable,\n        isStartInTable,\n        isEndInTable,\n        isSameTable,\n        isMultiTable\n      });\n    };\n\n    const tableCellRng = (start, end) => ({\n      start,\n      end\n    });\n    const tableSelection = (rng, table, cells) => ({\n      rng,\n      table,\n      cells\n    });\n    const deleteAction = Adt.generate([\n      {\n        singleCellTable: [\n          'rng',\n          'cell'\n        ]\n      },\n      { fullTable: ['table'] },\n      {\n        partialTable: [\n          'cells',\n          'outsideDetails'\n        ]\n      },\n      {\n        multiTable: [\n          'startTableCells',\n          'endTableCells',\n          'betweenRng'\n        ]\n      }\n    ]);\n    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\n    const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\n    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\n    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\n      const rows = table.dom.rows;\n      return rows.length === 1 && rows[0].cells.length === 1;\n    });\n    const getCellRng = (rng, isRoot) => {\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\n      return lift2(startCell, endCell, tableCellRng);\n    };\n    const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$3(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\n    const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\n    const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\n    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\n      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\n        return Optional.none();\n      } else if (selectionDetails.isSameTable) {\n        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: sameTableSelection,\n          end: sameTableSelection\n        });\n      } else {\n        const startCell = getClosestCell$1(rng.startContainer, isRoot);\n        const endCell = getClosestCell$1(rng.endContainer, isRoot);\n        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\n        return Optional.some({\n          start: startTableSelection,\n          end: endTableSelection\n        });\n      }\n    };\n    const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\n    const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\n    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\n    const unselectCells = (rng, selectionDetails) => {\n      const {startTable, endTable} = selectionDetails;\n      const otherContentRng = rng.cloneRange();\n      startTable.each(table => otherContentRng.setStartAfter(table.dom));\n      endTable.each(table => otherContentRng.setEndBefore(table.dom));\n      return otherContentRng;\n    };\n    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => start.or(end)).bind(tableSelection => {\n      const {isSameTable} = selectionDetails;\n      const selectedCells = getSelectedCells(tableSelection).getOr([]);\n      if (isSameTable && tableSelection.cells.length === selectedCells.length) {\n        return Optional.some(deleteAction.fullTable(tableSelection.table));\n      } else if (selectedCells.length > 0) {\n        if (isSameTable) {\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\n        } else {\n          const otherContentRng = unselectCells(rng, selectionDetails);\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({\n            ...selectionDetails,\n            rng: otherContentRng\n          })));\n        }\n      } else {\n        return Optional.none();\n      }\n    });\n    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => {\n      const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\n      const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\n      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\n        const otherContentRng = unselectCells(rng, selectionDetails);\n        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getActionFromRange = (root, rng) => {\n      const isRoot = isRootFromElement(root);\n      const optCellRng = getCellRng(rng, isRoot);\n      const selectionDetails = getTableDetailsFromRange(rng, isRoot);\n      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\n        return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\n      } else if (selectionDetails.isMultiTable) {\n        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\n      } else {\n        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\n      }\n    };\n\n    const cleanCells = cells => each$e(cells, cell => {\n      remove$a(cell, 'contenteditable');\n      fillWithPaddingBr(cell);\n    });\n    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\n    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\n      emptyBlock.each(block => {\n        if (startInTable) {\n          remove$5(block);\n        } else {\n          fillWithPaddingBr(block);\n          editor.selection.setCursorLocation(block.dom, 0);\n        }\n      });\n    };\n    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\n      const insideTableRng = rng.cloneRange();\n      if (isFirstCellInSelection) {\n        insideTableRng.setStart(rng.startContainer, rng.startOffset);\n        insideTableRng.setEndAfter(cell.dom.lastChild);\n      } else {\n        insideTableRng.setStartBefore(cell.dom.firstChild);\n        insideTableRng.setEnd(rng.endContainer, rng.endOffset);\n      }\n      deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\n    };\n    const collapseAndRestoreCellSelection = editor => {\n      const selectedCells = getCellsFromEditor(editor);\n      const selectedNode = SugarElement.fromDom(editor.selection.getNode());\n      if (isTableCell$3(selectedNode.dom) && isEmpty$2(selectedNode)) {\n        editor.selection.setCursorLocation(selectedNode.dom, 0);\n      } else {\n        editor.selection.collapse(true);\n      }\n      if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\n        set$3(selectedNode, 'data-mce-selected', '1');\n      }\n    };\n    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\n      const editorRng = editor.selection.getRng();\n      const cellsToClean = outsideDetails.bind(({rng, isStartInTable}) => {\n        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\n        rng.deleteContents();\n        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));\n        const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\n        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\n        if (!isEmpty$2(endPointCell)) {\n          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\n        } else {\n          return Optional.none();\n        }\n      }).getOr(cells);\n      cleanCells(cellsToClean);\n      collapseAndRestoreCellSelection(editor);\n    });\n    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\n      const rng = editor.selection.getRng();\n      const startCell = startTableCells[0];\n      const endCell = endTableCells[endTableCells.length - 1];\n      deleteContentInsideCell(editor, startCell, rng, true);\n      deleteContentInsideCell(editor, endCell, rng, false);\n      const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);\n      const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);\n      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\n      betweenRng.deleteContents();\n      collapseAndRestoreCellSelection(editor);\n    });\n    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {\n      deleteRangeContents(editor, rng, cell, moveSelection);\n    });\n    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\n    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\n    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\n    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\n    const deleteRange$3 = (editor, startElm, selectedCells) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\n    };\n    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);\n    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\n    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\n    const emptyElement = (editor, elm) => Optional.some(() => {\n      fillWithPaddingBr(elm);\n      editor.selection.setCursorLocation(elm.dom, 0);\n    });\n    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\n    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\n    const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\n    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\n    const deleteCaretCells = (editor, forward, rootElm, startElm) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\n    };\n    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\n    };\n    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\n    const isBeforeOrAfterTable = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\n    };\n    const deleteCaret$3 = (editor, forward, startElm) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\n    };\n    const backspaceDelete$a = (editor, forward) => {\n      const startElm = SugarElement.fromDom(editor.selection.getStart(true));\n      const cells = getCellsFromEditor(editor);\n      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells);\n    };\n\n    const getContentEditableRoot$1 = (root, node) => {\n      let tempNode = node;\n      while (tempNode && tempNode !== root) {\n        if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {\n          return tempNode;\n        }\n        tempNode = tempNode.parentNode;\n      }\n      return null;\n    };\n\n    const internalAttributesPrefixes = [\n      'data-ephox-',\n      'data-mce-',\n      'data-alloy-',\n      'data-snooker-',\n      '_'\n    ];\n    const each$9 = Tools.each;\n    const ElementUtils = editor => {\n      const dom = editor.dom;\n      const internalAttributes = new Set(editor.serializer.getTempAttrs());\n      const compare = (node1, node2) => {\n        if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {\n          return false;\n        }\n        const getAttribs = node => {\n          const attribs = {};\n          each$9(dom.getAttribs(node), attr => {\n            const name = attr.nodeName.toLowerCase();\n            if (name !== 'style' && !isAttributeInternal(name)) {\n              attribs[name] = dom.getAttrib(node, name);\n            }\n          });\n          return attribs;\n        };\n        const compareObjects = (obj1, obj2) => {\n          for (const name in obj1) {\n            if (has$2(obj1, name)) {\n              const value = obj2[name];\n              if (isUndefined(value)) {\n                return false;\n              }\n              if (obj1[name] !== value) {\n                return false;\n              }\n              delete obj2[name];\n            }\n          }\n          for (const name in obj2) {\n            if (has$2(obj2, name)) {\n              return false;\n            }\n          }\n          return true;\n        };\n        if (isElement$6(node1) && isElement$6(node2)) {\n          if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\n            return false;\n          }\n          if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\n            return false;\n          }\n        }\n        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\n      };\n      const isAttributeInternal = attributeName => exists(internalAttributesPrefixes, value => startsWith(attributeName, value)) || internalAttributes.has(attributeName);\n      return {\n        compare,\n        isAttributeInternal\n      };\n    };\n\n    const isHeading = node => [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6'\n    ].includes(node.name);\n    const isSummary = node => node.name === 'summary';\n\n    const traverse = (root, fn) => {\n      let node = root;\n      while (node = node.walk()) {\n        fn(node);\n      }\n    };\n    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\n      const name = node.name;\n      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\n        const filter = nodeFilters[ni];\n        if (filter.name === name) {\n          const match = matches.nodes[name];\n          if (match) {\n            match.nodes.push(node);\n          } else {\n            matches.nodes[name] = {\n              filter,\n              nodes: [node]\n            };\n          }\n        }\n      }\n      if (node.attributes) {\n        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\n          const filter = attributeFilters[ai];\n          const attrName = filter.name;\n          if (attrName in node.attributes.map) {\n            const match = matches.attributes[attrName];\n            if (match) {\n              match.nodes.push(node);\n            } else {\n              matches.attributes[attrName] = {\n                filter,\n                nodes: [node]\n              };\n            }\n          }\n        }\n      }\n    };\n    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\n      const matches = {\n        nodes: {},\n        attributes: {}\n      };\n      if (node.firstChild) {\n        traverse(node, childNode => {\n          matchNode$1(nodeFilters, attributeFilters, childNode, matches);\n        });\n      }\n      return matches;\n    };\n    const runFilters = (matches, args) => {\n      const run = (matchRecord, filteringAttributes) => {\n        each$d(matchRecord, match => {\n          const nodes = from(match.nodes);\n          each$e(match.filter.callbacks, callback => {\n            for (let i = nodes.length - 1; i >= 0; i--) {\n              const node = nodes[i];\n              const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;\n              if (!valueMatches || isNullable(node.parent)) {\n                nodes.splice(i, 1);\n              }\n            }\n            if (nodes.length > 0) {\n              callback(nodes, match.filter.name, args);\n            }\n          });\n        });\n      };\n      run(matches.nodes, false);\n      run(matches.attributes, true);\n    };\n    const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {\n      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\n      runFilters(matches, args);\n    };\n\n    const paddEmptyNode = (settings, args, isBlock, node) => {\n      const brPreferred = settings.pad_empty_with_br || args.insert;\n      if (brPreferred && isBlock(node)) {\n        const astNode = new AstNode('br', 1);\n        if (args.insert) {\n          astNode.attr('data-mce-bogus', '1');\n        }\n        node.empty().append(astNode);\n      } else {\n        node.empty().append(new AstNode('#text', 3)).value = nbsp;\n      }\n    };\n    const isPaddedWithNbsp = node => {\n      var _a;\n      return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;\n    };\n    const hasOnlyChild = (node, name) => {\n      const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;\n      return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;\n    };\n    const isPadded = (schema, node) => {\n      const rule = schema.getElementRule(node.name);\n      return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;\n    };\n    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\n    const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');\n    const findClosestEditingHost = scope => {\n      let editableNode;\n      for (let node = scope; node; node = node.parent) {\n        const contentEditable = node.attr('contenteditable');\n        if (contentEditable === 'false') {\n          break;\n        } else if (contentEditable === 'true') {\n          editableNode = node;\n        }\n      }\n      return Optional.from(editableNode);\n    };\n\n    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {\n      if (schema.getSpecialElements()[node.name]) {\n        node.empty().remove();\n      } else {\n        const children = node.children();\n        for (const childNode of children) {\n          if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {\n            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\n          }\n        }\n        node.unwrap();\n      }\n    };\n    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {\n      const textBlockElements = schema.getTextBlockElements();\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');\n      const fixed = new Set();\n      const isSplittableElement = node => node !== rootNode && !nonSplittableElements[node.name];\n      for (let ni = 0; ni < nodes.length; ni++) {\n        const node = nodes[ni];\n        let parent;\n        let newParent;\n        let tempNode;\n        if (!node.parent || fixed.has(node)) {\n          continue;\n        }\n        if (textBlockElements[node.name] && node.parent.name === 'li') {\n          let sibling = node.next;\n          while (sibling) {\n            if (textBlockElements[sibling.name]) {\n              sibling.name = 'li';\n              fixed.add(sibling);\n              node.parent.insert(sibling, node.parent);\n            } else {\n              break;\n            }\n            sibling = sibling.next;\n          }\n          node.unwrap();\n          continue;\n        }\n        const parents = [node];\n        for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {\n          parents.push(parent);\n        }\n        if (parent && parents.length > 1) {\n          if (!isInvalid(schema, node, parent)) {\n            parents.reverse();\n            newParent = parents[0].clone();\n            onCreate(newParent);\n            let currentNode = newParent;\n            for (let i = 0; i < parents.length - 1; i++) {\n              if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {\n                tempNode = parents[i].clone();\n                onCreate(tempNode);\n                currentNode.append(tempNode);\n              } else {\n                tempNode = currentNode;\n              }\n              for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\n                const nextNode = childNode.next;\n                tempNode.append(childNode);\n                childNode = nextNode;\n              }\n              currentNode = tempNode;\n            }\n            if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\n              parent.insert(newParent, parents[0], true);\n              parent.insert(node, newParent);\n            } else {\n              parent.insert(node, parents[0], true);\n            }\n            parent = parents[0];\n            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\n              parent.empty().remove();\n            }\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        } else if (node.parent) {\n          if (node.name === 'li') {\n            let sibling = node.prev;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\n              sibling.append(node);\n              continue;\n            }\n            sibling = node.next;\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {\n              sibling.insert(node, sibling.firstChild, true);\n              continue;\n            }\n            const wrapper = new AstNode('ul', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n            continue;\n          }\n          if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\n            const wrapper = new AstNode('div', 1);\n            onCreate(wrapper);\n            node.wrap(wrapper);\n          } else {\n            removeOrUnwrapInvalidNode(node, schema);\n          }\n        }\n      }\n    };\n    const hasClosest = (node, parentName) => {\n      let tempNode = node;\n      while (tempNode) {\n        if (tempNode.name === parentName) {\n          return true;\n        }\n        tempNode = tempNode.parent;\n      }\n      return false;\n    };\n    const isInvalid = (schema, node, parent = node.parent) => {\n      if (!parent) {\n        return false;\n      }\n      if (schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\n        return true;\n      }\n      if (node.name === 'a' && hasClosest(parent, 'a')) {\n        return true;\n      }\n      if (isSummary(parent) && isHeading(node)) {\n        return !((parent === null || parent === void 0 ? void 0 : parent.firstChild) === node && (parent === null || parent === void 0 ? void 0 : parent.lastChild) === node);\n      }\n      return false;\n    };\n\n    const createRange = (sc, so, ec, eo) => {\n      const rng = document.createRange();\n      rng.setStart(sc, so);\n      rng.setEnd(ec, eo);\n      return rng;\n    };\n    const normalizeBlockSelectionRange = rng => {\n      const startPos = CaretPosition.fromRangeStart(rng);\n      const endPos = CaretPosition.fromRangeEnd(rng);\n      const rootNode = rng.commonAncestorContainer;\n      return fromPosition(false, rootNode, endPos).map(newEndPos => {\n        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\n          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\n        } else {\n          return rng;\n        }\n      }).getOr(rng);\n    };\n    const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\n\n    const hasOnlyOneChild$1 = node => {\n      return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;\n    };\n    const isPaddingNode = node => {\n      return node.name === 'br' || node.value === nbsp;\n    };\n    const isPaddedEmptyBlock = (schema, node) => {\n      const blockElements = schema.getBlockElements();\n      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\n    };\n    const isEmptyFragmentElement = (schema, node) => {\n      const nonEmptyElements = schema.getNonEmptyElements();\n      return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\n    };\n    const isListFragment = (schema, fragment) => {\n      let firstChild = fragment.firstChild;\n      let lastChild = fragment.lastChild;\n      if (firstChild && firstChild.name === 'meta') {\n        firstChild = firstChild.next;\n      }\n      if (lastChild && lastChild.attr('id') === 'mce_marker') {\n        lastChild = lastChild.prev;\n      }\n      if (isEmptyFragmentElement(schema, lastChild)) {\n        lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;\n      }\n      if (!firstChild || firstChild !== lastChild) {\n        return false;\n      }\n      return firstChild.name === 'ul' || firstChild.name === 'ol';\n    };\n    const cleanupDomFragment = domFragment => {\n      var _a, _b;\n      const firstChild = domFragment.firstChild;\n      const lastChild = domFragment.lastChild;\n      if (firstChild && firstChild.nodeName === 'META') {\n        (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);\n      }\n      if (lastChild && lastChild.id === 'mce_marker') {\n        (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);\n      }\n      return domFragment;\n    };\n    const toDomFragment = (dom, serializer, fragment) => {\n      const html = serializer.serialize(fragment);\n      const domFragment = dom.createFragment(html);\n      return cleanupDomFragment(domFragment);\n    };\n    const listItems = elm => {\n      var _a;\n      return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], child => {\n        return child.nodeName === 'LI';\n      });\n    };\n    const isPadding = node => {\n      return node.data === nbsp || isBr$6(node);\n    };\n    const isListItemPadded = node => {\n      return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);\n    };\n    const isEmptyOrPadded = elm => {\n      return !elm.firstChild || isListItemPadded(elm);\n    };\n    const trimListItems = elms => {\n      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\n    };\n    const getParentLi = (dom, node) => {\n      const parentBlock = dom.getParent(node, dom.isBlock);\n      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\n    };\n    const isParentBlockLi = (dom, node) => {\n      return !!getParentLi(dom, node);\n    };\n    const getSplit = (parentNode, rng) => {\n      const beforeRng = rng.cloneRange();\n      const afterRng = rng.cloneRange();\n      beforeRng.setStartBefore(parentNode);\n      afterRng.setEndAfter(parentNode);\n      return [\n        beforeRng.cloneContents(),\n        afterRng.cloneContents()\n      ];\n    };\n    const findFirstIn = (node, rootNode) => {\n      const caretPos = CaretPosition.before(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.next(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const findLastOf = (node, rootNode) => {\n      const caretPos = CaretPosition.after(node);\n      const caretWalker = CaretWalker(rootNode);\n      const newCaretPos = caretWalker.prev(caretPos);\n      return newCaretPos ? newCaretPos.toRange() : null;\n    };\n    const insertMiddle = (target, elms, rootNode, rng) => {\n      const parts = getSplit(target, rng);\n      const parentElm = target.parentNode;\n      if (parentElm) {\n        parentElm.insertBefore(parts[0], target);\n        Tools.each(elms, li => {\n          parentElm.insertBefore(li, target);\n        });\n        parentElm.insertBefore(parts[1], target);\n        parentElm.removeChild(target);\n      }\n      return findLastOf(elms[elms.length - 1], rootNode);\n    };\n    const insertBefore$2 = (target, elms, rootNode) => {\n      const parentElm = target.parentNode;\n      if (parentElm) {\n        Tools.each(elms, elm => {\n          parentElm.insertBefore(elm, target);\n        });\n      }\n      return findFirstIn(target, rootNode);\n    };\n    const insertAfter$2 = (target, elms, rootNode, dom) => {\n      dom.insertAfter(elms.reverse(), target);\n      return findLastOf(elms[0], rootNode);\n    };\n    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\n      const domFragment = toDomFragment(dom, serializer, fragment);\n      const liTarget = getParentLi(dom, rng.startContainer);\n      const liElms = trimListItems(listItems(domFragment.firstChild));\n      const BEGINNING = 1, END = 2;\n      const rootNode = dom.getRoot();\n      const isAt = location => {\n        const caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(dom.getRoot());\n        const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\n        const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();\n        return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;\n      };\n      if (!liTarget) {\n        return null;\n      } else if (isAt(BEGINNING)) {\n        return insertBefore$2(liTarget, liElms, rootNode);\n      } else if (isAt(END)) {\n        return insertAfter$2(liTarget, liElms, rootNode, dom);\n      } else {\n        return insertMiddle(liTarget, liElms, rootNode, rng);\n      }\n    };\n\n    const mergeableWrappedElements = ['pre'];\n    const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {\n      var _a;\n      const firstNode = fragment.firstChild;\n      const lastNode = fragment.lastChild;\n      const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;\n      const isPastingSingleElement = firstNode === last;\n      const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);\n      if (isPastingSingleElement && isWrappedElement) {\n        const isContentEditable = firstNode.attr('contenteditable') !== 'false';\n        const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;\n        const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);\n        return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;\n      } else {\n        return false;\n      }\n    };\n    const isTableCell = isTableCell$3;\n    const isTableCellContentSelected = (dom, rng, cell) => {\n      if (isNonNullable(cell)) {\n        const endCell = dom.getParent(rng.endContainer, isTableCell);\n        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\n      } else {\n        return false;\n      }\n    };\n    const validInsertion = (editor, value, parentNode) => {\n      var _a;\n      if (parentNode.getAttribute('data-mce-bogus') === 'all') {\n        (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);\n      } else {\n        const node = parentNode.firstChild;\n        const node2 = parentNode.lastChild;\n        if (!node || node === node2 && node.nodeName === 'BR') {\n          editor.dom.setHTML(parentNode, value);\n        } else {\n          editor.selection.setContent(value, { no_events: true });\n        }\n      }\n    };\n    const trimBrsFromTableCell = (dom, elm, schema) => {\n      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(el => trimBlockTrailingBr(el, schema));\n    };\n    const reduceInlineTextElements = (editor, merge) => {\n      const textInlineElements = editor.schema.getTextInlineElements();\n      const dom = editor.dom;\n      if (merge) {\n        const root = editor.getBody();\n        const elementUtils = ElementUtils(editor);\n        Tools.each(dom.select('*[data-mce-fragment]'), node => {\n          const isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);\n          if (isInline && hasInheritableStyles(dom, node)) {\n            for (let parentNode = node.parentElement; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentElement) {\n              const styleConflict = hasStyleConflict(dom, node, parentNode);\n              if (styleConflict) {\n                break;\n              }\n              if (elementUtils.compare(parentNode, node)) {\n                dom.remove(node, true);\n                break;\n              }\n            }\n          }\n        });\n      }\n    };\n    const markFragmentElements = fragment => {\n      let node = fragment;\n      while (node = node.walk()) {\n        if (node.type === 1) {\n          node.attr('data-mce-fragment', '1');\n        }\n      }\n    };\n    const unmarkFragmentElements = elm => {\n      Tools.each(elm.getElementsByTagName('*'), elm => {\n        elm.removeAttribute('data-mce-fragment');\n      });\n    };\n    const isPartOfFragment = node => {\n      return !!node.getAttribute('data-mce-fragment');\n    };\n    const canHaveChildren = (editor, node) => {\n      return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];\n    };\n    const moveSelectionToMarker = (editor, marker) => {\n      var _a, _b, _c;\n      let nextRng;\n      const dom = editor.dom;\n      const selection = editor.selection;\n      if (!marker) {\n        return;\n      }\n      selection.scrollIntoView(marker);\n      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\n      if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {\n        dom.remove(marker);\n        selection.select(parentEditableElm);\n        return;\n      }\n      let rng = dom.createRng();\n      const node = marker.previousSibling;\n      if (isText$a(node)) {\n        rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\n        const node2 = marker.nextSibling;\n        if (isText$a(node2)) {\n          node.appendData(node2.data);\n          (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);\n        }\n      } else {\n        rng.setStartBefore(marker);\n        rng.setEndBefore(marker);\n      }\n      const findNextCaretRng = rng => {\n        let caretPos = CaretPosition.fromRangeStart(rng);\n        const caretWalker = CaretWalker(editor.getBody());\n        caretPos = caretWalker.next(caretPos);\n        return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();\n      };\n      const parentBlock = dom.getParent(marker, dom.isBlock);\n      dom.remove(marker);\n      if (parentBlock && dom.isEmpty(parentBlock)) {\n        const isCell = isTableCell(parentBlock);\n        empty(SugarElement.fromDom(parentBlock));\n        rng.setStart(parentBlock, 0);\n        rng.setEnd(parentBlock, 0);\n        if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\n          rng = nextRng;\n          dom.remove(parentBlock);\n        } else {\n          dom.add(parentBlock, dom.create('br', isCell ? {} : { 'data-mce-bogus': '1' }));\n        }\n      }\n      selection.setRng(rng);\n    };\n    const deleteSelectedContent = editor => {\n      const dom = editor.dom;\n      const rng = normalize(editor.selection.getRng());\n      editor.selection.setRng(rng);\n      const startCell = dom.getParent(rng.startContainer, isTableCell);\n      if (isTableCellContentSelected(dom, rng, startCell)) {\n        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\n      } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$a(rng.startContainer.childNodes[rng.startOffset])) {\n        rng.deleteContents();\n      } else {\n        editor.getDoc().execCommand('Delete', false);\n      }\n    };\n    const findMarkerNode = scope => {\n      for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {\n        if (markerNode.attr('id') === 'mce_marker') {\n          return Optional.some(markerNode);\n        }\n      }\n      return Optional.none();\n    };\n    const notHeadingsInSummary = (dom, node, fragment) => {\n      var _a;\n      return exists(fragment.children(), isHeading) && ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName) === 'SUMMARY';\n    };\n    const insertHtmlAtCaret = (editor, value, details) => {\n      var _a, _b;\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const parser = editor.parser;\n      const merge = details.merge;\n      const serializer = HtmlSerializer({ validate: true }, editor.schema);\n      const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\n      if (!details.preserve_zwsp) {\n        value = trim$2(value);\n      }\n      if (value.indexOf('{$caret}') === -1) {\n        value += '{$caret}';\n      }\n      value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\n      let rng = selection.getRng();\n      const caretElement = rng.startContainer;\n      const body = editor.getBody();\n      if (caretElement === body && selection.isCollapsed()) {\n        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\n          rng = dom.createRng();\n          rng.setStart(body.firstChild, 0);\n          rng.setEnd(body.firstChild, 0);\n          selection.setRng(rng);\n        }\n      }\n      if (!selection.isCollapsed()) {\n        deleteSelectedContent(editor);\n      }\n      const parentNode = selection.getNode();\n      const parserArgs = {\n        context: parentNode.nodeName.toLowerCase(),\n        data: details.data,\n        insert: true\n      };\n      const fragment = parser.parse(value, parserArgs);\n      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\n        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\n        if (rng) {\n          selection.setRng(rng);\n        }\n        return value;\n      }\n      if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {\n        (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();\n      }\n      markFragmentElements(fragment);\n      let node = fragment.lastChild;\n      if (node && node.attr('id') === 'mce_marker') {\n        const marker = node;\n        for (node = node.prev; node; node = node.walk(true)) {\n          if (node.type === 3 || !dom.isBlock(node.name)) {\n            if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {\n              node.parent.insert(marker, node, node.name === 'br');\n            }\n            break;\n          }\n        }\n      }\n      editor._selectionOverrides.showBlockCaretContainer(parentNode);\n      if (!parserArgs.invalid && !notHeadingsInSummary(dom, parentNode, fragment)) {\n        value = serializer.serialize(fragment);\n        validInsertion(editor, value, parentNode);\n      } else {\n        editor.selection.setContent(bookmarkHtml);\n        let parentNode = selection.getNode();\n        let tempNode;\n        const rootNode = editor.getBody();\n        if (isDocument$1(parentNode)) {\n          parentNode = tempNode = rootNode;\n        } else {\n          tempNode = parentNode;\n        }\n        while (tempNode && tempNode !== rootNode) {\n          parentNode = tempNode;\n          tempNode = tempNode.parentNode;\n        }\n        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\n        const root = parser.parse(value);\n        const markerNode = findMarkerNode(root);\n        const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);\n        markerNode.each(marker => marker.replace(fragment));\n        const toExtract = fragment.children();\n        const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;\n        fragment.unwrap();\n        const invalidChildren = filter$5(toExtract, node => isInvalid(editor.schema, node, parent));\n        cleanInvalidNodes(invalidChildren, editor.schema, editingHost);\n        filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);\n        value = serializer.serialize(root);\n        if (parentNode === rootNode) {\n          dom.setHTML(rootNode, value);\n        } else {\n          dom.setOuterHTML(parentNode, value);\n        }\n      }\n      reduceInlineTextElements(editor, merge);\n      moveSelectionToMarker(editor, dom.get('mce_marker'));\n      unmarkFragmentElements(editor.getBody());\n      trimBrsFromTableCell(dom, selection.getStart(), editor.schema);\n      updateCaret(editor.schema, editor.getBody(), selection.getStart());\n      return value;\n    };\n\n    const isTreeNode = content => content instanceof AstNode;\n\n    const moveSelection = editor => {\n      if (hasFocus(editor)) {\n        firstPositionIn(editor.getBody()).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const setEditorHtml = (editor, html, noSelection) => {\n      editor.dom.setHTML(editor.getBody(), html);\n      if (noSelection !== true) {\n        moveSelection(editor);\n      }\n    };\n    const setContentString = (editor, body, content, args) => {\n      content = trim$2(content);\n      if (content.length === 0 || /^\\s+$/.test(content)) {\n        const padd = '<br data-mce-bogus=\"1\">';\n        if (body.nodeName === 'TABLE') {\n          content = '<tr><td>' + padd + '</td></tr>';\n        } else if (/^(UL|OL)$/.test(body.nodeName)) {\n          content = '<li>' + padd + '</li>';\n        }\n        const forcedRootBlockName = getForcedRootBlock(editor);\n        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\n          content = padd;\n          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\n        } else if (!content) {\n          content = padd;\n        }\n        setEditorHtml(editor, content, args.no_selection);\n        return {\n          content,\n          html: content\n        };\n      } else {\n        if (args.format !== 'raw') {\n          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {\n            isRootContent: true,\n            insert: true\n          }));\n        }\n        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\n        setEditorHtml(editor, trimmedHtml, args.no_selection);\n        return {\n          content: trimmedHtml,\n          html: trimmedHtml\n        };\n      }\n    };\n    const setContentTree = (editor, body, content, args) => {\n      filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\n      const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);\n      const trimmedHtml = trim$2(isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html));\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\n      return {\n        content,\n        html: trimmedHtml\n      };\n    };\n    const setContentInternal = (editor, content, args) => {\n      return Optional.from(editor.getBody()).map(body => {\n        if (isTreeNode(content)) {\n          return setContentTree(editor, body, content, args);\n        } else {\n          return setContentString(editor, body, content, args);\n        }\n      }).getOr({\n        content,\n        html: isTreeNode(args.content) ? '' : args.content\n      });\n    };\n\n    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\n    const ancestor = (scope, transform, isRoot) => {\n      let element = scope.dom;\n      const stop = ensureIsRoot(isRoot);\n      while (element.parentNode) {\n        element = element.parentNode;\n        const el = SugarElement.fromDom(element);\n        const transformed = transform(el);\n        if (transformed.isSome()) {\n          return transformed;\n        } else if (stop(el)) {\n          break;\n        }\n      }\n      return Optional.none();\n    };\n    const closest$1 = (scope, transform, isRoot) => {\n      const current = transform(scope);\n      const stop = ensureIsRoot(isRoot);\n      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\n    };\n\n    const isEq$3 = isEq$5;\n    const matchesUnInheritedFormatSelector = (ed, node, name) => {\n      const formatList = ed.formatter.get(name);\n      if (formatList) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\n            return true;\n          }\n        }\n      }\n      return false;\n    };\n    const matchParents = (editor, node, name, vars, similar) => {\n      const root = editor.dom.getRoot();\n      if (node === root) {\n        return false;\n      }\n      const matchedNode = editor.dom.getParent(node, elm => {\n        if (matchesUnInheritedFormatSelector(editor, elm, name)) {\n          return true;\n        }\n        return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);\n      });\n      return !!matchNode(editor, matchedNode, name, vars, similar);\n    };\n    const matchName = (dom, node, format) => {\n      if (isInlineFormat(format) && isEq$3(node, format.inline)) {\n        return true;\n      }\n      if (isBlockFormat(format) && isEq$3(node, format.block)) {\n        return true;\n      }\n      if (isSelectorFormat(format)) {\n        return isElement$6(node) && dom.is(node, format.selector);\n      }\n      return false;\n    };\n    const matchItems = (dom, node, format, itemName, similar, vars) => {\n      const items = format[itemName];\n      const matchAttributes = itemName === 'attributes';\n      if (isFunction(format.onmatch)) {\n        return format.onmatch(node, format, itemName);\n      }\n      if (items) {\n        if (!isArrayLike(items)) {\n          for (const key in items) {\n            if (has$2(items, key)) {\n              const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);\n              const expectedValue = replaceVars(items[key], vars);\n              const isEmptyValue = isNullable(value) || isEmpty$3(value);\n              if (isEmptyValue && isNullable(expectedValue)) {\n                continue;\n              }\n              if (similar && isEmptyValue && !format.exact) {\n                return false;\n              }\n              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\n                return false;\n              }\n            }\n          }\n        } else {\n          for (let i = 0; i < items.length; i++) {\n            if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\n              return true;\n            }\n          }\n        }\n      }\n      return true;\n    };\n    const matchNode = (ed, node, name, vars, similar) => {\n      const formatList = ed.formatter.get(name);\n      const dom = ed.dom;\n      if (formatList && isElement$6(node)) {\n        for (let i = 0; i < formatList.length; i++) {\n          const format = formatList[i];\n          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\n            const classes = format.classes;\n            if (classes) {\n              for (let x = 0; x < classes.length; x++) {\n                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\n                  return;\n                }\n              }\n            }\n            return format;\n          }\n        }\n      }\n      return undefined;\n    };\n    const match$2 = (editor, name, vars, node, similar) => {\n      if (node) {\n        return matchParents(editor, node, name, vars, similar);\n      }\n      node = editor.selection.getNode();\n      if (matchParents(editor, node, name, vars, similar)) {\n        return true;\n      }\n      const startNode = editor.selection.getStart();\n      if (startNode !== node) {\n        if (matchParents(editor, startNode, name, vars, similar)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const matchAll = (editor, names, vars) => {\n      const matchedFormatNames = [];\n      const checkedMap = {};\n      const startElement = editor.selection.getStart();\n      editor.dom.getParent(startElement, node => {\n        for (let i = 0; i < names.length; i++) {\n          const name = names[i];\n          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\n            checkedMap[name] = true;\n            matchedFormatNames.push(name);\n          }\n        }\n      }, editor.dom.getRoot());\n      return matchedFormatNames;\n    };\n    const closest = (editor, names) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\n      return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$1(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\n    };\n    const canApply = (editor, name) => {\n      const formatList = editor.formatter.get(name);\n      const dom = editor.dom;\n      if (formatList && editor.selection.isEditable()) {\n        const startNode = editor.selection.getStart();\n        const parents = getParents$2(dom, startNode);\n        for (let x = formatList.length - 1; x >= 0; x--) {\n          const format = formatList[x];\n          if (!isSelectorFormat(format)) {\n            return true;\n          }\n          for (let i = parents.length - 1; i >= 0; i--) {\n            if (dom.is(parents[i], format.selector)) {\n              return true;\n            }\n          }\n        }\n      }\n      return false;\n    };\n    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\n      const matchSimilar = isVariableFormatName(editor, name);\n      if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\n        return acc.concat([name]);\n      } else {\n        return acc;\n      }\n    }, []);\n\n    const ZWSP = ZWSP$1;\n    const importNode = (ownerDocument, node) => {\n      return ownerDocument.importNode(node, true);\n    };\n    const findFirstTextNode = node => {\n      if (node) {\n        const walker = new DomTreeWalker(node, node);\n        for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {\n          if (isText$a(tempNode)) {\n            return tempNode;\n          }\n        }\n      }\n      return null;\n    };\n    const createCaretContainer = fill => {\n      const caretContainer = SugarElement.fromTag('span');\n      setAll$1(caretContainer, {\n        'id': CARET_ID,\n        'data-mce-bogus': '1',\n        'data-mce-type': 'format-caret'\n      });\n      if (fill) {\n        append$1(caretContainer, SugarElement.fromText(ZWSP));\n      }\n      return caretContainer;\n    };\n    const trimZwspFromCaretContainer = caretContainerNode => {\n      const textNode = findFirstTextNode(caretContainerNode);\n      if (textNode && textNode.data.charAt(0) === ZWSP) {\n        textNode.deleteData(0, 1);\n      }\n      return textNode;\n    };\n    const removeCaretContainerNode = (editor, node, moveCaret) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (isCaretContainerEmpty(node)) {\n        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret, true);\n      } else {\n        const rng = selection.getRng();\n        const block = dom.getParent(node, dom.isBlock);\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        const textNode = trimZwspFromCaretContainer(node);\n        dom.remove(node, true);\n        if (startContainer === textNode && startOffset > 0) {\n          rng.setStart(textNode, startOffset - 1);\n        }\n        if (endContainer === textNode && endOffset > 0) {\n          rng.setEnd(textNode, endOffset - 1);\n        }\n        if (block && dom.isEmpty(block)) {\n          fillWithPaddingBr(SugarElement.fromDom(block));\n        }\n        selection.setRng(rng);\n      }\n    };\n    const removeCaretContainer = (editor, node, moveCaret) => {\n      const dom = editor.dom, selection = editor.selection;\n      if (!node) {\n        node = getParentCaretContainer(editor.getBody(), selection.getStart());\n        if (!node) {\n          while (node = dom.get(CARET_ID)) {\n            removeCaretContainerNode(editor, node, moveCaret);\n          }\n        }\n      } else {\n        removeCaretContainerNode(editor, node, moveCaret);\n      }\n    };\n    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\n      var _a, _b;\n      const dom = editor.dom;\n      const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));\n      if (block && dom.isEmpty(block)) {\n        (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);\n      } else {\n        removeTrailingBr(SugarElement.fromDom(formatNode));\n        if (dom.isEmpty(formatNode)) {\n          (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);\n        } else {\n          dom.insertAfter(caretContainer, formatNode);\n        }\n      }\n    };\n    const appendNode = (parentNode, node) => {\n      parentNode.appendChild(node);\n      return node;\n    };\n    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\n      var _a;\n      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\n        return appendNode(parentNode, formatNode.cloneNode(false));\n      }, caretContainer);\n      const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));\n    };\n    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\n      const formatter = editor.formatter;\n      const dom = editor.dom;\n      const validFormats = filter$5(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\n      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\n      const uniqueFormats = filter$5(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\n      if (uniqueFormats.length > 0) {\n        const clonedFormatNode = formatNode.cloneNode(false);\n        dom.add(caretContainer, clonedFormatNode);\n        formatter.remove(name, vars, clonedFormatNode, similar);\n        dom.remove(clonedFormatNode);\n        return Optional.some(clonedFormatNode);\n      } else {\n        return Optional.none();\n      }\n    };\n    const applyCaretFormat = (editor, name, vars) => {\n      let caretContainer;\n      const selection = editor.selection;\n      const formatList = editor.formatter.get(name);\n      if (!formatList) {\n        return;\n      }\n      const selectionRng = selection.getRng();\n      let offset = selectionRng.startOffset;\n      const container = selectionRng.startContainer;\n      const text = container.nodeValue;\n      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\n      const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\n      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\n        const bookmark = selection.getBookmark();\n        selectionRng.collapse(true);\n        let rng = expandRng(editor.dom, selectionRng, formatList);\n        rng = split(rng);\n        editor.formatter.apply(name, vars, rng);\n        selection.moveToBookmark(bookmark);\n      } else {\n        let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;\n        if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {\n          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\n          textNode = caretContainer.firstChild;\n          selectionRng.insertNode(caretContainer);\n          offset = 1;\n          editor.formatter.apply(name, vars, caretContainer);\n        } else {\n          editor.formatter.apply(name, vars, caretContainer);\n        }\n        selection.setCursorLocation(textNode, offset);\n      }\n    };\n    const removeCaretFormat = (editor, name, vars, similar) => {\n      const dom = editor.dom;\n      const selection = editor.selection;\n      let hasContentAfter = false;\n      const formatList = editor.formatter.get(name);\n      if (!formatList) {\n        return;\n      }\n      const rng = selection.getRng();\n      const container = rng.startContainer;\n      const offset = rng.startOffset;\n      let node = container;\n      if (isText$a(container)) {\n        if (offset !== container.data.length) {\n          hasContentAfter = true;\n        }\n        node = node.parentNode;\n      }\n      const parents = [];\n      let formatNode;\n      while (node) {\n        if (matchNode(editor, node, name, vars, similar)) {\n          formatNode = node;\n          break;\n        }\n        if (node.nextSibling) {\n          hasContentAfter = true;\n        }\n        parents.push(node);\n        node = node.parentNode;\n      }\n      if (!formatNode) {\n        return;\n      }\n      if (hasContentAfter) {\n        const bookmark = selection.getBookmark();\n        rng.collapse(true);\n        let expandedRng = expandRng(dom, rng, formatList, true);\n        expandedRng = split(expandedRng);\n        editor.formatter.remove(name, vars, expandedRng, similar);\n        selection.moveToBookmark(bookmark);\n      } else {\n        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\n        const parentsAfter = isNonNullable(caretContainer) ? dom.getParents(formatNode.parentNode, always, caretContainer) : [];\n        const newCaretContainer = createCaretContainer(false).dom;\n        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);\n        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\n        const caretTextNode = insertFormatNodesIntoCaretContainer([\n          ...parents,\n          ...cleanedFormatNode.toArray(),\n          ...parentsAfter\n        ], newCaretContainer);\n        if (caretContainer) {\n          removeCaretContainerNode(editor, caretContainer, isNonNullable(caretContainer));\n        }\n        selection.setCursorLocation(caretTextNode, 1);\n        if (dom.isEmpty(formatNode)) {\n          dom.remove(formatNode);\n        }\n      }\n    };\n    const disableCaretContainer = (editor, keyCode, moveCaret) => {\n      const selection = editor.selection, body = editor.getBody();\n      removeCaretContainer(editor, null, moveCaret);\n      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n      }\n      if (keyCode === 37 || keyCode === 39) {\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\n      }\n    };\n    const endsWithNbsp = element => isText$a(element) && endsWith(element.data, nbsp);\n    const setup$v = editor => {\n      editor.on('mouseup keydown', e => {\n        disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));\n      });\n    };\n    const createCaretFormat = formatNodes => {\n      const caretContainer = createCaretContainer(false);\n      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\n      return {\n        caretContainer,\n        caretPosition: CaretPosition(innerMost, 0)\n      };\n    };\n    const replaceWithCaretFormat = (targetNode, formatNodes) => {\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\n      before$3(SugarElement.fromDom(targetNode), caretContainer);\n      remove$5(SugarElement.fromDom(targetNode));\n      return caretPosition;\n    };\n    const createCaretFormatAtStart$1 = (rng, formatNodes) => {\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\n      rng.insertNode(caretContainer.dom);\n      return caretPosition;\n    };\n    const isFormatElement = (editor, element) => {\n      if (isCaretNode(element.dom)) {\n        return false;\n      }\n      const inlineElements = editor.schema.getTextInlineElements();\n      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);\n    };\n\n    const postProcessHooks = {};\n    const isPre = matchNodeNames(['pre']);\n    const addPostProcessHook = (name, hook) => {\n      const hooks = postProcessHooks[name];\n      if (!hooks) {\n        postProcessHooks[name] = [];\n      }\n      postProcessHooks[name].push(hook);\n    };\n    const postProcess$1 = (name, editor) => {\n      if (has$2(postProcessHooks, name)) {\n        each$e(postProcessHooks[name], hook => {\n          hook(editor);\n        });\n      }\n    };\n    addPostProcessHook('pre', editor => {\n      const rng = editor.selection.getRng();\n      const hasPreSibling = blocks => pre => {\n        const prev = pre.previousSibling;\n        return isPre(prev) && contains$2(blocks, prev);\n      };\n      const joinPre = (pre1, pre2) => {\n        const sPre2 = SugarElement.fromDom(pre2);\n        const doc = documentOrOwner(sPre2).dom;\n        remove$5(sPre2);\n        append(SugarElement.fromDom(pre1), [\n          SugarElement.fromTag('br', doc),\n          SugarElement.fromTag('br', doc),\n          ...children$1(sPre2)\n        ]);\n      };\n      if (!rng.collapsed) {\n        const blocks = editor.selection.getSelectedBlocks();\n        const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));\n        each$e(preBlocks, pre => {\n          joinPre(pre.previousSibling, pre);\n        });\n      }\n    });\n\n    const listItemStyles = [\n      'fontWeight',\n      'fontStyle',\n      'color',\n      'fontSize',\n      'fontFamily'\n    ];\n    const hasListStyles = fmt => isObject(fmt.styles) && exists(keys(fmt.styles), name => contains$2(listItemStyles, name));\n    const findExpandedListItemFormat = formats => find$2(formats, fmt => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));\n    const getExpandedListItemFormat = (formatter, format) => {\n      const formatList = formatter.get(format);\n      return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();\n    };\n    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();\n    const isRngEndAtEndOfElement = (rng, elm) => {\n      return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(pos => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;\n    };\n    const isEditableListItem = dom => elm => isListItem$2(elm) && dom.isEditable(elm);\n    const getFullySelectedBlocks = selection => {\n      const blocks = selection.getSelectedBlocks();\n      const rng = selection.getRng();\n      if (selection.isCollapsed()) {\n        return [];\n      }\n      if (blocks.length === 1) {\n        return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];\n      } else {\n        const first = head(blocks).filter(elm => isRngStartAtStartOfElement(rng, elm)).toArray();\n        const last = last$3(blocks).filter(elm => isRngEndAtEndOfElement(rng, elm)).toArray();\n        const middle = blocks.slice(1, -1);\n        return first.concat(middle).concat(last);\n      }\n    };\n    const getFullySelectedListItems = selection => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));\n    const getPartiallySelectedListItems = selection => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));\n\n    const each$8 = Tools.each;\n    const isElementNode = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\n    const findElementSibling = (node, siblingName) => {\n      for (let sibling = node; sibling; sibling = sibling[siblingName]) {\n        if (isText$a(sibling) && isNotEmpty(sibling.data)) {\n          return node;\n        }\n        if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\n          return sibling;\n        }\n      }\n      return node;\n    };\n    const mergeSiblingsNodes = (editor, prev, next) => {\n      const elementUtils = ElementUtils(editor);\n      const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);\n      const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);\n      if (isPrevEditable && isNextEditable) {\n        const prevSibling = findElementSibling(prev, 'previousSibling');\n        const nextSibling = findElementSibling(next, 'nextSibling');\n        if (elementUtils.compare(prevSibling, nextSibling)) {\n          for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {\n            const tmpSibling = sibling;\n            sibling = sibling.nextSibling;\n            prevSibling.appendChild(tmpSibling);\n          }\n          editor.dom.remove(nextSibling);\n          Tools.each(Tools.grep(nextSibling.childNodes), node => {\n            prevSibling.appendChild(node);\n          });\n          return prevSibling;\n        }\n      }\n      return next;\n    };\n    const mergeSiblings = (editor, format, vars, node) => {\n      var _a;\n      if (node && format.merge_siblings !== false) {\n        const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;\n        mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));\n      }\n    };\n    const clearChildStyles = (dom, format, node) => {\n      if (format.clear_child_styles) {\n        const selector = format.links ? '*:not(a)' : '*';\n        each$8(dom.select(selector, node), childNode => {\n          if (isElementNode(childNode) && dom.isEditable(childNode)) {\n            each$8(format.styles, (_value, name) => {\n              dom.setStyle(childNode, name, '');\n            });\n          }\n        });\n      }\n    };\n    const processChildElements = (node, filter, process) => {\n      each$8(node.childNodes, node => {\n        if (isElementNode(node)) {\n          if (filter(node)) {\n            process(node);\n          }\n          if (node.hasChildNodes()) {\n            processChildElements(node, filter, process);\n          }\n        }\n      });\n    };\n    const unwrapEmptySpan = (dom, node) => {\n      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\n        dom.remove(node, true);\n      }\n    };\n    const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\n    const applyStyle = (dom, name, value) => node => {\n      dom.setStyle(node, name, value);\n      if (node.getAttribute('style') === '') {\n        node.removeAttribute('style');\n      }\n      unwrapEmptySpan(dom, node);\n    };\n\n    const removeResult = Adt.generate([\n      { keep: [] },\n      { rename: ['name'] },\n      { removed: [] }\n    ]);\n    const MCE_ATTR_RE = /^(src|href|style)$/;\n    const each$7 = Tools.each;\n    const isEq$2 = isEq$5;\n    const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\n    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\n    const getContainer = (ed, rng, start) => {\n      let container = rng[start ? 'startContainer' : 'endContainer'];\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\n      if (isElement$6(container)) {\n        const lastIdx = container.childNodes.length - 1;\n        if (!start && offset) {\n          offset--;\n        }\n        container = container.childNodes[offset > lastIdx ? lastIdx : offset];\n      }\n      if (isText$a(container) && start && offset >= container.data.length) {\n        container = new DomTreeWalker(container, ed.getBody()).next() || container;\n      }\n      if (isText$a(container) && !start && offset === 0) {\n        container = new DomTreeWalker(container, ed.getBody()).prev() || container;\n      }\n      return container;\n    };\n    const normalizeTableSelection = (node, start) => {\n      const prop = start ? 'firstChild' : 'lastChild';\n      const childNode = node[prop];\n      if (isTableCellOrRow(node) && childNode) {\n        if (node.nodeName === 'TR') {\n          return childNode[prop] || childNode;\n        } else {\n          return childNode;\n        }\n      }\n      return node;\n    };\n    const wrap$1 = (dom, node, name, attrs) => {\n      var _a;\n      const wrapper = dom.create(name, attrs);\n      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);\n      wrapper.appendChild(node);\n      return wrapper;\n    };\n    const wrapWithSiblings = (dom, node, next, name, attrs) => {\n      const start = SugarElement.fromDom(node);\n      const wrapper = SugarElement.fromDom(dom.create(name, attrs));\n      const siblings = next ? nextSiblings(start) : prevSiblings(start);\n      append(wrapper, siblings);\n      if (next) {\n        before$3(start, wrapper);\n        prepend(wrapper, start);\n      } else {\n        after$4(start, wrapper);\n        append$1(wrapper, start);\n      }\n      return wrapper.dom;\n    };\n    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\n    const removeNode = (ed, node, format) => {\n      const parentNode = node.parentNode;\n      let rootBlockElm;\n      const dom = ed.dom;\n      const forcedRootBlock = getForcedRootBlock(ed);\n      if (isBlockFormat(format)) {\n        if (parentNode === dom.getRoot()) {\n          if (!format.list_block || !isEq$2(node, format.list_block)) {\n            each$e(from(node.childNodes), node => {\n              if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\n                if (!rootBlockElm) {\n                  rootBlockElm = wrap$1(dom, node, forcedRootBlock);\n                  dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\n                } else {\n                  rootBlockElm.appendChild(node);\n                }\n              } else {\n                rootBlockElm = null;\n              }\n            });\n          }\n        }\n      }\n      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\n        return;\n      }\n      dom.remove(node, true);\n    };\n    const processFormatAttrOrStyle = (name, value, vars) => {\n      if (isNumber(name)) {\n        return {\n          name: value,\n          value: null\n        };\n      } else {\n        return {\n          name,\n          value: replaceVars(value, vars)\n        };\n      }\n    };\n    const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {\n      if (dom.getAttrib(elm, 'style') === '') {\n        elm.removeAttribute('style');\n        elm.removeAttribute('data-mce-style');\n      }\n    };\n    const removeStyles = (dom, elm, format, vars, compareNode) => {\n      let stylesModified = false;\n      each$7(format.styles, (value, name) => {\n        const {\n          name: styleName,\n          value: styleValue\n        } = processFormatAttrOrStyle(name, value, vars);\n        const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);\n        if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {\n          dom.setStyle(elm, styleName, '');\n        }\n        stylesModified = true;\n      });\n      if (stylesModified) {\n        removeEmptyStyleAttributeIfNeeded(dom, elm);\n      }\n    };\n    const removeListStyleFormats = (editor, name, vars) => {\n      if (name === 'removeformat') {\n        each$e(getPartiallySelectedListItems(editor.selection), li => {\n          each$e(listItemStyles, name => editor.dom.setStyle(li, name, ''));\n          removeEmptyStyleAttributeIfNeeded(editor.dom, li);\n        });\n      } else {\n        getExpandedListItemFormat(editor.formatter, name).each(liFmt => {\n          each$e(getPartiallySelectedListItems(editor.selection), li => removeStyles(editor.dom, li, liFmt, vars, null));\n        });\n      }\n    };\n    const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {\n      const dom = ed.dom;\n      const elementUtils = ElementUtils(ed);\n      const schema = ed.schema;\n      if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {\n        removeNode(ed, node, format);\n        return removeResult.removed();\n      }\n      if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {\n        return removeResult.keep();\n      }\n      if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\n        return removeResult.keep();\n      }\n      const elm = node;\n      const preserveAttributes = format.preserve_attributes;\n      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {\n        const attrsToPreserve = filter$5(dom.getAttribs(elm), attr => contains$2(preserveAttributes, attr.name.toLowerCase()));\n        dom.removeAllAttribs(elm);\n        each$e(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\n        if (attrsToPreserve.length > 0) {\n          return removeResult.rename('span');\n        }\n      }\n      if (format.remove !== 'all') {\n        removeStyles(dom, elm, format, vars, compareNode);\n        each$7(format.attributes, (value, name) => {\n          const {\n            name: attrName,\n            value: attrValue\n          } = processFormatAttrOrStyle(name, value, vars);\n          if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {\n            if (attrName === 'class') {\n              const currentValue = dom.getAttrib(elm, attrName);\n              if (currentValue) {\n                let valueOut = '';\n                each$e(currentValue.split(/\\s+/), cls => {\n                  if (/mce\\-\\w+/.test(cls)) {\n                    valueOut += (valueOut ? ' ' : '') + cls;\n                  }\n                });\n                if (valueOut) {\n                  dom.setAttrib(elm, attrName, valueOut);\n                  return;\n                }\n              }\n            }\n            if (MCE_ATTR_RE.test(attrName)) {\n              elm.removeAttribute('data-mce-' + attrName);\n            }\n            if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\n              elm.removeAttribute(attrName);\n              dom.setStyle(elm, 'list-style-type', 'none');\n              return;\n            }\n            if (attrName === 'class') {\n              elm.removeAttribute('className');\n            }\n            elm.removeAttribute(attrName);\n          }\n        });\n        each$7(format.classes, value => {\n          value = replaceVars(value, vars);\n          if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {\n            dom.removeClass(elm, value);\n          }\n        });\n        const attrs = dom.getAttribs(elm);\n        for (let i = 0; i < attrs.length; i++) {\n          const attrName = attrs[i].nodeName;\n          if (!elementUtils.isAttributeInternal(attrName)) {\n            return removeResult.keep();\n          }\n        }\n      }\n      if (format.remove !== 'none') {\n        removeNode(ed, elm, format);\n        return removeResult.removed();\n      }\n      return removeResult.keep();\n    };\n    const findFormatRoot = (editor, container, name, vars, similar) => {\n      let formatRoot;\n      if (container.parentNode) {\n        each$e(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\n          if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {\n            const format = matchNode(editor, parent, name, vars, similar);\n            if (format && format.split !== false) {\n              formatRoot = parent;\n            }\n          }\n        });\n      }\n      return formatRoot;\n    };\n    const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\n      const fragment = editor.dom.createFragment();\n      fragment.appendChild(clone);\n      return editor.dom.rename(clone, newName);\n    }, constant(null));\n    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\n      var _a, _b;\n      let lastClone;\n      let firstClone;\n      const dom = editor.dom;\n      if (formatRoot) {\n        const formatRootParent = formatRoot.parentNode;\n        for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\n          let clone = dom.clone(parent, false);\n          for (let i = 0; i < formatList.length; i++) {\n            clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);\n            if (clone === null) {\n              break;\n            }\n          }\n          if (clone) {\n            if (lastClone) {\n              clone.appendChild(lastClone);\n            }\n            if (!firstClone) {\n              firstClone = clone;\n            }\n            lastClone = clone;\n          }\n        }\n        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\n          container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;\n        }\n        if (lastClone && firstClone) {\n          (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);\n          firstClone.appendChild(target);\n          if (isInlineFormat(format)) {\n            mergeSiblings(editor, format, vars, lastClone);\n          }\n        }\n      }\n      return container;\n    };\n    const removeFormatInternal = (ed, name, vars, node, similar) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const splitToFormatRoot = container => {\n        const formatRoot = findFormatRoot(ed, container, name, vars, similar);\n        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\n      };\n      const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\n      const removeFormatOnNode = node => exists(formatList, fmt => removeNodeFormat(ed, fmt, vars, node, node));\n      const process = node => {\n        const children = from(node.childNodes);\n        const removed = removeFormatOnNode(node);\n        const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\n        const parentNode = node.parentNode;\n        if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n          removeFormatOnNode(parentNode);\n        }\n        if (format.deep) {\n          if (children.length) {\n            for (let i = 0; i < children.length; i++) {\n              process(children[i]);\n            }\n          }\n        }\n        const textDecorations = [\n          'underline',\n          'line-through',\n          'overline'\n        ];\n        each$e(textDecorations, decoration => {\n          if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\n            removeNodeFormat(ed, {\n              deep: false,\n              exact: true,\n              inline: 'span',\n              styles: { textDecoration: decoration }\n            }, undefined, node);\n          }\n        });\n      };\n      const unwrap = start => {\n        const node = dom.get(start ? '_start' : '_end');\n        if (node) {\n          let out = node[start ? 'firstChild' : 'lastChild'];\n          if (isRemoveBookmarkNode(out)) {\n            out = out[start ? 'firstChild' : 'lastChild'];\n          }\n          if (isText$a(out) && out.data.length === 0) {\n            out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\n          }\n          dom.remove(node, true);\n          return out;\n        } else {\n          return null;\n        }\n      };\n      const removeRngStyle = rng => {\n        let startContainer;\n        let endContainer;\n        let expandedRng = expandRng(dom, rng, formatList, rng.collapsed);\n        if (format.split) {\n          expandedRng = split(expandedRng);\n          startContainer = getContainer(ed, expandedRng, true);\n          endContainer = getContainer(ed, expandedRng);\n          if (startContainer !== endContainer) {\n            startContainer = normalizeTableSelection(startContainer, true);\n            endContainer = normalizeTableSelection(endContainer, false);\n            if (isChildOfInlineParent(dom, startContainer, endContainer)) {\n              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\n                'id': '_start',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(true);\n              return;\n            }\n            if (isChildOfInlineParent(dom, endContainer, startContainer)) {\n              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\n              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\n                'id': '_end',\n                'data-mce-type': 'bookmark'\n              }));\n              unwrap(false);\n              return;\n            }\n            startContainer = wrap$1(dom, startContainer, 'span', {\n              'id': '_start',\n              'data-mce-type': 'bookmark'\n            });\n            endContainer = wrap$1(dom, endContainer, 'span', {\n              'id': '_end',\n              'data-mce-type': 'bookmark'\n            });\n            const newRng = dom.createRng();\n            newRng.setStartAfter(startContainer);\n            newRng.setEndBefore(endContainer);\n            walk$3(dom, newRng, nodes => {\n              each$e(nodes, n => {\n                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\n                  splitToFormatRoot(n);\n                }\n              });\n            });\n            splitToFormatRoot(startContainer);\n            splitToFormatRoot(endContainer);\n            startContainer = unwrap(true);\n            endContainer = unwrap();\n          } else {\n            startContainer = endContainer = splitToFormatRoot(startContainer);\n          }\n          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\n          expandedRng.startOffset = dom.nodeIndex(startContainer);\n          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\n          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\n        }\n        walk$3(dom, expandedRng, nodes => {\n          each$e(nodes, process);\n        });\n      };\n      if (node) {\n        if (isNode(node)) {\n          const rng = dom.createRng();\n          rng.setStartBefore(node);\n          rng.setEndAfter(node);\n          removeRngStyle(rng);\n        } else {\n          removeRngStyle(node);\n        }\n        fireFormatRemove(ed, name, node, vars);\n        return;\n      }\n      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n        preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), startNode => isInlineFormat(format) && match$2(ed, name, vars, startNode));\n        ed.nodeChanged();\n      } else {\n        removeCaretFormat(ed, name, vars, similar);\n      }\n      removeListStyleFormats(ed, name, vars);\n      fireFormatRemove(ed, name, node, vars);\n    };\n    const removeFormat$1 = (ed, name, vars, node, similar) => {\n      if (node || ed.selection.isEditable()) {\n        removeFormatInternal(ed, name, vars, node, similar);\n      }\n    };\n    const removeNodeFormat = (editor, format, vars, node, compareNode) => {\n      return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, newName => {\n        editor.dom.rename(node, newName);\n        return true;\n      }, always);\n    };\n\n    const each$6 = Tools.each;\n    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\n      const processTextDecorationsAndColor = n => {\n        if (isHTMLElement(n) && isElement$6(n.parentNode) && dom.isEditable(n)) {\n          const parentTextDecoration = getTextDecoration(dom, n.parentNode);\n          if (dom.getStyle(n, 'color') && parentTextDecoration) {\n            dom.setStyle(n, 'text-decoration', parentTextDecoration);\n          } else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {\n            dom.setStyle(n, 'text-decoration', null);\n          }\n        }\n      };\n      if (format.styles && (format.styles.color || format.styles.textDecoration)) {\n        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\n        processTextDecorationsAndColor(node);\n      }\n    };\n    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\n      if (format.styles && format.styles.backgroundColor) {\n        const hasFontSize = hasStyle(dom, 'fontSize');\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\n      }\n    };\n    const mergeSubSup = (dom, format, vars, node) => {\n      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\n        const hasFontSize = hasStyle(dom, 'fontSize');\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'fontSize', ''));\n        const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), dom.isEditable);\n        dom.remove(inverseTagDescendants, true);\n      }\n    };\n    const mergeWithChildren = (editor, formatList, vars, node) => {\n      each$6(formatList, format => {\n        if (isInlineFormat(format)) {\n          each$6(editor.dom.select(format.inline, node), child => {\n            if (isElementNode(child)) {\n              removeNodeFormat(editor, format, vars, child, format.exact ? child : null);\n            }\n          });\n        }\n        clearChildStyles(editor.dom, format, node);\n      });\n    };\n    const mergeWithParents = (editor, format, name, vars, node) => {\n      const parentNode = node.parentNode;\n      if (matchNode(editor, parentNode, name, vars)) {\n        if (removeNodeFormat(editor, format, vars, node)) {\n          return;\n        }\n      }\n      if (format.merge_with_parents && parentNode) {\n        editor.dom.getParent(parentNode, parent => {\n          if (matchNode(editor, parent, name, vars)) {\n            removeNodeFormat(editor, format, vars, node);\n            return true;\n          } else {\n            return false;\n          }\n        });\n      }\n    };\n\n    const each$5 = Tools.each;\n    const canFormatBR = (editor, format, node, parentName) => {\n      if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {\n        const validBRParentElements = getTextRootBlockElements(editor.schema);\n        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\n        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;\n      } else {\n        return false;\n      }\n    };\n    const applyStyles = (dom, elm, format, vars) => {\n      each$5(format.styles, (value, name) => {\n        dom.setStyle(elm, name, replaceVars(value, vars));\n      });\n      if (format.styles) {\n        const styleVal = dom.getAttrib(elm, 'style');\n        if (styleVal) {\n          dom.setAttrib(elm, 'data-mce-style', styleVal);\n        }\n      }\n    };\n    const applyFormatAction = (ed, name, vars, node) => {\n      const formatList = ed.formatter.get(name);\n      const format = formatList[0];\n      const isCollapsed = !node && ed.selection.isCollapsed();\n      const dom = ed.dom;\n      const selection = ed.selection;\n      const setElementFormat = (elm, fmt = format) => {\n        if (isFunction(fmt.onformat)) {\n          fmt.onformat(elm, fmt, vars, node);\n        }\n        applyStyles(dom, elm, fmt, vars);\n        each$5(fmt.attributes, (value, name) => {\n          dom.setAttrib(elm, name, replaceVars(value, vars));\n        });\n        each$5(fmt.classes, value => {\n          const newValue = replaceVars(value, vars);\n          if (!dom.hasClass(elm, newValue)) {\n            dom.addClass(elm, newValue);\n          }\n        });\n      };\n      const applyNodeStyle = (formatList, node) => {\n        let found = false;\n        each$5(formatList, format => {\n          if (!isSelectorFormat(format)) {\n            return false;\n          }\n          if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {\n            return true;\n          }\n          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\n            return true;\n          }\n          if (dom.is(node, format.selector) && !isCaretNode(node)) {\n            setElementFormat(node, format);\n            found = true;\n            return false;\n          }\n          return true;\n        });\n        return found;\n      };\n      const createWrapElement = wrapName => {\n        if (isString(wrapName)) {\n          const wrapElm = dom.create(wrapName);\n          setElementFormat(wrapElm);\n          return wrapElm;\n        } else {\n          return null;\n        }\n      };\n      const applyRngStyle = (dom, rng, nodeSpecific) => {\n        const newWrappers = [];\n        let contentEditable = true;\n        const wrapName = format.inline || format.block;\n        const wrapElm = createWrapElement(wrapName);\n        const isMatchingWrappingBlock = node => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);\n        const canRenameBlock = (node, parentName, isEditableDescendant) => {\n          const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node) && isValid(ed, parentName, wrapName);\n          return isEditableDescendant && isValidBlockFormatForNode;\n        };\n        const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {\n          const nodeName = node.nodeName.toLowerCase();\n          const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);\n          const isZwsp = !nodeSpecific && isText$a(node) && isZwsp$1(node.data);\n          const isCaret = isCaretNode(node);\n          const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);\n          return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp && !isCaret && isCorrectFormatForNode;\n        };\n        walk$3(dom, rng, nodes => {\n          let currentWrapElm;\n          const process = node => {\n            let hasContentEditableState = false;\n            let lastContentEditable = contentEditable;\n            let isWrappableNoneditableElm = false;\n            const parentNode = node.parentNode;\n            const parentName = parentNode.nodeName.toLowerCase();\n            const contentEditableValue = dom.getContentEditable(node);\n            if (isNonNullable(contentEditableValue)) {\n              lastContentEditable = contentEditable;\n              contentEditable = contentEditableValue === 'true';\n              hasContentEditableState = true;\n              isWrappableNoneditableElm = isWrappableNoneditable(ed, node);\n            }\n            const isEditableDescendant = contentEditable && !hasContentEditableState;\n            if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {\n              currentWrapElm = null;\n              if (isBlockFormat(format)) {\n                dom.remove(node);\n              }\n              return;\n            }\n            if (isMatchingWrappingBlock(node)) {\n              currentWrapElm = null;\n              return;\n            }\n            if (canRenameBlock(node, parentName, isEditableDescendant)) {\n              const elm = dom.rename(node, wrapName);\n              setElementFormat(elm);\n              newWrappers.push(elm);\n              currentWrapElm = null;\n              return;\n            }\n            if (isSelectorFormat(format)) {\n              let found = applyNodeStyle(formatList, node);\n              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\n                found = applyNodeStyle(formatList, parentNode);\n              }\n              if (!isInlineFormat(format) || found) {\n                currentWrapElm = null;\n                return;\n              }\n            }\n            if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {\n              if (!currentWrapElm) {\n                currentWrapElm = dom.clone(wrapElm, false);\n                parentNode.insertBefore(currentWrapElm, node);\n                newWrappers.push(currentWrapElm);\n              }\n              if (isWrappableNoneditableElm && hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm.appendChild(node);\n            } else {\n              currentWrapElm = null;\n              each$e(from(node.childNodes), process);\n              if (hasContentEditableState) {\n                contentEditable = lastContentEditable;\n              }\n              currentWrapElm = null;\n            }\n          };\n          each$e(nodes, process);\n        });\n        if (format.links === true) {\n          each$e(newWrappers, node => {\n            const process = node => {\n              if (node.nodeName === 'A') {\n                setElementFormat(node, format);\n              }\n              each$e(from(node.childNodes), process);\n            };\n            process(node);\n          });\n        }\n        each$e(newWrappers, node => {\n          const getChildCount = node => {\n            let count = 0;\n            each$e(node.childNodes, node => {\n              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\n                count++;\n              }\n            });\n            return count;\n          };\n          const mergeStyles = node => {\n            const childElement = find$2(node.childNodes, isElementNode$1).filter(child => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));\n            return childElement.map(child => {\n              const clone = dom.clone(child, false);\n              setElementFormat(clone);\n              dom.replace(clone, node, true);\n              dom.remove(child, true);\n              return clone;\n            }).getOr(node);\n          };\n          const childCount = getChildCount(node);\n          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\n            dom.remove(node, true);\n            return;\n          }\n          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\n            if (!format.exact && childCount === 1) {\n              node = mergeStyles(node);\n            }\n            mergeWithChildren(ed, formatList, vars, node);\n            mergeWithParents(ed, format, name, vars, node);\n            mergeBackgroundColorAndFontSize(dom, format, vars, node);\n            mergeTextDecorationsAndColor(dom, format, vars, node);\n            mergeSubSup(dom, format, vars, node);\n            mergeSiblings(ed, format, vars, node);\n          }\n        });\n      };\n      const targetNode = isNode(node) ? node : selection.getNode();\n      if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {\n        node = targetNode;\n        applyNodeStyle(formatList, node);\n        fireFormatApply(ed, name, node, vars);\n        return;\n      }\n      if (format) {\n        if (node) {\n          if (isNode(node)) {\n            if (!applyNodeStyle(formatList, node)) {\n              const rng = dom.createRng();\n              rng.setStartBefore(node);\n              rng.setEndAfter(node);\n              applyRngStyle(dom, expandRng(dom, rng, formatList), true);\n            }\n          } else {\n            applyRngStyle(dom, node, true);\n          }\n        } else {\n          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\n            selection.setRng(normalize(selection.getRng()));\n            preserveSelection(ed, () => {\n              runOnRanges(ed, (selectionRng, fake) => {\n                const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);\n                applyRngStyle(dom, expandedRng, false);\n              });\n            }, always);\n            ed.nodeChanged();\n          } else {\n            applyCaretFormat(ed, name, vars);\n          }\n          getExpandedListItemFormat(ed.formatter, name).each(liFmt => {\n            each$e(getFullySelectedListItems(ed.selection), li => applyStyles(dom, li, liFmt, vars));\n          });\n        }\n        postProcess$1(name, ed);\n      }\n      fireFormatApply(ed, name, node, vars);\n    };\n    const applyFormat$1 = (editor, name, vars, node) => {\n      if (node || editor.selection.isEditable()) {\n        applyFormatAction(editor, name, vars, node);\n      }\n    };\n\n    const hasVars = value => has$2(value, 'vars');\n    const setup$u = (registeredFormatListeners, editor) => {\n      registeredFormatListeners.set({});\n      editor.on('NodeChange', e => {\n        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\n      });\n      editor.on('FormatApply FormatRemove', e => {\n        const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\n        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\n      });\n    };\n    const fallbackElement = editor => editor.selection.getStart();\n    const matchingNode = (editor, parents, format, similar, vars) => {\n      const isMatchingNode = node => {\n        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\n        return !isUndefined(matchingFormat);\n      };\n      const isUnableToMatch = node => {\n        if (matchesUnInheritedFormatSelector(editor, node, format)) {\n          return true;\n        } else {\n          if (!similar) {\n            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\n          } else {\n            return false;\n          }\n        }\n      };\n      return findUntil$1(parents, isMatchingNode, isUnableToMatch);\n    };\n    const getParents = (editor, elm) => {\n      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\n      return filter$5(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$2(node));\n    };\n    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\n      const parents = getParents(editor, elm);\n      each$d(registeredCallbacks, (data, format) => {\n        const runIfChanged = spec => {\n          const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\n          const isSet = match.isSome();\n          if (spec.state.get() !== isSet) {\n            spec.state.set(isSet);\n            const node = match.getOr(elm);\n            if (hasVars(spec)) {\n              spec.callback(isSet, {\n                node,\n                format,\n                parents\n              });\n            } else {\n              each$e(spec.callbacks, callback => callback(isSet, {\n                node,\n                format,\n                parents\n              }));\n            }\n          }\n        };\n        each$e([\n          data.withSimilar,\n          data.withoutSimilar\n        ], runIfChanged);\n        each$e(data.withVars, runIfChanged);\n      });\n    };\n    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$e(formats.split(','), format => {\n        const group = get$a(formatChangeItems, format).getOrThunk(() => {\n          const base = {\n            withSimilar: {\n              state: Cell(false),\n              similar: true,\n              callbacks: []\n            },\n            withoutSimilar: {\n              state: Cell(false),\n              similar: false,\n              callbacks: []\n            },\n            withVars: []\n          };\n          formatChangeItems[format] = base;\n          return base;\n        });\n        const getCurrent = () => {\n          const parents = getParents(editor);\n          return matchingNode(editor, parents, format, similar, vars).isSome();\n        };\n        if (isUndefined(vars)) {\n          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\n          toAppendTo.callbacks.push(callback);\n          if (toAppendTo.callbacks.length === 1) {\n            toAppendTo.state.set(getCurrent());\n          }\n        } else {\n          group.withVars.push({\n            state: Cell(getCurrent()),\n            similar,\n            vars,\n            callback\n          });\n        }\n      });\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const removeListeners = (registeredFormatListeners, formats, callback) => {\n      const formatChangeItems = registeredFormatListeners.get();\n      each$e(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\n        formatChangeItems[format] = {\n          withSimilar: {\n            ...group.withSimilar,\n            callbacks: filter$5(group.withSimilar.callbacks, cb => cb !== callback)\n          },\n          withoutSimilar: {\n            ...group.withoutSimilar,\n            callbacks: filter$5(group.withoutSimilar.callbacks, cb => cb !== callback)\n          },\n          withVars: filter$5(group.withVars, item => item.callback !== callback)\n        };\n      }));\n      registeredFormatListeners.set(formatChangeItems);\n    };\n    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\n      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\n      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };\n    };\n\n    const toggle = (editor, name, vars, node) => {\n      const fmt = editor.formatter.get(name);\n      if (fmt) {\n        if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\n          removeFormat$1(editor, name, vars, node);\n        } else {\n          applyFormat$1(editor, name, vars, node);\n        }\n      }\n    };\n\n    const explode$1 = Tools.explode;\n    const create$8 = () => {\n      const filters = {};\n      const addFilter = (name, callback) => {\n        each$e(explode$1(name), name => {\n          if (!has$2(filters, name)) {\n            filters[name] = {\n              name,\n              callbacks: []\n            };\n          }\n          filters[name].callbacks.push(callback);\n        });\n      };\n      const getFilters = () => values(filters);\n      const removeFilter = (name, callback) => {\n        each$e(explode$1(name), name => {\n          if (has$2(filters, name)) {\n            if (isNonNullable(callback)) {\n              const filter = filters[name];\n              const newCallbacks = filter$5(filter.callbacks, c => c !== callback);\n              if (newCallbacks.length > 0) {\n                filter.callbacks = newCallbacks;\n              } else {\n                delete filters[name];\n              }\n            } else {\n              delete filters[name];\n            }\n          }\n        });\n      };\n      return {\n        addFilter,\n        getFilters,\n        removeFilter\n      };\n    };\n\n    const removeAttrs = (node, names) => {\n      each$e(names, name => {\n        node.attr(name, null);\n      });\n    };\n    const addFontToSpansFilter = (domParser, styles, fontSizes) => {\n      domParser.addNodeFilter('font', nodes => {\n        each$e(nodes, node => {\n          const props = styles.parse(node.attr('style'));\n          const color = node.attr('color');\n          const face = node.attr('face');\n          const size = node.attr('size');\n          if (color) {\n            props.color = color;\n          }\n          if (face) {\n            props['font-family'] = face;\n          }\n          if (size) {\n            toInt(size).each(num => {\n              props['font-size'] = fontSizes[num - 1];\n            });\n          }\n          node.name = 'span';\n          node.attr('style', styles.serialize(props));\n          removeAttrs(node, [\n            'color',\n            'face',\n            'size'\n          ]);\n        });\n      });\n    };\n    const addStrikeFilter = (domParser, schema, styles) => {\n      domParser.addNodeFilter('strike', nodes => {\n        const convertToSTag = schema.type !== 'html4';\n        each$e(nodes, node => {\n          if (convertToSTag) {\n            node.name = 's';\n          } else {\n            const props = styles.parse(node.attr('style'));\n            props['text-decoration'] = 'line-through';\n            node.name = 'span';\n            node.attr('style', styles.serialize(props));\n          }\n        });\n      });\n    };\n    const addFilters = (domParser, settings, schema) => {\n      var _a;\n      const styles = Styles();\n      if (settings.convert_fonts_to_spans) {\n        addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));\n      }\n      addStrikeFilter(domParser, schema, styles);\n    };\n    const register$5 = (domParser, settings, schema) => {\n      if (settings.inline_styles) {\n        addFilters(domParser, settings, schema);\n      }\n    };\n\n    const addNodeFilter = (settings, htmlParser, schema) => {\n      htmlParser.addNodeFilter('br', (nodes, _, args) => {\n        const blockElements = Tools.extend({}, schema.getBlockElements());\n        const nonEmptyElements = schema.getNonEmptyElements();\n        const whitespaceElements = schema.getWhitespaceElements();\n        blockElements.body = 1;\n        const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node);\n        for (let i = 0, l = nodes.length; i < l; i++) {\n          let node = nodes[i];\n          let parent = node.parent;\n          if (parent && isBlock(parent) && node === parent.lastChild) {\n            let prev = node.prev;\n            while (prev) {\n              const prevName = prev.name;\n              if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\n                if (prevName === 'br') {\n                  node = null;\n                }\n                break;\n              }\n              prev = prev.prev;\n            }\n            if (node) {\n              node.remove();\n              if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\n                const elementRule = schema.getElementRule(parent.name);\n                if (elementRule) {\n                  if (elementRule.removeEmpty) {\n                    parent.remove();\n                  } else if (elementRule.paddEmpty) {\n                    paddEmptyNode(settings, args, isBlock, parent);\n                  }\n                }\n              }\n            }\n          } else {\n            let lastParent = node;\n            while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\n              lastParent = parent;\n              if (blockElements[parent.name]) {\n                break;\n              }\n              parent = parent.parent;\n            }\n            if (lastParent === parent) {\n              const textNode = new AstNode('#text', 3);\n              textNode.value = nbsp;\n              node.replace(textNode);\n            }\n          }\n        }\n      });\n    };\n\n    const blobUriToBlob = url => fetch(url).then(res => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({\n      message: `Cannot convert ${ url } to Blob. Resource might not exist or is inaccessible.`,\n      uriType: 'blob'\n    }));\n    const extractBase64Data = data => {\n      const matches = /([a-z0-9+\\/=\\s]+)/i.exec(data);\n      return matches ? matches[1] : '';\n    };\n    const parseDataUri = uri => {\n      const [type, ...rest] = uri.split(',');\n      const data = rest.join(',');\n      const matches = /data:([^/]+\\/[^;]+)(;.+)?/.exec(type);\n      if (matches) {\n        const base64Encoded = matches[2] === ';base64';\n        const extractedData = base64Encoded ? extractBase64Data(data) : decodeURIComponent(data);\n        return Optional.some({\n          type: matches[1],\n          data: extractedData,\n          base64Encoded\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const buildBlob = (type, data, base64Encoded = true) => {\n      let str = data;\n      if (base64Encoded) {\n        try {\n          str = atob(data);\n        } catch (e) {\n          return Optional.none();\n        }\n      }\n      const arr = new Uint8Array(str.length);\n      for (let i = 0; i < arr.length; i++) {\n        arr[i] = str.charCodeAt(i);\n      }\n      return Optional.some(new Blob([arr], { type }));\n    };\n    const dataUriToBlob = uri => {\n      return new Promise((resolve, reject) => {\n        parseDataUri(uri).bind(({type, data, base64Encoded}) => buildBlob(type, data, base64Encoded)).fold(() => reject('Invalid data URI'), resolve);\n      });\n    };\n    const uriToBlob = url => {\n      if (startsWith(url, 'blob:')) {\n        return blobUriToBlob(url);\n      } else if (startsWith(url, 'data:')) {\n        return dataUriToBlob(url);\n      } else {\n        return Promise.reject('Unknown URI format');\n      }\n    };\n    const blobToDataUri = blob => {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n          resolve(reader.result);\n        };\n        reader.onerror = () => {\n          var _a;\n          reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);\n        };\n        reader.readAsDataURL(blob);\n      });\n    };\n\n    let count$1 = 0;\n    const uniqueId$1 = prefix => {\n      return (prefix || 'blobid') + count$1++;\n    };\n    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {\n      return parseDataUri(dataUri).bind(({data, type, base64Encoded}) => {\n        if (base64Only && !base64Encoded) {\n          return Optional.none();\n        } else {\n          const base64 = base64Encoded ? data : btoa(data);\n          return generateBlobInfo(base64, type);\n        }\n      });\n    };\n    const createBlobInfo$1 = (blobCache, blob, base64) => {\n      const blobInfo = blobCache.create(uniqueId$1(), blob, base64);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {\n      return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map(blob => createBlobInfo$1(blobCache, blob, base64))));\n    };\n    const imageToBlobInfo = (blobCache, imageSrc) => {\n      const invalidDataUri = () => Promise.reject('Invalid data URI');\n      if (startsWith(imageSrc, 'blob:')) {\n        const blobInfo = blobCache.getByUri(imageSrc);\n        if (isNonNullable(blobInfo)) {\n          return Promise.resolve(blobInfo);\n        } else {\n          return uriToBlob(imageSrc).then(blob => {\n            return blobToDataUri(blob).then(dataUri => {\n              return processDataUri(dataUri, false, base64 => {\n                return Optional.some(createBlobInfo$1(blobCache, blob, base64));\n              }).getOrThunk(invalidDataUri);\n            });\n          });\n        }\n      } else if (startsWith(imageSrc, 'data:')) {\n        return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, blobInfo => Promise.resolve(blobInfo));\n      } else {\n        return Promise.reject('Unknown image data format');\n      }\n    };\n\n    const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\n    const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\n    const registerBase64ImageFilter = (parser, settings) => {\n      const {blob_cache: blobCache} = settings;\n      if (blobCache) {\n        const processImage = img => {\n          const inputSrc = img.attr('src');\n          if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {\n            return;\n          }\n          dataUriToBlobInfo(blobCache, inputSrc, true).each(blobInfo => {\n            img.attr('src', blobInfo.blobUri());\n          });\n        };\n        parser.addAttributeFilter('src', nodes => each$e(nodes, processImage));\n      }\n    };\n    const isMimeType = (mime, type) => startsWith(mime, `${ type }/`);\n    const createSafeEmbed = (mime, src, width, height, sandboxIframes) => {\n      let name;\n      if (isUndefined(mime)) {\n        name = 'iframe';\n      } else if (isMimeType(mime, 'image')) {\n        name = 'img';\n      } else if (isMimeType(mime, 'video')) {\n        name = 'video';\n      } else if (isMimeType(mime, 'audio')) {\n        name = 'audio';\n      } else {\n        name = 'iframe';\n      }\n      const embed = new AstNode(name, 1);\n      embed.attr(name === 'audio' ? { src } : {\n        src,\n        width,\n        height\n      });\n      if (name === 'audio' || name === 'video') {\n        embed.attr('controls', '');\n      }\n      if (name === 'iframe' && sandboxIframes) {\n        embed.attr('sandbox', '');\n      }\n      return embed;\n    };\n    const register$4 = (parser, settings) => {\n      const schema = parser.schema;\n      if (settings.remove_trailing_brs) {\n        addNodeFilter(settings, parser, schema);\n      }\n      parser.addAttributeFilter('href', nodes => {\n        let i = nodes.length;\n        const appendRel = rel => {\n          const parts = rel.split(' ').filter(p => p.length > 0);\n          return parts.concat(['noopener']).sort().join(' ');\n        };\n        const addNoOpener = rel => {\n          const newRel = rel ? Tools.trim(rel) : '';\n          if (!/\\b(noopener)\\b/g.test(newRel)) {\n            return appendRel(newRel);\n          } else {\n            return newRel;\n          }\n        };\n        if (!settings.allow_unsafe_link_target) {\n          while (i--) {\n            const node = nodes[i];\n            if (node.name === 'a' && node.attr('target') === '_blank') {\n              node.attr('rel', addNoOpener(node.attr('rel')));\n            }\n          }\n        }\n      });\n      if (!settings.allow_html_in_named_anchor) {\n        parser.addAttributeFilter('id,name', nodes => {\n          let i = nodes.length, sibling, prevSibling, parent, node;\n          while (i--) {\n            node = nodes[i];\n            if (node.name === 'a' && node.firstChild && !node.attr('href')) {\n              parent = node.parent;\n              sibling = node.lastChild;\n              while (sibling && parent) {\n                prevSibling = sibling.prev;\n                parent.insert(sibling, node);\n                sibling = prevSibling;\n              }\n            }\n          }\n        });\n      }\n      if (settings.fix_list_elements) {\n        parser.addNodeFilter('ul,ol', nodes => {\n          let i = nodes.length, node, parentNode;\n          while (i--) {\n            node = nodes[i];\n            parentNode = node.parent;\n            if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {\n              if (node.prev && node.prev.name === 'li') {\n                node.prev.append(node);\n              } else {\n                const li = new AstNode('li', 1);\n                li.attr('style', 'list-style-type: none');\n                node.wrap(li);\n              }\n            }\n          }\n        });\n      }\n      const validClasses = schema.getValidClasses();\n      if (settings.validate && validClasses) {\n        parser.addAttributeFilter('class', nodes => {\n          var _a;\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';\n            const classList = Tools.explode(clazz, ' ');\n            let classValue = '';\n            for (let ci = 0; ci < classList.length; ci++) {\n              const className = classList[ci];\n              let valid = false;\n              let validClassesMap = validClasses['*'];\n              if (validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              validClassesMap = validClasses[node.name];\n              if (!valid && validClassesMap && validClassesMap[className]) {\n                valid = true;\n              }\n              if (valid) {\n                if (classValue) {\n                  classValue += ' ';\n                }\n                classValue += className;\n              }\n            }\n            if (!classValue.length) {\n              classValue = null;\n            }\n            node.attr('class', classValue);\n          }\n        });\n      }\n      registerBase64ImageFilter(parser, settings);\n      if (settings.convert_unsafe_embeds) {\n        parser.addNodeFilter('object,embed', nodes => each$e(nodes, node => {\n          node.replace(createSafeEmbed(node.attr('type'), node.name === 'object' ? node.attr('data') : node.attr('src'), node.attr('width'), node.attr('height'), settings.sandbox_iframes));\n        }));\n      }\n      if (settings.sandbox_iframes) {\n        parser.addNodeFilter('iframe', nodes => each$e(nodes, node => node.attr('sandbox', '')));\n      }\n    };\n\n    const {entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor} = Object;\n    let {freeze, seal, create: create$7} = Object;\n    let {apply, construct} = typeof Reflect !== 'undefined' && Reflect;\n    if (!apply) {\n      apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n      };\n    }\n    if (!freeze) {\n      freeze = function freeze(x) {\n        return x;\n      };\n    }\n    if (!seal) {\n      seal = function seal(x) {\n        return x;\n      };\n    }\n    if (!construct) {\n      construct = function construct(Func, args) {\n        return new Func(...args);\n      };\n    }\n    const arrayForEach = unapply(Array.prototype.forEach);\n    const arrayPop = unapply(Array.prototype.pop);\n    const arrayPush = unapply(Array.prototype.push);\n    const stringToLowerCase = unapply(String.prototype.toLowerCase);\n    const stringToString = unapply(String.prototype.toString);\n    const stringMatch = unapply(String.prototype.match);\n    const stringReplace = unapply(String.prototype.replace);\n    const stringIndexOf = unapply(String.prototype.indexOf);\n    const stringTrim = unapply(String.prototype.trim);\n    const regExpTest = unapply(RegExp.prototype.test);\n    const typeErrorCreate = unconstruct(TypeError);\n    function unapply(func) {\n      return function (thisArg) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n        return apply(func, thisArg, args);\n      };\n    }\n    function unconstruct(func) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return construct(func, args);\n      };\n    }\n    function addToSet(set, array, transformCaseFunc) {\n      var _transformCaseFunc;\n      transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\n      if (setPrototypeOf) {\n        setPrototypeOf(set, null);\n      }\n      let l = array.length;\n      while (l--) {\n        let element = array[l];\n        if (typeof element === 'string') {\n          const lcElement = transformCaseFunc(element);\n          if (lcElement !== element) {\n            if (!isFrozen(array)) {\n              array[l] = lcElement;\n            }\n            element = lcElement;\n          }\n        }\n        set[element] = true;\n      }\n      return set;\n    }\n    function clone(object) {\n      const newObject = create$7(null);\n      for (const [property, value] of entries(object)) {\n        newObject[property] = value;\n      }\n      return newObject;\n    }\n    function lookupGetter(object, prop) {\n      while (object !== null) {\n        const desc = getOwnPropertyDescriptor(object, prop);\n        if (desc) {\n          if (desc.get) {\n            return unapply(desc.get);\n          }\n          if (typeof desc.value === 'function') {\n            return unapply(desc.value);\n          }\n        }\n        object = getPrototypeOf(object);\n      }\n      function fallbackValue(element) {\n        console.warn('fallback value for', element);\n        return null;\n      }\n      return fallbackValue;\n    }\n    const html$1 = freeze([\n      'a',\n      'abbr',\n      'acronym',\n      'address',\n      'area',\n      'article',\n      'aside',\n      'audio',\n      'b',\n      'bdi',\n      'bdo',\n      'big',\n      'blink',\n      'blockquote',\n      'body',\n      'br',\n      'button',\n      'canvas',\n      'caption',\n      'center',\n      'cite',\n      'code',\n      'col',\n      'colgroup',\n      'content',\n      'data',\n      'datalist',\n      'dd',\n      'decorator',\n      'del',\n      'details',\n      'dfn',\n      'dialog',\n      'dir',\n      'div',\n      'dl',\n      'dt',\n      'element',\n      'em',\n      'fieldset',\n      'figcaption',\n      'figure',\n      'font',\n      'footer',\n      'form',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'head',\n      'header',\n      'hgroup',\n      'hr',\n      'html',\n      'i',\n      'img',\n      'input',\n      'ins',\n      'kbd',\n      'label',\n      'legend',\n      'li',\n      'main',\n      'map',\n      'mark',\n      'marquee',\n      'menu',\n      'menuitem',\n      'meter',\n      'nav',\n      'nobr',\n      'ol',\n      'optgroup',\n      'option',\n      'output',\n      'p',\n      'picture',\n      'pre',\n      'progress',\n      'q',\n      'rp',\n      'rt',\n      'ruby',\n      's',\n      'samp',\n      'section',\n      'select',\n      'shadow',\n      'small',\n      'source',\n      'spacer',\n      'span',\n      'strike',\n      'strong',\n      'style',\n      'sub',\n      'summary',\n      'sup',\n      'table',\n      'tbody',\n      'td',\n      'template',\n      'textarea',\n      'tfoot',\n      'th',\n      'thead',\n      'time',\n      'tr',\n      'track',\n      'tt',\n      'u',\n      'ul',\n      'var',\n      'video',\n      'wbr'\n    ]);\n    const svg$1 = freeze([\n      'svg',\n      'a',\n      'altglyph',\n      'altglyphdef',\n      'altglyphitem',\n      'animatecolor',\n      'animatemotion',\n      'animatetransform',\n      'circle',\n      'clippath',\n      'defs',\n      'desc',\n      'ellipse',\n      'filter',\n      'font',\n      'g',\n      'glyph',\n      'glyphref',\n      'hkern',\n      'image',\n      'line',\n      'lineargradient',\n      'marker',\n      'mask',\n      'metadata',\n      'mpath',\n      'path',\n      'pattern',\n      'polygon',\n      'polyline',\n      'radialgradient',\n      'rect',\n      'stop',\n      'style',\n      'switch',\n      'symbol',\n      'text',\n      'textpath',\n      'title',\n      'tref',\n      'tspan',\n      'view',\n      'vkern'\n    ]);\n    const svgFilters = freeze([\n      'feBlend',\n      'feColorMatrix',\n      'feComponentTransfer',\n      'feComposite',\n      'feConvolveMatrix',\n      'feDiffuseLighting',\n      'feDisplacementMap',\n      'feDistantLight',\n      'feDropShadow',\n      'feFlood',\n      'feFuncA',\n      'feFuncB',\n      'feFuncG',\n      'feFuncR',\n      'feGaussianBlur',\n      'feImage',\n      'feMerge',\n      'feMergeNode',\n      'feMorphology',\n      'feOffset',\n      'fePointLight',\n      'feSpecularLighting',\n      'feSpotLight',\n      'feTile',\n      'feTurbulence'\n    ]);\n    const svgDisallowed = freeze([\n      'animate',\n      'color-profile',\n      'cursor',\n      'discard',\n      'font-face',\n      'font-face-format',\n      'font-face-name',\n      'font-face-src',\n      'font-face-uri',\n      'foreignobject',\n      'hatch',\n      'hatchpath',\n      'mesh',\n      'meshgradient',\n      'meshpatch',\n      'meshrow',\n      'missing-glyph',\n      'script',\n      'set',\n      'solidcolor',\n      'unknown',\n      'use'\n    ]);\n    const mathMl$1 = freeze([\n      'math',\n      'menclose',\n      'merror',\n      'mfenced',\n      'mfrac',\n      'mglyph',\n      'mi',\n      'mlabeledtr',\n      'mmultiscripts',\n      'mn',\n      'mo',\n      'mover',\n      'mpadded',\n      'mphantom',\n      'mroot',\n      'mrow',\n      'ms',\n      'mspace',\n      'msqrt',\n      'mstyle',\n      'msub',\n      'msup',\n      'msubsup',\n      'mtable',\n      'mtd',\n      'mtext',\n      'mtr',\n      'munder',\n      'munderover',\n      'mprescripts'\n    ]);\n    const mathMlDisallowed = freeze([\n      'maction',\n      'maligngroup',\n      'malignmark',\n      'mlongdiv',\n      'mscarries',\n      'mscarry',\n      'msgroup',\n      'mstack',\n      'msline',\n      'msrow',\n      'semantics',\n      'annotation',\n      'annotation-xml',\n      'mprescripts',\n      'none'\n    ]);\n    const text = freeze(['#text']);\n    const html = freeze([\n      'accept',\n      'action',\n      'align',\n      'alt',\n      'autocapitalize',\n      'autocomplete',\n      'autopictureinpicture',\n      'autoplay',\n      'background',\n      'bgcolor',\n      'border',\n      'capture',\n      'cellpadding',\n      'cellspacing',\n      'checked',\n      'cite',\n      'class',\n      'clear',\n      'color',\n      'cols',\n      'colspan',\n      'controls',\n      'controlslist',\n      'coords',\n      'crossorigin',\n      'datetime',\n      'decoding',\n      'default',\n      'dir',\n      'disabled',\n      'disablepictureinpicture',\n      'disableremoteplayback',\n      'download',\n      'draggable',\n      'enctype',\n      'enterkeyhint',\n      'face',\n      'for',\n      'headers',\n      'height',\n      'hidden',\n      'high',\n      'href',\n      'hreflang',\n      'id',\n      'inputmode',\n      'integrity',\n      'ismap',\n      'kind',\n      'label',\n      'lang',\n      'list',\n      'loading',\n      'loop',\n      'low',\n      'max',\n      'maxlength',\n      'media',\n      'method',\n      'min',\n      'minlength',\n      'multiple',\n      'muted',\n      'name',\n      'nonce',\n      'noshade',\n      'novalidate',\n      'nowrap',\n      'open',\n      'optimum',\n      'pattern',\n      'placeholder',\n      'playsinline',\n      'poster',\n      'preload',\n      'pubdate',\n      'radiogroup',\n      'readonly',\n      'rel',\n      'required',\n      'rev',\n      'reversed',\n      'role',\n      'rows',\n      'rowspan',\n      'spellcheck',\n      'scope',\n      'selected',\n      'shape',\n      'size',\n      'sizes',\n      'span',\n      'srclang',\n      'start',\n      'src',\n      'srcset',\n      'step',\n      'style',\n      'summary',\n      'tabindex',\n      'title',\n      'translate',\n      'type',\n      'usemap',\n      'valign',\n      'value',\n      'width',\n      'xmlns',\n      'slot'\n    ]);\n    const svg = freeze([\n      'accent-height',\n      'accumulate',\n      'additive',\n      'alignment-baseline',\n      'ascent',\n      'attributename',\n      'attributetype',\n      'azimuth',\n      'basefrequency',\n      'baseline-shift',\n      'begin',\n      'bias',\n      'by',\n      'class',\n      'clip',\n      'clippathunits',\n      'clip-path',\n      'clip-rule',\n      'color',\n      'color-interpolation',\n      'color-interpolation-filters',\n      'color-profile',\n      'color-rendering',\n      'cx',\n      'cy',\n      'd',\n      'dx',\n      'dy',\n      'diffuseconstant',\n      'direction',\n      'display',\n      'divisor',\n      'dur',\n      'edgemode',\n      'elevation',\n      'end',\n      'fill',\n      'fill-opacity',\n      'fill-rule',\n      'filter',\n      'filterunits',\n      'flood-color',\n      'flood-opacity',\n      'font-family',\n      'font-size',\n      'font-size-adjust',\n      'font-stretch',\n      'font-style',\n      'font-variant',\n      'font-weight',\n      'fx',\n      'fy',\n      'g1',\n      'g2',\n      'glyph-name',\n      'glyphref',\n      'gradientunits',\n      'gradienttransform',\n      'height',\n      'href',\n      'id',\n      'image-rendering',\n      'in',\n      'in2',\n      'k',\n      'k1',\n      'k2',\n      'k3',\n      'k4',\n      'kerning',\n      'keypoints',\n      'keysplines',\n      'keytimes',\n      'lang',\n      'lengthadjust',\n      'letter-spacing',\n      'kernelmatrix',\n      'kernelunitlength',\n      'lighting-color',\n      'local',\n      'marker-end',\n      'marker-mid',\n      'marker-start',\n      'markerheight',\n      'markerunits',\n      'markerwidth',\n      'maskcontentunits',\n      'maskunits',\n      'max',\n      'mask',\n      'media',\n      'method',\n      'mode',\n      'min',\n      'name',\n      'numoctaves',\n      'offset',\n      'operator',\n      'opacity',\n      'order',\n      'orient',\n      'orientation',\n      'origin',\n      'overflow',\n      'paint-order',\n      'path',\n      'pathlength',\n      'patterncontentunits',\n      'patterntransform',\n      'patternunits',\n      'points',\n      'preservealpha',\n      'preserveaspectratio',\n      'primitiveunits',\n      'r',\n      'rx',\n      'ry',\n      'radius',\n      'refx',\n      'refy',\n      'repeatcount',\n      'repeatdur',\n      'restart',\n      'result',\n      'rotate',\n      'scale',\n      'seed',\n      'shape-rendering',\n      'specularconstant',\n      'specularexponent',\n      'spreadmethod',\n      'startoffset',\n      'stddeviation',\n      'stitchtiles',\n      'stop-color',\n      'stop-opacity',\n      'stroke-dasharray',\n      'stroke-dashoffset',\n      'stroke-linecap',\n      'stroke-linejoin',\n      'stroke-miterlimit',\n      'stroke-opacity',\n      'stroke',\n      'stroke-width',\n      'style',\n      'surfacescale',\n      'systemlanguage',\n      'tabindex',\n      'targetx',\n      'targety',\n      'transform',\n      'transform-origin',\n      'text-anchor',\n      'text-decoration',\n      'text-rendering',\n      'textlength',\n      'type',\n      'u1',\n      'u2',\n      'unicode',\n      'values',\n      'viewbox',\n      'visibility',\n      'version',\n      'vert-adv-y',\n      'vert-origin-x',\n      'vert-origin-y',\n      'width',\n      'word-spacing',\n      'wrap',\n      'writing-mode',\n      'xchannelselector',\n      'ychannelselector',\n      'x',\n      'x1',\n      'x2',\n      'xmlns',\n      'y',\n      'y1',\n      'y2',\n      'z',\n      'zoomandpan'\n    ]);\n    const mathMl = freeze([\n      'accent',\n      'accentunder',\n      'align',\n      'bevelled',\n      'close',\n      'columnsalign',\n      'columnlines',\n      'columnspan',\n      'denomalign',\n      'depth',\n      'dir',\n      'display',\n      'displaystyle',\n      'encoding',\n      'fence',\n      'frame',\n      'height',\n      'href',\n      'id',\n      'largeop',\n      'length',\n      'linethickness',\n      'lspace',\n      'lquote',\n      'mathbackground',\n      'mathcolor',\n      'mathsize',\n      'mathvariant',\n      'maxsize',\n      'minsize',\n      'movablelimits',\n      'notation',\n      'numalign',\n      'open',\n      'rowalign',\n      'rowlines',\n      'rowspacing',\n      'rowspan',\n      'rspace',\n      'rquote',\n      'scriptlevel',\n      'scriptminsize',\n      'scriptsizemultiplier',\n      'selection',\n      'separator',\n      'separators',\n      'stretchy',\n      'subscriptshift',\n      'supscriptshift',\n      'symmetric',\n      'voffset',\n      'width',\n      'xmlns'\n    ]);\n    const xml = freeze([\n      'xlink:href',\n      'xml:id',\n      'xlink:title',\n      'xml:space',\n      'xmlns:xlink'\n    ]);\n    const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm);\n    const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n    const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\n    const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\n    const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\n    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\n    const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n    const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\n    const DOCTYPE_NAME = seal(/^html$/i);\n    var EXPRESSIONS = Object.freeze({\n      __proto__: null,\n      MUSTACHE_EXPR: MUSTACHE_EXPR,\n      ERB_EXPR: ERB_EXPR,\n      TMPLIT_EXPR: TMPLIT_EXPR,\n      DATA_ATTR: DATA_ATTR,\n      ARIA_ATTR: ARIA_ATTR,\n      IS_ALLOWED_URI: IS_ALLOWED_URI,\n      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE: ATTR_WHITESPACE,\n      DOCTYPE_NAME: DOCTYPE_NAME\n    });\n    const getGlobal = () => typeof window === 'undefined' ? null : window;\n    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n        return null;\n      }\n      let suffix = null;\n      const ATTR_NAME = 'data-tt-policy-suffix';\n      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\n      }\n      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n      try {\n        return trustedTypes.createPolicy(policyName, {\n          createHTML(html) {\n            return html;\n          },\n          createScriptURL(scriptUrl) {\n            return scriptUrl;\n          }\n        });\n      } catch (_) {\n        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n        return null;\n      }\n    };\n    function createDOMPurify() {\n      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n      const DOMPurify = root => createDOMPurify(root);\n      DOMPurify.version = '3.0.5';\n      DOMPurify.removed = [];\n      if (!window || !window.document || window.document.nodeType !== 9) {\n        DOMPurify.isSupported = false;\n        return DOMPurify;\n      }\n      const originalDocument = window.document;\n      const currentScript = originalDocument.currentScript;\n      let {document} = window;\n      const {DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes} = window;\n      const ElementPrototype = Element.prototype;\n      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n      if (typeof HTMLTemplateElement === 'function') {\n        const template = document.createElement('template');\n        if (template.content && template.content.ownerDocument) {\n          document = template.content.ownerDocument;\n        }\n      }\n      let trustedTypesPolicy;\n      let emptyHTML = '';\n      const {implementation, createNodeIterator, createDocumentFragment, getElementsByTagName} = document;\n      const {importNode} = originalDocument;\n      let hooks = {};\n      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n      const {MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE} = EXPRESSIONS;\n      let {IS_ALLOWED_URI: IS_ALLOWED_URI$1} = EXPRESSIONS;\n      let ALLOWED_TAGS = null;\n      const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n        ...html$1,\n        ...svg$1,\n        ...svgFilters,\n        ...mathMl$1,\n        ...text\n      ]);\n      let ALLOWED_ATTR = null;\n      const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n        ...html,\n        ...svg,\n        ...mathMl,\n        ...xml\n      ]);\n      let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\n        tagNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        attributeNameCheck: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: null\n        },\n        allowCustomizedBuiltInElements: {\n          writable: true,\n          configurable: false,\n          enumerable: true,\n          value: false\n        }\n      }));\n      let FORBID_TAGS = null;\n      let FORBID_ATTR = null;\n      let ALLOW_ARIA_ATTR = true;\n      let ALLOW_DATA_ATTR = true;\n      let ALLOW_UNKNOWN_PROTOCOLS = false;\n      let ALLOW_SELF_CLOSE_IN_ATTR = true;\n      let SAFE_FOR_TEMPLATES = false;\n      let WHOLE_DOCUMENT = false;\n      let SET_CONFIG = false;\n      let FORCE_BODY = false;\n      let RETURN_DOM = false;\n      let RETURN_DOM_FRAGMENT = false;\n      let RETURN_TRUSTED_TYPE = false;\n      let SANITIZE_DOM = true;\n      let SANITIZE_NAMED_PROPS = false;\n      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n      let KEEP_CONTENT = true;\n      let IN_PLACE = false;\n      let USE_PROFILES = {};\n      let FORBID_CONTENTS = null;\n      const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n        'annotation-xml',\n        'audio',\n        'colgroup',\n        'desc',\n        'foreignobject',\n        'head',\n        'iframe',\n        'math',\n        'mi',\n        'mn',\n        'mo',\n        'ms',\n        'mtext',\n        'noembed',\n        'noframes',\n        'noscript',\n        'plaintext',\n        'script',\n        'style',\n        'svg',\n        'template',\n        'thead',\n        'title',\n        'video',\n        'xmp'\n      ]);\n      let DATA_URI_TAGS = null;\n      const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n        'audio',\n        'video',\n        'img',\n        'source',\n        'image',\n        'track'\n      ]);\n      let URI_SAFE_ATTRIBUTES = null;\n      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n        'alt',\n        'class',\n        'for',\n        'id',\n        'label',\n        'name',\n        'pattern',\n        'placeholder',\n        'role',\n        'summary',\n        'title',\n        'value',\n        'style',\n        'xmlns'\n      ]);\n      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n      let NAMESPACE = HTML_NAMESPACE;\n      let IS_EMPTY_INPUT = false;\n      let ALLOWED_NAMESPACES = null;\n      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n        MATHML_NAMESPACE,\n        SVG_NAMESPACE,\n        HTML_NAMESPACE\n      ], stringToString);\n      let PARSER_MEDIA_TYPE;\n      const SUPPORTED_PARSER_MEDIA_TYPES = [\n        'application/xhtml+xml',\n        'text/html'\n      ];\n      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n      let transformCaseFunc;\n      let CONFIG = null;\n      const formElement = document.createElement('form');\n      const isRegexOrFunction = function isRegexOrFunction(testValue) {\n        return testValue instanceof RegExp || testValue instanceof Function;\n      };\n      const _parseConfig = function _parseConfig(cfg) {\n        if (CONFIG && CONFIG === cfg) {\n          return;\n        }\n        if (!cfg || typeof cfg !== 'object') {\n          cfg = {};\n        }\n        cfg = clone(cfg);\n        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\n        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n        ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\n        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\n        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\n        RETURN_DOM = cfg.RETURN_DOM || false;\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\n        FORCE_BODY = cfg.FORCE_BODY || false;\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\n        IN_PLACE = cfg.IN_PLACE || false;\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n        }\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          ALLOW_DATA_ATTR = false;\n        }\n        if (RETURN_DOM_FRAGMENT) {\n          RETURN_DOM = true;\n        }\n        if (USE_PROFILES) {\n          ALLOWED_TAGS = addToSet({}, [...text]);\n          ALLOWED_ATTR = [];\n          if (USE_PROFILES.html === true) {\n            addToSet(ALLOWED_TAGS, html$1);\n            addToSet(ALLOWED_ATTR, html);\n          }\n          if (USE_PROFILES.svg === true) {\n            addToSet(ALLOWED_TAGS, svg$1);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.svgFilters === true) {\n            addToSet(ALLOWED_TAGS, svgFilters);\n            addToSet(ALLOWED_ATTR, svg);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n          if (USE_PROFILES.mathMl === true) {\n            addToSet(ALLOWED_TAGS, mathMl$1);\n            addToSet(ALLOWED_ATTR, mathMl);\n            addToSet(ALLOWED_ATTR, xml);\n          }\n        }\n        if (cfg.ADD_TAGS) {\n          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n            ALLOWED_TAGS = clone(ALLOWED_TAGS);\n          }\n          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n        }\n        if (cfg.ADD_ATTR) {\n          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n            ALLOWED_ATTR = clone(ALLOWED_ATTR);\n          }\n          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n        }\n        if (cfg.ADD_URI_SAFE_ATTR) {\n          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n        }\n        if (cfg.FORBID_CONTENTS) {\n          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n            FORBID_CONTENTS = clone(FORBID_CONTENTS);\n          }\n          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n        }\n        if (KEEP_CONTENT) {\n          ALLOWED_TAGS['#text'] = true;\n        }\n        if (WHOLE_DOCUMENT) {\n          addToSet(ALLOWED_TAGS, [\n            'html',\n            'head',\n            'body'\n          ]);\n        }\n        if (ALLOWED_TAGS.table) {\n          addToSet(ALLOWED_TAGS, ['tbody']);\n          delete FORBID_TAGS.tbody;\n        }\n        if (cfg.TRUSTED_TYPES_POLICY) {\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n          }\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n          }\n          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        } else {\n          if (trustedTypesPolicy === undefined) {\n            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n          }\n          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n            emptyHTML = trustedTypesPolicy.createHTML('');\n          }\n        }\n        if (freeze) {\n          freeze(cfg);\n        }\n        CONFIG = cfg;\n      };\n      const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n        'mi',\n        'mo',\n        'mn',\n        'ms',\n        'mtext'\n      ]);\n      const HTML_INTEGRATION_POINTS = addToSet({}, [\n        'foreignobject',\n        'desc',\n        'title',\n        'annotation-xml'\n      ]);\n      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n        'title',\n        'style',\n        'font',\n        'a',\n        'script'\n      ]);\n      const ALL_SVG_TAGS = addToSet({}, svg$1);\n      addToSet(ALL_SVG_TAGS, svgFilters);\n      addToSet(ALL_SVG_TAGS, svgDisallowed);\n      const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\n      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\n      const _checkValidNamespace = function _checkValidNamespace(element) {\n        let parent = getParentNode(element);\n        if (!parent || !parent.tagName) {\n          parent = {\n            namespaceURI: NAMESPACE,\n            tagName: 'template'\n          };\n        }\n        const tagName = stringToLowerCase(element.tagName);\n        const parentTagName = stringToLowerCase(parent.tagName);\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return false;\n        }\n        if (element.namespaceURI === SVG_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'svg';\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE) {\n            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n          }\n          return Boolean(ALL_SVG_TAGS[tagName]);\n        }\n        if (element.namespaceURI === MATHML_NAMESPACE) {\n          if (parent.namespaceURI === HTML_NAMESPACE) {\n            return tagName === 'math';\n          }\n          if (parent.namespaceURI === SVG_NAMESPACE) {\n            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n          }\n          return Boolean(ALL_MATHML_TAGS[tagName]);\n        }\n        if (element.namespaceURI === HTML_NAMESPACE) {\n          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n            return false;\n          }\n          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n          return true;\n        }\n        return false;\n      };\n      const _forceRemove = function _forceRemove(node) {\n        arrayPush(DOMPurify.removed, { element: node });\n        try {\n          node.parentNode.removeChild(node);\n        } catch (_) {\n          node.remove();\n        }\n      };\n      const _removeAttribute = function _removeAttribute(name, node) {\n        try {\n          arrayPush(DOMPurify.removed, {\n            attribute: node.getAttributeNode(name),\n            from: node\n          });\n        } catch (_) {\n          arrayPush(DOMPurify.removed, {\n            attribute: null,\n            from: node\n          });\n        }\n        node.removeAttribute(name);\n        if (name === 'is' && !ALLOWED_ATTR[name]) {\n          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n            try {\n              _forceRemove(node);\n            } catch (_) {\n            }\n          } else {\n            try {\n              node.setAttribute(name, '');\n            } catch (_) {\n            }\n          }\n        }\n      };\n      const _initDocument = function _initDocument(dirty) {\n        let doc;\n        let leadingWhitespace;\n        if (FORCE_BODY) {\n          dirty = '<remove></remove>' + dirty;\n        } else {\n          const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n          leadingWhitespace = matches && matches[0];\n        }\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n          dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n        }\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        if (NAMESPACE === HTML_NAMESPACE) {\n          try {\n            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n          } catch (_) {\n          }\n        }\n        if (!doc || !doc.documentElement) {\n          doc = implementation.createDocument(NAMESPACE, 'template', null);\n          try {\n            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n          } catch (_) {\n          }\n        }\n        const body = doc.body || doc.documentElement;\n        if (dirty && leadingWhitespace) {\n          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n        }\n        if (NAMESPACE === HTML_NAMESPACE) {\n          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n        }\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\n      };\n      const _createIterator = function _createIterator(root) {\n        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\n      };\n      const _isClobbered = function _isClobbered(elm) {\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\n      };\n      const _isNode = function _isNode(object) {\n        return typeof Node === 'object' ? object instanceof Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\n      };\n      const _executeHook = function _executeHook(entryPoint, currentNode, data) {\n        if (!hooks[entryPoint]) {\n          return;\n        }\n        arrayForEach(hooks[entryPoint], hook => {\n          hook.call(DOMPurify, currentNode, data, CONFIG);\n        });\n      };\n      const _sanitizeElements = function _sanitizeElements(currentNode) {\n        let content;\n        _executeHook('beforeSanitizeElements', currentNode, null);\n        if (_isClobbered(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        const tagName = transformCaseFunc(currentNode.nodeName);\n        _executeHook('uponSanitizeElement', currentNode, {\n          tagName,\n          allowedTags: ALLOWED_TAGS\n        });\n        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))\n              return false;\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))\n              return false;\n          }\n          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n            const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n            if (childNodes && parentNode) {\n              const childCount = childNodes.length;\n              for (let i = childCount - 1; i >= 0; --i) {\n                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\n              }\n            }\n          }\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n          _forceRemove(currentNode);\n          return true;\n        }\n        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\n          content = currentNode.textContent;\n          content = stringReplace(content, MUSTACHE_EXPR, ' ');\n          content = stringReplace(content, ERB_EXPR, ' ');\n          content = stringReplace(content, TMPLIT_EXPR, ' ');\n          if (currentNode.textContent !== content) {\n            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n            currentNode.textContent = content;\n          }\n        }\n        _executeHook('afterSanitizeElements', currentNode, null);\n        return false;\n      };\n      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n          return false;\n        }\n        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName));\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName));\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));\n          else {\n            return false;\n          }\n        } else if (URI_SAFE_ATTRIBUTES[lcName]);\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, '')));\n        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]);\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, '')));\n        else if (value) {\n          return false;\n        } else ;\n        return true;\n      };\n      const _basicCustomElementTest = function _basicCustomElementTest(tagName) {\n        return tagName.indexOf('-') > 0;\n      };\n      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n        let attr;\n        let value;\n        let lcName;\n        let l;\n        _executeHook('beforeSanitizeAttributes', currentNode, null);\n        const {attributes} = currentNode;\n        if (!attributes) {\n          return;\n        }\n        const hookEvent = {\n          attrName: '',\n          attrValue: '',\n          keepAttr: true,\n          allowedAttributes: ALLOWED_ATTR\n        };\n        l = attributes.length;\n        while (l--) {\n          attr = attributes[l];\n          const {name, namespaceURI} = attr;\n          value = name === 'value' ? attr.value : stringTrim(attr.value);\n          const initValue = value;\n          lcName = transformCaseFunc(name);\n          hookEvent.attrName = lcName;\n          hookEvent.attrValue = value;\n          hookEvent.keepAttr = true;\n          hookEvent.forceKeepAttr = undefined;\n          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\n          value = hookEvent.attrValue;\n          if (hookEvent.forceKeepAttr) {\n            continue;\n          }\n          if (!hookEvent.keepAttr) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (SAFE_FOR_TEMPLATES) {\n            value = stringReplace(value, MUSTACHE_EXPR, ' ');\n            value = stringReplace(value, ERB_EXPR, ' ');\n            value = stringReplace(value, TMPLIT_EXPR, ' ');\n          }\n          const lcTag = transformCaseFunc(currentNode.nodeName);\n          if (!_isValidAttribute(lcTag, lcName, value)) {\n            _removeAttribute(name, currentNode);\n            continue;\n          }\n          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n            _removeAttribute(name, currentNode);\n            value = SANITIZE_NAMED_PROPS_PREFIX + value;\n          }\n          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n            if (namespaceURI);\n            else {\n              switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML': {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n              case 'TrustedScriptURL': {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n              }\n            }\n          }\n          if (value !== initValue) {\n            try {\n              if (namespaceURI) {\n                currentNode.setAttributeNS(namespaceURI, name, value);\n              } else {\n                currentNode.setAttribute(name, value);\n              }\n            } catch (_) {\n              _removeAttribute(name, currentNode);\n            }\n          }\n        }\n        _executeHook('afterSanitizeAttributes', currentNode, null);\n      };\n      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n        let shadowNode;\n        const shadowIterator = _createIterator(fragment);\n        _executeHook('beforeSanitizeShadowDOM', fragment, null);\n        while (shadowNode = shadowIterator.nextNode()) {\n          _executeHook('uponSanitizeShadowNode', shadowNode, null);\n          if (_sanitizeElements(shadowNode)) {\n            continue;\n          }\n          if (shadowNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(shadowNode.content);\n          }\n          _sanitizeAttributes(shadowNode);\n        }\n        _executeHook('afterSanitizeShadowDOM', fragment, null);\n      };\n      DOMPurify.sanitize = function (dirty) {\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        let body;\n        let importedNode;\n        let currentNode;\n        let returnNode;\n        IS_EMPTY_INPUT = !dirty;\n        if (IS_EMPTY_INPUT) {\n          dirty = '<!-->';\n        }\n        if (typeof dirty !== 'string' && !_isNode(dirty)) {\n          if (typeof dirty.toString === 'function') {\n            dirty = dirty.toString();\n            if (typeof dirty !== 'string') {\n              throw typeErrorCreate('dirty is not a string, aborting');\n            }\n          } else {\n            throw typeErrorCreate('toString is not a function');\n          }\n        }\n        if (!DOMPurify.isSupported) {\n          return dirty;\n        }\n        if (!SET_CONFIG) {\n          _parseConfig(cfg);\n        }\n        DOMPurify.removed = [];\n        if (typeof dirty === 'string') {\n          IN_PLACE = false;\n        }\n        if (IN_PLACE) {\n          if (dirty.nodeName) {\n            const tagName = transformCaseFunc(dirty.nodeName);\n            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n            }\n          }\n        } else if (dirty instanceof Node) {\n          body = _initDocument('<!---->');\n          importedNode = body.ownerDocument.importNode(dirty, true);\n          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\n            body = importedNode;\n          } else if (importedNode.nodeName === 'HTML') {\n            body = importedNode;\n          } else {\n            body.appendChild(importedNode);\n          }\n        } else {\n          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n          }\n          body = _initDocument(dirty);\n          if (!body) {\n            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n          }\n        }\n        if (body && FORCE_BODY) {\n          _forceRemove(body.firstChild);\n        }\n        const nodeIterator = _createIterator(IN_PLACE ? dirty : body);\n        while (currentNode = nodeIterator.nextNode()) {\n          if (_sanitizeElements(currentNode)) {\n            continue;\n          }\n          if (currentNode.content instanceof DocumentFragment) {\n            _sanitizeShadowDOM(currentNode.content);\n          }\n          _sanitizeAttributes(currentNode);\n        }\n        if (IN_PLACE) {\n          return dirty;\n        }\n        if (RETURN_DOM) {\n          if (RETURN_DOM_FRAGMENT) {\n            returnNode = createDocumentFragment.call(body.ownerDocument);\n            while (body.firstChild) {\n              returnNode.appendChild(body.firstChild);\n            }\n          } else {\n            returnNode = body;\n          }\n          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n            returnNode = importNode.call(originalDocument, returnNode, true);\n          }\n          return returnNode;\n        }\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n        }\n        if (SAFE_FOR_TEMPLATES) {\n          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, ' ');\n          serializedHTML = stringReplace(serializedHTML, ERB_EXPR, ' ');\n          serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, ' ');\n        }\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n      };\n      DOMPurify.setConfig = function (cfg) {\n        _parseConfig(cfg);\n        SET_CONFIG = true;\n      };\n      DOMPurify.clearConfig = function () {\n        CONFIG = null;\n        SET_CONFIG = false;\n      };\n      DOMPurify.isValidAttribute = function (tag, attr, value) {\n        if (!CONFIG) {\n          _parseConfig({});\n        }\n        const lcTag = transformCaseFunc(tag);\n        const lcName = transformCaseFunc(attr);\n        return _isValidAttribute(lcTag, lcName, value);\n      };\n      DOMPurify.addHook = function (entryPoint, hookFunction) {\n        if (typeof hookFunction !== 'function') {\n          return;\n        }\n        hooks[entryPoint] = hooks[entryPoint] || [];\n        arrayPush(hooks[entryPoint], hookFunction);\n      };\n      DOMPurify.removeHook = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          return arrayPop(hooks[entryPoint]);\n        }\n      };\n      DOMPurify.removeHooks = function (entryPoint) {\n        if (hooks[entryPoint]) {\n          hooks[entryPoint] = [];\n        }\n      };\n      DOMPurify.removeAllHooks = function () {\n        hooks = {};\n      };\n      return DOMPurify;\n    }\n    var purify = createDOMPurify();\n\n    const each$4 = Tools.each, trim = Tools.trim;\n    const queryParts = [\n      'source',\n      'protocol',\n      'authority',\n      'userInfo',\n      'user',\n      'password',\n      'host',\n      'port',\n      'relative',\n      'path',\n      'directory',\n      'file',\n      'query',\n      'anchor'\n    ];\n    const DEFAULT_PORTS = {\n      ftp: 21,\n      http: 80,\n      https: 443,\n      mailto: 25\n    };\n    const safeSvgDataUrlElements = [\n      'img',\n      'video'\n    ];\n    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\n      if (isNonNullable(allowSvgDataUrls)) {\n        return !allowSvgDataUrls;\n      } else {\n        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\n      }\n    };\n    const decodeUri = encodedUri => {\n      try {\n        return decodeURIComponent(encodedUri);\n      } catch (ex) {\n        return unescape(encodedUri);\n      }\n    };\n    const isInvalidUri = (settings, uri, tagName) => {\n      const decodedUri = decodeUri(uri).replace(/\\s/g, '');\n      if (settings.allow_script_urls) {\n        return false;\n      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\n        return true;\n      } else if (settings.allow_html_data_urls) {\n        return false;\n      } else if (/^data:image\\//i.test(decodedUri)) {\n        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\n      } else {\n        return /^data:/i.test(decodedUri);\n      }\n    };\n    class URI {\n      static parseDataUri(uri) {\n        let type;\n        const uriComponents = decodeURIComponent(uri).split(',');\n        const matches = /data:([^;]+)/.exec(uriComponents[0]);\n        if (matches) {\n          type = matches[1];\n        }\n        return {\n          type,\n          data: uriComponents[1]\n        };\n      }\n      static isDomSafe(uri, context, options = {}) {\n        if (options.allow_script_urls) {\n          return true;\n        } else {\n          const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\n          return !isInvalidUri(options, decodedUri, context);\n        }\n      }\n      static getDocumentBaseUrl(loc) {\n        var _a;\n        let baseUrl;\n        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\n          baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';\n        } else {\n          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\n        }\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\n          baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(baseUrl)) {\n            baseUrl += '/';\n          }\n        }\n        return baseUrl;\n      }\n      constructor(url, settings = {}) {\n        this.path = '';\n        this.directory = '';\n        url = trim(url);\n        this.settings = settings;\n        const baseUri = settings.base_uri;\n        const self = this;\n        if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\n          self.source = url;\n          return;\n        }\n        const isProtocolRelative = url.indexOf('//') === 0;\n        if (url.indexOf('/') === 0 && !isProtocolRelative) {\n          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\n        }\n        if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\n          const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;\n          if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {\n            url = '//mce_host' + self.toAbsPath(baseUrl, url);\n          } else {\n            const match = /([^#?]*)([#?]?.*)/.exec(url);\n            if (match) {\n              url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\n            }\n          }\n        }\n        url = url.replace(/@@/g, '(mce_at)');\n        const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\n        if (urlMatch) {\n          each$4(queryParts, (v, i) => {\n            let part = urlMatch[i];\n            if (part) {\n              part = part.replace(/\\(mce_at\\)/g, '@@');\n            }\n            self[v] = part;\n          });\n        }\n        if (baseUri) {\n          if (!self.protocol) {\n            self.protocol = baseUri.protocol;\n          }\n          if (!self.userInfo) {\n            self.userInfo = baseUri.userInfo;\n          }\n          if (!self.port && self.host === 'mce_host') {\n            self.port = baseUri.port;\n          }\n          if (!self.host || self.host === 'mce_host') {\n            self.host = baseUri.host;\n          }\n          self.source = '';\n        }\n        if (isProtocolRelative) {\n          self.protocol = '';\n        }\n      }\n      setPath(path) {\n        const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\n        if (pathMatch) {\n          this.path = pathMatch[0];\n          this.directory = pathMatch[1];\n          this.file = pathMatch[2];\n        }\n        this.source = '';\n        this.getURI();\n      }\n      toRelative(uri) {\n        if (uri === './') {\n          return uri;\n        }\n        const relativeUri = new URI(uri, { base_uri: this });\n        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\n          return relativeUri.getURI();\n        }\n        const tu = this.getURI(), uu = relativeUri.getURI();\n        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\n          return tu;\n        }\n        let output = this.toRelPath(this.path, relativeUri.path);\n        if (relativeUri.query) {\n          output += '?' + relativeUri.query;\n        }\n        if (relativeUri.anchor) {\n          output += '#' + relativeUri.anchor;\n        }\n        return output;\n      }\n      toAbsolute(uri, noHost) {\n        const absoluteUri = new URI(uri, { base_uri: this });\n        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\n      }\n      isSameOrigin(uri) {\n        if (this.host == uri.host && this.protocol == uri.protocol) {\n          if (this.port == uri.port) {\n            return true;\n          }\n          const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;\n          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\n            return true;\n          }\n        }\n        return false;\n      }\n      toRelPath(base, path) {\n        let breakPoint = 0, out = '', i, l;\n        const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\n        const items = path.split('/');\n        if (normalizedBase.length >= items.length) {\n          for (i = 0, l = normalizedBase.length; i < l; i++) {\n            if (i >= items.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (normalizedBase.length < items.length) {\n          for (i = 0, l = items.length; i < l; i++) {\n            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\n              breakPoint = i + 1;\n              break;\n            }\n          }\n        }\n        if (breakPoint === 1) {\n          return path;\n        }\n        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\n          out += '../';\n        }\n        for (i = breakPoint - 1, l = items.length; i < l; i++) {\n          if (i !== breakPoint - 1) {\n            out += '/' + items[i];\n          } else {\n            out += items[i];\n          }\n        }\n        return out;\n      }\n      toAbsPath(base, path) {\n        let nb = 0;\n        const tr = /\\/$/.test(path) ? '/' : '';\n        const normalizedBase = base.split('/');\n        const normalizedPath = path.split('/');\n        const baseParts = [];\n        each$4(normalizedBase, k => {\n          if (k) {\n            baseParts.push(k);\n          }\n        });\n        const pathParts = [];\n        for (let i = normalizedPath.length - 1; i >= 0; i--) {\n          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\n            continue;\n          }\n          if (normalizedPath[i] === '..') {\n            nb++;\n            continue;\n          }\n          if (nb > 0) {\n            nb--;\n            continue;\n          }\n          pathParts.push(normalizedPath[i]);\n        }\n        const i = baseParts.length - nb;\n        let outPath;\n        if (i <= 0) {\n          outPath = reverse(pathParts).join('/');\n        } else {\n          outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');\n        }\n        if (outPath.indexOf('/') !== 0) {\n          outPath = '/' + outPath;\n        }\n        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\n          outPath += tr;\n        }\n        return outPath;\n      }\n      getURI(noProtoHost = false) {\n        let s;\n        if (!this.source || noProtoHost) {\n          s = '';\n          if (!noProtoHost) {\n            if (this.protocol) {\n              s += this.protocol + '://';\n            } else {\n              s += '//';\n            }\n            if (this.userInfo) {\n              s += this.userInfo + '@';\n            }\n            if (this.host) {\n              s += this.host;\n            }\n            if (this.port) {\n              s += ':' + this.port;\n            }\n          }\n          if (this.path) {\n            s += this.path;\n          }\n          if (this.query) {\n            s += '?' + this.query;\n          }\n          if (this.anchor) {\n            s += '#' + this.anchor;\n          }\n          this.source = s;\n        }\n        return this.source;\n      }\n    }\n\n    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\n    const internalElementAttr = 'data-mce-type';\n    let uid = 0;\n    const processNode = (node, settings, schema, scope, evt) => {\n      var _a, _b, _c, _d;\n      const validate = settings.validate;\n      const specialElements = schema.getSpecialElements();\n      if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {\n        node.nodeValue = ' ' + node.nodeValue;\n      }\n      const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();\n      if (scope !== 'html' && schema.isValid(scope)) {\n        if (isNonNullable(evt)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n        return;\n      }\n      if (node.nodeType !== ELEMENT || lcTagName === 'body') {\n        return;\n      }\n      const element = SugarElement.fromDom(node);\n      const isInternalElement = has$1(element, internalElementAttr);\n      const bogus = get$9(element, 'data-mce-bogus');\n      if (!isInternalElement && isString(bogus)) {\n        if (bogus === 'all') {\n          remove$5(element);\n        } else {\n          unwrap(element);\n        }\n        return;\n      }\n      const rule = schema.getElementRule(lcTagName);\n      if (validate && !rule) {\n        if (has$2(specialElements, lcTagName)) {\n          remove$5(element);\n        } else {\n          unwrap(element);\n        }\n        return;\n      } else {\n        if (isNonNullable(evt)) {\n          evt.allowedTags[lcTagName] = true;\n        }\n      }\n      if (validate && rule && !isInternalElement) {\n        each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], attr => {\n          set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n        });\n        each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], attr => {\n          if (!has$1(element, attr.name)) {\n            set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\n          }\n        });\n        if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\n          unwrap(element);\n          return;\n        }\n        if (rule.removeEmptyAttrs && hasNone(element)) {\n          unwrap(element);\n          return;\n        }\n        if (rule.outputName && rule.outputName !== lcTagName) {\n          mutate(element, rule.outputName);\n        }\n      }\n    };\n    const processAttr = (ele, settings, schema, scope, evt) => {\n      const tagName = ele.tagName.toLowerCase();\n      const {attrName, attrValue} = evt;\n      evt.keepAttr = shouldKeepAttribute(settings, schema, scope, tagName, attrName, attrValue);\n      if (evt.keepAttr) {\n        evt.allowedAttributes[attrName] = true;\n        if (isBooleanAttribute(attrName, schema)) {\n          evt.attrValue = attrName;\n        }\n        if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\n          evt.forceKeepAttr = true;\n        }\n      } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {\n        evt.forceKeepAttr = true;\n      }\n    };\n    const shouldKeepAttribute = (settings, schema, scope, tagName, attrName, attrValue) => {\n      if (scope !== 'html' && !isNonHtmlElementRootName(tagName)) {\n        return true;\n      }\n      return !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));\n    };\n    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');\n    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();\n    const filterAttributes = (ele, settings, schema, scope) => {\n      const {attributes} = ele;\n      for (let i = attributes.length - 1; i >= 0; i--) {\n        const attr = attributes[i];\n        const attrName = attr.name;\n        const attrValue = attr.value;\n        if (!shouldKeepAttribute(settings, schema, scope, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {\n          ele.removeAttribute(attrName);\n        } else if (isBooleanAttribute(attrName, schema)) {\n          ele.setAttribute(attrName, attrName);\n        }\n      }\n    };\n    const setupPurify = (settings, schema, namespaceTracker) => {\n      const purify$1 = purify();\n      purify$1.addHook('uponSanitizeElement', (ele, evt) => {\n        processNode(ele, settings, schema, namespaceTracker.track(ele), evt);\n      });\n      purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\n        processAttr(ele, settings, schema, namespaceTracker.current(), evt);\n      });\n      return purify$1;\n    };\n    const getPurifyConfig = (settings, mimeType) => {\n      const basePurifyConfig = {\n        IN_PLACE: true,\n        ALLOW_UNKNOWN_PROTOCOLS: true,\n        ALLOWED_TAGS: [\n          '#comment',\n          '#cdata-section',\n          'body'\n        ],\n        ALLOWED_ATTR: []\n      };\n      const config = { ...basePurifyConfig };\n      config.PARSER_MEDIA_TYPE = mimeType;\n      if (settings.allow_script_urls) {\n        config.ALLOWED_URI_REGEXP = /.*/;\n      } else if (settings.allow_html_data_urls) {\n        config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\n      }\n      return config;\n    };\n    const sanitizeNamespaceElement = ele => {\n      const xlinkAttrs = [\n        'type',\n        'href',\n        'role',\n        'arcrole',\n        'title',\n        'show',\n        'actuate',\n        'label',\n        'from',\n        'to'\n      ].map(name => `xlink:${ name }`);\n      const config = {\n        IN_PLACE: true,\n        USE_PROFILES: {\n          html: true,\n          svg: true,\n          svgFilters: true\n        },\n        ALLOWED_ATTR: xlinkAttrs\n      };\n      purify().sanitize(ele, config);\n      return ele.innerHTML;\n    };\n    const getSanitizer = (settings, schema) => {\n      const namespaceTracker = createNamespaceTracker();\n      if (settings.sanitize) {\n        const purify = setupPurify(settings, schema, namespaceTracker);\n        const sanitizeHtmlElement = (body, mimeType) => {\n          purify.sanitize(body, getPurifyConfig(settings, mimeType));\n          purify.removed = [];\n          namespaceTracker.reset();\n        };\n        return {\n          sanitizeHtmlElement,\n          sanitizeNamespaceElement\n        };\n      } else {\n        const sanitizeHtmlElement = (body, _mimeType) => {\n          const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);\n          let node;\n          while (node = nodeIterator.nextNode()) {\n            const currentScope = namespaceTracker.track(node);\n            processNode(node, settings, schema, currentScope);\n            if (isElement$6(node)) {\n              filterAttributes(node, settings, schema, currentScope);\n            }\n          }\n          namespaceTracker.reset();\n        };\n        const sanitizeNamespaceElement = noop;\n        return {\n          sanitizeHtmlElement,\n          sanitizeNamespaceElement\n        };\n      }\n    };\n\n    const makeMap = Tools.makeMap, extend$1 = Tools.extend;\n    const transferChildren = (parent, nativeParent, specialElements, nsSanitizer) => {\n      const parentName = parent.name;\n      const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea';\n      const childNodes = nativeParent.childNodes;\n      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\n        const nativeChild = childNodes[ni];\n        const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\n        if (isElement$6(nativeChild)) {\n          const attributes = nativeChild.attributes;\n          for (let ai = 0, al = attributes.length; ai < al; ai++) {\n            const attr = attributes[ai];\n            child.attr(attr.name, attr.value);\n          }\n          if (isNonHtmlElementRootName(child.name)) {\n            nsSanitizer(nativeChild);\n            child.value = nativeChild.innerHTML;\n          }\n        } else if (isText$a(nativeChild)) {\n          child.value = nativeChild.data;\n          if (isSpecial) {\n            child.raw = true;\n          }\n        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\n          child.value = nativeChild.data;\n        }\n        if (!isNonHtmlElementRootName(child.name)) {\n          transferChildren(child, nativeChild, specialElements, nsSanitizer);\n        }\n        parent.append(child);\n      }\n    };\n    const walkTree = (root, preprocessors, postprocessors) => {\n      const traverseOrder = [];\n      for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {\n        const tempNode = node;\n        each$e(preprocessors, preprocess => preprocess(tempNode));\n        if (isNullable(tempNode.parent) && tempNode !== root) {\n          node = lastNode;\n        } else {\n          traverseOrder.push(tempNode);\n        }\n      }\n      for (let i = traverseOrder.length - 1; i >= 0; i--) {\n        const node = traverseOrder[i];\n        each$e(postprocessors, postprocess => postprocess(node));\n      }\n    };\n    const whitespaceCleaner = (root, schema, settings, args) => {\n      const validate = settings.validate;\n      const nonEmptyElements = schema.getNonEmptyElements();\n      const whitespaceElements = schema.getWhitespaceElements();\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n      const textRootBlockElements = getTextRootBlockElements(schema);\n      const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n      const hasWhitespaceParent = node => {\n        let tempNode = node.parent;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in whitespaceElements) {\n            return true;\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isTextRootBlockEmpty = node => {\n        let tempNode = node;\n        while (isNonNullable(tempNode)) {\n          if (tempNode.name in textRootBlockElements) {\n            return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);\n          } else {\n            tempNode = tempNode.parent;\n          }\n        }\n        return false;\n      };\n      const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node) || isNonHtmlElementRootName(node.name) && node.parent === root;\n      const isAtEdgeOfBlock = (node, start) => {\n        const neighbour = start ? node.prev : node.next;\n        if (isNonNullable(neighbour) || isNullable(node.parent)) {\n          return false;\n        }\n        return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);\n      };\n      const preprocess = node => {\n        var _a;\n        if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n            text = text.replace(allWhiteSpaceRegExp, ' ');\n            if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {\n              text = text.replace(startWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      const postprocess = node => {\n        var _a;\n        if (node.type === 1) {\n          const elementRule = schema.getElementRule(node.name);\n          if (validate && elementRule) {\n            const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\n            if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {\n              paddEmptyNode(settings, args, isBlock, node);\n            } else if (elementRule.removeEmpty && isNodeEmpty) {\n              if (isBlock(node)) {\n                node.remove();\n              } else {\n                node.unwrap();\n              }\n            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\n              paddEmptyNode(settings, args, isBlock, node);\n            }\n          }\n        } else if (node.type === 3) {\n          if (!hasWhitespaceParent(node)) {\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\n            if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {\n              text = text.replace(endWhiteSpaceRegExp, '');\n            }\n            if (text.length === 0) {\n              node.remove();\n            } else {\n              node.value = text;\n            }\n          }\n        }\n      };\n      return [\n        preprocess,\n        postprocess\n      ];\n    };\n    const getRootBlockName = (settings, args) => {\n      var _a;\n      const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\n      if (name === false) {\n        return '';\n      } else if (name === true) {\n        return 'p';\n      } else {\n        return name;\n      }\n    };\n    const DomParser = (settings = {}, schema = Schema()) => {\n      const nodeFilterRegistry = create$8();\n      const attributeFilterRegistry = create$8();\n      const defaultedSettings = {\n        validate: true,\n        root_name: 'body',\n        sanitize: true,\n        ...settings\n      };\n      const parser = new DOMParser();\n      const sanitizer = getSanitizer(defaultedSettings, schema);\n      const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {\n        const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\n        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\n        const content = isSpecialRoot ? `<${ rootName }>${ html }</${ rootName }>` : html;\n        const wrappedHtml = format === 'xhtml' ? `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${ content }</body></html>` : `<body>${ content }</body>`;\n        const body = parser.parseFromString(wrappedHtml, mimeType).body;\n        sanitizer.sanitizeHtmlElement(body, mimeType);\n        return isSpecialRoot ? body.firstChild : body;\n      };\n      const addNodeFilter = nodeFilterRegistry.addFilter;\n      const getNodeFilters = nodeFilterRegistry.getFilters;\n      const removeNodeFilter = nodeFilterRegistry.removeFilter;\n      const addAttributeFilter = attributeFilterRegistry.addFilter;\n      const getAttributeFilters = attributeFilterRegistry.getFilters;\n      const removeAttributeFilter = attributeFilterRegistry.removeFilter;\n      const findInvalidChildren = (node, invalidChildren) => {\n        if (isInvalid(schema, node)) {\n          invalidChildren.push(node);\n        }\n      };\n      const isWrappableNode = (blockElements, node) => {\n        const isInternalElement = isString(node.attr(internalElementAttr));\n        const isInlineElement = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node)) && !isNonHtmlElementRootName(node.name);\n        return node.type === 3 || isInlineElement && !isInternalElement;\n      };\n      const addRootBlocks = (rootNode, rootBlockName) => {\n        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\n        const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\n        const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\n        let node = rootNode.firstChild, rootBlockNode = null;\n        const trim = rootBlock => {\n          var _a, _b;\n          if (rootBlock) {\n            node = rootBlock.firstChild;\n            if (node && node.type === 3) {\n              node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');\n            }\n            node = rootBlock.lastChild;\n            if (node && node.type === 3) {\n              node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');\n            }\n          }\n        };\n        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\n          return;\n        }\n        while (node) {\n          const next = node.next;\n          if (isWrappableNode(blockElements, node)) {\n            if (!rootBlockNode) {\n              rootBlockNode = new AstNode(rootBlockName, 1);\n              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\n              rootNode.insert(rootBlockNode, node);\n              rootBlockNode.append(node);\n            } else {\n              rootBlockNode.append(node);\n            }\n          } else {\n            trim(rootBlockNode);\n            rootBlockNode = null;\n          }\n          node = next;\n        }\n        trim(rootBlockNode);\n      };\n      const parse = (html, args = {}) => {\n        var _a;\n        const validate = defaultedSettings.validate;\n        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\n        const element = parseAndSanitizeWithContext(html, rootName, args.format);\n        updateChildren(schema, element);\n        const rootNode = new AstNode(rootName, 11);\n        transferChildren(rootNode, element, schema.getSpecialElements(), sanitizer.sanitizeNamespaceElement);\n        element.innerHTML = '';\n        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\n        const invalidChildren = [];\n        const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\n        const matches = {\n          nodes: {},\n          attributes: {}\n        };\n        const matchFinder = node => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);\n        walkTree(rootNode, [\n          whitespacePre,\n          matchFinder\n        ], [\n          whitespacePost,\n          invalidFinder\n        ]);\n        invalidChildren.reverse();\n        if (validate && invalidChildren.length > 0) {\n          if (args.context) {\n            const {\n              pass: topLevelChildren,\n              fail: otherChildren\n            } = partition$2(invalidChildren, child => child.parent === rootNode);\n            cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);\n            args.invalid = topLevelChildren.length > 0;\n          } else {\n            cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);\n          }\n        }\n        const rootBlockName = getRootBlockName(defaultedSettings, args);\n        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\n          addRootBlocks(rootNode, rootBlockName);\n        }\n        if (!args.invalid) {\n          runFilters(matches, args);\n        }\n        return rootNode;\n      };\n      const exports = {\n        schema,\n        addAttributeFilter,\n        getAttributeFilters,\n        removeAttributeFilter,\n        addNodeFilter,\n        getNodeFilters,\n        removeNodeFilter,\n        parse\n      };\n      register$4(exports, defaultedSettings);\n      register$5(exports, defaultedSettings, schema);\n      return exports;\n    };\n\n    const serializeContent = content => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;\n    const withSerializedContent = (content, fireEvent, parserSettings) => {\n      const serializedContent = serializeContent(content);\n      const eventArgs = fireEvent(serializedContent);\n      if (eventArgs.isDefaultPrevented()) {\n        return eventArgs;\n      } else if (isTreeNode(content)) {\n        if (eventArgs.content !== serializedContent) {\n          const rootNode = DomParser({\n            validate: false,\n            forced_root_block: false,\n            ...parserSettings\n          }).parse(eventArgs.content, { context: content.name });\n          return {\n            ...eventArgs,\n            content: rootNode\n          };\n        } else {\n          return {\n            ...eventArgs,\n            content\n          };\n        }\n      } else {\n        return eventArgs;\n      }\n    };\n    const preProcessGetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const eventArgs = fireBeforeGetContent(editor, args);\n        if (eventArgs.isDefaultPrevented()) {\n          return Result.error(fireGetContent(editor, {\n            content: '',\n            ...eventArgs\n          }).content);\n        } else {\n          return Result.value(eventArgs);\n        }\n      }\n    };\n    const postProcessGetContent = (editor, content, args) => {\n      if (args.no_events) {\n        return content;\n      } else {\n        const processedEventArgs = withSerializedContent(content, content => fireGetContent(editor, {\n          ...args,\n          content\n        }), {\n          sanitize: shouldSanitizeXss(editor),\n          sandbox_iframes: shouldSandboxIframes(editor)\n        });\n        return processedEventArgs.content;\n      }\n    };\n    const preProcessSetContent = (editor, args) => {\n      if (args.no_events) {\n        return Result.value(args);\n      } else {\n        const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {\n          ...args,\n          content\n        }), {\n          sanitize: shouldSanitizeXss(editor),\n          sandbox_iframes: shouldSandboxIframes(editor)\n        });\n        if (processedEventArgs.isDefaultPrevented()) {\n          fireSetContent(editor, processedEventArgs);\n          return Result.error(undefined);\n        } else {\n          return Result.value(processedEventArgs);\n        }\n      }\n    };\n    const postProcessSetContent = (editor, content, args) => {\n      if (!args.no_events) {\n        fireSetContent(editor, {\n          ...args,\n          content\n        });\n      }\n    };\n\n    const tableModel = (element, width, rows) => ({\n      element,\n      width,\n      rows\n    });\n    const tableRow = (element, cells) => ({\n      element,\n      cells\n    });\n    const cellPosition = (x, y) => ({\n      x,\n      y\n    });\n    const getSpan = (td, key) => {\n      return getOpt(td, key).bind(toInt).getOr(1);\n    };\n    const fillout = (table, x, y, tr, td) => {\n      const rowspan = getSpan(td, 'rowspan');\n      const colspan = getSpan(td, 'colspan');\n      const rows = table.rows;\n      for (let y2 = y; y2 < y + rowspan; y2++) {\n        if (!rows[y2]) {\n          rows[y2] = tableRow(deep$1(tr), []);\n        }\n        for (let x2 = x; x2 < x + colspan; x2++) {\n          const cells = rows[y2].cells;\n          cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\n        }\n      }\n    };\n    const cellExists = (table, x, y) => {\n      const rows = table.rows;\n      const cells = rows[y] ? rows[y].cells : [];\n      return !!cells[x];\n    };\n    const skipCellsX = (table, x, y) => {\n      while (cellExists(table, x, y)) {\n        x++;\n      }\n      return x;\n    };\n    const getWidth = rows => {\n      return foldl(rows, (acc, row) => {\n        return row.cells.length > acc ? row.cells.length : acc;\n      }, 0);\n    };\n    const findElementPos = (table, element) => {\n      const rows = table.rows;\n      for (let y = 0; y < rows.length; y++) {\n        const cells = rows[y].cells;\n        for (let x = 0; x < cells.length; x++) {\n          if (eq(cells[x], element)) {\n            return Optional.some(cellPosition(x, y));\n          }\n        }\n      }\n      return Optional.none();\n    };\n    const extractRows = (table, sx, sy, ex, ey) => {\n      const newRows = [];\n      const rows = table.rows;\n      for (let y = sy; y <= ey; y++) {\n        const cells = rows[y].cells;\n        const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\n        newRows.push(tableRow(rows[y].element, slice));\n      }\n      return newRows;\n    };\n    const subTable = (table, startPos, endPos) => {\n      const sx = startPos.x, sy = startPos.y;\n      const ex = endPos.x, ey = endPos.y;\n      const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\n      return tableModel(table.element, getWidth(newRows), newRows);\n    };\n    const createDomTable = (table, rows) => {\n      const tableElement = shallow$1(table.element);\n      const tableBody = SugarElement.fromTag('tbody');\n      append(tableBody, rows);\n      append$1(tableElement, tableBody);\n      return tableElement;\n    };\n    const modelRowsToDomRows = table => {\n      return map$3(table.rows, row => {\n        const cells = map$3(row.cells, cell => {\n          const td = deep$1(cell);\n          remove$a(td, 'colspan');\n          remove$a(td, 'rowspan');\n          return td;\n        });\n        const tr = shallow$1(row.element);\n        append(tr, cells);\n        return tr;\n      });\n    };\n    const fromDom = tableElm => {\n      const table = tableModel(shallow$1(tableElm), 0, []);\n      each$e(descendants(tableElm, 'tr'), (tr, y) => {\n        each$e(descendants(tr, 'td,th'), (td, x) => {\n          fillout(table, skipCellsX(table, x, y), y, tr, td);\n        });\n      });\n      return tableModel(table.element, getWidth(table.rows), table.rows);\n    };\n    const toDom = table => {\n      return createDomTable(table, modelRowsToDomRows(table));\n    };\n    const subsection = (table, startElement, endElement) => {\n      return findElementPos(table, startElement).bind(startPos => {\n        return findElementPos(table, endElement).map(endPos => {\n          return subTable(table, startPos, endPos);\n        });\n      });\n    };\n\n    const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\n    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\n      const listElm = SugarElement.fromTag(name(listCont));\n      const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\n      setAll(listElm, listStyles);\n      return [\n        SugarElement.fromTag('li'),\n        listElm\n      ];\n    }).getOr([]));\n    const wrap = (innerElm, elms) => {\n      const wrapped = foldl(elms, (acc, elm) => {\n        append$1(elm, acc);\n        return elm;\n      }, innerElm);\n      return elms.length > 0 ? fromElements([wrapped]) : wrapped;\n    };\n    const directListWrappers = commonAnchorContainer => {\n      if (isListItem$1(commonAnchorContainer)) {\n        return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [\n          commonAnchorContainer,\n          listElm\n        ]);\n      } else {\n        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\n      }\n    };\n    const getWrapElements = (rootNode, rng, schema) => {\n      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\n      const parents = parentsAndSelf(commonAnchorContainer, rootNode);\n      const wrapElements = filter$5(parents, el => schema.isWrapper(name(el)));\n      const listWrappers = getFullySelectedListWrappers(parents, rng);\n      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\n      return map$3(allWrappers, shallow$1);\n    };\n    const emptyFragment = () => fromElements([]);\n    const getFragmentFromRange = (rootNode, rng, schema) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng, schema));\n    const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));\n    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\n      const firstCell = selectedTableCells[0];\n      const lastCell = selectedTableCells[selectedTableCells.length - 1];\n      const fullTableModel = fromDom(tableElm);\n      return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\n    }).getOrThunk(emptyFragment);\n    const getSelectionFragment = (rootNode, ranges, schema) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0], schema);\n    const read$3 = (rootNode, ranges, schema) => {\n      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\n      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges, schema);\n    };\n\n    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\n    const getInnerText = bin => {\n      return trim$2(bin.innerText);\n    };\n    const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\n    const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\n      var _a;\n      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\n      const body = editor.getBody();\n      const contextNodeName = getContextNodeName(parentBlockOpt);\n      const rangeContentClone = SugarElement.fromDom(rng.cloneContents());\n      cleanupBogusElements(rangeContentClone);\n      cleanupInputNames(rangeContentClone);\n      const bin = editor.dom.add(body, contextNodeName, {\n        'data-mce-bogus': 'all',\n        'style': 'overflow: hidden; opacity: 0;'\n      }, rangeContentClone.dom);\n      const text = getInnerText(bin);\n      const nonRenderedText = trim$2((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');\n      editor.dom.remove(bin);\n      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\n        const parentBlock = parentBlockOpt.getOr(body);\n        const parentBlockText = getInnerText(parentBlock);\n        const textIndex = parentBlockText.indexOf(text);\n        if (textIndex === -1) {\n          return text;\n        } else {\n          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\n          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\n          return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\n        }\n      } else {\n        return text;\n      }\n    }).getOr('');\n    const getSerializedContent = (editor, args) => {\n      const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');\n      const sel = editor.selection.getSel();\n      const ranges = processRanges(editor, getRanges$1(sel));\n      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema).dom : rng.cloneContents();\n      if (fragment) {\n        tmpElm.appendChild(fragment);\n      }\n      return editor.selection.serializer.serialize(tmpElm, args);\n    };\n    const extractSelectedContent = (editor, args) => {\n      if (args.format === 'text') {\n        return getTextContent(editor);\n      } else {\n        const content = getSerializedContent(editor, args);\n        if (args.format === 'tree') {\n          return content;\n        } else {\n          return editor.selection.isCollapsed() ? '' : content;\n        }\n      }\n    };\n    const setupArgs$3 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      selection: true,\n      getInner: true\n    });\n    const getSelectedContentInternal = (editor, format, args = {}) => {\n      const defaultedArgs = setupArgs$3(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = extractSelectedContent(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const KEEP = 0, INSERT = 1, DELETE = 2;\n    const diff = (left, right) => {\n      const size = left.length + right.length + 2;\n      const vDown = new Array(size);\n      const vUp = new Array(size);\n      const snake = (start, end, diag) => {\n        return {\n          start,\n          end,\n          diag\n        };\n      };\n      const buildScript = (start1, end1, start2, end2, script) => {\n        const middle = getMiddleSnake(start1, end1, start2, end2);\n        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\n          let i = start1;\n          let j = start2;\n          while (i < end1 || j < end2) {\n            if (i < end1 && j < end2 && left[i] === right[j]) {\n              script.push([\n                KEEP,\n                left[i]\n              ]);\n              ++i;\n              ++j;\n            } else {\n              if (end1 - start1 > end2 - start2) {\n                script.push([\n                  DELETE,\n                  left[i]\n                ]);\n                ++i;\n              } else {\n                script.push([\n                  INSERT,\n                  right[j]\n                ]);\n                ++j;\n              }\n            }\n          }\n        } else {\n          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\n          for (let i2 = middle.start; i2 < middle.end; ++i2) {\n            script.push([\n              KEEP,\n              left[i2]\n            ]);\n          }\n          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\n        }\n      };\n      const buildSnake = (start, diag, end1, end2) => {\n        let end = start;\n        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\n          ++end;\n        }\n        return snake(start, end, diag);\n      };\n      const getMiddleSnake = (start1, end1, start2, end2) => {\n        const m = end1 - start1;\n        const n = end2 - start2;\n        if (m === 0 || n === 0) {\n          return null;\n        }\n        const delta = m - n;\n        const sum = n + m;\n        const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\n        vDown[1 + offset] = start1;\n        vUp[1 + offset] = end1 + 1;\n        let d, k, i, x, y;\n        for (d = 0; d <= offset; ++d) {\n          for (k = -d; k <= d; k += 2) {\n            i = k + offset;\n            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\n              vDown[i] = vDown[i + 1];\n            } else {\n              vDown[i] = vDown[i - 1] + 1;\n            }\n            x = vDown[i];\n            y = x - start1 + start2 - k;\n            while (x < end1 && y < end2 && left[x] === right[y]) {\n              vDown[i] = ++x;\n              ++y;\n            }\n            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\n              if (vUp[i - delta] <= vDown[i]) {\n                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n          for (k = delta - d; k <= delta + d; k += 2) {\n            i = k + offset - delta;\n            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\n              vUp[i] = vUp[i + 1] - 1;\n            } else {\n              vUp[i] = vUp[i - 1];\n            }\n            x = vUp[i] - 1;\n            y = x - start1 + start2 - k;\n            while (x >= start1 && y >= start2 && left[x] === right[y]) {\n              vUp[i] = x--;\n              y--;\n            }\n            if (delta % 2 === 0 && -d <= k && k <= d) {\n              if (vUp[i] <= vDown[i + delta]) {\n                return buildSnake(vUp[i], k + start1 - start2, end1, end2);\n              }\n            }\n          }\n        }\n        return null;\n      };\n      const script = [];\n      buildScript(0, left.length, 0, right.length, script);\n      return script;\n    };\n\n    const getOuterHtml = elm => {\n      if (isElement$6(elm)) {\n        return elm.outerHTML;\n      } else if (isText$a(elm)) {\n        return Entities.encodeRaw(elm.data, false);\n      } else if (isComment(elm)) {\n        return '<!--' + elm.data + '-->';\n      }\n      return '';\n    };\n    const createFragment = html => {\n      let node;\n      const container = document.createElement('div');\n      const frag = document.createDocumentFragment();\n      if (html) {\n        container.innerHTML = html;\n      }\n      while (node = container.firstChild) {\n        frag.appendChild(node);\n      }\n      return frag;\n    };\n    const insertAt = (elm, html, index) => {\n      const fragment = createFragment(html);\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        elm.insertBefore(fragment, target);\n      } else {\n        elm.appendChild(fragment);\n      }\n    };\n    const removeAt = (elm, index) => {\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\n        const target = elm.childNodes[index];\n        elm.removeChild(target);\n      }\n    };\n    const applyDiff = (diff, elm) => {\n      let index = 0;\n      each$e(diff, action => {\n        if (action[0] === KEEP) {\n          index++;\n        } else if (action[0] === INSERT) {\n          insertAt(elm, action[1], index);\n          index++;\n        } else if (action[0] === DELETE) {\n          removeAt(elm, index);\n        }\n      });\n    };\n    const read$2 = (elm, trimZwsp) => filter$5(map$3(from(elm.childNodes), trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml), item => {\n      return item.length > 0;\n    });\n    const write = (fragments, elm) => {\n      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\n      applyDiff(diff(currentFragments, fragments), elm);\n      return elm;\n    };\n\n    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\n    const hasIframes = body => body.querySelector('iframe') !== null;\n    const createFragmentedLevel = fragments => {\n      return {\n        type: 'fragmented',\n        fragments,\n        content: '',\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createCompleteLevel = content => {\n      return {\n        type: 'complete',\n        fragments: null,\n        content,\n        bookmark: null,\n        beforeBookmark: null\n      };\n    };\n    const createFromEditor = editor => {\n      const tempAttrs = editor.serializer.getTempAttrs();\n      const body = trim$1(editor.getBody(), tempAttrs);\n      return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$2(body.innerHTML));\n    };\n    const applyToEditor = (editor, level, before) => {\n      const bookmark = before ? level.beforeBookmark : level.bookmark;\n      if (level.type === 'fragmented') {\n        write(level.fragments, editor.getBody());\n      } else {\n        editor.setContent(level.content, {\n          format: 'raw',\n          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\n        });\n      }\n      if (bookmark) {\n        editor.selection.moveToBookmark(bookmark);\n        editor.selection.scrollIntoView();\n      }\n    };\n    const getLevelContent = level => {\n      return level.type === 'fragmented' ? level.fragments.join('') : level.content;\n    };\n    const getCleanLevelContent = level => {\n      const elm = SugarElement.fromTag('body', lazyTempDocument());\n      set$1(elm, getLevelContent(level));\n      each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);\n      return get$6(elm);\n    };\n    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\n    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\n    const isEq$1 = (level1, level2) => {\n      if (!level1 || !level2) {\n        return false;\n      } else if (hasEqualContent(level1, level2)) {\n        return true;\n      } else {\n        return hasEqualCleanedContent(level1, level2);\n      }\n    };\n\n    const isUnlocked = locks => locks.get() === 0;\n\n    const setTyping = (undoManager, typing, locks) => {\n      if (isUnlocked(locks)) {\n        undoManager.typing = typing;\n      }\n    };\n    const endTyping = (undoManager, locks) => {\n      if (undoManager.typing) {\n        setTyping(undoManager, false, locks);\n        undoManager.add();\n      }\n    };\n    const endTypingLevelIgnoreLocks = undoManager => {\n      if (undoManager.typing) {\n        undoManager.typing = false;\n        undoManager.add();\n      }\n    };\n\n    const beforeChange$1 = (editor, locks, beforeBookmark) => {\n      if (isUnlocked(locks)) {\n        beforeBookmark.set(getUndoBookmark(editor.selection));\n      }\n    };\n    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\n      const currentLevel = createFromEditor(editor);\n      const newLevel = Tools.extend(level || {}, currentLevel);\n      if (!isUnlocked(locks) || editor.removed) {\n        return null;\n      }\n      const lastLevel = undoManager.data[index.get()];\n      if (editor.dispatch('BeforeAddUndo', {\n          level: newLevel,\n          lastLevel,\n          originalEvent: event\n        }).isDefaultPrevented()) {\n        return null;\n      }\n      if (lastLevel && isEq$1(lastLevel, newLevel)) {\n        return null;\n      }\n      if (undoManager.data[index.get()]) {\n        beforeBookmark.get().each(bm => {\n          undoManager.data[index.get()].beforeBookmark = bm;\n        });\n      }\n      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\n      if (customUndoRedoLevels) {\n        if (undoManager.data.length > customUndoRedoLevels) {\n          for (let i = 0; i < undoManager.data.length - 1; i++) {\n            undoManager.data[i] = undoManager.data[i + 1];\n          }\n          undoManager.data.length--;\n          index.set(undoManager.data.length);\n        }\n      }\n      newLevel.bookmark = getUndoBookmark(editor.selection);\n      if (index.get() < undoManager.data.length - 1) {\n        undoManager.data.length = index.get() + 1;\n      }\n      undoManager.data.push(newLevel);\n      index.set(undoManager.data.length - 1);\n      const args = {\n        level: newLevel,\n        lastLevel,\n        originalEvent: event\n      };\n      if (index.get() > 0) {\n        editor.setDirty(true);\n        editor.dispatch('AddUndo', args);\n        editor.dispatch('change', args);\n      } else {\n        editor.dispatch('AddUndo', args);\n      }\n      return newLevel;\n    };\n    const clear$1 = (editor, undoManager, index) => {\n      undoManager.data = [];\n      index.set(0);\n      undoManager.typing = false;\n      editor.dispatch('ClearUndos');\n    };\n    const extra$1 = (editor, undoManager, index, callback1, callback2) => {\n      if (undoManager.transact(callback1)) {\n        const bookmark = undoManager.data[index.get()].bookmark;\n        const lastLevel = undoManager.data[index.get() - 1];\n        applyToEditor(editor, lastLevel, true);\n        if (undoManager.transact(callback2)) {\n          undoManager.data[index.get() - 1].beforeBookmark = bookmark;\n        }\n      }\n    };\n    const redo$1 = (editor, index, data) => {\n      let level;\n      if (index.get() < data.length - 1) {\n        index.set(index.get() + 1);\n        level = data[index.get()];\n        applyToEditor(editor, level, false);\n        editor.setDirty(true);\n        editor.dispatch('Redo', { level });\n      }\n      return level;\n    };\n    const undo$1 = (editor, undoManager, locks, index) => {\n      let level;\n      if (undoManager.typing) {\n        undoManager.add();\n        undoManager.typing = false;\n        setTyping(undoManager, false, locks);\n      }\n      if (index.get() > 0) {\n        index.set(index.get() - 1);\n        level = undoManager.data[index.get()];\n        applyToEditor(editor, level, true);\n        editor.setDirty(true);\n        editor.dispatch('Undo', { level });\n      }\n      return level;\n    };\n    const reset$1 = undoManager => {\n      undoManager.clear();\n      undoManager.add();\n    };\n    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\n    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\n    const transact$1 = (undoManager, locks, callback) => {\n      endTyping(undoManager, locks);\n      undoManager.beforeChange();\n      undoManager.ignore(callback);\n      return undoManager.add();\n    };\n    const ignore$1 = (locks, callback) => {\n      try {\n        locks.set(locks.get() + 1);\n        callback();\n      } finally {\n        locks.set(locks.get() - 1);\n      }\n    };\n\n    const addVisualInternal = (editor, elm) => {\n      const dom = editor.dom;\n      const scope = isNonNullable(elm) ? elm : editor.getBody();\n      each$e(dom.select('table,a', scope), matchedElm => {\n        switch (matchedElm.nodeName) {\n        case 'TABLE':\n          const cls = getVisualAidsTableClass(editor);\n          const value = dom.getAttrib(matchedElm, 'border');\n          if ((!value || value === '0') && editor.hasVisual) {\n            dom.addClass(matchedElm, cls);\n          } else {\n            dom.removeClass(matchedElm, cls);\n          }\n          break;\n        case 'A':\n          if (!dom.getAttrib(matchedElm, 'href')) {\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\n            const cls = getVisualAidsAnchorClass(editor);\n            if (value && editor.hasVisual) {\n              dom.addClass(matchedElm, cls);\n            } else {\n              dom.removeClass(matchedElm, cls);\n            }\n          }\n          break;\n        }\n      });\n      editor.dispatch('VisualAid', {\n        element: elm,\n        hasVisual: editor.hasVisual\n      });\n    };\n\n    const makePlainAdaptor = editor => ({\n      init: { bindEvents: noop },\n      undoManager: {\n        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\n        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\n        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\n        redo: (index, data) => redo$1(editor, index, data),\n        clear: (undoManager, index) => clear$1(editor, undoManager, index),\n        reset: undoManager => reset$1(undoManager),\n        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\n        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\n        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\n        ignore: (locks, callback) => ignore$1(locks, callback),\n        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\n      },\n      formatter: {\n        match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\n        matchAll: (names, vars) => matchAll(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\n        canApply: name => canApply(editor, name),\n        closest: names => closest(editor, names),\n        apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\n        remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),\n        toggle: (name, vars, node) => toggle(editor, name, vars, node),\n        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\n      },\n      editor: {\n        getContent: args => getContentInternal(editor, args),\n        setContent: (content, args) => setContentInternal(editor, content, args),\n        insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\n        addVisual: elm => addVisualInternal(editor, elm)\n      },\n      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },\n      autocompleter: {\n        addDecoration: range => create$9(editor, range),\n        removeDecoration: () => remove$2(editor, SugarElement.fromDom(editor.getBody()))\n      },\n      raw: { getModel: () => Optional.none() }\n    });\n    const makeRtcAdaptor = rtcEditor => {\n      const defaultVars = vars => isObject(vars) ? vars : {};\n      const {init, undoManager, formatter, editor, selection, autocompleter, raw} = rtcEditor;\n      return {\n        init: { bindEvents: init.bindEvents },\n        undoManager: {\n          beforeChange: undoManager.beforeChange,\n          add: undoManager.add,\n          undo: undoManager.undo,\n          redo: undoManager.redo,\n          clear: undoManager.clear,\n          reset: undoManager.reset,\n          hasUndo: undoManager.hasUndo,\n          hasRedo: undoManager.hasRedo,\n          transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\n          ignore: (_locks, callback) => undoManager.ignore(callback),\n          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\n        },\n        formatter: {\n          match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\n          matchAll: formatter.matchAll,\n          matchNode: formatter.matchNode,\n          canApply: name => formatter.canApply(name),\n          closest: names => formatter.closest(names),\n          apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\n          remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\n          toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\n          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\n        },\n        editor: {\n          getContent: args => editor.getContent(args),\n          setContent: (content, args) => {\n            return {\n              content: editor.setContent(content, args),\n              html: ''\n            };\n          },\n          insertContent: (content, _details) => {\n            editor.insertContent(content);\n            return '';\n          },\n          addVisual: editor.addVisual\n        },\n        selection: { getContent: (_format, args) => selection.getContent(args) },\n        autocompleter: {\n          addDecoration: autocompleter.addDecoration,\n          removeDecoration: autocompleter.removeDecoration\n        },\n        raw: { getModel: () => Optional.some(raw.getRawModel()) }\n      };\n    };\n    const makeNoopAdaptor = () => {\n      const nul = constant(null);\n      const empty = constant('');\n      return {\n        init: { bindEvents: noop },\n        undoManager: {\n          beforeChange: noop,\n          add: nul,\n          undo: nul,\n          redo: nul,\n          clear: noop,\n          reset: noop,\n          hasUndo: never,\n          hasRedo: never,\n          transact: nul,\n          ignore: noop,\n          extra: noop\n        },\n        formatter: {\n          match: never,\n          matchAll: constant([]),\n          matchNode: constant(undefined),\n          canApply: never,\n          closest: empty,\n          apply: noop,\n          remove: noop,\n          toggle: noop,\n          formatChanged: constant({ unbind: noop })\n        },\n        editor: {\n          getContent: empty,\n          setContent: constant({\n            content: '',\n            html: ''\n          }),\n          insertContent: constant(''),\n          addVisual: noop\n        },\n        selection: { getContent: empty },\n        autocompleter: {\n          addDecoration: noop,\n          removeDecoration: noop\n        },\n        raw: { getModel: constant(Optional.none()) }\n      };\n    };\n    const isRtc = editor => has$2(editor.plugins, 'rtc');\n    const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\n    const setup$t = editor => {\n      const editorCast = editor;\n      return getRtcSetup(editor).fold(() => {\n        editorCast.rtcInstance = makePlainAdaptor(editor);\n        return Optional.none();\n      }, setup => {\n        editorCast.rtcInstance = makeNoopAdaptor();\n        return Optional.some(() => setup().then(rtcEditor => {\n          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\n          return rtcEditor.rtc.isRemote;\n        }));\n      });\n    };\n    const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\n    const getRtcInstanceWithError = editor => {\n      const rtcInstance = editor.rtcInstance;\n      if (!rtcInstance) {\n        throw new Error('Failed to get RTC instance not yet initialized.');\n      } else {\n        return rtcInstance;\n      }\n    };\n    const beforeChange = (editor, locks, beforeBookmark) => {\n      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\n    };\n    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\n    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\n    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\n    const clear = (editor, undoManager, index) => {\n      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\n    };\n    const reset = (editor, undoManager) => {\n      getRtcInstanceWithError(editor).undoManager.reset(undoManager);\n    };\n    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\n    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\n    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\n    const ignore = (editor, locks, callback) => {\n      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\n    };\n    const extra = (editor, undoManager, index, callback1, callback2) => {\n      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\n    };\n    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\n    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\n    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\n    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\n    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\n    const applyFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\n    };\n    const removeFormat = (editor, name, vars, node, similar) => {\n      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\n    };\n    const toggleFormat = (editor, name, vars, node) => {\n      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\n    };\n    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\n    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\n    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\n    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\n    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\n    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\n    const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\n    const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);\n    const removeAutocompleterDecoration = editor => getRtcInstanceWithError(editor).autocompleter.removeDecoration();\n\n    const getContent$1 = (editor, args = {}) => {\n      const format = args.format ? args.format : 'html';\n      return getSelectedContent(editor, format, args);\n    };\n\n    const removeEmpty = text => {\n      if (text.dom.length === 0) {\n        remove$5(text);\n        return Optional.none();\n      } else {\n        return Optional.some(text);\n      }\n    };\n    const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\n    const merge$1 = (outer, inner, rng, start, schema) => {\n      const outerElm = outer.dom;\n      const innerElm = inner.dom;\n      const oldLength = start ? outerElm.length : innerElm.length;\n      if (start) {\n        mergeTextNodes(outerElm, innerElm, schema, false, !start);\n        rng.setStart(innerElm, oldLength);\n      } else {\n        mergeTextNodes(innerElm, outerElm, schema, false, !start);\n        rng.setEnd(innerElm, oldLength);\n      }\n    };\n    const normalizeTextIfRequired = (inner, start, schema) => {\n      parent(inner).each(root => {\n        const text = inner.dom;\n        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {\n          normalizeWhitespaceAfter(text, 0, schema);\n        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length), schema)) {\n          normalizeWhitespaceBefore(text, text.length, schema);\n        }\n      });\n    };\n    const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {\n      outerNode.bind(outer => {\n        const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\n        normalizer(outer.dom, start ? outer.dom.length : 0, schema);\n        return innerNode.filter(isText$b).map(inner => merge$1(outer, inner, rng, start, schema));\n      }).orThunk(() => {\n        const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$b);\n        return innerTextNode.map(inner => normalizeTextIfRequired(inner, start, schema));\n      });\n    };\n    const rngSetContent = (rng, fragment, schema) => {\n      const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\n      const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\n      rng.deleteContents();\n      rng.insertNode(fragment);\n      const prevText = firstChild.bind(prevSibling).filter(isText$b).bind(removeEmpty);\n      const nextText = lastChild.bind(nextSibling).filter(isText$b).bind(removeEmpty);\n      mergeAndNormalizeText(prevText, firstChild, rng, true, schema);\n      mergeAndNormalizeText(nextText, lastChild, rng, false, schema);\n      rng.collapse(false);\n    };\n    const setupArgs$2 = (args, content) => ({\n      format: 'html',\n      ...args,\n      set: true,\n      selection: true,\n      content\n    });\n    const cleanContent = (editor, args) => {\n      if (args.format !== 'raw') {\n        const rng = editor.selection.getRng();\n        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\n        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};\n        const node = editor.parser.parse(args.content, {\n          forced_root_block: false,\n          ...contextArgs,\n          ...args\n        });\n        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);\n      } else {\n        return args.content;\n      }\n    };\n    const setContent$1 = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs$2(args, content);\n      preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\n        const cleanedContent = cleanContent(editor, updatedArgs);\n        const rng = editor.selection.getRng();\n        rngSetContent(rng, rng.createContextualFragment(cleanedContent), editor.schema);\n        editor.selection.setRng(rng);\n        scrollRangeIntoView(editor, rng);\n        postProcessSetContent(editor, cleanedContent, updatedArgs);\n      });\n    };\n\n    const deleteFromCallbackMap = (callbackMap, selector, callback) => {\n      if (has$2(callbackMap, selector)) {\n        const newCallbacks = filter$5(callbackMap[selector], cb => cb !== callback);\n        if (newCallbacks.length === 0) {\n          delete callbackMap[selector];\n        } else {\n          callbackMap[selector] = newCallbacks;\n        }\n      }\n    };\n    var SelectorChanged = (dom, editor) => {\n      let selectorChangedData;\n      let currentSelectors;\n      const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\n      const getParents = elem => dom.getParents(elem, undefined, dom.getRoot());\n      const setup = () => {\n        selectorChangedData = {};\n        currentSelectors = {};\n        editor.on('NodeChange', e => {\n          const node = e.element;\n          const parents = getParents(node);\n          const matchedSelectors = {};\n          each$d(selectorChangedData, (callbacks, selector) => {\n            findMatchingNode(selector, parents).each(node => {\n              if (!currentSelectors[selector]) {\n                each$e(callbacks, callback => {\n                  callback(true, {\n                    node,\n                    selector,\n                    parents\n                  });\n                });\n                currentSelectors[selector] = callbacks;\n              }\n              matchedSelectors[selector] = callbacks;\n            });\n          });\n          each$d(currentSelectors, (callbacks, selector) => {\n            if (!matchedSelectors[selector]) {\n              delete currentSelectors[selector];\n              each$e(callbacks, callback => {\n                callback(false, {\n                  node,\n                  selector,\n                  parents\n                });\n              });\n            }\n          });\n        });\n      };\n      return {\n        selectorChangedWithUnbind: (selector, callback) => {\n          if (!selectorChangedData) {\n            setup();\n          }\n          if (!selectorChangedData[selector]) {\n            selectorChangedData[selector] = [];\n          }\n          selectorChangedData[selector].push(callback);\n          findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\n            currentSelectors[selector] = selectorChangedData[selector];\n          });\n          return {\n            unbind: () => {\n              deleteFromCallbackMap(selectorChangedData, selector, callback);\n              deleteFromCallbackMap(currentSelectors, selector, callback);\n            }\n          };\n        }\n      };\n    };\n\n    const isAttachedToDom = node => {\n      return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\n    };\n    const isValidRange = rng => {\n      if (!rng) {\n        return false;\n      } else {\n        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\n      }\n    };\n    const EditorSelection = (dom, win, serializer, editor) => {\n      let selectedRange;\n      let explicitRange;\n      const {selectorChangedWithUnbind} = SelectorChanged(dom, editor);\n      const setCursorLocation = (node, offset) => {\n        const rng = dom.createRng();\n        if (isNonNullable(node) && isNonNullable(offset)) {\n          rng.setStart(node, offset);\n          rng.setEnd(node, offset);\n          setRng(rng);\n          collapse(false);\n        } else {\n          moveEndPoint(dom, rng, editor.getBody(), true);\n          setRng(rng);\n        }\n      };\n      const getContent = args => getContent$1(editor, args);\n      const setContent = (content, args) => setContent$1(editor, content, args);\n      const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\n      const getEnd = real => getEnd$1(editor.getBody(), getRng$1(), real);\n      const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\n      const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\n      const select$1 = (node, content) => {\n        select(dom, node, content).each(setRng);\n        return node;\n      };\n      const isCollapsed = () => {\n        const rng = getRng$1(), sel = getSel();\n        if (!rng || rng.item) {\n          return false;\n        }\n        if (rng.compareEndPoints) {\n          return rng.compareEndPoints('StartToEnd', rng) === 0;\n        }\n        return !sel || rng.collapsed;\n      };\n      const isEditable = () => {\n        const rng = getRng$1();\n        const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected=\"1\"]');\n        if (fakeSelectedElements.length > 0) {\n          return forall(fakeSelectedElements, el => dom.isEditable(el.parentElement));\n        } else {\n          return isEditableRange(dom, rng);\n        }\n      };\n      const collapse = toStart => {\n        const rng = getRng$1();\n        rng.collapse(!!toStart);\n        setRng(rng);\n      };\n      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\n      const getRng$1 = () => {\n        let rng;\n        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\n          try {\n            return sourceRange.compareBoundaryPoints(how, destinationRange);\n          } catch (ex) {\n            return -1;\n          }\n        };\n        const doc = win.document;\n        if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\n          const bookmark = getRng(editor);\n          if (bookmark.isSome()) {\n            return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\n          }\n        }\n        try {\n          const selection = getSel();\n          if (selection && !isRestrictedNode(selection.anchorNode)) {\n            if (selection.rangeCount > 0) {\n              rng = selection.getRangeAt(0);\n            } else {\n              rng = doc.createRange();\n            }\n            rng = processRanges(editor, [rng])[0];\n          }\n        } catch (ex) {\n        }\n        if (!rng) {\n          rng = doc.createRange();\n        }\n        if (isDocument$1(rng.startContainer) && rng.collapsed) {\n          const elm = dom.getRoot();\n          rng.setStart(elm, 0);\n          rng.setEnd(elm, 0);\n        }\n        if (selectedRange && explicitRange) {\n          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\n            rng = explicitRange;\n          } else {\n            selectedRange = null;\n            explicitRange = null;\n          }\n        }\n        return rng;\n      };\n      const setRng = (rng, forward) => {\n        if (!isValidRange(rng)) {\n          return;\n        }\n        const sel = getSel();\n        const evt = editor.dispatch('SetSelectionRange', {\n          range: rng,\n          forward\n        });\n        rng = evt.range;\n        if (sel) {\n          explicitRange = rng;\n          try {\n            sel.removeAllRanges();\n            sel.addRange(rng);\n          } catch (ex) {\n          }\n          if (forward === false && sel.extend) {\n            sel.collapse(rng.endContainer, rng.endOffset);\n            sel.extend(rng.startContainer, rng.startOffset);\n          }\n          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\n        }\n        if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {\n          if (rng.endOffset - rng.startOffset < 2) {\n            if (rng.startContainer.hasChildNodes()) {\n              const node = rng.startContainer.childNodes[rng.startOffset];\n              if (node && node.nodeName === 'IMG') {\n                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\n                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\n                  sel.setBaseAndExtent(node, 0, node, 1);\n                }\n              }\n            }\n          }\n        }\n        editor.dispatch('AfterSetSelectionRange', {\n          range: rng,\n          forward\n        });\n      };\n      const setNode = elm => {\n        setContent(dom.getOuterHTML(elm));\n        return elm;\n      };\n      const getNode$1 = () => getNode(editor.getBody(), getRng$1());\n      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\n      const isForward = () => {\n        const sel = getSel();\n        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\n          return true;\n        }\n        const anchorRange = dom.createRng();\n        const focusRange = dom.createRng();\n        try {\n          anchorRange.setStart(anchorNode, sel.anchorOffset);\n          anchorRange.collapse(true);\n          focusRange.setStart(focusNode, sel.focusOffset);\n          focusRange.collapse(true);\n        } catch (e) {\n          return true;\n        }\n        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\n      };\n      const normalize = () => {\n        const rng = getRng$1();\n        const sel = getSel();\n        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\n          const normRng = normalize$2(dom, rng);\n          normRng.each(normRng => {\n            setRng(normRng, isForward());\n          });\n          return normRng.getOr(rng);\n        }\n        return rng;\n      };\n      const selectorChanged = (selector, callback) => {\n        selectorChangedWithUnbind(selector, callback);\n        return exports;\n      };\n      const getScrollContainer = () => {\n        let scrollContainer;\n        let node = dom.getRoot();\n        while (node && node.nodeName !== 'BODY') {\n          if (node.scrollHeight > node.clientHeight) {\n            scrollContainer = node;\n            break;\n          }\n          node = node.parentNode;\n        }\n        return scrollContainer;\n      };\n      const scrollIntoView = (elm, alignToTop) => {\n        if (isNonNullable(elm)) {\n          scrollElementIntoView(editor, elm, alignToTop);\n        } else {\n          scrollRangeIntoView(editor, getRng$1(), alignToTop);\n        }\n      };\n      const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\n      const getBoundingClientRect = () => {\n        const rng = getRng$1();\n        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\n      };\n      const destroy = () => {\n        win = selectedRange = explicitRange = null;\n        controlSelection.destroy();\n      };\n      const expand = (options = { type: 'word' }) => setRng(RangeUtils(dom).expand(getRng$1(), options));\n      const exports = {\n        dom,\n        win,\n        serializer,\n        editor,\n        expand,\n        collapse,\n        setCursorLocation,\n        getContent,\n        setContent,\n        getBookmark,\n        moveToBookmark,\n        select: select$1,\n        isCollapsed,\n        isEditable,\n        isForward,\n        setNode,\n        getNode: getNode$1,\n        getSel,\n        setRng,\n        getRng: getRng$1,\n        getStart: getStart$1,\n        getEnd,\n        getSelectedBlocks: getSelectedBlocks$1,\n        normalize,\n        selectorChanged,\n        selectorChangedWithUnbind,\n        getScrollContainer,\n        scrollIntoView,\n        placeCaretAt,\n        getBoundingClientRect,\n        destroy\n      };\n      const bookmarkManager = BookmarkManager(exports);\n      const controlSelection = ControlSelection(exports, editor);\n      exports.bookmarkManager = bookmarkManager;\n      exports.controlSelection = controlSelection;\n      return exports;\n    };\n\n    const register$3 = (htmlParser, settings, dom) => {\n      htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          node.attr('tabindex', node.attr('data-mce-tabindex'));\n          node.attr(name, null);\n        }\n      });\n      htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\n        const internalName = 'data-mce-' + name;\n        const urlConverter = settings.url_converter;\n        const urlConverterScope = settings.url_converter_scope;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(internalName);\n          if (value !== undefined) {\n            node.attr(name, value.length > 0 ? value : null);\n            node.attr(internalName, null);\n          } else {\n            value = node.attr(name);\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n            } else if (urlConverter) {\n              value = urlConverter.call(urlConverterScope, value, name, node.name);\n            }\n            node.attr(name, value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr('class');\n          if (value) {\n            value = value.replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\n            node.attr('class', value.length > 0 ? value : null);\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\n            const hasChildren = Optional.from(node.firstChild).exists(firstChild => {\n              var _a;\n              return !isZwsp$1((_a = firstChild.value) !== null && _a !== void 0 ? _a : '');\n            });\n            if (hasChildren) {\n              node.unwrap();\n            } else {\n              node.remove();\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('noscript', nodes => {\n        var _a;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i].firstChild;\n          if (node) {\n            node.value = Entities.decode((_a = node.value) !== null && _a !== void 0 ? _a : '');\n          }\n        }\n      });\n      htmlParser.addNodeFilter('script,style', (nodes, name) => {\n        var _a;\n        const trim = value => {\n          return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\n        };\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const firstChild = node.firstChild;\n          const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';\n          if (name === 'script') {\n            const type = node.attr('type');\n            if (type) {\n              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\n            }\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n              firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\n            }\n          } else {\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\n              firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\n            }\n          }\n        }\n      });\n      htmlParser.addNodeFilter('#comment', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const value = node.value;\n          if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {\n            node.name = '#cdata';\n            node.type = 4;\n            node.value = dom.decode(value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\n          } else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = unescape(value).substr(14);\n          }\n        }\n      });\n      htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (node.type === 7) {\n            node.remove();\n          } else if (node.type === 1) {\n            if (name === 'input' && !node.attr('type')) {\n              node.attr('type', 'text');\n            }\n          }\n        }\n      });\n      htmlParser.addAttributeFilter('data-mce-type', nodes => {\n        each$e(nodes, node => {\n          if (node.attr('data-mce-type') === 'format-caret') {\n            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\n              node.remove();\n            } else {\n              node.unwrap();\n            }\n          }\n        });\n      });\n      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,data-mce-block,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\n        let i = nodes.length;\n        while (i--) {\n          nodes[i].attr(name, null);\n        }\n      });\n      if (settings.remove_trailing_brs) {\n        addNodeFilter(settings, htmlParser, htmlParser.schema);\n      }\n    };\n    const trimTrailingBr = rootNode => {\n      const isBr = node => {\n        return (node === null || node === void 0 ? void 0 : node.name) === 'br';\n      };\n      const brNode1 = rootNode.lastChild;\n      if (isBr(brNode1)) {\n        const brNode2 = brNode1.prev;\n        if (isBr(brNode2)) {\n          brNode1.remove();\n          brNode2.remove();\n        }\n      }\n    };\n\n    const preProcess$1 = (editor, node, args) => {\n      let oldDoc;\n      const dom = editor.dom;\n      let clonedNode = node.cloneNode(true);\n      const impl = document.implementation;\n      if (impl.createHTMLDocument) {\n        const doc = impl.createHTMLDocument('');\n        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\n          doc.body.appendChild(doc.importNode(node, true));\n        });\n        if (clonedNode.nodeName !== 'BODY') {\n          clonedNode = doc.body.firstChild;\n        } else {\n          clonedNode = doc.body;\n        }\n        oldDoc = dom.doc;\n        dom.doc = doc;\n      }\n      firePreProcess(editor, {\n        ...args,\n        node: clonedNode\n      });\n      if (oldDoc) {\n        dom.doc = oldDoc;\n      }\n      return clonedNode;\n    };\n    const shouldFireEvent = (editor, args) => {\n      return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;\n    };\n    const process$1 = (editor, node, args) => {\n      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\n    };\n\n    const addTempAttr = (htmlParser, tempAttrs, name) => {\n      if (Tools.inArray(tempAttrs, name) === -1) {\n        htmlParser.addAttributeFilter(name, (nodes, name) => {\n          let i = nodes.length;\n          while (i--) {\n            nodes[i].attr(name, null);\n          }\n        });\n        tempAttrs.push(name);\n      }\n    };\n    const postProcess = (editor, args, content) => {\n      if (!args.no_events && editor) {\n        const outArgs = firePostProcess(editor, {\n          ...args,\n          content\n        });\n        return outArgs.content;\n      } else {\n        return content;\n      }\n    };\n    const getHtmlFromNode = (dom, node, args) => {\n      const html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\n      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\n    };\n    const parseHtml = (htmlParser, html, args) => {\n      const parserArgs = args.selection ? {\n        forced_root_block: false,\n        ...args\n      } : args;\n      const rootNode = htmlParser.parse(html, parserArgs);\n      trimTrailingBr(rootNode);\n      return rootNode;\n    };\n    const serializeNode = (settings, schema, node) => {\n      const htmlSerializer = HtmlSerializer(settings, schema);\n      return htmlSerializer.serialize(node);\n    };\n    const toHtml = (editor, settings, schema, rootNode, args) => {\n      const content = serializeNode(settings, schema, rootNode);\n      return postProcess(editor, args, content);\n    };\n    const DomSerializerImpl = (settings, editor) => {\n      const tempAttrs = ['data-mce-selected'];\n      const defaultedSettings = {\n        entity_encoding: 'named',\n        remove_trailing_brs: true,\n        pad_empty_with_br: false,\n        ...settings\n      };\n      const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\n      const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);\n      const htmlParser = DomParser(defaultedSettings, schema);\n      register$3(htmlParser, defaultedSettings, dom);\n      const serialize = (node, parserArgs = {}) => {\n        const args = {\n          format: 'html',\n          ...parserArgs\n        };\n        const targetNode = process$1(editor, node, args);\n        const html = getHtmlFromNode(dom, targetNode, args);\n        const rootNode = parseHtml(htmlParser, html, args);\n        return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);\n      };\n      return {\n        schema,\n        addNodeFilter: htmlParser.addNodeFilter,\n        addAttributeFilter: htmlParser.addAttributeFilter,\n        serialize: serialize,\n        addRules: schema.addValidElements,\n        setRules: schema.setValidElements,\n        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\n        getTempAttrs: constant(tempAttrs),\n        getNodeFilters: htmlParser.getNodeFilters,\n        getAttributeFilters: htmlParser.getAttributeFilters,\n        removeNodeFilter: htmlParser.removeNodeFilter,\n        removeAttributeFilter: htmlParser.removeAttributeFilter\n      };\n    };\n\n    const DomSerializer = (settings, editor) => {\n      const domSerializer = DomSerializerImpl(settings, editor);\n      return {\n        schema: domSerializer.schema,\n        addNodeFilter: domSerializer.addNodeFilter,\n        addAttributeFilter: domSerializer.addAttributeFilter,\n        serialize: domSerializer.serialize,\n        addRules: domSerializer.addRules,\n        setRules: domSerializer.setRules,\n        addTempAttr: domSerializer.addTempAttr,\n        getTempAttrs: domSerializer.getTempAttrs,\n        getNodeFilters: domSerializer.getNodeFilters,\n        getAttributeFilters: domSerializer.getAttributeFilters,\n        removeNodeFilter: domSerializer.removeNodeFilter,\n        removeAttributeFilter: domSerializer.removeAttributeFilter\n      };\n    };\n\n    const defaultFormat$1 = 'html';\n    const setupArgs$1 = (args, format) => ({\n      ...args,\n      format,\n      get: true,\n      getInner: true\n    });\n    const getContent = (editor, args = {}) => {\n      const format = args.format ? args.format : defaultFormat$1;\n      const defaultedArgs = setupArgs$1(args, format);\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\n        const content = getContent$2(editor, updatedArgs);\n        return postProcessGetContent(editor, content, updatedArgs);\n      });\n    };\n\n    const defaultFormat = 'html';\n    const setupArgs = (args, content) => ({\n      format: defaultFormat,\n      ...args,\n      set: true,\n      content\n    });\n    const setContent = (editor, content, args = {}) => {\n      const defaultedArgs = setupArgs(args, content);\n      return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\n        const result = setContent$2(editor, updatedArgs.content, updatedArgs);\n        postProcessSetContent(editor, result.html, updatedArgs);\n        return result.content;\n      }).getOr(content);\n    };\n\n    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');\n    const deprecatedOptions = 'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format'.split(',');\n    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');\n    const deprecatedPlugins = [\n      {\n        name: 'template',\n        replacedWith: 'Advanced Template'\n      },\n      { name: 'rtc' }\n    ];\n    const getMatchingOptions = (options, searchingFor) => {\n      const settingNames = filter$5(searchingFor, setting => has$2(options, setting));\n      return sort(settingNames);\n    };\n    const getRemovedOptions = options => {\n      const settingNames = getMatchingOptions(options, removedOptions);\n      const forcedRootBlock = options.forced_root_block;\n      if (forcedRootBlock === false || forcedRootBlock === '') {\n        settingNames.push('forced_root_block (false only)');\n      }\n      return sort(settingNames);\n    };\n    const getDeprecatedOptions = options => getMatchingOptions(options, deprecatedOptions);\n    const getMatchingPlugins = (options, searchingFor) => {\n      const plugins = Tools.makeMap(options.plugins, ' ');\n      const hasPlugin = plugin => has$2(plugins, plugin);\n      const pluginNames = filter$5(searchingFor, hasPlugin);\n      return sort(pluginNames);\n    };\n    const getRemovedPlugins = options => getMatchingPlugins(options, removedPlugins);\n    const getDeprecatedPlugins = options => getMatchingPlugins(options, deprecatedPlugins.map(entry => entry.name));\n    const logRemovedWarnings = (rawOptions, normalizedOptions) => {\n      const removedOptions = getRemovedOptions(rawOptions);\n      const removedPlugins = getRemovedPlugins(normalizedOptions);\n      const hasRemovedPlugins = removedPlugins.length > 0;\n      const hasRemovedOptions = removedOptions.length > 0;\n      const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\n      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\n        const listJoiner = '\\n- ';\n        const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${ listJoiner }mobile` : '';\n        const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${ listJoiner }${ removedPlugins.join(listJoiner) }` : '';\n        const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${ listJoiner }${ removedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\n      }\n    };\n    const getPluginDescription = name => find$2(deprecatedPlugins, entry => entry.name === name).fold(() => name, entry => {\n      if (entry.replacedWith) {\n        return `${ name }, replaced by ${ entry.replacedWith }`;\n      } else {\n        return name;\n      }\n    });\n    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {\n      const deprecatedOptions = getDeprecatedOptions(rawOptions);\n      const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);\n      const hasDeprecatedPlugins = deprecatedPlugins.length > 0;\n      const hasDeprecatedOptions = deprecatedOptions.length > 0;\n      if (hasDeprecatedPlugins || hasDeprecatedOptions) {\n        const listJoiner = '\\n- ';\n        const pluginsMessage = hasDeprecatedPlugins ? `\\n\\nPlugins:${ listJoiner }${ deprecatedPlugins.map(getPluginDescription).join(listJoiner) }` : '';\n        const optionsMessage = hasDeprecatedOptions ? `\\n\\nOptions:${ listJoiner }${ deprecatedOptions.join(listJoiner) }` : '';\n        console.warn('The following deprecated features are currently enabled but will be removed soon.' + pluginsMessage + optionsMessage);\n      }\n    };\n    const logWarnings = (rawOptions, normalizedOptions) => {\n      logRemovedWarnings(rawOptions, normalizedOptions);\n      logDeprecatedWarnings(rawOptions, normalizedOptions);\n    };\n\n    const DOM$8 = DOMUtils.DOM;\n    const restoreOriginalStyles = editor => {\n      DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\n    };\n    const safeDestroy = x => Optional.from(x).each(x => x.destroy());\n    const clearDomReferences = editor => {\n      const ed = editor;\n      ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;\n      ed.bodyElement = ed.contentDocument = ed.contentWindow = null;\n      ed.iframeElement = ed.targetElm = null;\n      const selection = editor.selection;\n      if (selection) {\n        const dom = selection.dom;\n        ed.selection = selection.win = selection.dom = dom.doc = null;\n      }\n    };\n    const restoreForm = editor => {\n      const form = editor.formElement;\n      if (form) {\n        if (form._mceOldSubmit) {\n          form.submit = form._mceOldSubmit;\n          delete form._mceOldSubmit;\n        }\n        DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\n      }\n    };\n    const remove$1 = editor => {\n      if (!editor.removed) {\n        const {_selectionOverrides, editorUpload} = editor;\n        const body = editor.getBody();\n        const element = editor.getElement();\n        if (body) {\n          editor.save({ is_removing: true });\n        }\n        editor.removed = true;\n        editor.unbindAllNativeEvents();\n        if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {\n          DOM$8.remove(element.nextSibling);\n        }\n        fireRemove(editor);\n        editor.editorManager.remove(editor);\n        if (!editor.inline && body) {\n          restoreOriginalStyles(editor);\n        }\n        fireDetach(editor);\n        DOM$8.remove(editor.getContainer());\n        safeDestroy(_selectionOverrides);\n        safeDestroy(editorUpload);\n        editor.destroy();\n      }\n    };\n    const destroy = (editor, automatic) => {\n      const {selection, dom} = editor;\n      if (editor.destroyed) {\n        return;\n      }\n      if (!automatic && !editor.removed) {\n        editor.remove();\n        return;\n      }\n      if (!automatic) {\n        editor.editorManager.off('beforeunload', editor._beforeUnload);\n        if (editor.theme && editor.theme.destroy) {\n          editor.theme.destroy();\n        }\n        safeDestroy(selection);\n        safeDestroy(dom);\n      }\n      restoreForm(editor);\n      clearDomReferences(editor);\n      editor.destroyed = true;\n    };\n\n    const CreateIconManager = () => {\n      const lookup = {};\n      const add = (id, iconPack) => {\n        lookup[id] = iconPack;\n      };\n      const get = id => {\n        if (lookup[id]) {\n          return lookup[id];\n        } else {\n          return { icons: {} };\n        }\n      };\n      const has = id => has$2(lookup, id);\n      return {\n        add,\n        get,\n        has\n      };\n    };\n    const IconManager = CreateIconManager();\n\n    const ModelManager = AddOnManager.ModelManager;\n\n    const getProp = (propName, elm) => {\n      const rawElm = elm.dom;\n      return rawElm[propName];\n    };\n    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\n    const getClientWidth = curry(getProp, 'clientWidth');\n    const getClientHeight = curry(getProp, 'clientHeight');\n    const getMarginTop = curry(getComputedSizeProp, 'margin-top');\n    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\n    const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\n    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\n      const clientWidth = getClientWidth(bodyElm);\n      const clientHeight = getClientHeight(bodyElm);\n      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\n    };\n    const transpose = (inline, elm, clientX, clientY) => {\n      const clientRect = getBoundingClientRect(elm);\n      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\n      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\n      const x = clientX - deltaX;\n      const y = clientY - deltaY;\n      return {\n        x,\n        y\n      };\n    };\n    const isXYInContentArea = (editor, clientX, clientY) => {\n      const bodyElm = SugarElement.fromDom(editor.getBody());\n      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\n      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\n      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\n    };\n    const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\n    const isEditorAttachedToDom = editor => {\n      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\n      return fromDomSafe(rawContainer).map(inBody).getOr(false);\n    };\n\n    var NotificationManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a NotificationManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        close: unimplemented,\n        getArgs: unimplemented\n      };\n    };\n\n    const NotificationManager = editor => {\n      const notifications = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\n      };\n      const getTopNotification = () => {\n        return Optional.from(notifications[0]);\n      };\n      const isEqual = (a, b) => {\n        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\n      };\n      const reposition = () => {\n        each$e(notifications, notification => {\n          notification.reposition();\n        });\n      };\n      const addNotification = notification => {\n        notifications.push(notification);\n      };\n      const closeNotification = notification => {\n        findIndex$2(notifications, otherNotification => {\n          return otherNotification === notification;\n        }).each(index => {\n          notifications.splice(index, 1);\n        });\n      };\n      const open = (spec, fireEvent = true) => {\n        if (editor.removed || !isEditorAttachedToDom(editor)) {\n          return {};\n        }\n        if (fireEvent) {\n          editor.dispatch('BeforeOpenNotification', { notification: spec });\n        }\n        return find$2(notifications, notification => {\n          return isEqual(getImplementation().getArgs(notification), spec);\n        }).getOrThunk(() => {\n          editor.editorManager.setActive(editor);\n          const notification = getImplementation().open(spec, () => {\n            closeNotification(notification);\n            reposition();\n            if (hasEditorOrUiFocus(editor)) {\n              getTopNotification().fold(() => editor.focus(), top => focus$1(SugarElement.fromDom(top.getEl())));\n            }\n          });\n          addNotification(notification);\n          reposition();\n          editor.dispatch('OpenNotification', { notification: { ...notification } });\n          return notification;\n        });\n      };\n      const close = () => {\n        getTopNotification().each(notification => {\n          getImplementation().close(notification);\n          closeNotification(notification);\n          reposition();\n        });\n      };\n      const getNotifications = constant(notifications);\n      const registerEvents = editor => {\n        editor.on('SkinLoaded', () => {\n          const serviceMessage = getServiceMessage(editor);\n          if (serviceMessage) {\n            open({\n              text: serviceMessage,\n              type: 'warning',\n              timeout: 0\n            }, false);\n          }\n          reposition();\n        });\n        editor.on('show ResizeEditor ResizeWindow NodeChange', () => {\n          requestAnimationFrame(reposition);\n        });\n        editor.on('remove', () => {\n          each$e(notifications.slice(), notification => {\n            getImplementation().close(notification);\n          });\n        });\n      };\n      registerEvents(editor);\n      return {\n        open,\n        close,\n        getNotifications\n      };\n    };\n\n    const PluginManager = AddOnManager.PluginManager;\n\n    const ThemeManager = AddOnManager.ThemeManager;\n\n    var WindowManagerImpl = () => {\n      const unimplemented = () => {\n        throw new Error('Theme did not provide a WindowManager implementation.');\n      };\n      return {\n        open: unimplemented,\n        openUrl: unimplemented,\n        alert: unimplemented,\n        confirm: unimplemented,\n        close: unimplemented\n      };\n    };\n\n    const WindowManager = editor => {\n      let dialogs = [];\n      const getImplementation = () => {\n        const theme = editor.theme;\n        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\n      };\n      const funcBind = (scope, f) => {\n        return (...args) => {\n          return f ? f.apply(scope, args) : undefined;\n        };\n      };\n      const fireOpenEvent = dialog => {\n        editor.dispatch('OpenWindow', { dialog });\n      };\n      const fireCloseEvent = dialog => {\n        editor.dispatch('CloseWindow', { dialog });\n      };\n      const addDialog = dialog => {\n        dialogs.push(dialog);\n        fireOpenEvent(dialog);\n      };\n      const closeDialog = dialog => {\n        fireCloseEvent(dialog);\n        dialogs = filter$5(dialogs, otherDialog => {\n          return otherDialog !== dialog;\n        });\n        if (dialogs.length === 0) {\n          editor.focus();\n        }\n      };\n      const getTopDialog = () => {\n        return Optional.from(dialogs[dialogs.length - 1]);\n      };\n      const storeSelectionAndOpenDialog = openDialog => {\n        editor.editorManager.setActive(editor);\n        store(editor);\n        editor.ui.show();\n        const dialog = openDialog();\n        addDialog(dialog);\n        return dialog;\n      };\n      const open = (args, params) => {\n        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\n      };\n      const openUrl = args => {\n        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\n      };\n      const alert = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const confirm = (message, callback, scope) => {\n        const windowManagerImpl = getImplementation();\n        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\n      };\n      const close = () => {\n        getTopDialog().each(dialog => {\n          getImplementation().close(dialog);\n          closeDialog(dialog);\n        });\n      };\n      editor.on('remove', () => {\n        each$e(dialogs, dialog => {\n          getImplementation().close(dialog);\n        });\n      });\n      return {\n        open,\n        openUrl,\n        alert,\n        confirm,\n        close\n      };\n    };\n\n    const displayNotification = (editor, message) => {\n      editor.notificationManager.open({\n        type: 'error',\n        text: message\n      });\n    };\n    const displayError = (editor, message) => {\n      if (editor._skinLoaded) {\n        displayNotification(editor, message);\n      } else {\n        editor.on('SkinLoaded', () => {\n          displayNotification(editor, message);\n        });\n      }\n    };\n    const uploadError = (editor, message) => {\n      displayError(editor, I18n.translate([\n        'Failed to upload image: {0}',\n        message\n      ]));\n    };\n    const logError = (editor, errorType, msg) => {\n      fireError(editor, errorType, { message: msg });\n      console.error(msg);\n    };\n    const createLoadError = (type, url, name) => name ? `Failed to load ${ type }: ${ name } from url ${ url }` : `Failed to load ${ type } url: ${ url }`;\n    const pluginLoadError = (editor, url, name) => {\n      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\n    };\n    const iconsLoadError = (editor, url, name) => {\n      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\n    };\n    const languageLoadError = (editor, url, name) => {\n      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\n    };\n    const themeLoadError = (editor, url, name) => {\n      logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\n    };\n    const modelLoadError = (editor, url, name) => {\n      logError(editor, 'ModelLoadError', createLoadError('model', url, name));\n    };\n    const pluginInitError = (editor, name, err) => {\n      const message = I18n.translate([\n        'Failed to initialize plugin: {0}',\n        name\n      ]);\n      fireError(editor, 'PluginLoadError', { message });\n      initError(message, err);\n      displayError(editor, message);\n    };\n    const initError = (message, ...x) => {\n      const console = window.console;\n      if (console) {\n        if (console.error) {\n          console.error(message, ...x);\n        } else {\n          console.log(message, ...x);\n        }\n      }\n    };\n\n    const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\n    const toContentSkinResourceName = url => 'content/' + url + '/content.css';\n    const isBundledCssSkinName = url => tinymce.Resource.has(toContentSkinResourceName(url));\n    const getContentCssUrls = editor => {\n      return transformToUrls(editor, getContentCss(editor));\n    };\n    const getFontCssUrls = editor => {\n      return transformToUrls(editor, getFontCss(editor));\n    };\n    const transformToUrls = (editor, cssLinks) => {\n      const skinUrl = editor.editorManager.baseURL + '/skins/content';\n      const suffix = editor.editorManager.suffix;\n      const contentCssFile = `content${ suffix }.css`;\n      return map$3(cssLinks, url => {\n        if (isBundledCssSkinName(url)) {\n          return url;\n        } else if (isContentCssSkinName(url) && !editor.inline) {\n          return `${ skinUrl }/${ url }/${ contentCssFile }`;\n        } else {\n          return editor.documentBaseURI.toAbsolute(url);\n        }\n      });\n    };\n    const appendContentCssFromSettings = editor => {\n      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\n    };\n\n    const getAllImages = elm => {\n      return elm ? from(elm.getElementsByTagName('img')) : [];\n    };\n    const ImageScanner = (uploadStatus, blobCache) => {\n      const cachedPromises = {};\n      const findAll = (elm, predicate = always) => {\n        const images = filter$5(getAllImages(elm), img => {\n          const src = img.src;\n          if (img.hasAttribute('data-mce-bogus')) {\n            return false;\n          }\n          if (img.hasAttribute('data-mce-placeholder')) {\n            return false;\n          }\n          if (!src || src === Env.transparentSrc) {\n            return false;\n          }\n          if (startsWith(src, 'blob:')) {\n            return !uploadStatus.isUploaded(src) && predicate(img);\n          }\n          if (startsWith(src, 'data:')) {\n            return predicate(img);\n          }\n          return false;\n        });\n        const promises = map$3(images, img => {\n          const imageSrc = img.src;\n          if (has$2(cachedPromises, imageSrc)) {\n            return cachedPromises[imageSrc].then(imageInfo => {\n              if (isString(imageInfo)) {\n                return imageInfo;\n              } else {\n                return {\n                  image: img,\n                  blobInfo: imageInfo.blobInfo\n                };\n              }\n            });\n          } else {\n            const newPromise = imageToBlobInfo(blobCache, imageSrc).then(blobInfo => {\n              delete cachedPromises[imageSrc];\n              return {\n                image: img,\n                blobInfo\n              };\n            }).catch(error => {\n              delete cachedPromises[imageSrc];\n              return error;\n            });\n            cachedPromises[imageSrc] = newPromise;\n            return newPromise;\n          }\n        });\n        return Promise.all(promises);\n      };\n      return { findAll };\n    };\n\n    const UploadStatus = () => {\n      const PENDING = 1, UPLOADED = 2;\n      let blobUriStatuses = {};\n      const createStatus = (status, resultUri) => {\n        return {\n          status,\n          resultUri\n        };\n      };\n      const hasBlobUri = blobUri => {\n        return blobUri in blobUriStatuses;\n      };\n      const getResultUri = blobUri => {\n        const result = blobUriStatuses[blobUri];\n        return result ? result.resultUri : null;\n      };\n      const isPending = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\n      };\n      const isUploaded = blobUri => {\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\n      };\n      const markPending = blobUri => {\n        blobUriStatuses[blobUri] = createStatus(PENDING, null);\n      };\n      const markUploaded = (blobUri, resultUri) => {\n        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\n      };\n      const removeFailed = blobUri => {\n        delete blobUriStatuses[blobUri];\n      };\n      const destroy = () => {\n        blobUriStatuses = {};\n      };\n      return {\n        hasBlobUri,\n        getResultUri,\n        isPending,\n        isUploaded,\n        markPending,\n        markUploaded,\n        removeFailed,\n        destroy\n      };\n    };\n\n    let count = 0;\n    const seed = () => {\n      const rnd = () => {\n        return Math.round(Math.random() * 4294967295).toString(36);\n      };\n      const now = new Date().getTime();\n      return 's' + now.toString(36) + rnd() + rnd() + rnd();\n    };\n    const uuid = prefix => {\n      return prefix + count++ + seed();\n    };\n\n    const BlobCache = () => {\n      let cache = [];\n      const mimeToExt = mime => {\n        const mimes = {\n          'image/jpeg': 'jpg',\n          'image/jpg': 'jpg',\n          'image/gif': 'gif',\n          'image/png': 'png',\n          'image/apng': 'apng',\n          'image/avif': 'avif',\n          'image/svg+xml': 'svg',\n          'image/webp': 'webp',\n          'image/bmp': 'bmp',\n          'image/tiff': 'tiff'\n        };\n        return mimes[mime.toLowerCase()] || 'dat';\n      };\n      const create = (o, blob, base64, name, filename) => {\n        if (isString(o)) {\n          const id = o;\n          return toBlobInfo({\n            id,\n            name,\n            filename,\n            blob: blob,\n            base64: base64\n          });\n        } else if (isObject(o)) {\n          return toBlobInfo(o);\n        } else {\n          throw new Error('Unknown input type');\n        }\n      };\n      const toBlobInfo = o => {\n        if (!o.blob || !o.base64) {\n          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\n        }\n        const id = o.id || uuid('blobid');\n        const name = o.name || id;\n        const blob = o.blob;\n        return {\n          id: constant(id),\n          name: constant(name),\n          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\n          blob: constant(blob),\n          base64: constant(o.base64),\n          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\n          uri: constant(o.uri)\n        };\n      };\n      const add = blobInfo => {\n        if (!get(blobInfo.id())) {\n          cache.push(blobInfo);\n        }\n      };\n      const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\n      const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\n      const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\n      const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\n      const removeByUri = blobUri => {\n        cache = filter$5(cache, blobInfo => {\n          if (blobInfo.blobUri() === blobUri) {\n            URL.revokeObjectURL(blobInfo.blobUri());\n            return false;\n          }\n          return true;\n        });\n      };\n      const destroy = () => {\n        each$e(cache, cachedBlobInfo => {\n          URL.revokeObjectURL(cachedBlobInfo.blobUri());\n        });\n        cache = [];\n      };\n      return {\n        create,\n        add,\n        get,\n        getByUri,\n        getByData,\n        findFirst,\n        removeByUri,\n        destroy\n      };\n    };\n\n    const Uploader = (uploadStatus, settings) => {\n      const pendingPromises = {};\n      const pathJoin = (path1, path2) => {\n        if (path1) {\n          return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\n        }\n        return path2;\n      };\n      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\n        const xhr = new XMLHttpRequest();\n        xhr.open('POST', settings.url);\n        xhr.withCredentials = settings.credentials;\n        xhr.upload.onprogress = e => {\n          progress(e.loaded / e.total * 100);\n        };\n        xhr.onerror = () => {\n          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\n        };\n        xhr.onload = () => {\n          if (xhr.status < 200 || xhr.status >= 300) {\n            failure('HTTP Error: ' + xhr.status);\n            return;\n          }\n          const json = JSON.parse(xhr.responseText);\n          if (!json || !isString(json.location)) {\n            failure('Invalid JSON: ' + xhr.responseText);\n            return;\n          }\n          success(pathJoin(settings.basePath, json.location));\n        };\n        const formData = new FormData();\n        formData.append('file', blobInfo.blob(), blobInfo.filename());\n        xhr.send(formData);\n      });\n      const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;\n      const noUpload = () => new Promise(resolve => {\n        resolve([]);\n      });\n      const handlerSuccess = (blobInfo, url) => ({\n        url,\n        blobInfo,\n        status: true\n      });\n      const handlerFailure = (blobInfo, error) => ({\n        url: '',\n        blobInfo,\n        status: false,\n        error\n      });\n      const resolvePending = (blobUri, result) => {\n        Tools.each(pendingPromises[blobUri], resolve => {\n          resolve(result);\n        });\n        delete pendingPromises[blobUri];\n      };\n      const uploadBlobInfo = (blobInfo, handler, openNotification) => {\n        uploadStatus.markPending(blobInfo.blobUri());\n        return new Promise(resolve => {\n          let notification;\n          let progress;\n          try {\n            const closeNotification = () => {\n              if (notification) {\n                notification.close();\n                progress = noop;\n              }\n            };\n            const success = url => {\n              closeNotification();\n              uploadStatus.markUploaded(blobInfo.blobUri(), url);\n              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\n              resolve(handlerSuccess(blobInfo, url));\n            };\n            const failure = error => {\n              closeNotification();\n              uploadStatus.removeFailed(blobInfo.blobUri());\n              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\n              resolve(handlerFailure(blobInfo, error));\n            };\n            progress = percent => {\n              if (percent < 0 || percent > 100) {\n                return;\n              }\n              Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\n                notification = n;\n                n.progressBar.value(percent);\n              });\n            };\n            handler(blobInfo, progress).then(success, err => {\n              failure(isString(err) ? { message: err } : err);\n            });\n          } catch (ex) {\n            resolve(handlerFailure(blobInfo, ex));\n          }\n        });\n      };\n      const isDefaultHandler = handler => handler === defaultHandler;\n      const pendingUploadBlobInfo = blobInfo => {\n        const blobUri = blobInfo.blobUri();\n        return new Promise(resolve => {\n          pendingPromises[blobUri] = pendingPromises[blobUri] || [];\n          pendingPromises[blobUri].push(resolve);\n        });\n      };\n      const uploadBlobs = (blobInfos, openNotification) => {\n        blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\n        return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));\n      };\n      const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\n      return { upload };\n    };\n\n    const openNotification = editor => () => editor.notificationManager.open({\n      text: editor.translate('Image uploading...'),\n      type: 'info',\n      timeout: -1,\n      progressBar: true\n    });\n    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\n      url: getImageUploadUrl(editor),\n      basePath: getImageUploadBasePath(editor),\n      credentials: getImagesUploadCredentials(editor),\n      handler: getImagesUploadHandler(editor)\n    });\n    const ImageUploader = editor => {\n      const uploadStatus = UploadStatus();\n      const uploader = createUploader(editor, uploadStatus);\n      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined) };\n    };\n\n    const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);\n    const addPaddingToEmpty = editor => element => {\n      if (isEmptyForPadding(editor, element)) {\n        append$1(element, SugarElement.fromHtml('<br data-mce-bogus=\"1\" />'));\n      }\n    };\n    const EditorUpload = editor => {\n      const blobCache = BlobCache();\n      let uploader, imageScanner;\n      const uploadStatus = UploadStatus();\n      const urlFilters = [];\n      const aliveGuard = callback => {\n        return result => {\n          if (editor.selection) {\n            return callback(result);\n          }\n          return [];\n        };\n      };\n      const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\n      const replaceString = (content, search, replace) => {\n        let index = 0;\n        do {\n          index = content.indexOf(search, index);\n          if (index !== -1) {\n            content = content.substring(0, index) + replace + content.substr(index + search.length);\n            index += replace.length - search.length + 1;\n          }\n        } while (index !== -1);\n        return content;\n      };\n      const replaceImageUrl = (content, targetUrl, replacementUrl) => {\n        const replacementString = `src=\"${ replacementUrl }\"${ replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : '' }`;\n        content = replaceString(content, `src=\"${ targetUrl }\"`, replacementString);\n        content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\n        return content;\n      };\n      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\n        each$e(editor.undoManager.data, level => {\n          if (level.type === 'fragmented') {\n            level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\n          } else {\n            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\n          }\n        });\n      };\n      const replaceImageUriInView = (image, resultUri) => {\n        const src = editor.convertURL(resultUri, 'src');\n        replaceUrlInUndoStack(image.src, resultUri);\n        setAll$1(SugarElement.fromDom(image), {\n          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\n          'data-mce-src': src\n        });\n      };\n      const uploadImages = () => {\n        if (!uploader) {\n          uploader = createUploader(editor, uploadStatus);\n        }\n        return scanForImages().then(aliveGuard(imageInfos => {\n          const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\n          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\n            const imagesToRemove = [];\n            let shouldDispatchChange = false;\n            const filteredResult = map$3(result, (uploadInfo, index) => {\n              const {blobInfo, image} = imageInfos[index];\n              let removed = false;\n              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\n                if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {\n                  shouldDispatchChange = true;\n                }\n                blobCache.removeByUri(image.src);\n                if (isRtc(editor)) ; else {\n                  replaceImageUriInView(image, uploadInfo.url);\n                }\n              } else if (uploadInfo.error) {\n                if (uploadInfo.error.remove) {\n                  replaceUrlInUndoStack(image.src, Env.transparentSrc);\n                  imagesToRemove.push(image);\n                  removed = true;\n                }\n                uploadError(editor, uploadInfo.error.message);\n              }\n              return {\n                element: image,\n                status: uploadInfo.status,\n                uploadUri: uploadInfo.url,\n                blobInfo,\n                removed\n              };\n            });\n            if (imagesToRemove.length > 0 && !isRtc(editor)) {\n              editor.undoManager.transact(() => {\n                each$e(fromDom$1(imagesToRemove), sugarElement => {\n                  const parentOpt = parent(sugarElement);\n                  remove$5(sugarElement);\n                  parentOpt.each(addPaddingToEmpty(editor));\n                  blobCache.removeByUri(sugarElement.dom.src);\n                });\n              });\n            } else if (shouldDispatchChange) {\n              editor.undoManager.dispatchChange();\n            }\n            return filteredResult;\n          }));\n        }));\n      };\n      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\n      const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\n      const addFilter = filter => {\n        urlFilters.push(filter);\n      };\n      const scanForImages = () => {\n        if (!imageScanner) {\n          imageScanner = ImageScanner(uploadStatus, blobCache);\n        }\n        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\n          const filteredResult = filter$5(result, resultItem => {\n            if (isString(resultItem)) {\n              displayError(editor, resultItem);\n              return false;\n            } else if (resultItem.uriType === 'blob') {\n              return false;\n            } else {\n              return true;\n            }\n          });\n          if (isRtc(editor)) ; else {\n            each$e(filteredResult, resultItem => {\n              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\n              resultItem.image.src = resultItem.blobInfo.blobUri();\n              resultItem.image.removeAttribute('data-mce-src');\n            });\n          }\n          return filteredResult;\n        }));\n      };\n      const destroy = () => {\n        blobCache.destroy();\n        uploadStatus.destroy();\n        imageScanner = uploader = null;\n      };\n      const replaceBlobUris = content => {\n        return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\n          const resultUri = uploadStatus.getResultUri(blobUri);\n          if (resultUri) {\n            return 'src=\"' + resultUri + '\"';\n          }\n          let blobInfo = blobCache.getByUri(blobUri);\n          if (!blobInfo) {\n            blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\n              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\n            }, undefined);\n          }\n          if (blobInfo) {\n            const blob = blobInfo.blob();\n            return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\n          }\n          return match;\n        });\n      };\n      editor.on('SetContent', () => {\n        if (isAutomaticUploadsEnabled(editor)) {\n          uploadImagesAuto();\n        } else {\n          scanForImages();\n        }\n      });\n      editor.on('RawSaveContent', e => {\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('GetContent', e => {\n        if (e.source_view || e.format === 'raw' || e.format === 'tree') {\n          return;\n        }\n        e.content = replaceBlobUris(e.content);\n      });\n      editor.on('PostRender', () => {\n        editor.parser.addNodeFilter('img', images => {\n          each$e(images, img => {\n            const src = img.attr('src');\n            if (!src || blobCache.getByUri(src)) {\n              return;\n            }\n            const resultUri = uploadStatus.getResultUri(src);\n            if (resultUri) {\n              img.attr('src', resultUri);\n            }\n          });\n        });\n      });\n      return {\n        blobCache,\n        addFilter,\n        uploadImages,\n        uploadImagesAuto,\n        scanForImages,\n        destroy\n      };\n    };\n\n    const get$1 = editor => {\n      const dom = editor.dom;\n      const schemaType = editor.schema.type;\n      const formats = {\n        valigntop: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'top' }\n          }],\n        valignmiddle: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'middle' }\n          }],\n        valignbottom: [{\n            selector: 'td,th',\n            styles: { verticalAlign: 'bottom' }\n          }],\n        alignleft: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-left',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'left' },\n            inherit: false,\n            preview: false\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'left' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: '0px',\n              marginRight: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: { float: 'left' }\n          }\n        ],\n        aligncenter: [\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'center' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-center',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: {\n              display: 'block',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object',\n            ceFalseOverride: true,\n            styles: {\n              display: 'table',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          },\n          {\n            selector: '[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: {\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            },\n            preview: false\n          }\n        ],\n        alignright: [\n          {\n            selector: 'figure.image',\n            collapsed: false,\n            classes: 'align-right',\n            ceFalseOverride: true,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'right' },\n            inherit: false,\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'img,audio,video',\n            collapsed: false,\n            styles: { float: 'right' },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: 'table',\n            collapsed: false,\n            styles: {\n              marginRight: '0px',\n              marginLeft: 'auto'\n            },\n            onformat: table => {\n              dom.setStyle(table, 'float', null);\n            },\n            preview: 'font-family font-size'\n          },\n          {\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\n            ceFalseOverride: true,\n            styles: { float: 'right' },\n            preview: false\n          }\n        ],\n        alignjustify: [{\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\n            styles: { textAlign: 'justify' },\n            inherit: false,\n            preview: 'font-family font-size'\n          }],\n        bold: [\n          {\n            inline: 'strong',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontWeight: 'bold' }\n          },\n          {\n            inline: 'b',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        italic: [\n          {\n            inline: 'em',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          },\n          {\n            inline: 'span',\n            styles: { fontStyle: 'italic' }\n          },\n          {\n            inline: 'i',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        underline: [\n          {\n            inline: 'span',\n            styles: { textDecoration: 'underline' },\n            exact: true\n          },\n          {\n            inline: 'u',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          }\n        ],\n        strikethrough: (() => {\n          const span = {\n            inline: 'span',\n            styles: { textDecoration: 'line-through' },\n            exact: true\n          };\n          const strike = {\n            inline: 'strike',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          const s = {\n            inline: 's',\n            remove: 'all',\n            preserve_attributes: [\n              'class',\n              'style'\n            ]\n          };\n          return schemaType !== 'html4' ? [\n            s,\n            span,\n            strike\n          ] : [\n            span,\n            s,\n            strike\n          ];\n        })(),\n        forecolor: {\n          inline: 'span',\n          styles: { color: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        hilitecolor: {\n          inline: 'span',\n          styles: { backgroundColor: '%value' },\n          links: true,\n          remove_similar: true,\n          clear_child_styles: true\n        },\n        fontname: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontFamily: '%value' },\n          clear_child_styles: true\n        },\n        fontsize: {\n          inline: 'span',\n          toggle: false,\n          styles: { fontSize: '%value' },\n          clear_child_styles: true\n        },\n        lineheight: {\n          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\n          styles: { lineHeight: '%value' }\n        },\n        fontsize_class: {\n          inline: 'span',\n          attributes: { class: '%value' }\n        },\n        blockquote: {\n          block: 'blockquote',\n          wrapper: true,\n          remove: 'all'\n        },\n        subscript: { inline: 'sub' },\n        superscript: { inline: 'sup' },\n        code: { inline: 'code' },\n        link: {\n          inline: 'a',\n          selector: 'a',\n          remove: 'all',\n          split: true,\n          deep: true,\n          onmatch: (node, _fmt, _itemName) => {\n            return isElement$6(node) && node.hasAttribute('href');\n          },\n          onformat: (elm, _fmt, vars) => {\n            Tools.each(vars, (value, key) => {\n              dom.setAttrib(elm, key, value);\n            });\n          }\n        },\n        lang: {\n          inline: 'span',\n          clear_child_styles: true,\n          remove_similar: true,\n          attributes: {\n            'lang': '%value',\n            'data-mce-lang': vars => {\n              var _a;\n              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\n            }\n          }\n        },\n        removeformat: [\n          {\n            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\n            remove: 'all',\n            split: true,\n            expand: false,\n            block_expand: true,\n            deep: true\n          },\n          {\n            selector: 'span',\n            attributes: [\n              'style',\n              'class'\n            ],\n            remove: 'empty',\n            split: true,\n            expand: false,\n            deep: true\n          },\n          {\n            selector: '*',\n            attributes: [\n              'style',\n              'class'\n            ],\n            split: false,\n            expand: false,\n            deep: true\n          }\n        ]\n      };\n      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\n        formats[name] = {\n          block: name,\n          remove: 'all'\n        };\n      });\n      return formats;\n    };\n\n    const genericBase = {\n      remove_similar: true,\n      inherit: false\n    };\n    const cellBase = {\n      selector: 'td,th',\n      ...genericBase\n    };\n    const cellFormats = {\n      tablecellbackgroundcolor: {\n        styles: { backgroundColor: '%value' },\n        ...cellBase\n      },\n      tablecellverticalalign: {\n        styles: { 'vertical-align': '%value' },\n        ...cellBase\n      },\n      tablecellbordercolor: {\n        styles: { borderColor: '%value' },\n        ...cellBase\n      },\n      tablecellclass: {\n        classes: ['%value'],\n        ...cellBase\n      },\n      tableclass: {\n        selector: 'table',\n        classes: ['%value'],\n        ...genericBase\n      },\n      tablecellborderstyle: {\n        styles: { borderStyle: '%value' },\n        ...cellBase\n      },\n      tablecellborderwidth: {\n        styles: { borderWidth: '%value' },\n        ...cellBase\n      }\n    };\n    const get = constant(cellFormats);\n\n    const FormatRegistry = editor => {\n      const formats = {};\n      const get$2 = name => isNonNullable(name) ? formats[name] : formats;\n      const has = name => has$2(formats, name);\n      const register = (name, format) => {\n        if (name) {\n          if (!isString(name)) {\n            each$d(name, (format, name) => {\n              register(name, format);\n            });\n          } else {\n            if (!isArray$1(format)) {\n              format = [format];\n            }\n            each$e(format, format => {\n              if (isUndefined(format.deep)) {\n                format.deep = !isSelectorFormat(format);\n              }\n              if (isUndefined(format.split)) {\n                format.split = !isSelectorFormat(format) || isInlineFormat(format);\n              }\n              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\n                format.remove = 'none';\n              }\n              if (isSelectorFormat(format) && isInlineFormat(format)) {\n                format.mixed = true;\n                format.block_expand = true;\n              }\n              if (isString(format.classes)) {\n                format.classes = format.classes.split(/\\s+/);\n              }\n            });\n            formats[name] = format;\n          }\n        }\n      };\n      const unregister = name => {\n        if (name && formats[name]) {\n          delete formats[name];\n        }\n        return formats;\n      };\n      register(get$1(editor));\n      register(get());\n      register(getFormats(editor));\n      return {\n        get: get$2,\n        has,\n        register,\n        unregister\n      };\n    };\n\n    const each$3 = Tools.each;\n    const dom = DOMUtils.DOM;\n    const isPreviewItem = item => isNonNullable(item) && isObject(item);\n    const parsedSelectorToHtml = (ancestry, editor) => {\n      const schema = editor && editor.schema || Schema({});\n      const decorate = (elm, item) => {\n        if (item.classes.length > 0) {\n          dom.addClass(elm, item.classes.join(' '));\n        }\n        dom.setAttribs(elm, item.attrs);\n      };\n      const createElement = sItem => {\n        const item = isString(sItem) ? {\n          name: sItem,\n          classes: [],\n          attrs: {}\n        } : sItem;\n        const elm = dom.create(item.name);\n        decorate(elm, item);\n        return elm;\n      };\n      const getRequiredParent = (elm, candidate) => {\n        const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());\n        const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;\n        if (parentsRequired && parentsRequired.length) {\n          return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];\n        } else {\n          return false;\n        }\n      };\n      const wrapInHtml = (elm, ancestors, siblings) => {\n        let parentCandidate;\n        const ancestor = ancestors[0];\n        const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;\n        const parentRequired = getRequiredParent(elm, ancestorName);\n        if (parentRequired) {\n          if (ancestorName === parentRequired) {\n            parentCandidate = ancestor;\n            ancestors = ancestors.slice(1);\n          } else {\n            parentCandidate = parentRequired;\n          }\n        } else if (ancestor) {\n          parentCandidate = ancestor;\n          ancestors = ancestors.slice(1);\n        } else if (!siblings) {\n          return elm;\n        }\n        const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');\n        parent.appendChild(elm);\n        if (siblings) {\n          Tools.each(siblings, sibling => {\n            const siblingElm = createElement(sibling);\n            parent.insertBefore(siblingElm, elm);\n          });\n        }\n        const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;\n        return wrapInHtml(parent, ancestors, parentSiblings);\n      };\n      const fragment = dom.create('div');\n      if (ancestry.length > 0) {\n        const item = ancestry[0];\n        const elm = createElement(item);\n        const siblings = isPreviewItem(item) ? item.siblings : undefined;\n        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));\n      }\n      return fragment;\n    };\n    const parseSelectorItem = item => {\n      item = Tools.trim(item);\n      let tagName = 'div';\n      const obj = {\n        name: tagName,\n        classes: [],\n        attrs: {},\n        selector: item\n      };\n      if (item !== '*') {\n        tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\n          switch ($1) {\n          case '#':\n            obj.attrs.id = $2;\n            break;\n          case '.':\n            obj.classes.push($2);\n            break;\n          case ':':\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\n              obj.attrs[$2] = $2;\n            }\n            break;\n          }\n          if ($3 === '[') {\n            const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\n            if (m) {\n              obj.attrs[m[1]] = m[2];\n            }\n          }\n          return '';\n        });\n      }\n      obj.name = tagName || 'div';\n      return obj;\n    };\n    const parseSelector = selector => {\n      if (!isString(selector)) {\n        return [];\n      }\n      selector = selector.split(/\\s*,\\s*/)[0];\n      selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\n      return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\n        const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\n        const obj = siblings.pop();\n        if (siblings.length) {\n          obj.siblings = siblings;\n        }\n        return obj;\n      }).reverse();\n    };\n    const getCssText = (editor, format) => {\n      let previewCss = '';\n      let previewStyles = getPreviewStyles(editor);\n      if (previewStyles === '') {\n        return '';\n      }\n      const removeVars = val => {\n        return isString(val) ? val.replace(/%(\\w+)/g, '') : '';\n      };\n      const getComputedStyle = (name, elm) => {\n        return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);\n      };\n      if (isString(format)) {\n        const formats = editor.formatter.get(format);\n        if (!formats) {\n          return '';\n        }\n        format = formats[0];\n      }\n      if ('preview' in format) {\n        const preview = format.preview;\n        if (preview === false) {\n          return '';\n        } else {\n          previewStyles = preview || previewStyles;\n        }\n      }\n      let name = format.block || format.inline || 'span';\n      let previewFrag;\n      const items = parseSelector(format.selector);\n      if (items.length > 0) {\n        if (!items[0].name) {\n          items[0].name = name;\n        }\n        name = format.selector;\n        previewFrag = parsedSelectorToHtml(items, editor);\n      } else {\n        previewFrag = parsedSelectorToHtml([name], editor);\n      }\n      const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\n      each$3(format.styles, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setStyle(previewElm, name, newValue);\n        }\n      });\n      each$3(format.attributes, (value, name) => {\n        const newValue = removeVars(value);\n        if (newValue) {\n          dom.setAttrib(previewElm, name, newValue);\n        }\n      });\n      each$3(format.classes, value => {\n        const newValue = removeVars(value);\n        if (!dom.hasClass(previewElm, newValue)) {\n          dom.addClass(previewElm, newValue);\n        }\n      });\n      editor.dispatch('PreviewFormats');\n      dom.setStyles(previewFrag, {\n        position: 'absolute',\n        left: -65535\n      });\n      editor.getBody().appendChild(previewFrag);\n      const rawParentFontSize = getComputedStyle('fontSize');\n      const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;\n      each$3(previewStyles.split(' '), name => {\n        let value = getComputedStyle(name, previewElm);\n        if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\n          value = getComputedStyle(name);\n          if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\n            return;\n          }\n        }\n        if (name === 'color') {\n          if (rgbaToHexString(value).toLowerCase() === '#000000') {\n            return;\n          }\n        }\n        if (name === 'font-size') {\n          if (/em|%$/.test(value)) {\n            if (parentFontSize === 0) {\n              return;\n            }\n            const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\n            value = numValue * parentFontSize + 'px';\n          }\n        }\n        if (name === 'border' && value) {\n          previewCss += 'padding:0 2px;';\n        }\n        previewCss += name + ':' + value + ';';\n      });\n      editor.dispatch('AfterPreviewFormats');\n      dom.remove(previewFrag);\n      return previewCss;\n    };\n\n    const setup$s = editor => {\n      editor.addShortcut('meta+b', '', 'Bold');\n      editor.addShortcut('meta+i', '', 'Italic');\n      editor.addShortcut('meta+u', '', 'Underline');\n      for (let i = 1; i <= 6; i++) {\n        editor.addShortcut('access+' + i, '', [\n          'FormatBlock',\n          false,\n          'h' + i\n        ]);\n      }\n      editor.addShortcut('access+7', '', [\n        'FormatBlock',\n        false,\n        'p'\n      ]);\n      editor.addShortcut('access+8', '', [\n        'FormatBlock',\n        false,\n        'div'\n      ]);\n      editor.addShortcut('access+9', '', [\n        'FormatBlock',\n        false,\n        'address'\n      ]);\n    };\n\n    const Formatter = editor => {\n      const formats = FormatRegistry(editor);\n      const formatChangeState = Cell({});\n      setup$s(editor);\n      setup$v(editor);\n      if (!isRtc(editor)) {\n        setup$u(formatChangeState, editor);\n      }\n      return {\n        get: formats.get,\n        has: formats.has,\n        register: formats.register,\n        unregister: formats.unregister,\n        apply: (name, vars, node) => {\n          applyFormat(editor, name, vars, node);\n        },\n        remove: (name, vars, node, similar) => {\n          removeFormat(editor, name, vars, node, similar);\n        },\n        toggle: (name, vars, node) => {\n          toggleFormat(editor, name, vars, node);\n        },\n        match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\n        closest: names => closestFormat(editor, names),\n        matchAll: (names, vars) => matchAllFormats(editor, names, vars),\n        matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\n        canApply: name => canApplyFormat(editor, name),\n        formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\n        getCssText: curry(getCssText, editor)\n      };\n    };\n\n    const shouldIgnoreCommand = cmd => {\n      switch (cmd.toLowerCase()) {\n      case 'undo':\n      case 'redo':\n      case 'mcefocus':\n        return true;\n      default:\n        return false;\n      }\n    };\n    const registerEvents = (editor, undoManager, locks) => {\n      const isFirstTypedCharacter = Cell(false);\n      const addNonTypingUndoLevel = e => {\n        setTyping(undoManager, false, locks);\n        undoManager.add({}, e);\n      };\n      editor.on('init', () => {\n        undoManager.add();\n      });\n      editor.on('BeforeExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          endTyping(undoManager, locks);\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('ExecCommand', e => {\n        const cmd = e.command;\n        if (!shouldIgnoreCommand(cmd)) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('ObjectResizeStart cut', () => {\n        undoManager.beforeChange();\n      });\n      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\n      editor.on('dragend', addNonTypingUndoLevel);\n      editor.on('keyup', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        const isMeta = Env.os.isMacOS() && e.key === 'Meta';\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey || isMeta) {\n          addNonTypingUndoLevel();\n          editor.nodeChanged();\n        }\n        if (keyCode === 46 || keyCode === 8) {\n          editor.nodeChanged();\n        }\n        if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {\n          if (!editor.isDirty()) {\n            editor.setDirty(true);\n          }\n          editor.dispatch('TypingUndo');\n          isFirstTypedCharacter.set(false);\n          editor.nodeChanged();\n        }\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.keyCode;\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\n          if (undoManager.typing) {\n            addNonTypingUndoLevel(e);\n          }\n          return;\n        }\n        const modKey = e.ctrlKey && !e.altKey || e.metaKey;\n        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\n          undoManager.beforeChange();\n          setTyping(undoManager, true, locks);\n          undoManager.add({}, e);\n          isFirstTypedCharacter.set(true);\n          return;\n        }\n        const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;\n        if (hasOnlyMetaOrCtrlModifier) {\n          undoManager.beforeChange();\n        }\n      });\n      editor.on('mousedown', e => {\n        if (undoManager.typing) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\n      const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\n      const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\n      editor.on('input', e => {\n        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\n          addNonTypingUndoLevel(e);\n        }\n      });\n      editor.on('AddUndo Undo Redo ClearUndos', e => {\n        if (!e.isDefaultPrevented()) {\n          editor.nodeChanged();\n        }\n      });\n    };\n    const addKeyboardShortcuts = editor => {\n      editor.addShortcut('meta+z', '', 'Undo');\n      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\n    };\n\n    const UndoManager = editor => {\n      const beforeBookmark = value$2();\n      const locks = Cell(0);\n      const index = Cell(0);\n      const undoManager = {\n        data: [],\n        typing: false,\n        beforeChange: () => {\n          beforeChange(editor, locks, beforeBookmark);\n        },\n        add: (level, event) => {\n          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\n        },\n        dispatchChange: () => {\n          editor.setDirty(true);\n          const level = createFromEditor(editor);\n          level.bookmark = getUndoBookmark(editor.selection);\n          editor.dispatch('change', {\n            level,\n            lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()\n          });\n        },\n        undo: () => {\n          return undo(editor, undoManager, locks, index);\n        },\n        redo: () => {\n          return redo(editor, index, undoManager.data);\n        },\n        clear: () => {\n          clear(editor, undoManager, index);\n        },\n        reset: () => {\n          reset(editor, undoManager);\n        },\n        hasUndo: () => {\n          return hasUndo(editor, undoManager, index);\n        },\n        hasRedo: () => {\n          return hasRedo(editor, undoManager, index);\n        },\n        transact: callback => {\n          return transact(editor, undoManager, locks, callback);\n        },\n        ignore: callback => {\n          ignore(editor, locks, callback);\n        },\n        extra: (callback1, callback2) => {\n          extra(editor, undoManager, index, callback1, callback2);\n        }\n      };\n      if (!isRtc(editor)) {\n        registerEvents(editor, undoManager, locks);\n      }\n      addKeyboardShortcuts(editor);\n      return undoManager;\n    };\n\n    const nonTypingKeycodes = [\n      9,\n      27,\n      VK.HOME,\n      VK.END,\n      19,\n      20,\n      44,\n      144,\n      145,\n      33,\n      34,\n      45,\n      16,\n      17,\n      18,\n      91,\n      92,\n      93,\n      VK.DOWN,\n      VK.UP,\n      VK.LEFT,\n      VK.RIGHT\n    ].concat(Env.browser.isFirefox() ? [224] : []);\n    const placeholderAttr = 'data-mce-placeholder';\n    const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\n    const isDeleteEvent = e => {\n      const keyCode = e.keyCode;\n      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\n    };\n    const isNonTypingKeyboardEvent = e => {\n      if (isKeyboardEvent(e)) {\n        const keyCode = e.keyCode;\n        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\n      } else {\n        return false;\n      }\n    };\n    const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\n    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\n      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {\n        const firstElement = rootElm.firstElementChild;\n        if (!firstElement) {\n          return true;\n        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\n          return false;\n        } else {\n          return forcedRootBlock === firstElement.nodeName.toLowerCase();\n        }\n      } else {\n        return false;\n      }\n    };\n    const setup$r = editor => {\n      var _a;\n      const dom = editor.dom;\n      const rootBlock = getForcedRootBlock(editor);\n      const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';\n      const updatePlaceholder = (e, initial) => {\n        if (isNonTypingKeyboardEvent(e)) {\n          return;\n        }\n        const body = editor.getBody();\n        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\n        const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\n        if (isPlaceholderShown !== showPlaceholder || initial) {\n          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\n          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);\n          firePlaceholderToggle(editor, showPlaceholder);\n          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\n          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\n        }\n      };\n      if (isNotEmpty(placeholder)) {\n        editor.on('init', e => {\n          updatePlaceholder(e, true);\n          editor.on('change SetContent ExecCommand', updatePlaceholder);\n          editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\n        });\n      }\n    };\n\n    const blockPosition = (block, position) => ({\n      block,\n      position\n    });\n    const blockBoundary = (from, to) => ({\n      from,\n      to\n    });\n    const getBlockPosition = (rootNode, pos) => {\n      const rootElm = SugarElement.fromDom(rootNode);\n      const containerElm = SugarElement.fromDom(pos.container());\n      return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\n    };\n    const isDifferentBlocks = blockBoundary => !eq(blockBoundary.from.block, blockBoundary.to.block);\n    const getClosestHost = (root, scope) => {\n      const isRoot = node => eq(node, root);\n      const isHost = node => isTableCell$2(node) || isContentEditableTrue$3(node.dom);\n      return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);\n    };\n    const hasSameHost = (rootNode, blockBoundary) => {\n      const root = SugarElement.fromDom(rootNode);\n      return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));\n    };\n    const isEditable$1 = blockBoundary => isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;\n    const hasValidBlocks = blockBoundary => {\n      const isValidBlock = block => isTextBlock$2(block) || hasBlockAttr(block.dom);\n      return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);\n    };\n    const skipLastBr = (rootNode, forward, blockPosition) => {\n      if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(blockPosition.block)) {\n        return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\n          if (lastPositionInBlock.isEqual(blockPosition.position)) {\n            return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\n          } else {\n            return Optional.some(blockPosition);\n          }\n        }).getOr(blockPosition);\n      } else {\n        return blockPosition;\n      }\n    };\n    const readFromRange = (rootNode, forward, rng) => {\n      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\n      const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(rootNode, forward, blockPos))));\n      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary));\n    };\n    const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();\n\n    const getChildrenUntilBlockBoundary = (block, schema) => {\n      const children = children$1(block);\n      return findIndex$2(children, el => schema.isBlock(name(el))).fold(constant(children), index => children.slice(0, index));\n    };\n    const extractChildren = (block, schema) => {\n      const children = getChildrenUntilBlockBoundary(block, schema);\n      each$e(children, remove$5);\n      return children;\n    };\n    const removeEmptyRoot = (rootNode, block) => {\n      const parents = parentsAndSelf(block, rootNode);\n      return find$2(parents.reverse(), element => isEmpty$2(element)).each(remove$5);\n    };\n    const isEmptyBefore = el => filter$5(prevSiblings(el), el => !isEmpty$2(el)).length === 0;\n    const nestedBlockMerge = (rootNode, fromBlock, toBlock, schema, insertionPoint) => {\n      if (isEmpty$2(toBlock)) {\n        fillWithPaddingBr(toBlock);\n        return firstPositionIn(toBlock.dom);\n      }\n      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {\n        before$3(insertionPoint, SugarElement.fromTag('br'));\n      }\n      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\n      each$e(extractChildren(fromBlock, schema), child => {\n        before$3(insertionPoint, child);\n      });\n      removeEmptyRoot(rootNode, fromBlock);\n      return position;\n    };\n    const isInline = (schema, node) => schema.isInline(name(node));\n    const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema) => {\n      if (isEmpty$2(toBlock)) {\n        if (isEmpty$2(fromBlock)) {\n          const getInlineToBlockDescendants = el => {\n            const helper = (node, elements) => firstChild(node).fold(() => elements, child => isInline(schema, child) ? helper(child, elements.concat(shallow$1(child))) : elements);\n            return helper(el, []);\n          };\n          const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {\n            wrap$2(element, descendant);\n            return descendant;\n          }, createPaddingBr());\n          empty(fromBlock);\n          append$1(fromBlock, newFromBlockDescendants);\n        }\n        remove$5(toBlock);\n        return firstPositionIn(fromBlock.dom);\n      }\n      const position = lastPositionIn(toBlock.dom);\n      each$e(extractChildren(fromBlock, schema), child => {\n        append$1(toBlock, child);\n      });\n      removeEmptyRoot(rootNode, fromBlock);\n      return position;\n    };\n    const findInsertionPoint = (toBlock, block) => {\n      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\n      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\n    };\n    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\n    const trimBr = (first, block) => {\n      positionIn(first, block.dom).bind(position => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$5);\n    };\n    const mergeBlockInto = (rootNode, fromBlock, toBlock, schema) => {\n      trimBr(true, fromBlock);\n      trimBr(false, toBlock);\n      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema), curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema));\n    };\n    const mergeBlocks = (rootNode, forward, block1, block2, schema) => forward ? mergeBlockInto(rootNode, block2, block1, schema) : mergeBlockInto(rootNode, block1, block2, schema);\n\n    const backspaceDelete$9 = (editor, forward) => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\n        mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block, editor.schema).each(pos => {\n          editor.selection.setRng(pos.toRange());\n        });\n      });\n      return position;\n    };\n\n    const deleteRangeMergeBlocks = (rootNode, selection, schema) => {\n      const rng = selection.getRng();\n      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\n        if (!eq(block1, block2)) {\n          return Optional.some(() => {\n            rng.deleteContents();\n            mergeBlocks(rootNode, true, block1, block2, schema).each(pos => {\n              selection.setRng(pos.toRange());\n            });\n          });\n        } else {\n          return Optional.none();\n        }\n      }).getOr(Optional.none());\n    };\n    const isRawNodeInTable = (root, rawNode) => {\n      const node = SugarElement.fromDom(rawNode);\n      const isRoot = curry(eq, root);\n      return ancestor$4(node, isTableCell$2, isRoot).isSome();\n    };\n    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\n    const isEverythingSelected = (root, rng) => {\n      const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\n      const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\n      return !isSelectionInTable(root, rng) && noPrevious && noNext;\n    };\n    const emptyEditor = editor => {\n      return Optional.some(() => {\n        editor.setContent('');\n        editor.selection.setCursorLocation();\n      });\n    };\n    const deleteRange$2 = editor => {\n      const rootNode = SugarElement.fromDom(editor.getBody());\n      const rng = editor.selection.getRng();\n      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);\n    };\n    const backspaceDelete$8 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);\n\n    const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\n    const getNodeRange = node => {\n      const rng = node.ownerDocument.createRange();\n      rng.selectNode(node);\n      return rng;\n    };\n    const selectNode = (editor, node) => {\n      const e = editor.dispatch('BeforeObjectSelected', { target: node });\n      if (e.isDefaultPrevented()) {\n        return Optional.none();\n      }\n      return Optional.some(getNodeRange(node));\n    };\n    const renderCaretAtRange = (editor, range, scrollIntoView) => {\n      const normalizedRange = normalizeRange(1, editor.getBody(), range);\n      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\n      const caretPositionNode = caretPosition.getNode();\n      if (isInlineFakeCaretTarget(caretPositionNode)) {\n        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\n      }\n      const caretPositionBeforeNode = caretPosition.getNode(true);\n      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\n        return showCaret(1, editor, caretPositionBeforeNode, false, false);\n      }\n      const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());\n      if (isInlineFakeCaretTarget(ceRoot)) {\n        return showCaret(1, editor, ceRoot, false, scrollIntoView);\n      }\n      return Optional.none();\n    };\n    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\n\n    const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\n    const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\n    const trimEmptyTextNode = (dom, node) => {\n      if (isText$a(node) && node.data.length === 0) {\n        dom.remove(node);\n      }\n    };\n    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\n      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\n        if (range.collapsed) {\n          const deleteRange = range.cloneRange();\n          if (forward) {\n            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\n          } else {\n            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\n          }\n          deleteRange.deleteContents();\n        } else {\n          range.deleteContents();\n        }\n        editor.selection.setRng(caretRange);\n      });\n      trimEmptyTextNode(editor.dom, node);\n    };\n    const deleteBoundaryText = (editor, forward) => {\n      const range = editor.selection.getRng();\n      if (!isText$a(range.commonAncestorContainer)) {\n        return Optional.none();\n      }\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const nextCaretPosition = getNextPosFn(caretPosition);\n      const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;\n      if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {\n        return Optional.none();\n      } else if (isBeforeFn(normalizedNextCaretPosition)) {\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));\n      }\n      const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {\n          return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\n        }\n      }\n      return Optional.none();\n    };\n    const backspaceDelete$7 = (editor, forward) => deleteBoundaryText(editor, forward);\n\n    const getEdgeCefPosition = (editor, atStart) => {\n      const root = editor.getBody();\n      return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);\n    };\n    const isCefAtEdgeSelected = editor => {\n      const rng = editor.selection.getRng();\n      return !rng.collapsed && (getEdgeCefPosition(editor, true).exists(pos => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists(pos => pos.isEqual(CaretPosition.fromRangeEnd(rng))));\n    };\n\n    const isCompoundElement = node => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));\n    const DeleteAction = Adt.generate([\n      { remove: ['element'] },\n      { moveToElement: ['element'] },\n      { moveToPosition: ['position'] }\n    ]);\n    const isAtContentEditableBlockCaret = (forward, from) => {\n      const elm = from.getNode(!forward);\n      const caretLocation = forward ? 'after' : 'before';\n      return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\n    };\n    const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {\n      const inSameBlock = elm => schema.isInline(elm.nodeName.toLowerCase()) && !isInSameBlock(from, to, root);\n      return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\n    };\n    const deleteEmptyBlockOrMoveToCef = (root, forward, from, to) => {\n      const toCefElm = to.getNode(!forward);\n      return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\n    };\n    const findCefPosition = (root, forward, from, schema) => fromPosition(forward, root, from).bind(to => {\n      if (isCompoundElement(to.getNode())) {\n        return Optional.none();\n      } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$b(to.getNode())) {\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n      } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\n      } else if (forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else if (!forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      } else {\n        return Optional.none();\n      }\n    });\n    const getContentEditableBlockAction = (forward, elm) => {\n      if (isNullable(elm)) {\n        return Optional.none();\n      } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\n      } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {\n        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\n      } else {\n        return Optional.none();\n      }\n    };\n    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\n      if (isInSameBlock(from, to, root)) {\n        return Optional.none();\n      } else {\n        return Optional.some(DeleteAction.moveToPosition(to));\n      }\n    });\n    const getContentEditableAction = (root, forward, from, schema) => {\n      if (isAtContentEditableBlockCaret(forward, from)) {\n        return getContentEditableBlockAction(forward, from.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from, schema));\n      } else {\n        return findCefPosition(root, forward, from, schema).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\n      }\n    };\n    const read = (root, forward, rng, schema) => {\n      const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\n      const from = CaretPosition.fromRangeStart(normalizedRange);\n      const rootElement = SugarElement.fromDom(root);\n      if (!forward && isAfterContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode(true)));\n      } else if (forward && isBeforeContentEditableFalse(from)) {\n        return Optional.some(DeleteAction.remove(from.getNode()));\n      } else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from, schema)) {\n        return findPreviousBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from, schema)) {\n        return findNextBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\n      } else {\n        return getContentEditableAction(root, forward, from, schema);\n      }\n    };\n\n    const deleteElement$1 = (editor, forward) => element => {\n      editor._selectionOverrides.hideFakeCaret();\n      deleteElement$2(editor, forward, SugarElement.fromDom(element));\n      return true;\n    };\n    const moveToElement = (editor, forward) => element => {\n      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const moveToPosition = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    };\n    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\n    const backspaceDeleteCaret = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng(), editor.schema).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\n    };\n    const deleteOffscreenSelection = rootElement => {\n      each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$5);\n    };\n    const backspaceDeleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {\n        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);\n        return hasCefAncestor.fold(() => Optional.some(() => {\n          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\n          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\n          paddEmptyBody(editor);\n        }), () => Optional.some(noop));\n      }\n      if (isCefAtEdgeSelected(editor)) {\n        return Optional.some(() => {\n          deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));\n        });\n      }\n      return Optional.none();\n    };\n    const paddEmptyElement = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\n      if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\n        const br = dom.create('br', { 'data-mce-bogus': '1' });\n        dom.setHTML(ceRoot, '');\n        ceRoot.appendChild(br);\n        selection.setRng(CaretPosition.before(br).toRange());\n      }\n      return true;\n    };\n    const backspaceDelete$6 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return backspaceDeleteCaret(editor, forward);\n      } else {\n        return backspaceDeleteRange(editor, forward);\n      }\n    };\n\n    const deleteCaret$2 = (editor, forward) => {\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map(elm => () => editor.selection.select(elm));\n    };\n    const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\n\n    const isText$2 = isText$a;\n    const startsWithCaretContainer = node => isText$2(node) && node.data[0] === ZWSP$1;\n    const endsWithCaretContainer = node => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;\n    const createZwsp = node => {\n      var _a;\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\n      return doc.createTextNode(ZWSP$1);\n    };\n    const insertBefore$1 = node => {\n      var _a;\n      if (isText$2(node.previousSibling)) {\n        if (endsWithCaretContainer(node.previousSibling)) {\n          return node.previousSibling;\n        } else {\n          node.previousSibling.appendData(ZWSP$1);\n          return node.previousSibling;\n        }\n      } else if (isText$2(node)) {\n        if (startsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.insertData(0, ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);\n        return newNode;\n      }\n    };\n    const insertAfter$1 = node => {\n      var _a, _b;\n      if (isText$2(node.nextSibling)) {\n        if (startsWithCaretContainer(node.nextSibling)) {\n          return node.nextSibling;\n        } else {\n          node.nextSibling.insertData(0, ZWSP$1);\n          return node.nextSibling;\n        }\n      } else if (isText$2(node)) {\n        if (endsWithCaretContainer(node)) {\n          return node;\n        } else {\n          node.appendData(ZWSP$1);\n          return node;\n        }\n      } else {\n        const newNode = createZwsp(node);\n        if (node.nextSibling) {\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);\n        } else {\n          (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);\n        }\n        return newNode;\n      }\n    };\n    const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);\n    const insertInlineBefore = curry(insertInline, true);\n    const insertInlineAfter = curry(insertInline, false);\n\n    const insertInlinePos = (pos, before) => {\n      if (isText$a(pos.container())) {\n        return insertInline(before, pos.container());\n      } else {\n        return insertInline(before, pos.getNode());\n      }\n    };\n    const isPosCaretContainer = (pos, caret) => {\n      const caretNode = caret.get();\n      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\n    };\n    const renderCaret = (caret, location) => location.fold(element => {\n      remove$3(caret.get());\n      const text = insertInlineBefore(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, text.length - 1));\n    }, element => firstPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$3(caret.get());\n        const text = insertInlinePos(pos, true);\n        caret.set(text);\n        return CaretPosition(text, 1);\n      } else {\n        const node = caret.get();\n        return CaretPosition(node, 1);\n      }\n    }), element => lastPositionIn(element).map(pos => {\n      if (!isPosCaretContainer(pos, caret)) {\n        remove$3(caret.get());\n        const text = insertInlinePos(pos, false);\n        caret.set(text);\n        return CaretPosition(text, text.length - 1);\n      } else {\n        const node = caret.get();\n        return CaretPosition(node, node.length - 1);\n      }\n    }), element => {\n      remove$3(caret.get());\n      const text = insertInlineAfter(element);\n      caret.set(text);\n      return Optional.some(CaretPosition(text, 1));\n    });\n\n    const evaluateUntil = (fns, args) => {\n      for (let i = 0; i < fns.length; i++) {\n        const result = fns[i].apply(null, args);\n        if (result.isSome()) {\n          return result;\n        }\n      }\n      return Optional.none();\n    };\n\n    const Location = Adt.generate([\n      { before: ['element'] },\n      { start: ['element'] },\n      { end: ['element'] },\n      { after: ['element'] }\n    ]);\n    const rescope$1 = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const before = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\n    };\n    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\n    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\n    const start$1 = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const prevPos = prevPosition(inline, nPos);\n        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\n      });\n    };\n    const end = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeForwards(pos);\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\n        const nextPos = nextPosition(inline, nPos);\n        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\n      });\n    };\n    const after = (isInlineTarget, rootNode, pos) => {\n      const nPos = normalizeBackwards(pos);\n      const scope = rescope$1(rootNode, nPos.container());\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\n    };\n    const isValidLocation = location => !isRtl(getElement(location));\n    const readLocation = (isInlineTarget, rootNode, pos) => {\n      const location = evaluateUntil([\n        before,\n        start$1,\n        end,\n        after\n      ], [\n        isInlineTarget,\n        rootNode,\n        pos\n      ]);\n      return location.filter(isValidLocation);\n    };\n    const getElement = location => location.fold(identity, identity, identity, identity);\n    const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\n    const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\n    const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\n    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\n    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\n      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\n        return Location.after(forward ? fromInline : toInline);\n      } else {\n        return location;\n      }\n    }).getOr(location);\n    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\n    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\n      const from = normalizePosition(forward, pos);\n      const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\n      const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\n      return location.filter(isValidLocation);\n    };\n    const findLocationSimple = (forward, location) => {\n      if (forward) {\n        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\n      } else {\n        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\n      }\n    };\n    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\n      const from = normalizePosition(forward, pos);\n      const fromLocation = readLocation(isInlineTarget, rootNode, from);\n      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\n    };\n\n    const hasSelectionModifyApi = editor => {\n      return isFunction(editor.selection.getSel().modify);\n    };\n    const moveRel = (forward, selection, pos) => {\n      const delta = forward ? 1 : -1;\n      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\n      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\n      return true;\n    };\n    const moveByWord = (forward, editor) => {\n      const rng = editor.selection.getRng();\n      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      if (!hasSelectionModifyApi(editor)) {\n        return false;\n      } else if (forward && isBeforeInline(pos)) {\n        return moveRel(true, editor.selection, pos);\n      } else if (!forward && isAfterInline(pos)) {\n        return moveRel(false, editor.selection, pos);\n      } else {\n        return false;\n      }\n    };\n\n    var BreakType;\n    (function (BreakType) {\n      BreakType[BreakType['Br'] = 0] = 'Br';\n      BreakType[BreakType['Block'] = 1] = 'Block';\n      BreakType[BreakType['Wrap'] = 2] = 'Wrap';\n      BreakType[BreakType['Eol'] = 3] = 'Eol';\n    }(BreakType || (BreakType = {})));\n    const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\n    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\n    const getBreakType = (scope, direction, currentPos, nextPos) => {\n      if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {\n        return BreakType.Br;\n      } else if (isInSameBlock(currentPos, nextPos) === false) {\n        return BreakType.Block;\n      } else {\n        return BreakType.Wrap;\n      }\n    };\n    const getPositionsUntil = (predicate, direction, scope, start) => {\n      const caretWalker = CaretWalker(scope);\n      let currentPos = start;\n      const positions = [];\n      while (currentPos) {\n        const nextPos = walk$1(direction, caretWalker, currentPos);\n        if (!nextPos) {\n          break;\n        }\n        if (isBr$6(nextPos.getNode(false))) {\n          if (direction === HDirection.Forwards) {\n            return {\n              positions: flip(direction, positions).concat([nextPos]),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          } else {\n            return {\n              positions: flip(direction, positions),\n              breakType: BreakType.Br,\n              breakAt: Optional.some(nextPos)\n            };\n          }\n        }\n        if (!nextPos.isVisible()) {\n          currentPos = nextPos;\n          continue;\n        }\n        if (predicate(currentPos, nextPos)) {\n          const breakType = getBreakType(scope, direction, currentPos, nextPos);\n          return {\n            positions: flip(direction, positions),\n            breakType,\n            breakAt: Optional.some(nextPos)\n          };\n        }\n        positions.push(nextPos);\n        currentPos = nextPos;\n      }\n      return {\n        positions: flip(direction, positions),\n        breakType: BreakType.Eol,\n        breakAt: Optional.none()\n      };\n    };\n    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\n      const positions = getPositionsUntilBreak(scope, pos).positions;\n      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\n    }).getOr([]);\n    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\n      const lastDist = Math.abs(x - lastRect.left);\n      const newDist = Math.abs(x - newRect.left);\n      return newDist <= lastDist ? newPos : lastPos;\n    }).or(acc)), Optional.none());\n    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\n    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\n    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\n    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\n    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\n    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\n    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\n    const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\n    const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\n    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);\n    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);\n\n    const isContentEditableFalse$4 = isContentEditableFalse$b;\n    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\n    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\n      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\n      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\n      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {\n        return clientRect;\n      }\n      if (newDistance < oldDistance) {\n        return clientRect;\n      }\n      return oldClientRect;\n    });\n\n    const getNodeClientRects = node => {\n      const toArrayWithNode = clientRects => {\n        return map$3(clientRects, rect => {\n          const clientRect = clone$1(rect);\n          clientRect.node = node;\n          return clientRect;\n        });\n      };\n      if (isElement$6(node)) {\n        return toArrayWithNode(node.getClientRects());\n      } else if (isText$a(node)) {\n        const rng = node.ownerDocument.createRange();\n        rng.setStart(node, 0);\n        rng.setEnd(node, node.data.length);\n        return toArrayWithNode(rng.getClientRects());\n      } else {\n        return [];\n      }\n    };\n    const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\n\n    var VDirection;\n    (function (VDirection) {\n      VDirection[VDirection['Up'] = -1] = 'Up';\n      VDirection[VDirection['Down'] = 1] = 'Down';\n    }(VDirection || (VDirection = {})));\n    const findUntil = (direction, root, predicateFn, node) => {\n      let currentNode = node;\n      while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {\n        if (predicateFn(currentNode)) {\n          return;\n        }\n      }\n    };\n    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\n      let line = 0;\n      const result = [];\n      const add = node => {\n        let clientRects = getClientRects([node]);\n        if (direction === -1) {\n          clientRects = clientRects.reverse();\n        }\n        for (let i = 0; i < clientRects.length; i++) {\n          const clientRect = clientRects[i];\n          if (isBeflowFn(clientRect, targetClientRect)) {\n            continue;\n          }\n          if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {\n            line++;\n          }\n          clientRect.line = line;\n          if (predicateFn(clientRect)) {\n            return true;\n          }\n          result.push(clientRect);\n        }\n        return false;\n      };\n      const targetClientRect = last$2(caretPosition.getClientRects());\n      if (!targetClientRect) {\n        return result;\n      }\n      const node = caretPosition.getNode();\n      if (node) {\n        add(node);\n        findUntil(direction, root, add, node);\n      }\n      return result;\n    };\n    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\n    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\n    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\n    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\n    const getLastClientRect = caretPosition => {\n      return last$2(caretPosition.getClientRects());\n    };\n    const positionsUntil = (direction, root, predicateFn, node) => {\n      const caretWalker = CaretWalker(root);\n      let walkFn;\n      let isBelowFn;\n      let isAboveFn;\n      let caretPosition;\n      const result = [];\n      let line = 0;\n      if (direction === 1) {\n        walkFn = caretWalker.next;\n        isBelowFn = isBelow$1;\n        isAboveFn = isAbove$1;\n        caretPosition = CaretPosition.after(node);\n      } else {\n        walkFn = caretWalker.prev;\n        isBelowFn = isAbove$1;\n        isAboveFn = isBelow$1;\n        caretPosition = CaretPosition.before(node);\n      }\n      const targetClientRect = getLastClientRect(caretPosition);\n      do {\n        if (!caretPosition.isVisible()) {\n          continue;\n        }\n        const rect = getLastClientRect(caretPosition);\n        if (isAboveFn(rect, targetClientRect)) {\n          continue;\n        }\n        if (result.length > 0 && isBelowFn(rect, last$2(result))) {\n          line++;\n        }\n        const clientRect = clone$1(rect);\n        clientRect.position = caretPosition;\n        clientRect.line = line;\n        if (predicateFn(clientRect)) {\n          return result;\n        }\n        result.push(clientRect);\n      } while (caretPosition = walkFn(caretPosition));\n      return result;\n    };\n    const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\n    const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\n\n    const moveToRange = (editor, rng) => {\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, editor.selection.getRng());\n    };\n    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\n    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const forwards = direction === HDirection.Forwards;\n      const caretWalker = CaretWalker(editor.getBody());\n      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\n      const isBeforeFn = forwards ? isBefore : isAfter;\n      if (!range.collapsed) {\n        const node = getSelectedNode(range);\n        if (isElement(node)) {\n          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\n        } else if (isCefAtEdgeSelected(editor)) {\n          const newRange = range.cloneRange();\n          newRange.collapse(direction === HDirection.Backwards);\n          return Optional.from(newRange);\n        }\n      }\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      if (isBeforeFn(caretPosition)) {\n        return selectNode(editor, caretPosition.getNode(!forwards));\n      }\n      let nextCaretPosition = getNextPosFn(caretPosition);\n      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\n      if (!nextCaretPosition) {\n        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\n      } else {\n        nextCaretPosition = normalizePosition(forwards, nextCaretPosition);\n      }\n      if (isBeforeFn(nextCaretPosition)) {\n        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\n      }\n      const peekCaretPosition = getNextPosFn(nextCaretPosition);\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\n          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\n        }\n      }\n      if (rangeIsInContainerBlock) {\n        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\n      }\n      return Optional.none();\n    };\n    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\n      const caretClientRect = last$2(caretPosition.getClientRects());\n      const forwards = direction === VDirection.Down;\n      const root = editor.getBody();\n      if (!caretClientRect) {\n        return Optional.none();\n      }\n      if (isCefAtEdgeSelected(editor)) {\n        const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);\n        const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;\n        return getClosestFn(root, caretPosition).orThunk(() => Optional.from(caretPosition)).map(pos => pos.toRange());\n      }\n      const walkerFn = forwards ? downUntil : upUntil;\n      const linePositions = walkerFn(root, isAboveLine(1), caretPosition);\n      const nextLinePositions = filter$5(linePositions, isLine(1));\n      const clientX = caretClientRect.left;\n      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\n      if (nextLineRect && isElement(nextLineRect.node)) {\n        const dist1 = Math.abs(clientX - nextLineRect.left);\n        const dist2 = Math.abs(clientX - nextLineRect.right);\n        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\n      }\n      let currentNode;\n      if (isBefore(caretPosition)) {\n        currentNode = caretPosition.getNode();\n      } else if (isAfter(caretPosition)) {\n        currentNode = caretPosition.getNode(true);\n      } else {\n        currentNode = getSelectedNode(range);\n      }\n      if (currentNode) {\n        const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);\n        let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n        closestNextLineRect = last$2(filter$5(caretPositions, isLine(0)));\n        if (closestNextLineRect) {\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\n        }\n      }\n      if (nextLinePositions.length === 0) {\n        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\n      }\n      return Optional.none();\n    };\n    const getLineEndPoint = (editor, forward) => {\n      const rng = editor.selection.getRng();\n      const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n      const host = getEditingHost(from.container(), editor.getBody());\n      if (forward) {\n        const lineInfo = getPositionsUntilNextLine(host, from);\n        return last$3(lineInfo.positions);\n      } else {\n        const lineInfo = getPositionsUntilPreviousLine(host, from);\n        return head(lineInfo.positions);\n      }\n    };\n    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\n      editor.selection.setRng(pos.toRange());\n      return true;\n    });\n\n    const setCaretPosition = (editor, pos) => {\n      const rng = editor.dom.createRng();\n      rng.setStart(pos.container(), pos.offset());\n      rng.setEnd(pos.container(), pos.offset());\n      editor.selection.setRng(rng);\n    };\n    const setSelected = (state, elm) => {\n      if (state) {\n        elm.setAttribute('data-mce-selected', 'inline-boundary');\n      } else {\n        elm.removeAttribute('data-mce-selected');\n      }\n    };\n    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\n      setCaretPosition(editor, pos);\n      return location;\n    });\n    const getPositionFromRange = (range, root, forward) => {\n      const start = CaretPosition.fromRangeStart(range);\n      if (range.collapsed) {\n        return start;\n      } else {\n        const end = CaretPosition.fromRangeEnd(range);\n        return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);\n      }\n    };\n    const findLocation = (editor, caret, forward) => {\n      const rootNode = editor.getBody();\n      const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\n      return location.bind(location => renderCaretLocation(editor, caret, location));\n    };\n    const toggleInlines = (isInlineTarget, dom, elms) => {\n      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\n      const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);\n      const targetInlines = filter$5(elms, isInlineTarget);\n      each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));\n      each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));\n    };\n    const safeRemoveCaretContainer = (editor, caret) => {\n      const caretValue = caret.get();\n      if (editor.selection.isCollapsed() && !editor.composing && caretValue) {\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {\n          setCaretPosition(editor, removeAndReposition(caretValue, pos));\n          caret.set(null);\n        }\n      }\n    };\n    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\n      if (editor.selection.isCollapsed()) {\n        const inlines = filter$5(elms, isInlineTarget);\n        each$e(inlines, _inline => {\n          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n          readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\n        });\n      }\n    };\n    const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\n    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\n    const setupSelectedState = editor => {\n      const caret = Cell(null);\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.on('NodeChange', e => {\n        if (isInlineBoundariesEnabled(editor)) {\n          toggleInlines(isInlineTarget$1, editor.dom, e.parents);\n          safeRemoveCaretContainer(editor, caret);\n          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\n        }\n      });\n      return caret;\n    };\n    const moveNextWord = curry(moveWord, true);\n    const movePrevWord = curry(moveWord, false);\n    const moveToLineEndPoint$2 = (editor, forward, caret) => {\n      if (isInlineBoundariesEnabled(editor)) {\n        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\n          const rng = editor.selection.getRng();\n          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\n        });\n        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\n          const outsideLoc = outside(loc);\n          return renderCaret(caret, outsideLoc).exists(pos => {\n            setCaretPosition(editor, pos);\n            return true;\n          });\n        });\n      } else {\n        return false;\n      }\n    };\n\n    const rangeFromPositions = (from, to) => {\n      const range = document.createRange();\n      range.setStart(from.container(), from.offset());\n      range.setEnd(to.container(), to.offset());\n      return range;\n    };\n    const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\n      const normalizedFirstPos = normalizePosition(true, firstPos);\n      const normalizedLastPos = normalizePosition(false, lastPos);\n      return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\n    }).getOr(true);\n    const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\n    const deleteFromTo = (editor, caret, from, to) => {\n      const rootNode = editor.getBody();\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      editor.undoManager.ignore(() => {\n        editor.selection.setRng(rangeFromPositions(from, to));\n        execNativeDeleteCommand(editor);\n        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\n      });\n      editor.nodeChanged();\n    };\n    const rescope = (rootNode, node) => {\n      const parentBlock = getParentBlock$3(node, rootNode);\n      return parentBlock ? parentBlock : rootNode;\n    };\n    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\n      const rootNode = rescope(editor.getBody(), from.container());\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\n      const location = fromLocation.bind(location => {\n        if (forward) {\n          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\n        } else {\n          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\n        }\n      });\n      return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\n        const toPosition = navigate(forward, rootNode, from);\n        const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\n        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\n          if (hasOnlyTwoOrLessPositionsLeft(elm)) {\n            return Optional.some(() => {\n              deleteElement$2(editor, forward, SugarElement.fromDom(elm));\n            });\n          } else {\n            return Optional.none();\n          }\n        })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\n          return () => {\n            if (forward) {\n              deleteFromTo(editor, caret, from, to);\n            } else {\n              deleteFromTo(editor, caret, to, from);\n            }\n          };\n        })));\n      });\n    };\n    const backspaceDelete$4 = (editor, caret, forward) => {\n      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\n        const from = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return backspaceDeleteCollapsed(editor, caret, forward, from);\n      }\n      return Optional.none();\n    };\n\n    const hasMultipleChildren = elm => childNodesCount(elm) > 1;\n    const getParentsUntil = (editor, pred) => {\n      const rootElm = SugarElement.fromDom(editor.getBody());\n      const startElm = SugarElement.fromDom(editor.selection.getStart());\n      const parents = parentsAndSelf(startElm, rootElm);\n      return findIndex$2(parents, pred).fold(constant(parents), index => parents.slice(0, index));\n    };\n    const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\n    const getParentInlinesUntilMultichildInline = editor => getParentsUntil(editor, elm => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm));\n    const getParentInlines = editor => getParentsUntil(editor, el => editor.schema.isBlock(name(el)));\n    const getFormatNodes = (editor, parentInlines) => {\n      const isFormatElement$1 = curry(isFormatElement, editor);\n      return bind$3(parentInlines, elm => isFormatElement$1(elm) ? [elm.dom] : []);\n    };\n    const getFormatNodesAtStart = editor => {\n      const parentInlines = getParentInlines(editor);\n      return getFormatNodes(editor, parentInlines);\n    };\n    const deleteLastPosition = (forward, editor, target, parentInlines) => {\n      const formatNodes = getFormatNodes(editor, parentInlines);\n      if (formatNodes.length === 0) {\n        deleteElement$2(editor, forward, target);\n      } else {\n        const pos = replaceWithCaretFormat(target.dom, formatNodes);\n        editor.selection.setRng(pos.toRange());\n      }\n    };\n    const deleteCaret$1 = (editor, forward) => {\n      const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);\n      return last$3(parentInlines).bind(target => {\n        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\n          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\n        } else {\n          return Optional.none();\n        }\n      });\n    };\n    const isBrInEmptyElement = (editor, elm) => {\n      const parentElm = elm.parentElement;\n      return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);\n    };\n    const isEmptyCaret = elm => isEmptyCaretFormatElement(SugarElement.fromDom(elm));\n    const createCaretFormatAtStart = (editor, formatNodes) => {\n      const startElm = editor.selection.getStart();\n      const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);\n      editor.selection.setRng(pos.toRange());\n    };\n    const updateCaretFormat = (editor, updateFormats) => {\n      const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));\n      if (missingFormats.length > 0) {\n        createCaretFormatAtStart(editor, missingFormats);\n      }\n    };\n    const rangeStartsAtTextContainer = rng => isText$a(rng.startContainer);\n    const rangeStartsAtStartOfTextContainer = rng => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);\n    const rangeStartParentIsFormatElement = (editor, rng) => {\n      const startParent = rng.startContainer.parentElement;\n      return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));\n    };\n    const rangeStartAndEndHaveSameParent = rng => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);\n    };\n    const rangeEndsAtEndOfEndContainer = rng => {\n      const endContainer = rng.endContainer;\n      return rng.endOffset === (isText$a(endContainer) ? endContainer.length : endContainer.childNodes.length);\n    };\n    const rangeEndsAtEndOfStartContainer = rng => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);\n    const rangeEndsAfterEndOfStartContainer = rng => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);\n    const rangeEndsAtOrAfterEndOfStartContainer = rng => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);\n    const requiresDeleteRangeOverride = editor => {\n      const rng = editor.selection.getRng();\n      return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);\n    };\n    const deleteRange$1 = editor => {\n      if (requiresDeleteRangeOverride(editor)) {\n        const formatNodes = getFormatNodesAtStart(editor);\n        return Optional.some(() => {\n          execNativeDeleteCommand(editor);\n          updateCaretFormat(editor, formatNodes);\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);\n    const hasAncestorInlineCaret = (elm, schema) => ancestor$1(elm, node => isCaretNode(node.dom), el => schema.isBlock(name(el)));\n    const hasAncestorInlineCaretAtStart = editor => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()), editor.schema);\n    const requiresRefreshCaretOverride = editor => {\n      const rng = editor.selection.getRng();\n      return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);\n    };\n    const refreshCaret = editor => {\n      if (requiresRefreshCaretOverride(editor)) {\n        createCaretFormatAtStart(editor, []);\n      }\n      return true;\n    };\n\n    const deleteElement = (editor, forward, element) => {\n      if (isNonNullable(element)) {\n        return Optional.some(() => {\n          editor._selectionOverrides.hideFakeCaret();\n          deleteElement$2(editor, forward, SugarElement.fromDom(element));\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const deleteCaret = (editor, forward) => {\n      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\n      if (isNearMedia(fromPos)) {\n        return deleteElement(editor, forward, fromPos.getNode(!forward));\n      } else {\n        return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind(pos => deleteElement(editor, forward, pos.getNode(!forward)));\n      }\n    };\n    const deleteRange = (editor, forward) => {\n      const selectedNode = editor.selection.getNode();\n      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\n    };\n    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\n\n    const isEditable = target => closest$4(target, elm => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists(elm => isContentEditableTrue$3(elm.dom));\n    const parseIndentValue = value => toInt(value !== null && value !== void 0 ? value : '').getOr(0);\n    const getIndentStyleName = (useMargin, element) => {\n      const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';\n      const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\n      return indentStyleName + suffix;\n    };\n    const indentElement = (dom, command, useMargin, value, unit, element) => {\n      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\n      const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));\n      if (command === 'outdent') {\n        const styleValue = Math.max(0, parsedValue - value);\n        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\n      } else {\n        const styleValue = parsedValue + value + unit;\n        dom.setStyle(element, indentStyleName, styleValue);\n      }\n    };\n    const validateBlocks = (editor, blocks) => forall(blocks, block => {\n      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\n      const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);\n      const contentEditable = editor.dom.getContentEditable(block.dom);\n      return contentEditable !== 'false' && intentValue > 0;\n    });\n    const canOutdent = editor => {\n      const blocks = getBlocksToIndent(editor);\n      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\n    };\n    const isListComponent = el => isList(el) || isListItem$1(el);\n    const parentIsListComponent = el => parent(el).exists(isListComponent);\n    const getBlocksToIndent = editor => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));\n    const handle = (editor, command) => {\n      var _a, _b;\n      const {dom} = editor;\n      const indentation = getIndentation(editor);\n      const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';\n      const indentValue = parseIndentValue(indentation);\n      const useMargin = shouldIndentUseMargin(editor);\n      each$e(getBlocksToIndent(editor), block => {\n        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\n      });\n    };\n    const indent = editor => handle(editor, 'indent');\n    const outdent = editor => handle(editor, 'outdent');\n\n    const backspaceDelete$1 = editor => {\n      if (editor.selection.isCollapsed() && canOutdent(editor)) {\n        const dom = editor.dom;\n        const rng = editor.selection.getRng();\n        const pos = CaretPosition.fromRangeStart(rng);\n        const block = dom.getParent(rng.startContainer, dom.isBlock);\n        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)) {\n          return Optional.some(() => outdent(editor));\n        }\n      }\n      return Optional.none();\n    };\n\n    const findAction = (editor, caret, forward) => findMap([\n      backspaceDelete$1,\n      backspaceDelete$6,\n      backspaceDelete$7,\n      (editor, forward) => backspaceDelete$4(editor, caret, forward),\n      backspaceDelete$9,\n      backspaceDelete$a,\n      backspaceDelete$5,\n      backspaceDelete$2,\n      backspaceDelete$8,\n      backspaceDelete$3\n    ], item => item(editor, forward)).filter(_ => editor.selection.isEditable());\n    const deleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, false);\n      result.fold(() => {\n        if (editor.selection.isEditable()) {\n          execNativeDeleteCommand(editor);\n          paddEmptyBody(editor);\n        }\n      }, call);\n    };\n    const forwardDeleteCommand = (editor, caret) => {\n      const result = findAction(editor, caret, true);\n      result.fold(() => {\n        if (editor.selection.isEditable()) {\n          execNativeForwardDeleteCommand(editor);\n        }\n      }, call);\n    };\n    const setup$q = (editor, caret) => {\n      editor.addCommand('delete', () => {\n        deleteCommand(editor, caret);\n      });\n      editor.addCommand('forwardDelete', () => {\n        forwardDeleteCommand(editor, caret);\n      });\n    };\n\n    const SIGNIFICANT_MOVE = 5;\n    const LONGPRESS_DELAY = 400;\n    const getTouch = event => {\n      if (event.touches === undefined || event.touches.length !== 1) {\n        return Optional.none();\n      }\n      return Optional.some(event.touches[0]);\n    };\n    const isFarEnough = (touch, data) => {\n      const distX = Math.abs(touch.clientX - data.x);\n      const distY = Math.abs(touch.clientY - data.y);\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\n    };\n    const setup$p = editor => {\n      const startData = value$2();\n      const longpressFired = Cell(false);\n      const debounceLongpress = last$1(e => {\n        editor.dispatch('longpress', {\n          ...e,\n          type: 'longpress'\n        });\n        longpressFired.set(true);\n      }, LONGPRESS_DELAY);\n      editor.on('touchstart', e => {\n        getTouch(e).each(touch => {\n          debounceLongpress.cancel();\n          const data = {\n            x: touch.clientX,\n            y: touch.clientY,\n            target: e.target\n          };\n          debounceLongpress.throttle(e);\n          longpressFired.set(false);\n          startData.set(data);\n        });\n      }, true);\n      editor.on('touchmove', e => {\n        debounceLongpress.cancel();\n        getTouch(e).each(touch => {\n          startData.on(data => {\n            if (isFarEnough(touch, data)) {\n              startData.clear();\n              longpressFired.set(false);\n              editor.dispatch('longpresscancel');\n            }\n          });\n        });\n      }, true);\n      editor.on('touchend touchcancel', e => {\n        debounceLongpress.cancel();\n        if (e.type === 'touchcancel') {\n          return;\n        }\n        startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\n          if (longpressFired.get()) {\n            e.preventDefault();\n          } else {\n            editor.dispatch('tap', {\n              ...e,\n              type: 'tap'\n            });\n          }\n        });\n      }, true);\n    };\n\n    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\n    const isValidTarget = (schema, node) => {\n      if (isText$a(node)) {\n        return true;\n      } else if (isElement$6(node)) {\n        return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node) && !isNonHtmlElementRoot(node);\n      } else {\n        return false;\n      }\n    };\n    const hasBlockParent = (blockElements, root, node) => {\n      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\n        return isBlockElement(blockElements, elm.dom);\n      });\n    };\n    const shouldRemoveTextNode = (blockElements, node) => {\n      if (isText$a(node)) {\n        if (node.data.length === 0) {\n          return true;\n        } else if (/^\\s+$/.test(node.data)) {\n          return !node.nextSibling || isBlockElement(blockElements, node.nextSibling) || isNonHtmlElementRoot(node.nextSibling);\n        }\n      }\n      return false;\n    };\n    const createRootBlock = editor => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n    const addRootBlocks = editor => {\n      const dom = editor.dom, selection = editor.selection;\n      const schema = editor.schema;\n      const blockElements = schema.getBlockElements();\n      const startNode = selection.getStart();\n      const rootNode = editor.getBody();\n      let rootBlockNode;\n      let tempNode;\n      let wrapped = false;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!startNode || !isElement$6(startNode)) {\n        return;\n      }\n      const rootNodeName = rootNode.nodeName.toLowerCase();\n      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {\n        return;\n      }\n      const rng = selection.getRng();\n      const {startContainer, startOffset, endContainer, endOffset} = rng;\n      const restoreSelection = hasFocus(editor);\n      let node = rootNode.firstChild;\n      while (node) {\n        if (isElement$6(node)) {\n          updateElement(schema, node);\n        }\n        if (isValidTarget(schema, node)) {\n          if (shouldRemoveTextNode(blockElements, node)) {\n            tempNode = node;\n            node = node.nextSibling;\n            dom.remove(tempNode);\n            continue;\n          }\n          if (!rootBlockNode) {\n            rootBlockNode = createRootBlock(editor);\n            rootNode.insertBefore(rootBlockNode, node);\n            wrapped = true;\n          }\n          tempNode = node;\n          node = node.nextSibling;\n          rootBlockNode.appendChild(tempNode);\n        } else {\n          rootBlockNode = null;\n          node = node.nextSibling;\n        }\n      }\n      if (wrapped && restoreSelection) {\n        rng.setStart(startContainer, startOffset);\n        rng.setEnd(endContainer, endOffset);\n        selection.setRng(rng);\n        editor.nodeChanged();\n      }\n    };\n    const insertEmptyLine = (editor, root, insertBlock) => {\n      const block = SugarElement.fromDom(createRootBlock(editor));\n      const br = createPaddingBr();\n      append$1(block, br);\n      insertBlock(root, block);\n      const rng = document.createRange();\n      rng.setStartBefore(br.dom);\n      rng.setEndBefore(br.dom);\n      return rng;\n    };\n    const setup$o = editor => {\n      editor.on('NodeChange', curry(addRootBlocks, editor));\n    };\n\n    const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\n    const replaceMatchWithSpan = (editor, content, cls) => {\n      return function (match) {\n        const args = arguments, index = args[args.length - 2];\n        const prevChar = index > 0 ? content.charAt(index - 1) : '';\n        if (prevChar === '\"') {\n          return match;\n        }\n        if (prevChar === '>') {\n          const findStartTagIndex = content.lastIndexOf('<', index);\n          if (findStartTagIndex !== -1) {\n            const tagHtml = content.substring(findStartTagIndex, index);\n            if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\n              return match;\n            }\n          }\n        }\n        return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\n      };\n    };\n    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\n      let i = nonEditableRegExps.length, content = e.content;\n      if (e.format === 'raw') {\n        return;\n      }\n      while (i--) {\n        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\n      }\n      e.content = content;\n    };\n    const setup$n = editor => {\n      const contentEditableAttrName = 'contenteditable';\n      const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\n      const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\n      const hasEditClass = hasClass(editClass);\n      const hasNonEditClass = hasClass(nonEditClass);\n      const nonEditableRegExps = getNonEditableRegExps(editor);\n      if (nonEditableRegExps.length > 0) {\n        editor.on('BeforeSetContent', e => {\n          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\n        });\n      }\n      editor.parser.addAttributeFilter('class', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (hasEditClass(node)) {\n            node.attr(contentEditableAttrName, 'true');\n          } else if (hasNonEditClass(node)) {\n            node.attr(contentEditableAttrName, 'false');\n          }\n        }\n      });\n      editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          if (!hasEditClass(node) && !hasNonEditClass(node)) {\n            continue;\n          }\n          if (nonEditableRegExps.length > 0 && node.attr('data-mce-content')) {\n            node.name = '#text';\n            node.type = 3;\n            node.raw = true;\n            node.value = node.attr('data-mce-content');\n          } else {\n            node.attr(contentEditableAttrName, null);\n          }\n        }\n      });\n    };\n\n    const findBlockCaretContainer = editor => descendant$1(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\n    const showBlockCaretContainer = (editor, blockCaretContainer) => {\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n        showCaretContainerBlock(blockCaretContainer);\n        editor.selection.setRng(editor.selection.getRng());\n        editor.selection.scrollIntoView(blockCaretContainer);\n      }\n    };\n    const handleBlockContainer = (editor, e) => {\n      const blockCaretContainer = findBlockCaretContainer(editor);\n      if (!blockCaretContainer) {\n        return;\n      }\n      if (e.type === 'compositionstart') {\n        e.preventDefault();\n        e.stopPropagation();\n        showBlockCaretContainer(editor, blockCaretContainer);\n        return;\n      }\n      if (hasContent(blockCaretContainer)) {\n        showBlockCaretContainer(editor, blockCaretContainer);\n        editor.undoManager.add();\n      }\n    };\n    const setup$m = editor => {\n      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\n    };\n\n    const isContentEditableFalse$3 = isContentEditableFalse$b;\n    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);\n    const moveToCeFalseVertically = (direction, editor, range) => {\n      const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\n      const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\n      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$3);\n    };\n    const createTextBlock = editor => {\n      const textBlock = editor.dom.create(getForcedRootBlock(editor));\n      textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\n      return textBlock;\n    };\n    const exitPreBlock = (editor, direction, range) => {\n      const caretWalker = CaretWalker(editor.getBody());\n      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\n      if (range.collapsed) {\n        const pre = editor.dom.getParent(range.startContainer, 'PRE');\n        if (!pre) {\n          return;\n        }\n        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\n        if (!caretPos) {\n          const newBlock = SugarElement.fromDom(createTextBlock(editor));\n          if (direction === 1) {\n            after$4(SugarElement.fromDom(pre), newBlock);\n          } else {\n            before$3(SugarElement.fromDom(pre), newBlock);\n          }\n          editor.selection.select(newBlock.dom, true);\n          editor.selection.collapse();\n        }\n      }\n    };\n    const getHorizontalRange = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const getVerticalRange = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\n        exitPreBlock(editor, direction, range);\n        return Optional.none();\n      });\n    };\n    const flipDirection = (selection, forward) => {\n      const elm = forward ? selection.getEnd(true) : selection.getStart(true);\n      return isRtl(elm) ? !forward : forward;\n    };\n    const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\n      moveToRange(editor, newRange);\n      return true;\n    });\n    const moveToLineEndPoint$1 = (editor, forward) => {\n      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\n      return moveToLineEndPoint$3(editor, forward, isCefPosition);\n    };\n    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map(pos => {\n      const rng = pos.toRange();\n      const curRng = editor.selection.getRng();\n      if (forward) {\n        rng.setStart(curRng.startContainer, curRng.startOffset);\n      } else {\n        rng.setEnd(curRng.endContainer, curRng.endOffset);\n      }\n      return rng;\n    }).exists(rng => {\n      moveToRange(editor, rng);\n      return true;\n    });\n\n    const isTarget = node => contains$2(['figcaption'], name(node));\n    const getClosestTargetBlock = (pos, root, schema) => {\n      const isRoot = curry(eq, root);\n      return closest$4(SugarElement.fromDom(pos.container()), el => schema.isBlock(name(el)), isRoot).filter(isTarget);\n    };\n    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\n    const moveCaretToNewEmptyLine = (editor, forward) => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return getClosestTargetBlock(pos, root, editor.schema).exists(() => {\n        if (isAtFirstOrLastLine(root, forward, pos)) {\n          const insertFn = forward ? append$1 : prepend;\n          const rng = insertEmptyLine(editor, root, insertFn);\n          editor.selection.setRng(rng);\n          return true;\n        } else {\n          return false;\n        }\n      });\n    };\n    const moveV$3 = (editor, forward) => {\n      if (editor.selection.isCollapsed()) {\n        return moveCaretToNewEmptyLine(editor, forward);\n      } else {\n        return false;\n      }\n    };\n\n    const moveUp = (editor, details, summary) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (root.firstChild === details && isAtFirstLine(summary, pos)) {\n        editor.execCommand('InsertNewBlockBefore');\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const moveDown = (editor, details) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (root.lastChild === details && isAtLastLine(details, pos)) {\n        editor.execCommand('InsertNewBlockAfter');\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$2 = (editor, forward) => {\n      if (forward) {\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details')).map(details => moveDown(editor, details)).getOr(false);\n      } else {\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary')).bind(summary => Optional.from(editor.dom.getParent(summary, 'details')).map(details => moveUp(editor, details, summary))).getOr(false);\n      }\n    };\n    const moveV$2 = (editor, forward) => move$2(editor, forward);\n\n    const baseKeyPattern = {\n      shiftKey: false,\n      altKey: false,\n      ctrlKey: false,\n      metaKey: false,\n      keyCode: 0\n    };\n    const defaultPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      ...pattern\n    }));\n    const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({\n      ...baseKeyPattern,\n      ...pattern\n    }));\n    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\n    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\n    const action = (f, ...x) => () => f.apply(null, x);\n    const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\n    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\n\n    const moveH$1 = (editor, forward) => {\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\n      const range = editor.selection.getRng();\n      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveV$1 = (editor, down) => {\n      const direction = down ? 1 : -1;\n      const range = editor.selection.getRng();\n      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\n        moveToRange(editor, newRange);\n        return true;\n      });\n    };\n    const moveToLineEndPoint = (editor, forward) => {\n      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\n      return moveToLineEndPoint$3(editor, forward, isNearMedia);\n    };\n\n    const adt = Adt.generate([\n      { none: ['current'] },\n      { first: ['current'] },\n      {\n        middle: [\n          'current',\n          'target'\n        ]\n      },\n      { last: ['current'] }\n    ]);\n    const none = current => adt.none(current);\n    const CellLocation = {\n      ...adt,\n      none\n    };\n\n    const firstLayer = (scope, selector) => {\n      return filterFirstLayer(scope, selector, always);\n    };\n    const filterFirstLayer = (scope, selector, predicate) => {\n      return bind$3(children$1(scope), x => {\n        if (is$1(x, selector)) {\n          return predicate(x) ? [x] : [];\n        } else {\n          return filterFirstLayer(x, selector, predicate);\n        }\n      });\n    };\n\n    const lookup$1 = (tags, element, isRoot = never) => {\n      if (isRoot(element)) {\n        return Optional.none();\n      }\n      if (contains$2(tags, name(element))) {\n        return Optional.some(element);\n      }\n      const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\n      return ancestor$3(element, tags.join(','), isRootOrUpperTable);\n    };\n    const cell = (element, isRoot) => lookup$1([\n      'td',\n      'th'\n    ], element, isRoot);\n    const cells = ancestor => firstLayer(ancestor, 'th,td');\n    const table = (element, isRoot) => closest$3(element, 'table', isRoot);\n\n    const walk = (all, current, index, direction, isEligible = always) => {\n      const forwards = direction === 1;\n      if (!forwards && index <= 0) {\n        return CellLocation.first(all[0]);\n      } else if (forwards && index >= all.length - 1) {\n        return CellLocation.last(all[all.length - 1]);\n      } else {\n        const newIndex = index + direction;\n        const elem = all[newIndex];\n        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\n      }\n    };\n    const detect = (current, isRoot) => {\n      return table(current, isRoot).bind(table => {\n        const all = cells(table);\n        const index = findIndex$2(all, x => eq(current, x));\n        return index.map(index => ({\n          index,\n          all\n        }));\n      });\n    };\n    const next = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none(current);\n      }, info => {\n        return walk(info.all, current, info.index, 1, isEligible);\n      });\n    };\n    const prev = (current, isEligible, isRoot) => {\n      const detection = detect(current, isRoot);\n      return detection.fold(() => {\n        return CellLocation.none();\n      }, info => {\n        return walk(info.all, current, info.index, -1, isEligible);\n      });\n    };\n\n    const deflate = (rect, delta) => ({\n      left: rect.left - delta,\n      top: rect.top - delta,\n      right: rect.right + delta * 2,\n      bottom: rect.bottom + delta * 2,\n      width: rect.width + delta,\n      height: rect.height + delta\n    });\n    const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\n      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\n      return [\n        {\n          x: rect.left,\n          y: getYAxisValue(rect),\n          cell: td\n        },\n        {\n          x: rect.right,\n          y: getYAxisValue(rect),\n          cell: td\n        }\n      ];\n    });\n    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\n      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\n      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\n      return Optional.some(newDist < oldDist ? newCorner : oldCorner);\n    }), Optional.none());\n    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\n      const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\n      const corners = filter$5(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\n      return findClosestCorner(corners, x, y).map(corner => corner.cell);\n    };\n    const getBottomValue = rect => rect.bottom;\n    const getTopValue = rect => rect.top;\n    const isAbove = (corner, y) => corner.y < y;\n    const isBelow = (corner, y) => corner.y > y;\n    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\n    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\n    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\n    const findClosestPositionInBelowCell = (table, pos) => last$3(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\n\n    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\n    const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\n    const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\n    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\n      const lineInfo = getPositionsUntil(scope, pos);\n      if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {\n        return !hasNextBreak(getPositionsUntil, scope, lineInfo);\n      } else {\n        return lineInfo.breakAt.isNone();\n      }\n    };\n    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\n    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\n    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\n    };\n    const navigateHorizontally = (editor, forward, table, _td) => {\n      const rng = editor.selection.getRng();\n      const direction = forward ? 1 : -1;\n      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\n        showCaret(direction, editor, table, !forward, false).each(newRng => {\n          moveToRange(editor, newRng);\n        });\n        return true;\n      }\n      return false;\n    };\n    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\n    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\n    const getTable = (previous, pos) => {\n      const node = pos.getNode(previous);\n      return isTable$2(node) ? Optional.some(node) : Optional.none();\n    };\n    const renderBlock = (down, editor, table) => {\n      editor.undoManager.transact(() => {\n        const insertFn = down ? after$4 : before$3;\n        const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);\n        moveToRange(editor, rng);\n      });\n    };\n    const moveCaret = (editor, down, pos) => {\n      const table = down ? getTable(true, pos) : getTable(false, pos);\n      const last = down === false;\n      table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\n    };\n    const navigateVertically = (editor, down, table, td) => {\n      const rng = editor.selection.getRng();\n      const pos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (!down && isAtFirstTableCellLine(td, pos)) {\n        const newPos = getClosestAbovePosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else if (down && isAtLastTableCellLine(td, pos)) {\n        const newPos = getClosestBelowPosition(root, table, pos);\n        moveCaret(editor, down, newPos);\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\n    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\n    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\n    const getCellFirstCursorPosition = cell => {\n      const selection = SimSelection.exact(cell, 0, cell, 0);\n      return toNative(selection);\n    };\n    const tabGo = (editor, isRoot, cell) => {\n      return cell.fold(Optional.none, Optional.none, (_current, next) => {\n        return first(next).map(cell => {\n          return getCellFirstCursorPosition(cell);\n        });\n      }, current => {\n        editor.execCommand('mceTableInsertRowAfter');\n        return tabForward(editor, isRoot, current);\n      });\n    };\n    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable$2));\n    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable$2));\n    const handleTab = (editor, forward) => {\n      const rootElements = [\n        'table',\n        'li',\n        'dl'\n      ];\n      const body = SugarElement.fromDom(editor.getBody());\n      const isRoot = element => {\n        const name$1 = name(element);\n        return eq(element, body) || contains$2(rootElements, name$1);\n      };\n      const rng = editor.selection.getRng();\n      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\n      return cell(container, isRoot).map(cell => {\n        table(cell, isRoot).each(table => {\n          editor.model.table.clearSelectedCells(table.dom);\n        });\n        editor.selection.collapse(!forward);\n        const navigation = !forward ? tabBackward : tabForward;\n        const rng = navigation(editor, isRoot, cell);\n        rng.each(range => {\n          editor.selection.setRng(range);\n        });\n        return true;\n      }).getOr(false);\n    };\n\n    const executeKeydownOverride$4 = (editor, caret, evt) => {\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      execute([\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$2, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$2, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$4, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$4, editor, true)\n        },\n        ...isMac ? [\n          {\n            keyCode: VK.UP,\n            action: action(selectToEndPoint, editor, false),\n            metaKey: true,\n            shiftKey: true\n          },\n          {\n            keyCode: VK.DOWN,\n            action: action(selectToEndPoint, editor, true),\n            metaKey: true,\n            shiftKey: true\n          }\n        ] : [],\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV, editor, true)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$2, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$2, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(moveH$1, editor, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(moveH$1, editor, false)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$1, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$1, editor, true)\n        },\n        {\n          keyCode: VK.RIGHT,\n          action: action(move$3, editor, caret, true)\n        },\n        {\n          keyCode: VK.LEFT,\n          action: action(move$3, editor, caret, false)\n        },\n        {\n          keyCode: VK.RIGHT,\n          ctrlKey: !isMac,\n          altKey: isMac,\n          action: action(moveNextWord, editor, caret)\n        },\n        {\n          keyCode: VK.LEFT,\n          ctrlKey: !isMac,\n          altKey: isMac,\n          action: action(movePrevWord, editor, caret)\n        },\n        {\n          keyCode: VK.UP,\n          action: action(moveV$3, editor, false)\n        },\n        {\n          keyCode: VK.DOWN,\n          action: action(moveV$3, editor, true)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$l = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$4(editor, caret, evt);\n        }\n      });\n    };\n\n    const point = (container, offset) => ({\n      container,\n      offset\n    });\n\n    const DOM$7 = DOMUtils.DOM;\n    const alwaysNext = startNode => node => startNode === node ? -1 : 0;\n    const isBoundary = dom => node => dom.isBlock(node) || contains$2([\n      'BR',\n      'IMG',\n      'HR',\n      'INPUT'\n    ], node.nodeName) || dom.getContentEditable(node) === 'false';\n    const textBefore = (node, offset, rootNode) => {\n      if (isText$a(node) && offset >= 0) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\n      }\n    };\n    const textAfter = (node, offset, rootNode) => {\n      if (isText$a(node) && offset >= node.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\n      }\n    };\n    const scanLeft = (node, offset, rootNode) => {\n      if (!isText$a(node)) {\n        return Optional.none();\n      }\n      const text = node.data;\n      if (offset >= 0 && offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\n          const prevText = prev.container.data;\n          return scanLeft(prev.container, offset + prevText.length, rootNode);\n        });\n      }\n    };\n    const scanRight = (node, offset, rootNode) => {\n      if (!isText$a(node)) {\n        return Optional.none();\n      }\n      const text = node.data;\n      if (offset <= text.length) {\n        return Optional.some(point(node, offset));\n      } else {\n        const textSeeker = TextSeeker(DOM$7);\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\n      }\n    };\n    const repeatLeft = (dom, node, offset, process, rootNode) => {\n      const search = TextSeeker(dom, isBoundary(dom));\n      return Optional.from(search.backwards(node, offset, process, rootNode));\n    };\n\n    const isValidTextRange = rng => rng.collapsed && isText$a(rng.startContainer);\n    const getText = rng => trim$2(rng.toString().replace(/\\u00A0/g, ' '));\n    const isWhitespace = chr => chr !== '' && ' \\xA0\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\n\n    const stripTrigger = (text, trigger) => text.substring(trigger.length);\n    const findTrigger = (text, index, trigger) => {\n      let i;\n      const firstChar = trigger.charAt(0);\n      for (i = index - 1; i >= 0; i--) {\n        const char = text.charAt(i);\n        if (isWhitespace(char)) {\n          return Optional.none();\n        }\n        if (firstChar === char && contains$1(text, trigger, i, index)) {\n          break;\n        }\n      }\n      return Optional.some(i);\n    };\n    const findStart = (dom, initRange, trigger, minChars = 0) => {\n      if (!isValidTextRange(initRange)) {\n        return Optional.none();\n      }\n      const buffer = {\n        text: '',\n        offset: 0\n      };\n      const findTriggerIndex = (element, offset, text) => {\n        buffer.text = text + buffer.text;\n        buffer.offset += offset;\n        return findTrigger(buffer.text, buffer.offset, trigger).getOr(offset);\n      };\n      const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\n      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind(spot => {\n        const range = initRange.cloneRange();\n        range.setStart(spot.container, spot.offset);\n        range.setEnd(initRange.endContainer, initRange.endOffset);\n        if (range.collapsed) {\n          return Optional.none();\n        }\n        const text = getText(range);\n        const triggerIndex = text.lastIndexOf(trigger);\n        if (triggerIndex !== 0 || stripTrigger(text, trigger).length < minChars) {\n          return Optional.none();\n        } else {\n          return Optional.some({\n            text: stripTrigger(text, trigger),\n            range,\n            trigger\n          });\n        }\n      });\n    };\n    const getContext = (dom, initRange, trigger, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom, initRange, trigger, minChars), elm => {\n      const range = dom.createRng();\n      range.selectNode(elm.dom);\n      const text = getText(range);\n      return Optional.some({\n        range,\n        text: stripTrigger(text, trigger),\n        trigger\n      });\n    });\n\n    const isText$1 = node => node.nodeType === TEXT;\n    const isElement = node => node.nodeType === ELEMENT;\n    const toLast = node => {\n      if (isText$1(node)) {\n        return point(node, node.data.length);\n      } else {\n        const children = node.childNodes;\n        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\n      }\n    };\n    const toLeaf = (node, offset) => {\n      const children = node.childNodes;\n      if (children.length > 0 && offset < children.length) {\n        return toLeaf(children[offset], 0);\n      } else if (children.length > 0 && isElement(node) && children.length === offset) {\n        return toLast(children[children.length - 1]);\n      } else {\n        return point(node, offset);\n      }\n    };\n\n    const isPreviousCharContent = (dom, leaf) => {\n      var _a;\n      const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter(spot => {\n        const char = spot.container.data.charAt(spot.offset - 1);\n        return !isWhitespace(char);\n      }).isSome();\n    };\n    const isStartOfWord = dom => rng => {\n      const leaf = toLeaf(rng.startContainer, rng.startOffset);\n      return !isPreviousCharContent(dom, leaf);\n    };\n    const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, trigger => getContext(dom, initRange, trigger));\n    const lookup = (editor, getDatabase) => {\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\n    };\n    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {\n      var _a;\n      const database = getDatabase();\n      const rng = editor.selection.getRng();\n      const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';\n      const autocompleters = filter$5(database.lookupByTrigger(context.trigger), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\n      if (autocompleters.length === 0) {\n        return Optional.none();\n      }\n      const lookupData = Promise.all(map$3(autocompleters, ac => {\n        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\n        return fetchResult.then(results => ({\n          matchText: context.text,\n          items: results,\n          columns: ac.columns,\n          onAction: ac.onAction,\n          highlightOn: ac.highlightOn\n        }));\n      }));\n      return Optional.some({\n        lookupData,\n        context\n      });\n    };\n\n    var SimpleResultType;\n    (function (SimpleResultType) {\n      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\n      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\n    }(SimpleResultType || (SimpleResultType = {})));\n    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\n    const partition = results => {\n      const values = [];\n      const errors = [];\n      each$e(results, obj => {\n        fold$1(obj, err => errors.push(err), val => values.push(val));\n      });\n      return {\n        values,\n        errors\n      };\n    };\n    const mapError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return {\n          stype: SimpleResultType.Error,\n          serror: f(res.serror)\n        };\n      } else {\n        return res;\n      }\n    };\n    const map = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return {\n          stype: SimpleResultType.Value,\n          svalue: f(res.svalue)\n        };\n      } else {\n        return res;\n      }\n    };\n    const bind$1 = (res, f) => {\n      if (res.stype === SimpleResultType.Value) {\n        return f(res.svalue);\n      } else {\n        return res;\n      }\n    };\n    const bindError = (res, f) => {\n      if (res.stype === SimpleResultType.Error) {\n        return f(res.serror);\n      } else {\n        return res;\n      }\n    };\n    const svalue = v => ({\n      stype: SimpleResultType.Value,\n      svalue: v\n    });\n    const serror = e => ({\n      stype: SimpleResultType.Error,\n      serror: e\n    });\n    const toResult = res => fold$1(res, Result.error, Result.value);\n    const fromResult = res => res.fold(serror, svalue);\n    const SimpleResult = {\n      fromResult,\n      toResult,\n      svalue,\n      partition,\n      serror,\n      bind: bind$1,\n      bindError,\n      map,\n      mapError,\n      fold: fold$1\n    };\n\n    const formatObj = input => {\n      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\n    };\n    const formatErrors = errors => {\n      const es = errors.length > 10 ? errors.slice(0, 10).concat([{\n          path: [],\n          getErrorInfo: constant('... (only showing first ten failures)')\n        }]) : errors;\n      return map$3(es, e => {\n        return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\n      });\n    };\n\n    const nu = (path, getErrorInfo) => {\n      return SimpleResult.serror([{\n          path,\n          getErrorInfo\n        }]);\n    };\n    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\n    const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\n    const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\n    const custom = (path, err) => nu(path, constant(err));\n\n    const chooseFrom = (path, input, branches, ch) => {\n      const fields = get$a(branches, ch);\n      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\n    };\n    const choose$1 = (key, branches) => {\n      const extract = (path, input) => {\n        const choice = get$a(input, key);\n        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\n      };\n      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const shallow = (old, nu) => {\n      return nu;\n    };\n    const deep = (old, nu) => {\n      const bothObjects = isPlainObject(old) && isPlainObject(nu);\n      return bothObjects ? deepMerge(old, nu) : nu;\n    };\n    const baseMerge = merger => {\n      return (...objects) => {\n        if (objects.length === 0) {\n          throw new Error(`Can't merge zero objects`);\n        }\n        const ret = {};\n        for (let j = 0; j < objects.length; j++) {\n          const curObject = objects[j];\n          for (const key in curObject) {\n            if (has$2(curObject, key)) {\n              ret[key] = merger(ret[key], curObject[key]);\n            }\n          }\n        }\n        return ret;\n      };\n    };\n    const deepMerge = baseMerge(deep);\n    const merge = baseMerge(shallow);\n\n    const required = () => ({\n      tag: 'required',\n      process: {}\n    });\n    const defaultedThunk = fallbackThunk => ({\n      tag: 'defaultedThunk',\n      process: fallbackThunk\n    });\n    const defaulted$1 = fallback => defaultedThunk(constant(fallback));\n    const asOption = () => ({\n      tag: 'option',\n      process: {}\n    });\n\n    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\n    const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\n    const consolidateObj = (objects, base) => {\n      const partition = SimpleResult.partition(objects);\n      return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\n    };\n    const consolidateArr = objects => {\n      const partitions = SimpleResult.partition(objects);\n      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\n    };\n    const ResultCombine = {\n      consolidateObj,\n      consolidateArr\n    };\n\n    const field$1 = (key, newKey, presence, prop) => ({\n      tag: 'field',\n      key,\n      newKey,\n      presence,\n      prop\n    });\n    const customField$1 = (newKey, instantiator) => ({\n      tag: 'custom',\n      newKey,\n      instantiator\n    });\n    const fold = (value, ifField, ifCustom) => {\n      switch (value.tag) {\n      case 'field':\n        return ifField(value.key, value.newKey, value.presence, value.prop);\n      case 'custom':\n        return ifCustom(value.newKey, value.instantiator);\n      }\n    };\n\n    const value = validator => {\n      const extract = (path, val) => {\n        return SimpleResult.bindError(validator(val), err => custom(path, err));\n      };\n      const toString = constant('val');\n      return {\n        extract,\n        toString\n      };\n    };\n    const anyValue$1 = value(SimpleResult.svalue);\n\n    const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\n    const fallbackAccess = (obj, key, fallback, bundle) => {\n      const v = get$a(obj, key).getOrThunk(() => fallback(obj));\n      return bundle(v);\n    };\n    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\n    const optionDefaultedAccess = (obj, key, fallback, bundle) => {\n      const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\n      return bundle(opt);\n    };\n    const extractField = (field, path, obj, key, prop) => {\n      const bundle = av => prop.extract(path.concat([key]), av);\n      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\n        const result = prop.extract(path.concat([key]), ov);\n        return SimpleResult.map(result, Optional.some);\n      });\n      switch (field.tag) {\n      case 'required':\n        return requiredAccess(path, obj, key, bundle);\n      case 'defaultedThunk':\n        return fallbackAccess(obj, key, field.process, bundle);\n      case 'option':\n        return optionAccess(obj, key, bundleAsOption);\n      case 'defaultedOptionThunk':\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\n      case 'mergeWithThunk': {\n          return fallbackAccess(obj, key, constant({}), v => {\n            const result = deepMerge(field.process(obj), v);\n            return bundle(result);\n          });\n        }\n      }\n    };\n    const extractFields = (path, obj, fields) => {\n      const success = {};\n      const errors = [];\n      for (const field of fields) {\n        fold(field, (key, newKey, presence, prop) => {\n          const result = extractField(presence, path, obj, key, prop);\n          SimpleResult.fold(result, err => {\n            errors.push(...err);\n          }, res => {\n            success[newKey] = res;\n          });\n        }, (newKey, instantiator) => {\n          success[newKey] = instantiator(obj);\n        });\n      }\n      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\n    };\n    const objOf = values => {\n      const extract = (path, o) => extractFields(path, o, values);\n      const toString = () => {\n        const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\n        return 'obj{\\n' + fieldStrings.join('\\n') + '}';\n      };\n      return {\n        extract,\n        toString\n      };\n    };\n    const arrOf = prop => {\n      const extract = (path, array) => {\n        const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\n        return ResultCombine.consolidateArr(results);\n      };\n      const toString = () => 'array(' + prop.toString() + ')';\n      return {\n        extract,\n        toString\n      };\n    };\n\n    const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\n    const extractValue = (label, prop, obj) => {\n      const res = prop.extract([label], obj);\n      return SimpleResult.mapError(res, errs => ({\n        input: obj,\n        errors: errs\n      }));\n    };\n    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\n    const formatError = errInfo => {\n      return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\n    };\n    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\n\n    const anyValue = constant(anyValue$1);\n    const typedValue = (validator, expectedType) => value(a => {\n      const actualType = typeof a;\n      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);\n    });\n    const number = typedValue(isNumber, 'number');\n    const string = typedValue(isString, 'string');\n    const boolean = typedValue(isBoolean, 'boolean');\n    const functionProcessor = typedValue(isFunction, 'function');\n\n    const field = field$1;\n    const customField = customField$1;\n    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${ value }\", choose one of \"${ values.join(', ') }\".`));\n    const requiredOf = (key, schema) => field(key, key, required(), schema);\n    const requiredString = key => requiredOf(key, string);\n    const requiredFunction = key => requiredOf(key, functionProcessor);\n    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\n    const optionOf = (key, schema) => field(key, key, asOption(), schema);\n    const optionString = key => optionOf(key, string);\n    const optionFunction = key => optionOf(key, functionProcessor);\n    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\n    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\n    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\n    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\n    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\n    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\n    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\n    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\n\n    const type = requiredString('type');\n    const fetch$1 = requiredFunction('fetch');\n    const onAction = requiredFunction('onAction');\n    const onSetup = defaultedFunction('onSetup', () => noop);\n    const optionalText = optionString('text');\n    const optionalIcon = optionString('icon');\n    const optionalTooltip = optionString('tooltip');\n    const optionalLabel = optionString('label');\n    const active = defaultedBoolean('active', false);\n    const enabled = defaultedBoolean('enabled', true);\n    const primary = defaultedBoolean('primary', false);\n    const defaultedColumns = num => defaulted('columns', num);\n    const defaultedType = type => defaultedString('type', type);\n\n    const autocompleterSchema = objOf([\n      type,\n      requiredString('trigger'),\n      defaultedNumber('minChars', 1),\n      defaultedColumns(1),\n      defaultedNumber('maxResults', 10),\n      optionFunction('matches'),\n      fetch$1,\n      onAction,\n      defaultedArrayOf('highlightOn', [], string)\n    ]);\n    const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, {\n      trigger: spec.ch,\n      ...spec\n    });\n\n    const baseToolbarButtonFields = [\n      enabled,\n      optionalTooltip,\n      optionalIcon,\n      optionalText,\n      onSetup\n    ];\n\n    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\n\n    const contextBarFields = [\n      defaultedFunction('predicate', never),\n      defaultedStringEnum('scope', 'node', [\n        'node',\n        'editor'\n      ]),\n      defaultedStringEnum('position', 'selection', [\n        'node',\n        'selection',\n        'line'\n      ])\n    ];\n\n    const contextButtonFields = baseToolbarButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([\n      defaultedType('contextformbutton'),\n      primary,\n      onAction,\n      customField('original', identity)\n    ]);\n    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\n    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\n    const toggleOrNormal = choose('type', {\n      contextformbutton: contextButtonFields,\n      contextformtogglebutton: contextToggleButtonFields\n    });\n    objOf([\n      defaultedType('contextform'),\n      defaultedFunction('initValue', constant('')),\n      optionalLabel,\n      requiredArrayOf('commands', toggleOrNormal),\n      optionOf('launch', choose('type', {\n        contextformbutton: launchButtonFields,\n        contextformtogglebutton: launchToggleButtonFields\n      }))\n    ].concat(contextBarFields));\n\n    const register$2 = editor => {\n      const popups = editor.ui.registry.getAll().popups;\n      const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\n        throw new Error(formatError(err));\n      }, identity));\n      const triggers = stringArray(mapToArray(dataset, v => v.trigger));\n      const datasetValues = values(dataset);\n      const lookupByTrigger = trigger => filter$5(datasetValues, dv => dv.trigger === trigger);\n      return {\n        dataset,\n        triggers,\n        lookupByTrigger\n      };\n    };\n\n    const setupEditorInput = (editor, api) => {\n      const update = last$1(api.load, 50);\n      editor.on('keypress compositionend', e => {\n        if (e.which === 27) {\n          return;\n        }\n        update.throttle();\n      });\n      editor.on('keydown', e => {\n        const keyCode = e.which;\n        if (keyCode === 8) {\n          update.throttle();\n        } else if (keyCode === 27) {\n          api.cancelIfNecessary();\n        }\n      });\n      editor.on('remove', update.cancel);\n    };\n    const setup$k = editor => {\n      const activeAutocompleter = value$2();\n      const uiActive = Cell(false);\n      const isActive = activeAutocompleter.isSet;\n      const cancelIfNecessary = () => {\n        if (isActive()) {\n          removeAutocompleterDecoration(editor);\n          fireAutocompleterEnd(editor);\n          uiActive.set(false);\n          activeAutocompleter.clear();\n        }\n      };\n      const commenceIfNecessary = context => {\n        if (!isActive()) {\n          addAutocompleterDecoration(editor, context.range);\n          activeAutocompleter.set({\n            trigger: context.trigger,\n            matchLength: context.text.length\n          });\n        }\n      };\n      const getAutocompleters = cached(() => register$2(editor));\n      const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.trigger).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\n      const load = fetchOptions => {\n        doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\n          commenceIfNecessary(lookupInfo.context);\n          lookupInfo.lookupData.then(lookupData => {\n            activeAutocompleter.get().map(ac => {\n              const context = lookupInfo.context;\n              if (ac.trigger === context.trigger) {\n                if (context.text.length - ac.matchLength >= 10) {\n                  cancelIfNecessary();\n                } else {\n                  activeAutocompleter.set({\n                    ...ac,\n                    matchLength: context.text.length\n                  });\n                  if (uiActive.get()) {\n                    fireAutocompleterUpdate(editor, { lookupData });\n                  } else {\n                    uiActive.set(true);\n                    fireAutocompleterStart(editor, { lookupData });\n                  }\n                }\n              }\n            });\n          });\n        });\n      };\n      editor.addCommand('mceAutocompleterReload', (_ui, value) => {\n        const fetchOptions = isObject(value) ? value.fetchOptions : {};\n        load(fetchOptions);\n      });\n      editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\n      setupEditorInput(editor, {\n        cancelIfNecessary,\n        load\n      });\n    };\n\n    const browser$1 = detect$2().browser;\n    const isSafari = browser$1.isSafari();\n    const emptyNodeContents = node => fillWithPaddingBr(SugarElement.fromDom(node));\n    const isEntireNodeSelected = (rng, node) => {\n      var _a;\n      return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);\n    };\n    const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));\n    const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();\n    const getDetailsElements = (dom, rng) => {\n      const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));\n      const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));\n      if (startDetails.isSome() || endDetails.isSome()) {\n        const startSummary = startDetails.bind(details => Optional.from(dom.select('summary', details)[0]));\n        return Optional.some({\n          startSummary,\n          startDetails,\n          endDetails\n        });\n      } else {\n        return Optional.none();\n      }\n    };\n    const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists(pos => pos.isEqual(caretPos));\n    const isCaretInTheEndOf = (caretPos, element) => {\n      return lastPositionIn(element).exists(pos => {\n        if (isBr$6(pos.getNode())) {\n          return prevPosition(element, pos).exists(pos2 => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);\n        } else {\n          return pos.isEqual(caretPos);\n        }\n      });\n    };\n    const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheBeginningOf(caretPos, summary));\n    const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheEndOf(caretPos, summary));\n    const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists(details => prevPosition(details, caretPos).forall(pos => detailsElements.startSummary.exists(summary => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));\n    const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists(details => nextPosition(root, caretPos).forall(pos => !details.contains(pos.container())));\n    const setCaretToPosition = (editor, position) => {\n      const node = position.getNode();\n      if (!isUndefined(node)) {\n        editor.selection.setCursorLocation(node, position.offset());\n      }\n    };\n    const moveCaretToDetailsPos = (editor, pos, forward) => {\n      const details = editor.dom.getParent(pos.container(), 'details');\n      if (details && !details.open) {\n        const summary = editor.dom.select('summary', details)[0];\n        if (summary) {\n          const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);\n          newPos.each(pos => setCaretToPosition(editor, pos));\n        }\n      } else {\n        setCaretToPosition(editor, pos);\n      }\n    };\n    const isPartialDelete = (rng, detailsElements) => {\n      const containsStart = element => element.contains(rng.startContainer);\n      const containsEnd = element => element.contains(rng.endContainer);\n      const startInSummary = detailsElements.startSummary.exists(containsStart);\n      const endInSummary = detailsElements.startSummary.exists(containsEnd);\n      const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall(startDetails => detailsElements.endDetails.forall(endDetails => startDetails !== endDetails));\n      const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);\n      return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;\n    };\n    const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {\n      const {dom, selection} = editor;\n      const root = editor.getBody();\n      if (granularity === 'character') {\n        const caretPos = CaretPosition.fromRangeStart(selection.getRng());\n        const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);\n        const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);\n        const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);\n        const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);\n        const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);\n        if (inEmptyParentBlock) {\n          const firstOrLast = forward ? isLastBlock : isFirstBlock;\n          if (firstOrLast) {\n            const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists(pos => {\n              return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));\n            });\n            if (isBeforeAfterDetails) {\n              return true;\n            }\n          }\n        }\n        return navigate(forward, root, caretPos).fold(never, pos => {\n          const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);\n          if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {\n            if (!forward) {\n              moveCaretToDetailsPos(editor, pos, false);\n            }\n            if (parentBlock && inEmptyParentBlock) {\n              if (forward && isFirstBlock) {\n                return true;\n              } else if (!forward && isLastBlock) {\n                return true;\n              }\n              moveCaretToDetailsPos(editor, pos, forward);\n              editor.dom.remove(parentBlock);\n            }\n            return true;\n          } else {\n            return false;\n          }\n        });\n      } else {\n        return false;\n      }\n    };\n    const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {\n      const selection = editor.selection;\n      const rng = selection.getRng();\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      const root = editor.getBody();\n      if (granularity === 'selection') {\n        return isPartialDelete(rng, detailElements);\n      } else if (forward) {\n        return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);\n      } else {\n        return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);\n      }\n    };\n    const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), detailsElements => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));\n    const handleDeleteActionSafari = (editor, forward, granularity) => {\n      const selection = editor.selection;\n      const node = selection.getNode();\n      const rng = selection.getRng();\n      const caretPos = CaretPosition.fromRangeStart(rng);\n      if (isSummary$1(node)) {\n        if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {\n          emptyNodeContents(node);\n        } else {\n          editor.undoManager.transact(() => {\n            const sel = selection.getSel();\n            let {anchorNode, anchorOffset, focusNode, focusOffset} = sel !== null && sel !== void 0 ? sel : {};\n            const applySelection = () => {\n              if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {\n                sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\n              }\n            };\n            const updateSelection = () => {\n              anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\n              anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;\n              focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\n              focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;\n            };\n            const appendAllChildNodes = (from, to) => {\n              each$e(from.childNodes, child => {\n                if (isNode(child)) {\n                  to.appendChild(child);\n                }\n              });\n            };\n            const container = editor.dom.create('span', { 'data-mce-bogus': '1' });\n            appendAllChildNodes(node, container);\n            node.appendChild(container);\n            applySelection();\n            if (granularity === 'word' || granularity === 'line') {\n              sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);\n            }\n            if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {\n              emptyNodeContents(node);\n            } else {\n              editor.execCommand(forward ? 'ForwardDelete' : 'Delete');\n              updateSelection();\n              appendAllChildNodes(container, node);\n              applySelection();\n            }\n            editor.dom.remove(container);\n          });\n        }\n        return true;\n      } else {\n        return false;\n      }\n    };\n    const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity) ? Optional.some(noop) : Optional.none();\n\n    const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {\n      const target = editor.getBody();\n      const overrides = {\n        bubbles: true,\n        composed: true,\n        data: null,\n        isComposing: false,\n        detail: 0,\n        view: null,\n        target,\n        currentTarget: target,\n        eventPhase: Event.AT_TARGET,\n        originalTarget: target,\n        explicitOriginalTarget: target,\n        isTrusted: false,\n        srcElement: target,\n        cancelable: false,\n        preventDefault: noop,\n        inputType\n      };\n      const input = clone$3(new InputEvent(eventType));\n      return editor.dispatch(eventType, {\n        ...input,\n        ...overrides,\n        ...specifics\n      });\n    };\n    const fireInputEvent = createAndFireInputEvent('input');\n    const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');\n\n    const platform$2 = detect$2();\n    const os = platform$2.os;\n    const isMacOSOriOS = os.isMacOS() || os.isiOS();\n    const browser = platform$2.browser;\n    const isFirefox = browser.isFirefox();\n    const executeKeydownOverride$3 = (editor, caret, evt) => {\n      const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\n      const isCollapsed = editor.selection.isCollapsed();\n      const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';\n      const getModifiedGranularity = isWord => {\n        if (isCollapsed) {\n          return isWord ? 'word' : 'line';\n        } else {\n          return 'selection';\n        }\n      };\n      executeWithDelayedAction([\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$1, editor)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$6, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$6, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$7, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$7, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$4, editor, caret, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$4, editor, caret, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$a, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$a, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete, editor, false, unmodifiedGranularity)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete, editor, true, unmodifiedGranularity)\n        },\n        ...isMacOSOriOS ? [\n          {\n            keyCode: VK.BACKSPACE,\n            altKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.DELETE,\n            altKey: true,\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.BACKSPACE,\n            metaKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(false))\n          }\n        ] : [\n          {\n            keyCode: VK.BACKSPACE,\n            ctrlKey: true,\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\n          },\n          {\n            keyCode: VK.DELETE,\n            ctrlKey: true,\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\n          }\n        ],\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$5, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$5, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$2, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$2, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$8, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$8, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$9, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$9, editor, true)\n        },\n        {\n          keyCode: VK.BACKSPACE,\n          action: action(backspaceDelete$3, editor, false)\n        },\n        {\n          keyCode: VK.DELETE,\n          action: action(backspaceDelete$3, editor, true)\n        }\n      ], evt).filter(_ => editor.selection.isEditable()).each(applyAction => {\n        evt.preventDefault();\n        const beforeInput = fireBeforeInputEvent(editor, inputType);\n        if (!beforeInput.isDefaultPrevented()) {\n          applyAction();\n          fireInputEvent(editor, inputType);\n        }\n      });\n    };\n    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([\n      {\n        keyCode: VK.BACKSPACE,\n        action: action(paddEmptyElement, editor)\n      },\n      {\n        keyCode: VK.DELETE,\n        action: action(paddEmptyElement, editor)\n      },\n      ...isMacOSOriOS ? [\n        {\n          keyCode: VK.BACKSPACE,\n          altKey: true,\n          action: action(refreshCaret, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          altKey: true,\n          action: action(refreshCaret, editor)\n        },\n        ...isBackspaceKeydown ? [{\n            keyCode: isFirefox ? 224 : 91,\n            action: action(refreshCaret, editor)\n          }] : []\n      ] : [\n        {\n          keyCode: VK.BACKSPACE,\n          ctrlKey: true,\n          action: action(refreshCaret, editor)\n        },\n        {\n          keyCode: VK.DELETE,\n          ctrlKey: true,\n          action: action(refreshCaret, editor)\n        }\n      ]\n    ], evt);\n    const setup$j = (editor, caret) => {\n      let isBackspaceKeydown = false;\n      editor.on('keydown', evt => {\n        isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$3(editor, caret, evt);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeyupOverride(editor, evt, isBackspaceKeydown);\n        }\n        isBackspaceKeydown = false;\n      });\n    };\n\n    const firstNonWhiteSpaceNodeSibling = node => {\n      while (node) {\n        if (isElement$6(node) || isText$a(node) && node.data && /[\\r\\n\\s]/.test(node.data)) {\n          return node;\n        }\n        node = node.nextSibling;\n      }\n      return null;\n    };\n    const moveToCaretPosition = (editor, root) => {\n      const dom = editor.dom;\n      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\n      if (!root) {\n        return;\n      }\n      if (/^(LI|DT|DD)$/.test(root.nodeName)) {\n        const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\n        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\n          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\n        }\n      }\n      const rng = dom.createRng();\n      root.normalize();\n      if (root.hasChildNodes()) {\n        const walker = new DomTreeWalker(root, root);\n        let lastNode = root;\n        let node;\n        while (node = walker.current()) {\n          if (isText$a(node)) {\n            rng.setStart(node, 0);\n            rng.setEnd(node, 0);\n            break;\n          }\n          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\n            rng.setStartBefore(node);\n            rng.setEndBefore(node);\n            break;\n          }\n          lastNode = node;\n          node = walker.next();\n        }\n        if (!node) {\n          rng.setStart(lastNode, 0);\n          rng.setEnd(lastNode, 0);\n        }\n      } else {\n        if (isBr$6(root)) {\n          if (root.nextSibling && dom.isBlock(root.nextSibling)) {\n            rng.setStartBefore(root);\n            rng.setEndBefore(root);\n          } else {\n            rng.setStartAfter(root);\n            rng.setEndAfter(root);\n          }\n        } else {\n          rng.setStart(root, 0);\n          rng.setEnd(root, 0);\n        }\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const getEditableRoot = (dom, node) => {\n      const root = dom.getRoot();\n      let editableRoot;\n      let parent = node;\n      while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {\n        if (dom.getContentEditable(parent) === 'true') {\n          editableRoot = parent;\n          break;\n        }\n        parent = parent.parentNode;\n      }\n      return parent !== root ? editableRoot : root;\n    };\n    const getParentBlock$1 = editor => {\n      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\n    };\n    const getParentBlockName = editor => {\n      return getParentBlock$1(editor).fold(constant(''), parentBlock => {\n        return parentBlock.nodeName.toUpperCase();\n      });\n    };\n    const isListItemParentBlock = editor => {\n      return getParentBlock$1(editor).filter(elm => {\n        return isListItem$1(SugarElement.fromDom(elm));\n      }).isSome();\n    };\n    const emptyBlock = elm => {\n      elm.innerHTML = '<br data-mce-bogus=\"1\">';\n    };\n    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\n      const dom = editor.dom;\n      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\n        const currentStyles = getAllRaw(SugarElement.fromDom(node));\n        const newStyles = {\n          ...currentStyles,\n          ...attrStyles\n        };\n        dom.setStyles(node, newStyles);\n      });\n      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\n      const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$5(currentClasses.split(/\\s+/), clazz => clazz !== ''));\n      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\n        const filteredClasses = filter$5(currentClasses, clazz => !contains$2(attrClasses, clazz));\n        const newClasses = [\n          ...attrClasses,\n          ...filteredClasses\n        ];\n        dom.setAttrib(node, 'class', newClasses.join(' '));\n      });\n      const appliedAttrs = [\n        'style',\n        'class'\n      ];\n      const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\n      dom.setAttribs(node, remainingAttrs);\n    };\n    const setForcedBlockAttrs = (editor, node) => {\n      const forcedRootBlockName = getForcedRootBlock(editor);\n      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\n        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\n        applyAttributes(editor, node, forcedRootBlockAttrs);\n      }\n    };\n    const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name, styles) => {\n      const dom = editor.dom;\n      const schema = editor.schema;\n      const newBlockName = getForcedRootBlock(editor);\n      const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      let node = container;\n      const textInlineElements = schema.getTextInlineElements();\n      let block;\n      if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\n        block = dom.create(name || newBlockName, styles || {});\n      } else {\n        block = parentBlock.cloneNode(false);\n      }\n      let caretNode = block;\n      if (!keepStyles) {\n        dom.setAttrib(block, 'style', null);\n        dom.setAttrib(block, 'class', null);\n      } else {\n        do {\n          if (textInlineElements[node.nodeName]) {\n            if (isCaretNode(node) || isBookmarkNode$1(node)) {\n              continue;\n            }\n            const clonedNode = node.cloneNode(false);\n            dom.setAttrib(clonedNode, 'id', '');\n            if (block.hasChildNodes()) {\n              clonedNode.appendChild(block.firstChild);\n              block.appendChild(clonedNode);\n            } else {\n              caretNode = clonedNode;\n              block.appendChild(clonedNode);\n            }\n          }\n        } while ((node = node.parentNode) && node !== editableRoot);\n      }\n      setForcedBlockAttrs(editor, block);\n      emptyBlock(caretNode);\n      return block;\n    };\n\n    const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);\n    const isAtDetailsEdge = (root, element, isTextBlock) => {\n      let node = element;\n      while (node && node !== root && isNull(node.nextSibling)) {\n        const parent = node.parentElement;\n        if (!parent || !isTextBlock(parent)) {\n          return isDetails(parent);\n        }\n        node = parent;\n      }\n      return false;\n    };\n    const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, el => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));\n    const insertNewLine = (editor, createNewBlock, parentBlock) => {\n      var _a, _b, _c;\n      const newBlock = createNewBlock(getForcedRootBlock(editor));\n      const root = getDetailsRoot(editor, parentBlock);\n      if (!root) {\n        return;\n      }\n      editor.dom.insertAfter(newBlock, root);\n      moveToCaretPosition(editor, newBlock);\n      if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {\n        editor.dom.remove(parentBlock);\n      }\n    };\n\n    const hasFirstChild = (elm, name) => {\n      return elm.firstChild && elm.firstChild.nodeName === name;\n    };\n    const isFirstChild = elm => {\n      var _a;\n      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\n    };\n    const hasParent = (elm, parentName) => {\n      const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;\n      return isNonNullable(parentNode) && parentNode.nodeName === parentName;\n    };\n    const isListBlock = elm => {\n      return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);\n    };\n    const isListItem = elm => {\n      return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);\n    };\n    const isNestedList = elm => {\n      return isListBlock(elm) && isListBlock(elm.parentNode);\n    };\n    const getContainerBlock = containerBlock => {\n      const containerBlockParent = containerBlock.parentNode;\n      return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;\n    };\n    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\n      let node = containerBlock[first ? 'firstChild' : 'lastChild'];\n      while (node) {\n        if (isElement$6(node)) {\n          break;\n        }\n        node = node[first ? 'nextSibling' : 'previousSibling'];\n      }\n      return node === parentBlock;\n    };\n    const getStyles = elm => foldl(mapToArray(getAllRaw(SugarElement.fromDom(elm)), (style, styleName) => `${ styleName }: ${ style };`), (acc, s) => acc + s, '');\n    const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const containerParent = containerBlock.parentNode;\n      if (containerBlock === editor.getBody() || !containerParent) {\n        return;\n      }\n      if (isNestedList(containerBlock)) {\n        newBlockName = 'LI';\n      }\n      const parentBlockStyles = isListItem(parentBlock) ? getStyles(parentBlock) : undefined;\n      let newBlock = isListItem(parentBlock) && parentBlockStyles ? createNewBlock(newBlockName, { style: getStyles(parentBlock) }) : createNewBlock(newBlockName);\n      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        if (hasParent(containerBlock, 'LI')) {\n          const containerBlockParent = getContainerBlock(containerBlock);\n          dom.insertAfter(newBlock, containerBlockParent);\n          if (isFirstChild(containerBlock)) {\n            dom.remove(containerBlockParent);\n          } else {\n            dom.remove(containerBlock);\n          }\n        } else {\n          dom.replace(newBlock, containerBlock);\n        }\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\n        if (hasParent(containerBlock, 'LI')) {\n          dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n          newBlock.appendChild(dom.doc.createTextNode(' '));\n          newBlock.appendChild(containerBlock);\n        } else {\n          containerParent.insertBefore(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\n        dom.remove(parentBlock);\n      } else {\n        containerBlock = getContainerBlock(containerBlock);\n        const tmpRng = rng.cloneRange();\n        tmpRng.setStartAfter(parentBlock);\n        tmpRng.setEndAfter(containerBlock);\n        const fragment = tmpRng.extractContents();\n        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\n          const previousChildren = filter$5(map$3(newBlock.children, SugarElement.fromDom), not(isTag('br')));\n          newBlock = fragment.firstChild;\n          dom.insertAfter(fragment, containerBlock);\n          each$e(previousChildren, child => prepend(SugarElement.fromDom(newBlock), child));\n          if (parentBlockStyles) {\n            newBlock.setAttribute('style', parentBlockStyles);\n          }\n        } else {\n          dom.insertAfter(fragment, containerBlock);\n          dom.insertAfter(newBlock, containerBlock);\n        }\n        dom.remove(parentBlock);\n      }\n      moveToCaretPosition(editor, newBlock);\n    };\n\n    const trimZwsp = fragment => {\n      each$e(descendants$1(SugarElement.fromDom(fragment), isText$b), text => {\n        const rawNode = text.dom;\n        rawNode.nodeValue = trim$2(rawNode.data);\n      });\n    };\n    const isWithinNonEditableList = (editor, node) => {\n      const parentList = editor.dom.getParent(node, 'ol,ul,dl');\n      return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';\n    };\n    const isEmptyAnchor = (dom, elm) => {\n      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\n    };\n    const containerAndSiblingName = (container, nodeName) => {\n      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\n    };\n    const canSplitBlock = (dom, node) => {\n      return isNonNullable(node) && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';\n    };\n    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\n      var _a;\n      const firstChilds = [];\n      if (!block) {\n        return;\n      }\n      let currentNode = block;\n      while (currentNode = currentNode.firstChild) {\n        if (dom.isBlock(currentNode)) {\n          return;\n        }\n        if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {\n          firstChilds.push(currentNode);\n        }\n      }\n      let i = firstChilds.length;\n      while (i--) {\n        currentNode = firstChilds[i];\n        if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '') {\n          dom.remove(currentNode);\n        } else {\n          if (isEmptyAnchor(dom, currentNode)) {\n            dom.remove(currentNode);\n          }\n        }\n      }\n    };\n    const normalizeZwspOffset = (start, container, offset) => {\n      if (!isText$a(container)) {\n        return offset;\n      } else if (start) {\n        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\n      } else {\n        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\n      }\n    };\n    const includeZwspInRange = rng => {\n      const newRng = rng.cloneRange();\n      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\n      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\n      return newRng;\n    };\n    const trimLeadingLineBreaks = node => {\n      let currentNode = node;\n      do {\n        if (isText$a(currentNode)) {\n          currentNode.data = currentNode.data.replace(/^[\\r\\n]+/, '');\n        }\n        currentNode = currentNode.firstChild;\n      } while (currentNode);\n    };\n    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\n      var _a, _b;\n      const dom = editor.dom;\n      const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\n        parentBlock = parentBlock || editableRoot;\n        if (!parentBlock.hasChildNodes()) {\n          const newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          parentBlock.appendChild(newBlock);\n          rng.setStart(newBlock, 0);\n          rng.setEnd(newBlock, 0);\n          return newBlock;\n        }\n        let node = container;\n        while (node && node.parentNode !== parentBlock) {\n          node = node.parentNode;\n        }\n        let startNode;\n        while (node && !dom.isBlock(node)) {\n          startNode = node;\n          node = node.previousSibling;\n        }\n        const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;\n        if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {\n          const startNodeParent = startNode.parentNode;\n          const newBlock = dom.create(newBlockName);\n          setForcedBlockAttrs(editor, newBlock);\n          startNodeParent.insertBefore(newBlock, startNode);\n          node = startNode;\n          while (node && !dom.isBlock(node)) {\n            const next = node.nextSibling;\n            newBlock.appendChild(node);\n            node = next;\n          }\n          rng.setStart(container, offset);\n          rng.setEnd(container, offset);\n        }\n      }\n      return container;\n    };\n    const addBrToBlockIfNeeded = (dom, block) => {\n      block.normalize();\n      const lastChild = block.lastChild;\n      if (!lastChild || isElement$6(lastChild) && /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\n        dom.add(block, 'br');\n      }\n    };\n    const shouldEndContainer = (editor, container) => {\n      const optionValue = shouldEndContainerOnEmptyBlock(editor);\n      if (isNullable(container)) {\n        return false;\n      } else if (isString(optionValue)) {\n        return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());\n      } else {\n        return optionValue;\n      }\n    };\n    const insert$3 = (editor, evt) => {\n      let container;\n      let offset;\n      let parentBlockName;\n      let containerBlock;\n      let isAfterLastNodeInContainer = false;\n      const dom = editor.dom;\n      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();\n      const rng = editor.selection.getRng();\n      const newBlockName = getForcedRootBlock(editor);\n      const start = SugarElement.fromDom(rng.startContainer);\n      const child = child$1(start, rng.startOffset);\n      const isCef = child.exists(element => isHTMLElement$1(element) && !isEditable$2(element));\n      const collapsedAndCef = rng.collapsed && isCef;\n      const createNewBlock$1 = (name, styles) => {\n        return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name, styles);\n      };\n      const isCaretAtStartOrEndOfBlock = start => {\n        const normalizedOffset = normalizeZwspOffset(start, container, offset);\n        if (isText$a(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {\n          return false;\n        }\n        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {\n          return true;\n        }\n        if (start && isElement$6(container) && container === parentBlock.firstChild) {\n          return true;\n        }\n        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {\n          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\n        }\n        const walker = new DomTreeWalker(container, parentBlock);\n        if (isText$a(container)) {\n          if (start && normalizedOffset === 0) {\n            walker.prev();\n          } else if (!start && normalizedOffset === container.data.length) {\n            walker.next();\n          }\n        }\n        let node;\n        while (node = walker.current()) {\n          if (isElement$6(node)) {\n            if (!node.getAttribute('data-mce-bogus')) {\n              const name = node.nodeName.toLowerCase();\n              if (nonEmptyElementsMap[name] && name !== 'br') {\n                return false;\n              }\n            }\n          } else if (isText$a(node) && !isWhitespaceText(node.data)) {\n            return false;\n          }\n          if (start) {\n            walker.prev();\n          } else {\n            walker.next();\n          }\n        }\n        return true;\n      };\n      const insertNewBlockAfter = () => {\n        let block;\n        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\n          block = createNewBlock$1(newBlockName);\n        } else {\n          block = createNewBlock$1();\n        }\n        if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, { includeZwsp: true })) {\n          block = dom.split(containerBlock, parentBlock);\n        } else {\n          dom.insertAfter(block, parentBlock);\n        }\n        moveToCaretPosition(editor, block);\n        return block;\n      };\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      container = rng.startContainer;\n      offset = rng.startOffset;\n      const shiftKey = !!(evt && evt.shiftKey);\n      const ctrlKey = !!(evt && evt.ctrlKey);\n      if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {\n        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$a(container)) {\n          offset = container.data.length;\n        } else {\n          offset = 0;\n        }\n      }\n      const editableRoot = getEditableRoot(dom, container);\n      if (!editableRoot || isWithinNonEditableList(editor, container)) {\n        return;\n      }\n      if (!shiftKey) {\n        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();\n      containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      if (containerBlockName === 'LI' && !ctrlKey) {\n        const liBlock = containerBlock;\n        parentBlock = liBlock;\n        containerBlock = liBlock.parentNode;\n        parentBlockName = containerBlockName;\n      }\n      if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {\n        return insertNewLine(editor, createNewBlock$1, parentBlock);\n      }\n      if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {\n        if (dom.isEmpty(parentBlock)) {\n          insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);\n          return;\n        }\n      }\n      if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {\n        return;\n      }\n      const parentBlockParent = parentBlock.parentNode;\n      let newBlock;\n      if (collapsedAndCef) {\n        newBlock = createNewBlock$1(newBlockName);\n        child.fold(() => {\n          append$1(start, SugarElement.fromDom(newBlock));\n        }, child => {\n          before$3(child, SugarElement.fromDom(newBlock));\n        });\n        editor.selection.setCursorLocation(newBlock, 0);\n      } else if (isCaretContainerBlock$1(parentBlock)) {\n        newBlock = showCaretContainerBlock(parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        setForcedBlockAttrs(editor, newBlock);\n        moveToCaretPosition(editor, newBlock);\n      } else if (isCaretAtStartOrEndOfBlock(false)) {\n        newBlock = insertNewBlockAfter();\n      } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {\n        newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);\n        const isNearChildren = hasChildNodes(SugarElement.fromDom(rng.startContainer)) && rng.collapsed;\n        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') || isNearChildren ? newBlock : parentBlock);\n      } else {\n        const tmpRng = includeZwspInRange(rng).cloneRange();\n        tmpRng.setEndAfter(parentBlock);\n        const fragment = tmpRng.extractContents();\n        trimZwsp(fragment);\n        trimLeadingLineBreaks(fragment);\n        newBlock = fragment.firstChild;\n        dom.insertAfter(fragment, parentBlock);\n        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\n        addBrToBlockIfNeeded(dom, parentBlock);\n        if (dom.isEmpty(parentBlock)) {\n          emptyBlock(parentBlock);\n        }\n        newBlock.normalize();\n        if (dom.isEmpty(newBlock)) {\n          dom.remove(newBlock);\n          insertNewBlockAfter();\n        } else {\n          setForcedBlockAttrs(editor, newBlock);\n          moveToCaretPosition(editor, newBlock);\n        }\n      }\n      dom.setAttrib(newBlock, 'id', '');\n      editor.dispatch('NewBlock', { newBlock });\n    };\n    const fakeEventName$1 = 'insertParagraph';\n    const blockbreak = {\n      insert: insert$3,\n      fakeEventName: fakeEventName$1\n    };\n\n    const hasRightSideContent = (schema, container, parentBlock) => {\n      const walker = new DomTreeWalker(container, parentBlock);\n      let node;\n      const nonEmptyElementsMap = schema.getNonEmptyElements();\n      while (node = walker.next()) {\n        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$a(node) && node.length > 0) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const moveSelectionToBr = (editor, brElm, extraBr) => {\n      const rng = editor.dom.createRng();\n      if (!extraBr) {\n        rng.setStartAfter(brElm);\n        rng.setEndAfter(brElm);\n      } else {\n        rng.setStartBefore(brElm);\n        rng.setEndBefore(brElm);\n      }\n      editor.selection.setRng(rng);\n      scrollRangeIntoView(editor, rng);\n    };\n    const insertBrAtCaret = (editor, evt) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      const rng = selection.getRng();\n      let brElm;\n      let extraBr = false;\n      normalize$2(dom, rng).each(normRng => {\n        rng.setStart(normRng.startContainer, normRng.startOffset);\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\n      });\n      let offset = rng.startOffset;\n      let container = rng.startContainer;\n      if (isElement$6(container) && container.hasChildNodes()) {\n        const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\n        if (isAfterLastNodeInContainer && isText$a(container)) {\n          offset = container.data.length;\n        } else {\n          offset = 0;\n        }\n      }\n      let parentBlock = dom.getParent(container, dom.isBlock);\n      const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\n      const isControlKey = !!(evt && evt.ctrlKey);\n      if (containerBlockName === 'LI' && !isControlKey) {\n        parentBlock = containerBlock;\n      }\n      if (isText$a(container) && offset >= container.data.length) {\n        if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {\n          brElm = dom.create('br');\n          rng.insertNode(brElm);\n          rng.setStartAfter(brElm);\n          rng.setEndAfter(brElm);\n          extraBr = true;\n        }\n      }\n      brElm = dom.create('br');\n      rangeInsertNode(dom, rng, brElm);\n      moveSelectionToBr(editor, brElm, extraBr);\n      editor.undoManager.add();\n    };\n    const insertBrBefore = (editor, inline) => {\n      const br = SugarElement.fromTag('br');\n      before$3(SugarElement.fromDom(inline), br);\n      editor.undoManager.add();\n    };\n    const insertBrAfter = (editor, inline) => {\n      if (!hasBrAfter(editor.getBody(), inline)) {\n        after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\n      }\n      const br = SugarElement.fromTag('br');\n      after$4(SugarElement.fromDom(inline), br);\n      moveSelectionToBr(editor, br.dom, false);\n      editor.undoManager.add();\n    };\n    const isBeforeBr = pos => {\n      return isBr$6(pos.getNode());\n    };\n    const hasBrAfter = (rootNode, startNode) => {\n      if (isBeforeBr(CaretPosition.after(startNode))) {\n        return true;\n      } else {\n        return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\n          return isBr$6(pos.getNode());\n        }).getOr(false);\n      }\n    };\n    const isAnchorLink = elm => {\n      return elm && elm.nodeName === 'A' && 'href' in elm;\n    };\n    const isInsideAnchor = location => {\n      return location.fold(never, isAnchorLink, isAnchorLink, never);\n    };\n    const readInlineAnchorLocation = editor => {\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\n      const position = CaretPosition.fromRangeStart(editor.selection.getRng());\n      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\n    };\n    const insertBrOutsideAnchor = (editor, location) => {\n      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\n    };\n    const insert$2 = (editor, evt) => {\n      const anchorLocation = readInlineAnchorLocation(editor);\n      if (anchorLocation.isSome()) {\n        anchorLocation.each(curry(insertBrOutsideAnchor, editor));\n      } else {\n        insertBrAtCaret(editor, evt);\n      }\n    };\n    const fakeEventName = 'insertLineBreak';\n    const linebreak = {\n      insert: insert$2,\n      fakeEventName\n    };\n\n    const matchesSelector = (editor, selector) => {\n      return getParentBlock$1(editor).filter(parentBlock => {\n        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\n      }).isSome();\n    };\n    const shouldInsertBr = editor => {\n      return matchesSelector(editor, getBrNewLineSelector(editor));\n    };\n    const shouldBlockNewLine$1 = editor => {\n      return matchesSelector(editor, getNoNewLineSelector(editor));\n    };\n\n    const newLineAction = Adt.generate([\n      { br: [] },\n      { block: [] },\n      { none: [] }\n    ]);\n    const shouldBlockNewLine = (editor, _shiftKey) => {\n      return shouldBlockNewLine$1(editor);\n    };\n    const inListBlock = requiredState => {\n      return (editor, _shiftKey) => {\n        return isListItemParentBlock(editor) === requiredState;\n      };\n    };\n    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\n      const state = getParentBlockName(editor) === blockName.toUpperCase();\n      return state === requiredState;\n    };\n    const inCefBlock = editor => {\n      const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());\n      return isNullable(editableRoot);\n    };\n    const inPreBlock = requiredState => inBlock('pre', requiredState);\n    const inSummaryBlock = () => inBlock('summary', true);\n    const shouldPutBrInPre = requiredState => {\n      return (editor, _shiftKey) => {\n        return shouldPutBrInPre$1(editor) === requiredState;\n      };\n    };\n    const inBrContext = (editor, _shiftKey) => {\n      return shouldInsertBr(editor);\n    };\n    const hasShiftKey = (_editor, shiftKey) => {\n      return shiftKey;\n    };\n    const canInsertIntoEditableRoot = editor => {\n      const forcedRootBlock = getForcedRootBlock(editor);\n      const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());\n      return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\n    };\n    const isInRootWithEmptyOrCEF = editor => {\n      const rng = editor.selection.getRng();\n      const start = SugarElement.fromDom(rng.startContainer);\n      const child = child$1(start, rng.startOffset);\n      const isCefOpt = child.map(element => isHTMLElement$1(element) && !isEditable$2(element));\n      return rng.collapsed && isCefOpt.getOr(true);\n    };\n    const match = (predicates, action) => {\n      return (editor, shiftKey) => {\n        const isMatch = foldl(predicates, (res, p) => {\n          return res && p(editor, shiftKey);\n        }, true);\n        return isMatch ? Optional.some(action) : Optional.none();\n      };\n    };\n    const getAction = (editor, evt) => {\n      return evaluateUntil([\n        match([shouldBlockNewLine], newLineAction.none()),\n        match([\n          inPreBlock(true),\n          inCefBlock\n        ], newLineAction.none()),\n        match([inSummaryBlock()], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(false)\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true),\n          hasShiftKey\n        ], newLineAction.block()),\n        match([\n          inPreBlock(true),\n          shouldPutBrInPre(true)\n        ], newLineAction.br()),\n        match([\n          inListBlock(true),\n          hasShiftKey\n        ], newLineAction.br()),\n        match([inListBlock(true)], newLineAction.block()),\n        match([inBrContext], newLineAction.br()),\n        match([hasShiftKey], newLineAction.br()),\n        match([canInsertIntoEditableRoot], newLineAction.block()),\n        match([isInRootWithEmptyOrCEF], newLineAction.block())\n      ], [\n        editor,\n        !!(evt && evt.shiftKey)\n      ]).getOr(newLineAction.none());\n    };\n\n    const insertBreak = (breakType, editor, evt) => {\n      if (!editor.selection.isCollapsed()) {\n        execEditorDeleteCommand(editor);\n      }\n      if (isNonNullable(evt)) {\n        const event = fireBeforeInputEvent(editor, breakType.fakeEventName);\n        if (event.isDefaultPrevented()) {\n          return;\n        }\n      }\n      breakType.insert(editor, evt);\n      if (isNonNullable(evt)) {\n        fireInputEvent(editor, breakType.fakeEventName);\n      }\n    };\n    const insert$1 = (editor, evt) => {\n      const br = () => insertBreak(linebreak, editor, evt);\n      const block = () => insertBreak(blockbreak, editor, evt);\n      const logicalAction = getAction(editor, evt);\n      switch (getNewlineBehavior(editor)) {\n      case 'linebreak':\n        logicalAction.fold(br, br, noop);\n        break;\n      case 'block':\n        logicalAction.fold(block, block, noop);\n        break;\n      case 'invert':\n        logicalAction.fold(block, br, noop);\n        break;\n      default:\n        logicalAction.fold(br, block, noop);\n        break;\n      }\n    };\n\n    const platform$1 = detect$2();\n    const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();\n    const handleEnterKeyEvent = (editor, event) => {\n      if (event.isDefaultPrevented()) {\n        return;\n      }\n      event.preventDefault();\n      endTypingLevelIgnoreLocks(editor.undoManager);\n      editor.undoManager.transact(() => {\n        insert$1(editor, event);\n      });\n    };\n    const isCaretAfterKoreanCharacter = rng => {\n      if (!rng.collapsed) {\n        return false;\n      }\n      const startContainer = rng.startContainer;\n      if (isText$a(startContainer)) {\n        const koreanCharRegex = /^[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uD7B0-\\uD7FF]$/;\n        const char = startContainer.data.charAt(rng.startOffset - 1);\n        return koreanCharRegex.test(char);\n      } else {\n        return false;\n      }\n    };\n    const setup$i = editor => {\n      let iOSSafariKeydownBookmark = Optional.none();\n      const iOSSafariKeydownOverride = editor => {\n        iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());\n        editor.undoManager.add();\n      };\n      const iOSSafariKeyupOverride = (editor, event) => {\n        editor.undoManager.undo();\n        iOSSafariKeydownBookmark.fold(noop, b => editor.selection.moveToBookmark(b));\n        handleEnterKeyEvent(editor, event);\n        iOSSafariKeydownBookmark = Optional.none();\n      };\n      editor.on('keydown', event => {\n        if (event.keyCode === VK.ENTER) {\n          if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {\n            iOSSafariKeydownOverride(editor);\n          } else {\n            handleEnterKeyEvent(editor, event);\n          }\n        }\n      });\n      editor.on('keyup', event => {\n        if (event.keyCode === VK.ENTER) {\n          iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));\n        }\n      });\n    };\n\n    const executeKeydownOverride$2 = (editor, caret, evt) => {\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      execute([\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$1, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$1, editor, false)\n        },\n        ...!isMac ? [\n          {\n            keyCode: VK.HOME,\n            action: action(selectToEndPoint, editor, false),\n            ctrlKey: true,\n            shiftKey: true\n          },\n          {\n            keyCode: VK.END,\n            action: action(selectToEndPoint, editor, true),\n            ctrlKey: true,\n            shiftKey: true\n          }\n        ] : [],\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint, editor, true)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint, editor, false)\n        },\n        {\n          keyCode: VK.END,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        },\n        {\n          keyCode: VK.HOME,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        }\n      ], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$h = (editor, caret) => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$2(editor, caret, evt);\n        }\n      });\n    };\n\n    const setup$g = editor => {\n      editor.on('input', e => {\n        if (!e.isComposing) {\n          normalizeNbspsInEditor(editor);\n        }\n      });\n    };\n\n    const platform = detect$2();\n    const executeKeyupAction = (editor, caret, evt) => {\n      execute([\n        {\n          keyCode: VK.PAGE_UP,\n          action: action(moveToLineEndPoint$2, editor, false, caret)\n        },\n        {\n          keyCode: VK.PAGE_DOWN,\n          action: action(moveToLineEndPoint$2, editor, true, caret)\n        }\n      ], evt);\n    };\n    const stopImmediatePropagation = e => e.stopImmediatePropagation();\n    const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\n    const setNodeChangeBlocker = (blocked, editor, block) => {\n      if (block && !blocked.get()) {\n        editor.on('NodeChange', stopImmediatePropagation, true);\n      } else if (!block && blocked.get()) {\n        editor.off('NodeChange', stopImmediatePropagation);\n      }\n      blocked.set(block);\n    };\n    const setup$f = (editor, caret) => {\n      if (platform.os.isMacOS()) {\n        return;\n      }\n      const blocked = Cell(false);\n      editor.on('keydown', evt => {\n        if (isPageUpDown(evt)) {\n          setNodeChangeBlocker(blocked, editor, true);\n        }\n      });\n      editor.on('keyup', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeyupAction(editor, caret, evt);\n        }\n        if (isPageUpDown(evt) && blocked.get()) {\n          setNodeChangeBlocker(blocked, editor, false);\n          editor.nodeChanged();\n        }\n      });\n    };\n\n    const setup$e = editor => {\n      editor.on('beforeinput', e => {\n        if (!editor.selection.isEditable() || exists(e.getTargetRanges(), rng => !isEditableRange(editor.dom, rng))) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const insertTextAtPosition = (text, pos) => {\n      const container = pos.container();\n      const offset = pos.offset();\n      if (isText$a(container)) {\n        container.insertData(offset, text);\n        return Optional.some(CaretPosition(container, offset + text.length));\n      } else {\n        return getElementFromPosition(pos).map(elm => {\n          const textNode = SugarElement.fromText(text);\n          if (pos.isAtEnd()) {\n            after$4(elm, textNode);\n          } else {\n            before$3(elm, textNode);\n          }\n          return CaretPosition(textNode.dom, text.length);\n        });\n      }\n    };\n    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\n    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\n\n    const insertSpaceOrNbspAtPosition = (root, pos, schema) => needsToHaveNbsp(root, pos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\n    const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => checkPos => needsToHaveNbsp(root, checkPos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\n    const setSelection = editor => pos => {\n      editor.selection.setRng(pos.toRange());\n      editor.nodeChanged();\n    };\n    const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));\n    const insertSpaceOrNbspAtSelection = editor => {\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n      const root = SugarElement.fromDom(editor.getBody());\n      if (editor.selection.isCollapsed()) {\n        const isInlineTarget$1 = curry(isInlineTarget, editor);\n        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\n        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos, editor.schema)(checkPos).each(setSelection(editor)));\n      } else {\n        return Optional.none();\n      }\n    };\n    const insertSpaceInSummaryAtSelectionOnFirefox = editor => {\n      const insertSpaceThunk = () => {\n        const root = SugarElement.fromDom(editor.getBody());\n        if (!editor.selection.isCollapsed()) {\n          editor.getDoc().execCommand('Delete');\n        }\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\n        insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(setSelection(editor));\n      };\n      return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);\n    };\n\n    const executeKeydownOverride$1 = (editor, evt) => {\n      executeWithDelayedAction([\n        {\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceOrNbspAtSelection, editor)\n        },\n        {\n          keyCode: VK.SPACEBAR,\n          action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)\n        }\n      ], evt).each(applyAction => {\n        evt.preventDefault();\n        const event = fireBeforeInputEvent(editor, 'insertText', { data: ' ' });\n        if (!event.isDefaultPrevented()) {\n          applyAction();\n          fireInputEvent(editor, 'insertText', { data: ' ' });\n        }\n      });\n    };\n    const setup$d = editor => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride$1(editor, evt);\n        }\n      });\n    };\n\n    const tableTabNavigation = editor => {\n      if (hasTableTabNavigation(editor)) {\n        return [\n          {\n            keyCode: VK.TAB,\n            action: action(handleTab, editor, true)\n          },\n          {\n            keyCode: VK.TAB,\n            shiftKey: true,\n            action: action(handleTab, editor, false)\n          }\n        ];\n      } else {\n        return [];\n      }\n    };\n    const executeKeydownOverride = (editor, evt) => {\n      execute([...tableTabNavigation(editor)], evt).each(_ => {\n        evt.preventDefault();\n      });\n    };\n    const setup$c = editor => {\n      editor.on('keydown', evt => {\n        if (!evt.isDefaultPrevented()) {\n          executeKeydownOverride(editor, evt);\n        }\n      });\n    };\n\n    const setup$b = editor => {\n      editor.addShortcut('Meta+P', '', 'mcePrint');\n      setup$k(editor);\n      if (isRtc(editor)) {\n        return Cell(null);\n      } else {\n        const caret = setupSelectedState(editor);\n        setup$e(editor);\n        setup$m(editor);\n        setup$l(editor, caret);\n        setup$j(editor, caret);\n        setup$i(editor);\n        setup$d(editor);\n        setup$g(editor);\n        setup$c(editor);\n        setup$h(editor, caret);\n        setup$f(editor, caret);\n        return caret;\n      }\n    };\n\n    class NodeChange {\n      constructor(editor) {\n        this.lastPath = [];\n        this.editor = editor;\n        let lastRng;\n        const self = this;\n        if (!('onselectionchange' in editor.getDoc())) {\n          editor.on('NodeChange click mouseup keyup focus', e => {\n            const nativeRng = editor.selection.getRng();\n            const fakeRng = {\n              startContainer: nativeRng.startContainer,\n              startOffset: nativeRng.startOffset,\n              endContainer: nativeRng.endContainer,\n              endOffset: nativeRng.endOffset\n            };\n            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\n              editor.dispatch('SelectionChange');\n            }\n            lastRng = fakeRng;\n          });\n        }\n        editor.on('contextmenu', () => {\n          editor.dispatch('SelectionChange');\n        });\n        editor.on('SelectionChange', () => {\n          const startElm = editor.selection.getStart(true);\n          if (!startElm) {\n            return;\n          }\n          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\n            editor.nodeChanged({ selectionChange: true });\n          }\n        });\n        editor.on('mouseup', e => {\n          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\n            if (editor.selection.getNode().nodeName === 'IMG') {\n              Delay.setEditorTimeout(editor, () => {\n                editor.nodeChanged();\n              });\n            } else {\n              editor.nodeChanged();\n            }\n          }\n        });\n      }\n      nodeChanged(args = {}) {\n        const selection = this.editor.selection;\n        let node;\n        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {\n          const root = this.editor.getBody();\n          node = selection.getStart(true) || root;\n          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {\n            node = root;\n          }\n          const parents = [];\n          this.editor.dom.getParent(node, node => {\n            if (node === root) {\n              return true;\n            } else {\n              parents.push(node);\n              return false;\n            }\n          });\n          this.editor.dispatch('NodeChange', {\n            ...args,\n            element: node,\n            parents\n          });\n        }\n      }\n      isSameElementPath(startElm) {\n        let i;\n        const editor = this.editor;\n        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\n        if (currentPath.length === this.lastPath.length) {\n          for (i = currentPath.length; i >= 0; i--) {\n            if (currentPath[i] !== this.lastPath[i]) {\n              break;\n            }\n          }\n          if (i === -1) {\n            this.lastPath = currentPath;\n            return true;\n          }\n        }\n        this.lastPath = currentPath;\n        return false;\n      }\n    }\n\n    const imageId = generate$1('image');\n    const getDragImage = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[imageId]);\n    };\n    const setDragImage = (transfer, imageData) => {\n      const dt = transfer;\n      dt[imageId] = imageData;\n    };\n\n    const eventId = generate$1('event');\n    const getEvent = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[eventId]);\n    };\n    const mkSetEventFn = type => transfer => {\n      const dt = transfer;\n      dt[eventId] = type;\n    };\n    const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);\n    const setDragstartEvent = mkSetEventFn(0);\n    const setDropEvent = mkSetEventFn(2);\n    const setDragendEvent = mkSetEventFn(1);\n    const checkEvent = expectedType => transfer => {\n      const dt = transfer;\n      return Optional.from(dt[eventId]).exists(type => type === expectedType);\n    };\n    const isInDragStartEvent = checkEvent(0);\n\n    const createEmptyFileList = () => Object.freeze({\n      length: 0,\n      item: _ => null\n    });\n\n    const modeId = generate$1('mode');\n    const getMode = transfer => {\n      const dt = transfer;\n      return Optional.from(dt[modeId]);\n    };\n    const mkSetModeFn = mode => transfer => {\n      const dt = transfer;\n      dt[modeId] = mode;\n    };\n    const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);\n    const setReadWriteMode = mkSetModeFn(0);\n    const setReadOnlyMode = mkSetModeFn(2);\n    const setProtectedMode = mkSetModeFn(1);\n    const checkMode = expectedMode => transfer => {\n      const dt = transfer;\n      return Optional.from(dt[modeId]).exists(mode => mode === expectedMode);\n    };\n    const isInReadWriteMode = checkMode(0);\n    const isInProtectedMode = checkMode(1);\n\n    const normalizeItems = (dataTransfer, itemsImpl) => ({\n      ...itemsImpl,\n      get length() {\n        return itemsImpl.length;\n      },\n      add: (data, type) => {\n        if (isInReadWriteMode(dataTransfer)) {\n          if (isString(data)) {\n            if (!isUndefined(type)) {\n              return itemsImpl.add(data, type);\n            }\n          } else {\n            return itemsImpl.add(data);\n          }\n        }\n        return null;\n      },\n      remove: idx => {\n        if (isInReadWriteMode(dataTransfer)) {\n          itemsImpl.remove(idx);\n        }\n      },\n      clear: () => {\n        if (isInReadWriteMode(dataTransfer)) {\n          itemsImpl.clear();\n        }\n      }\n    });\n\n    const validDropEffects = [\n      'none',\n      'copy',\n      'link',\n      'move'\n    ];\n    const validEffectAlloweds = [\n      'none',\n      'copy',\n      'copyLink',\n      'copyMove',\n      'link',\n      'linkMove',\n      'move',\n      'all',\n      'uninitialized'\n    ];\n    const createDataTransfer = () => {\n      const dataTransferImpl = new window.DataTransfer();\n      let dropEffect = 'move';\n      let effectAllowed = 'all';\n      const dataTransfer = {\n        get dropEffect() {\n          return dropEffect;\n        },\n        set dropEffect(effect) {\n          if (contains$2(validDropEffects, effect)) {\n            dropEffect = effect;\n          }\n        },\n        get effectAllowed() {\n          return effectAllowed;\n        },\n        set effectAllowed(allowed) {\n          if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {\n            effectAllowed = allowed;\n          }\n        },\n        get items() {\n          return normalizeItems(dataTransfer, dataTransferImpl.items);\n        },\n        get files() {\n          if (isInProtectedMode(dataTransfer)) {\n            return createEmptyFileList();\n          } else {\n            return dataTransferImpl.files;\n          }\n        },\n        get types() {\n          return dataTransferImpl.types;\n        },\n        setDragImage: (image, x, y) => {\n          if (isInReadWriteMode(dataTransfer)) {\n            setDragImage(dataTransfer, {\n              image,\n              x,\n              y\n            });\n            dataTransferImpl.setDragImage(image, x, y);\n          }\n        },\n        getData: format => {\n          if (isInProtectedMode(dataTransfer)) {\n            return '';\n          } else {\n            return dataTransferImpl.getData(format);\n          }\n        },\n        setData: (format, data) => {\n          if (isInReadWriteMode(dataTransfer)) {\n            dataTransferImpl.setData(format, data);\n          }\n        },\n        clearData: format => {\n          if (isInReadWriteMode(dataTransfer)) {\n            dataTransferImpl.clearData(format);\n          }\n        }\n      };\n      setReadWriteMode(dataTransfer);\n      return dataTransfer;\n    };\n    const cloneDataTransfer = original => {\n      const clone = createDataTransfer();\n      const originalMode = getMode(original);\n      setReadOnlyMode(original);\n      setDragstartEvent(clone);\n      clone.dropEffect = original.dropEffect;\n      clone.effectAllowed = original.effectAllowed;\n      getDragImage(original).each(imageData => clone.setDragImage(imageData.image, imageData.x, imageData.y));\n      each$e(original.types, type => {\n        if (type !== 'Files') {\n          clone.setData(type, original.getData(type));\n        }\n      });\n      each$e(original.files, file => clone.items.add(file));\n      getEvent(original).each(type => {\n        setEvent(clone, type);\n      });\n      originalMode.each(mode => {\n        setMode$1(original, mode);\n        setMode$1(clone, mode);\n      });\n      return clone;\n    };\n\n    const getHtmlData = dataTransfer => {\n      const html = dataTransfer.getData('text/html');\n      return html === '' ? Optional.none() : Optional.some(html);\n    };\n    const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);\n\n    const internalMimeType = 'x-tinymce/html';\n    const internalHtmlMime = constant(internalMimeType);\n    const internalMark = '<!-- ' + internalMimeType + ' -->';\n    const mark = html => internalMark + html;\n    const unmark = html => html.replace(internalMark, '');\n    const isMarked = html => html.indexOf(internalMark) !== -1;\n\n    const isPlainText = text => {\n      return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\n    };\n    const openContainer = (rootTag, rootAttrs) => {\n      let tag = '<' + rootTag;\n      const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\n      if (attrs.length) {\n        tag += ' ' + attrs.join(' ');\n      }\n      return tag + '>';\n    };\n    const toBlockElements = (text, rootTag, rootAttrs) => {\n      const blocks = text.split(/\\n\\n/);\n      const tagOpen = openContainer(rootTag, rootAttrs);\n      const tagClose = '</' + rootTag + '>';\n      const paragraphs = map$3(blocks, p => {\n        return p.split(/\\n/).join('<br />');\n      });\n      const stitch = p => {\n        return tagOpen + p + tagClose;\n      };\n      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\n    };\n\n    const pasteBinDefaultContent = '%MCEPASTEBIN%';\n    const create$6 = (editor, lastRngCell) => {\n      const {dom, selection} = editor;\n      const body = editor.getBody();\n      lastRngCell.set(selection.getRng());\n      const pasteBinElm = dom.add(editor.getBody(), 'div', {\n        'id': 'mcepastebin',\n        'class': 'mce-pastebin',\n        'contentEditable': true,\n        'data-mce-bogus': 'all',\n        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\n      }, pasteBinDefaultContent);\n      if (Env.browser.isFirefox()) {\n        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\n      }\n      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\n        e.stopPropagation();\n      });\n      pasteBinElm.focus();\n      selection.select(pasteBinElm, true);\n    };\n    const remove = (editor, lastRngCell) => {\n      const dom = editor.dom;\n      if (getEl(editor)) {\n        let pasteBinClone;\n        const lastRng = lastRngCell.get();\n        while (pasteBinClone = getEl(editor)) {\n          dom.remove(pasteBinClone);\n          dom.unbind(pasteBinClone);\n        }\n        if (lastRng) {\n          editor.selection.setRng(lastRng);\n        }\n      }\n      lastRngCell.set(null);\n    };\n    const getEl = editor => editor.dom.get('mcepastebin');\n    const isPasteBin = elm => isNonNullable(elm) && elm.id === 'mcepastebin';\n    const getHtml = editor => {\n      const dom = editor.dom;\n      const copyAndRemove = (toElm, fromElm) => {\n        toElm.appendChild(fromElm);\n        dom.remove(fromElm, true);\n      };\n      const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);\n      each$e(pasteBinClones, pasteBinClone => {\n        copyAndRemove(pasteBinElm, pasteBinClone);\n      });\n      const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\n      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\n        const cleanWrapper = dom.create('div');\n        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\n        copyAndRemove(cleanWrapper, dirtyWrappers[i]);\n      }\n      return pasteBinElm ? pasteBinElm.innerHTML : '';\n    };\n    const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\n    const PasteBin = editor => {\n      const lastRng = Cell(null);\n      return {\n        create: () => create$6(editor, lastRng),\n        remove: () => remove(editor, lastRng),\n        getEl: () => getEl(editor),\n        getHtml: () => getHtml(editor),\n        getLastRng: lastRng.get\n      };\n    };\n\n    const filter$1 = (content, items) => {\n      Tools.each(items, v => {\n        if (is$4(v, RegExp)) {\n          content = content.replace(v, '');\n        } else {\n          content = content.replace(v[0], v[1]);\n        }\n      });\n      return content;\n    };\n    const innerText = html => {\n      const schema = Schema();\n      const domParser = DomParser({}, schema);\n      let text = '';\n      const voidElements = schema.getVoidElements();\n      const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\n      const blockElements = schema.getBlockElements();\n      const walk = node => {\n        const name = node.name, currentNode = node;\n        if (name === 'br') {\n          text += '\\n';\n          return;\n        }\n        if (name === 'wbr') {\n          return;\n        }\n        if (voidElements[name]) {\n          text += ' ';\n        }\n        if (ignoreElements[name]) {\n          text += ' ';\n          return;\n        }\n        if (node.type === 3) {\n          text += node.value;\n        }\n        if (!(node.name in schema.getVoidElements())) {\n          let currentNode = node.firstChild;\n          if (currentNode) {\n            do {\n              walk(currentNode);\n            } while (currentNode = currentNode.next);\n          }\n        }\n        if (blockElements[name] && currentNode.next) {\n          text += '\\n';\n          if (name === 'p') {\n            text += '\\n';\n          }\n        }\n      };\n      html = filter$1(html, [/<!\\[[^\\]]+\\]>/g]);\n      walk(domParser.parse(html));\n      return text;\n    };\n    const trimHtml = html => {\n      const trimSpaces = (all, s1, s2) => {\n        if (!s1 && !s2) {\n          return ' ';\n        }\n        return nbsp;\n      };\n      html = filter$1(html, [\n        /^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig,\n        /<!--StartFragment-->|<!--EndFragment-->/g,\n        [\n          /( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g,\n          trimSpaces\n        ],\n        /<br class=\"Apple-interchange-newline\">/g,\n        /<br>$/i\n      ]);\n      return html;\n    };\n    const createIdGenerator = prefix => {\n      let count = 0;\n      return () => {\n        return prefix + count++;\n      };\n    };\n    const getImageMimeType = ext => {\n      const lowerExt = ext.toLowerCase();\n      const mimeOverrides = {\n        jpg: 'jpeg',\n        jpe: 'jpeg',\n        jfi: 'jpeg',\n        jif: 'jpeg',\n        jfif: 'jpeg',\n        pjpeg: 'jpeg',\n        pjp: 'jpeg',\n        svg: 'svg+xml'\n      };\n      return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\n    };\n\n    const preProcess = (editor, html) => {\n      const parser = DomParser({\n        sanitize: shouldSanitizeXss(editor),\n        sandbox_iframes: shouldSandboxIframes(editor)\n      }, editor.schema);\n      parser.addNodeFilter('meta', nodes => {\n        Tools.each(nodes, node => {\n          node.remove();\n        });\n      });\n      const fragment = parser.parse(html, {\n        forced_root_block: false,\n        isRootContent: true\n      });\n      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);\n    };\n    const processResult = (content, cancelled) => ({\n      content,\n      cancelled\n    });\n    const postProcessFilter = (editor, html, internal) => {\n      const tempBody = editor.dom.create('div', { style: 'display:none' }, html);\n      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\n      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\n    };\n    const filterContent = (editor, content, internal) => {\n      const preProcessArgs = firePastePreProcess(editor, content, internal);\n      const filteredContent = preProcess(editor, preProcessArgs.content);\n      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\n        return postProcessFilter(editor, filteredContent, internal);\n      } else {\n        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\n      }\n    };\n    const process = (editor, html, internal) => {\n      return filterContent(editor, html, internal);\n    };\n\n    const pasteHtml$1 = (editor, html) => {\n      editor.insertContent(html, {\n        merge: shouldPasteMergeFormats(editor),\n        paste: true\n      });\n      return true;\n    };\n    const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\-\\/+=.,!;:&%@^~(){}?#]+$/i.test(url);\n    const isImageUrl = (editor, url) => {\n      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${ type.toLowerCase() }`));\n    };\n    const createImage = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.insertContent('<img src=\"' + url + '\">');\n      });\n      return true;\n    };\n    const createLink = (editor, url, pasteHtmlFn) => {\n      editor.undoManager.extra(() => {\n        pasteHtmlFn(editor, url);\n      }, () => {\n        editor.execCommand('mceInsertLink', false, url);\n      });\n      return true;\n    };\n    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\n    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\n    const smartInsertContent = (editor, html) => {\n      Tools.each([\n        linkSelection,\n        insertImage,\n        pasteHtml$1\n      ], action => {\n        return !action(editor, html, pasteHtml$1);\n      });\n    };\n    const insertContent = (editor, html, pasteAsText) => {\n      if (pasteAsText || !isSmartPasteEnabled(editor)) {\n        pasteHtml$1(editor, html);\n      } else {\n        smartInsertContent(editor, html);\n      }\n    };\n\n    const uniqueId = createIdGenerator('mceclip');\n    const createPasteDataTransfer = html => {\n      const dataTransfer = createDataTransfer();\n      setHtmlData(dataTransfer, html);\n      setReadOnlyMode(dataTransfer);\n      return dataTransfer;\n    };\n    const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {\n      const res = process(editor, content, internal);\n      if (!res.cancelled) {\n        const content = res.content;\n        const doPasteAction = () => insertContent(editor, content, pasteAsText);\n        if (shouldSimulateInputEvent) {\n          const args = fireBeforeInputEvent(editor, 'insertFromPaste', { dataTransfer: createPasteDataTransfer(content) });\n          if (!args.isDefaultPrevented()) {\n            doPasteAction();\n            fireInputEvent(editor, 'insertFromPaste');\n          }\n        } else {\n          doPasteAction();\n        }\n      }\n    };\n    const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {\n      const internal = internalFlag ? internalFlag : isMarked(html);\n      doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);\n    };\n    const pasteText = (editor, text, shouldSimulateInputEvent) => {\n      const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\n      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\n      const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\n      doPaste(editor, html, false, true, shouldSimulateInputEvent);\n    };\n    const getDataTransferItems = dataTransfer => {\n      const items = {};\n      if (dataTransfer && dataTransfer.types) {\n        for (let i = 0; i < dataTransfer.types.length; i++) {\n          const contentType = dataTransfer.types[i];\n          try {\n            items[contentType] = dataTransfer.getData(contentType);\n          } catch (ex) {\n            items[contentType] = '';\n          }\n        }\n      }\n      return items;\n    };\n    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\n    const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\n    const extractFilename = (editor, str) => {\n      const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\n      return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;\n    };\n    const createBlobInfo = (editor, blobCache, file, base64) => {\n      const id = uniqueId();\n      const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\n      const name = useFileName ? extractFilename(editor, file.name) : id;\n      const filename = useFileName ? file.name : undefined;\n      const blobInfo = blobCache.create(id, file, base64, name, filename);\n      blobCache.add(blobInfo);\n      return blobInfo;\n    };\n    const pasteImage = (editor, imageItem) => {\n      parseDataUri(imageItem.uri).each(({data, type, base64Encoded}) => {\n        const base64 = base64Encoded ? data : btoa(data);\n        const file = imageItem.file;\n        const blobCache = editor.editorUpload.blobCache;\n        const existingBlobInfo = blobCache.getByData(base64, type);\n        const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\n        pasteHtml(editor, `<img src=\"${ blobInfo.blobUri() }\">`, false, true);\n      });\n    };\n    const isClipboardEvent = event => event.type === 'paste';\n    const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\n      return blobToDataUri(file).then(uri => ({\n        file,\n        uri\n      }));\n    }));\n    const isImage = editor => {\n      const allowedExtensions = getAllowedImageFileTypes(editor);\n      return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\n        return getImageMimeType(extension) === file.type;\n      });\n    };\n    const getImagesFromDataTransfer = (editor, dataTransfer) => {\n      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\n        return item.kind === 'file' ? [item.getAsFile()] : [];\n      }) : [];\n      const files = dataTransfer.files ? from(dataTransfer.files) : [];\n      return filter$5(items.length > 0 ? items : files, isImage(editor));\n    };\n    const pasteImageData = (editor, e, rng) => {\n      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\n      if (shouldPasteDataImages(editor) && dataTransfer) {\n        const images = getImagesFromDataTransfer(editor, dataTransfer);\n        if (images.length > 0) {\n          e.preventDefault();\n          readFilesAsDataUris(images).then(fileResults => {\n            if (rng) {\n              editor.selection.setRng(rng);\n            }\n            each$e(fileResults, result => {\n              pasteImage(editor, result);\n            });\n          });\n          return true;\n        }\n      }\n      return false;\n    };\n    const isBrokenAndroidClipboardEvent = e => {\n      var _a, _b;\n      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\n    };\n    const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\n    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {\n      let content = trimHtml(html);\n      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\n      const isPlainTextHtml = !isInternal && isPlainText(content);\n      const isAbsoluteUrl$1 = isAbsoluteUrl(content);\n      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\n        plainTextMode = true;\n      }\n      if (plainTextMode || isAbsoluteUrl$1) {\n        if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\n          content = clipboardContent['text/plain'];\n        } else {\n          content = innerText(content);\n        }\n      }\n      if (isDefaultPasteBinContent(content)) {\n        return;\n      }\n      if (plainTextMode) {\n        pasteText(editor, content, shouldSimulateInputEvent);\n      } else {\n        pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);\n      }\n    };\n    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\n      let keyboardPastePlainTextState;\n      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\n      editor.on('keydown', e => {\n        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\n          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\n        }\n      });\n      editor.on('paste', e => {\n        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\n          return;\n        }\n        const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\n        keyboardPastePlainTextState = false;\n        const clipboardContent = getDataTransferItems(e.clipboardData);\n        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\n          return;\n        }\n        if (hasContentType(clipboardContent, 'text/html')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);\n        } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {\n          e.preventDefault();\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);\n        } else {\n          pasteBin.create();\n          Delay.setEditorTimeout(editor, () => {\n            const html = pasteBin.getHtml();\n            pasteBin.remove();\n            insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);\n          }, 0);\n        }\n      });\n    };\n    const registerDataImageFilter = editor => {\n      const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\n      const isDataUri = src => startsWith(src, 'data:');\n      const isPasteInsert = args => {\n        var _a;\n        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\n      };\n      editor.parser.addNodeFilter('img', (nodes, name, args) => {\n        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\n          for (const node of nodes) {\n            const src = node.attr('src');\n            if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\n              if (isWebKitFakeUrl(src)) {\n                node.remove();\n              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\n                node.remove();\n              }\n            }\n          }\n        }\n      });\n    };\n    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\n      registerEventHandlers(editor, pasteBin, pasteFormat);\n      registerDataImageFilter(editor);\n    };\n\n    const togglePlainTextPaste = (editor, pasteFormat) => {\n      if (pasteFormat.get() === 'text') {\n        pasteFormat.set('html');\n        firePastePlainTextToggle(editor, false);\n      } else {\n        pasteFormat.set('text');\n        firePastePlainTextToggle(editor, true);\n      }\n      editor.focus();\n    };\n    const register$1 = (editor, pasteFormat) => {\n      editor.addCommand('mceTogglePlainTextPaste', () => {\n        togglePlainTextPaste(editor, pasteFormat);\n      });\n      editor.addCommand('mceInsertClipboardContent', (ui, value) => {\n        if (value.html) {\n          pasteHtml(editor, value.html, value.internal, false);\n        }\n        if (value.text) {\n          pasteText(editor, value.text, false);\n        }\n      });\n    };\n\n    const setHtml5Clipboard = (clipboardData, html, text) => {\n      if (clipboardData) {\n        try {\n          clipboardData.clearData();\n          clipboardData.setData('text/html', html);\n          clipboardData.setData('text/plain', text);\n          clipboardData.setData(internalHtmlMime(), html);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      } else {\n        return false;\n      }\n    };\n    const setClipboardData = (evt, data, fallback, done) => {\n      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\n        evt.preventDefault();\n        done();\n      } else {\n        fallback(data.html, done);\n      }\n    };\n    const fallback = editor => (html, done) => {\n      const {dom, selection} = editor;\n      const outer = dom.create('div', {\n        'contenteditable': 'false',\n        'data-mce-bogus': 'all'\n      });\n      const inner = dom.create('div', { contenteditable: 'true' }, html);\n      dom.setStyles(outer, {\n        position: 'fixed',\n        top: '0',\n        left: '-3000px',\n        width: '1000px',\n        overflow: 'hidden'\n      });\n      outer.appendChild(inner);\n      dom.add(editor.getBody(), outer);\n      const range = selection.getRng();\n      inner.focus();\n      const offscreenRange = dom.createRng();\n      offscreenRange.selectNodeContents(inner);\n      selection.setRng(offscreenRange);\n      Delay.setEditorTimeout(editor, () => {\n        selection.setRng(range);\n        dom.remove(outer);\n        done();\n      }, 0);\n    };\n    const getData = editor => ({\n      html: mark(editor.selection.getContent({ contextual: true })),\n      text: editor.selection.getContent({ format: 'text' })\n    });\n    const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\n    const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\n    const cut = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor) && editor.selection.isEditable()) {\n        setClipboardData(evt, getData(editor), fallback(editor), () => {\n          if (Env.browser.isChromium() || Env.browser.isFirefox()) {\n            const rng = editor.selection.getRng();\n            Delay.setEditorTimeout(editor, () => {\n              editor.selection.setRng(rng);\n              editor.execCommand('Delete');\n            }, 0);\n          } else {\n            editor.execCommand('Delete');\n          }\n        });\n      }\n    };\n    const copy = editor => evt => {\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\n        setClipboardData(evt, getData(editor), fallback(editor), noop);\n      }\n    };\n    const register = editor => {\n      editor.on('cut', cut(editor));\n      editor.on('copy', copy(editor));\n    };\n\n    const getCaretRangeFromEvent = (editor, e) => {\n      var _a, _b;\n      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\n    };\n    const isPlainTextFileUrl = content => {\n      const plainTextContent = content['text/plain'];\n      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\n    };\n    const setFocusedRange = (editor, rng) => {\n      editor.focus();\n      if (rng) {\n        editor.selection.setRng(rng);\n      }\n    };\n    const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\n    const needsCustomInternalDrop = (dom, schema, target, dropContent) => {\n      const parentTransparent = dom.getParent(target, node => isTransparentBlock(schema, node));\n      const inSummary = !isNull(dom.getParent(target, 'summary'));\n      if (inSummary) {\n        return true;\n      } else if (parentTransparent && has$2(dropContent, 'text/html')) {\n        const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;\n        return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));\n      } else {\n        return false;\n      }\n    };\n    const setupSummaryDeleteByDragFix = editor => {\n      editor.on('input', e => {\n        const hasNoSummary = el => isNull(el.querySelector('summary'));\n        if (e.inputType === 'deleteByDrag') {\n          const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);\n          each$e(brokenDetailElements, details => {\n            if (isBr$6(details.firstChild)) {\n              details.firstChild.remove();\n            }\n            const summary = editor.dom.create('summary');\n            summary.appendChild(createPaddingBr().dom);\n            details.prepend(summary);\n          });\n        }\n      });\n    };\n    const setup$a = (editor, draggingInternallyState) => {\n      if (shouldPasteBlockDrop(editor)) {\n        editor.on('dragend dragover draggesture dragdrop drop drag', e => {\n          e.preventDefault();\n          e.stopPropagation();\n        });\n      }\n      if (!shouldPasteDataImages(editor)) {\n        editor.on('drop', e => {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && hasImage(dataTransfer)) {\n            e.preventDefault();\n          }\n        });\n      }\n      editor.on('drop', e => {\n        if (e.isDefaultPrevented()) {\n          return;\n        }\n        const rng = getCaretRangeFromEvent(editor, e);\n        if (isNullable(rng)) {\n          return;\n        }\n        const dropContent = getDataTransferItems(e.dataTransfer);\n        const internal = hasContentType(dropContent, internalHtmlMime());\n        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\n          return;\n        }\n        const internalContent = dropContent[internalHtmlMime()];\n        const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\n        const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);\n        const isInternalDrop = draggingInternallyState.get();\n        if (isInternalDrop && !needsInternalDrop) {\n          return;\n        }\n        if (content) {\n          e.preventDefault();\n          Delay.setEditorTimeout(editor, () => {\n            editor.undoManager.transact(() => {\n              if (internalContent || isInternalDrop && needsInternalDrop) {\n                editor.execCommand('Delete');\n              }\n              setFocusedRange(editor, rng);\n              const trimmedContent = trimHtml(content);\n              if (dropContent['text/html']) {\n                pasteHtml(editor, trimmedContent, internal, true);\n              } else {\n                pasteText(editor, trimmedContent, true);\n              }\n            });\n          });\n        }\n      });\n      editor.on('dragstart', _e => {\n        draggingInternallyState.set(true);\n      });\n      editor.on('dragover dragend', e => {\n        if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {\n          e.preventDefault();\n          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\n        }\n        if (e.type === 'dragend') {\n          draggingInternallyState.set(false);\n        }\n      });\n      setupSummaryDeleteByDragFix(editor);\n    };\n\n    const setup$9 = editor => {\n      const processEvent = f => e => {\n        f(editor, e);\n      };\n      const preProcess = getPastePreProcess(editor);\n      if (isFunction(preProcess)) {\n        editor.on('PastePreProcess', processEvent(preProcess));\n      }\n      const postProcess = getPastePostProcess(editor);\n      if (isFunction(postProcess)) {\n        editor.on('PastePostProcess', processEvent(postProcess));\n      }\n    };\n\n    const addPreProcessFilter = (editor, filterFunc) => {\n      editor.on('PastePreProcess', e => {\n        e.content = filterFunc(editor, e.content, e.internal);\n      });\n    };\n    const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\n    const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\n    const removeWebKitStyles = (editor, content, internal) => {\n      const webKitStylesOption = getPasteWebkitStyles(editor);\n      if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\n        return content;\n      }\n      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\n      if (webKitStyles && webKitStylesOption !== 'none') {\n        const dom = editor.dom, node = editor.selection.getNode();\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\n          const inputStyles = dom.parseStyle(dom.decode(value));\n          const outputStyles = {};\n          for (let i = 0; i < webKitStyles.length; i++) {\n            const inputValue = inputStyles[webKitStyles[i]];\n            let compareInput = inputValue;\n            let currentValue = dom.getStyle(node, webKitStyles[i], true);\n            if (/color/.test(webKitStyles[i])) {\n              compareInput = rgbToHex(compareInput);\n              currentValue = rgbToHex(currentValue);\n            }\n            if (currentValue !== compareInput) {\n              outputStyles[webKitStyles[i]] = inputValue;\n            }\n          }\n          const outputStyle = dom.serializeStyle(outputStyles, 'span');\n          if (outputStyle) {\n            return before + ' style=\"' + outputStyle + '\"' + after;\n          }\n          return before + after;\n        });\n      } else {\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\n      }\n      content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\n        return before + ' style=\"' + value + '\"' + after;\n      });\n      return content;\n    };\n    const setup$8 = editor => {\n      if (Env.browser.isChromium() || Env.browser.isSafari()) {\n        addPreProcessFilter(editor, removeWebKitStyles);\n      }\n    };\n\n    const setup$7 = editor => {\n      const draggingInternallyState = Cell(false);\n      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\n      const pasteBin = PasteBin(editor);\n      setup$8(editor);\n      register$1(editor, pasteFormat);\n      setup$9(editor);\n      editor.on('PreInit', () => {\n        register(editor);\n        setup$a(editor, draggingInternallyState);\n        registerEventsAndFilters(editor, pasteBin, pasteFormat);\n      });\n    };\n\n    const preventSummaryToggle = editor => {\n      editor.on('click', e => {\n        if (editor.dom.getParent(e.target, 'details')) {\n          e.preventDefault();\n        }\n      });\n    };\n    const filterDetails = editor => {\n      editor.parser.addNodeFilter('details', elms => {\n        const initialStateOption = getDetailsInitialState(editor);\n        each$e(elms, details => {\n          if (initialStateOption === 'expanded') {\n            details.attr('open', 'open');\n          } else if (initialStateOption === 'collapsed') {\n            details.attr('open', null);\n          }\n        });\n      });\n      editor.serializer.addNodeFilter('details', elms => {\n        const serializedStateOption = getDetailsSerializedState(editor);\n        each$e(elms, details => {\n          if (serializedStateOption === 'expanded') {\n            details.attr('open', 'open');\n          } else if (serializedStateOption === 'collapsed') {\n            details.attr('open', null);\n          }\n        });\n      });\n    };\n    const setup$6 = editor => {\n      preventSummaryToggle(editor);\n      filterDetails(editor);\n    };\n\n    const isBr = isBr$6;\n    const isText = isText$a;\n    const isContentEditableFalse$2 = elm => isContentEditableFalse$b(elm.dom);\n    const isContentEditableTrue = elm => isContentEditableTrue$3(elm.dom);\n    const isRoot = rootNode => elm => eq(SugarElement.fromDom(rootNode), elm);\n    const getClosestScope = (node, rootNode, schema) => closest$4(SugarElement.fromDom(node), elm => isContentEditableTrue(elm) || schema.isBlock(name(elm)), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;\n    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));\n    const findEdgeCaretCandidate = (startNode, scope, forward) => {\n      const walker = new DomTreeWalker(startNode, scope);\n      const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);\n      let result = startNode;\n      for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {\n        if (isCaretCandidate$3(current)) {\n          result = current;\n        }\n      }\n      return result;\n    };\n    const findClosestBlockRange = (startRng, rootNode, schema) => {\n      const startPos = CaretPosition.fromRangeStart(startRng);\n      const clickNode = startPos.getNode();\n      const scope = getClosestScope(clickNode, rootNode, schema);\n      const startNode = findEdgeCaretCandidate(clickNode, scope, false);\n      const endNode = findEdgeCaretCandidate(clickNode, scope, true);\n      const rng = document.createRange();\n      getClosestCef(startNode, scope).fold(() => {\n        if (isText(startNode)) {\n          rng.setStart(startNode, 0);\n        } else {\n          rng.setStartBefore(startNode);\n        }\n      }, cef => rng.setStartBefore(cef.dom));\n      getClosestCef(endNode, scope).fold(() => {\n        if (isText(endNode)) {\n          rng.setEnd(endNode, endNode.data.length);\n        } else {\n          rng.setEndAfter(endNode);\n        }\n      }, cef => rng.setEndAfter(cef.dom));\n      return rng;\n    };\n    const onTripleClickSelect = editor => {\n      const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody(), editor.schema);\n      editor.selection.setRng(normalize(rng));\n    };\n    const setup$5 = editor => {\n      editor.on('mousedown', e => {\n        if (e.detail >= 3) {\n          e.preventDefault();\n          onTripleClickSelect(editor);\n        }\n      });\n    };\n\n    var FakeCaretPosition;\n    (function (FakeCaretPosition) {\n      FakeCaretPosition['Before'] = 'before';\n      FakeCaretPosition['After'] = 'after';\n    }(FakeCaretPosition || (FakeCaretPosition = {})));\n    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\n    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\n    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\n    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\n    const isOverlapping = (r1, r2) => {\n      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\n      return collidesY(r1, r2) && overlap > 0.5;\n    };\n    const splitRectsPerAxis = (rects, y) => {\n      const intersectingRects = filter$5(rects, rect => isInsideY(y, rect));\n      return boundingClientRectFromRects(intersectingRects).fold(() => [\n        [],\n        rects\n      ], boundingRect => {\n        const {\n          pass: horizontal,\n          fail: vertical\n        } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\n        return [\n          horizontal,\n          vertical\n        ];\n      });\n    };\n    const clientInfo = (rect, clientX) => {\n      return {\n        node: rect.node,\n        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\n      };\n    };\n    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\n    const closestChildCaretCandidateNodeRect = (children, clientX, clientY, findCloserTextNode) => {\n      const caretCandidateRect = rect => {\n        if (isCaretCandidate$3(rect.node)) {\n          return Optional.some(rect);\n        } else if (isElement$6(rect.node)) {\n          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY, false);\n        } else {\n          return Optional.none();\n        }\n      };\n      const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {\n        return caretCandidateRect(sndClosest).filter(rect => {\n          const deltaDistance = Math.abs(distance(closest, clientX, clientY) - distance(rect, clientX, clientY));\n          return deltaDistance < 2 && isText$a(rect.node);\n        });\n      };\n      const findClosestCaretCandidateNodeRect = (rects, distance) => {\n        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\n        return findMap(sortedRects, caretCandidateRect).map(closest => {\n          if (findCloserTextNode && !isText$a(closest.node) && sortedRects.length > 1) {\n            return tryFindSecondBestTextNode(closest, sortedRects[1], distance).getOr(closest);\n          } else {\n            return closest;\n          }\n        });\n      };\n      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\n      const {\n        pass: above,\n        fail: below\n      } = partition$2(verticalRects, rect => rect.top < clientY);\n      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\n    };\n    const traverseUp = (rootElm, scope, clientX, clientY) => {\n      const helper = (scope, prevScope) => {\n        const isDragGhostContainer = node => isElement$6(node) && node.classList.contains('mce-drag-container');\n        const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));\n        return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY, true), prevScope => {\n          const uncheckedChildren = filter$5(childNodesWithoutGhost, node => node !== prevScope.dom);\n          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY, true);\n        }).orThunk(() => {\n          const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\n          return parent.bind(newScope => helper(newScope, Optional.some(scope)));\n        });\n      };\n      return helper(scope, Optional.none());\n    };\n    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\n      const rootElm = SugarElement.fromDom(root);\n      const ownerDoc = documentOrOwner(rootElm);\n      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\n      const element = elementAtPoint.getOr(rootElm);\n      return traverseUp(rootElm, element, clientX, clientY);\n    };\n    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\n\n    const getAbsolutePosition = elm => {\n      var _a, _b;\n      const clientRect = elm.getBoundingClientRect();\n      const doc = elm.ownerDocument;\n      const docElem = doc.documentElement;\n      const win = doc.defaultView;\n      return {\n        top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,\n        left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft\n      };\n    };\n    const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\n      left: 0,\n      top: 0\n    };\n    const getScrollPosition = editor => {\n      const body = editor.getBody();\n      return editor.inline ? {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      } : {\n        left: 0,\n        top: 0\n      };\n    };\n    const getBodyScroll = editor => {\n      const body = editor.getBody(), docElm = editor.getDoc().documentElement;\n      const inlineScroll = {\n        left: body.scrollLeft,\n        top: body.scrollTop\n      };\n      const iframeScroll = {\n        left: body.scrollLeft || docElm.scrollLeft,\n        top: body.scrollTop || docElm.scrollTop\n      };\n      return editor.inline ? inlineScroll : iframeScroll;\n    };\n    const getMousePosition = (editor, event) => {\n      if (event.target.ownerDocument !== editor.getDoc()) {\n        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\n        const scrollPosition = getBodyScroll(editor);\n        return {\n          left: event.pageX - iframePosition.left + scrollPosition.left,\n          top: event.pageY - iframePosition.top + scrollPosition.top\n        };\n      }\n      return {\n        left: event.pageX,\n        top: event.pageY\n      };\n    };\n    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\n      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\n      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\n    });\n    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\n\n    const getTargetProps = target => ({\n      target,\n      srcElement: target\n    });\n    const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({\n      ...mouseEvent,\n      dataTransfer,\n      type,\n      ...getTargetProps(target)\n    });\n    const makeDndEvent = (type, target, dataTransfer) => {\n      const fail = die('Function not supported on simulated event.');\n      const event = {\n        bubbles: true,\n        cancelBubble: false,\n        cancelable: true,\n        composed: false,\n        currentTarget: null,\n        defaultPrevented: false,\n        eventPhase: 0,\n        isTrusted: true,\n        returnValue: false,\n        timeStamp: 0,\n        type,\n        composedPath: fail,\n        initEvent: fail,\n        preventDefault: noop,\n        stopImmediatePropagation: noop,\n        stopPropagation: noop,\n        AT_TARGET: window.Event.AT_TARGET,\n        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,\n        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,\n        NONE: window.Event.NONE,\n        altKey: false,\n        button: 0,\n        buttons: 0,\n        clientX: 0,\n        clientY: 0,\n        ctrlKey: false,\n        metaKey: false,\n        movementX: 0,\n        movementY: 0,\n        offsetX: 0,\n        offsetY: 0,\n        pageX: 0,\n        pageY: 0,\n        relatedTarget: null,\n        screenX: 0,\n        screenY: 0,\n        shiftKey: false,\n        x: 0,\n        y: 0,\n        detail: 0,\n        view: null,\n        which: 0,\n        initUIEvent: fail,\n        initMouseEvent: fail,\n        getModifierState: fail,\n        dataTransfer,\n        ...getTargetProps(target)\n      };\n      return event;\n    };\n    const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {\n      const copy = cloneDataTransfer(dataTransfer);\n      if (eventType === 'dragstart') {\n        setDragstartEvent(copy);\n        setReadWriteMode(copy);\n      } else if (eventType === 'drop') {\n        setDropEvent(copy);\n        setReadOnlyMode(copy);\n      } else {\n        setDragendEvent(copy);\n        setProtectedMode(copy);\n      }\n      return copy;\n    };\n    const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {\n      const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);\n      return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);\n    };\n\n    const scrollPixelsPerInterval = 32;\n    const scrollIntervalValue = 100;\n    const mouseRangeToTriggerScrollInsideEditor = 8;\n    const mouseRangeToTriggerScrollOutsideEditor = 16;\n    const isContentEditableFalse$1 = isContentEditableFalse$b;\n    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);\n    const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);\n    const isValidDropTarget = (editor, targetElement, dragElement) => {\n      if (isNullable(targetElement)) {\n        return false;\n      } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\n        return false;\n      } else {\n        return editor.dom.isEditable(targetElement);\n      }\n    };\n    const createGhost = (editor, elm, width, height) => {\n      const dom = editor.dom;\n      const clonedElm = elm.cloneNode(true);\n      dom.setStyles(clonedElm, {\n        width,\n        height\n      });\n      dom.setAttrib(clonedElm, 'data-mce-selected', null);\n      const ghostElm = dom.create('div', {\n        'class': 'mce-drag-container',\n        'data-mce-bogus': 'all',\n        'unselectable': 'on',\n        'contenteditable': 'false'\n      });\n      dom.setStyles(ghostElm, {\n        position: 'absolute',\n        opacity: 0.5,\n        overflow: 'hidden',\n        border: 0,\n        padding: 0,\n        margin: 0,\n        width,\n        height\n      });\n      dom.setStyles(clonedElm, {\n        margin: 0,\n        boxSizing: 'border-box'\n      });\n      ghostElm.appendChild(clonedElm);\n      return ghostElm;\n    };\n    const appendGhostToBody = (ghostElm, bodyElm) => {\n      if (ghostElm.parentNode !== bodyElm) {\n        bodyElm.appendChild(ghostElm);\n      }\n    };\n    const scrollEditor = (direction, amount) => win => () => {\n      const current = direction === 'left' ? win.scrollX : win.scrollY;\n      win.scroll({\n        [direction]: current + amount,\n        behavior: 'smooth'\n      });\n    };\n    const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);\n    const scrollRight = scrollEditor('left', scrollPixelsPerInterval);\n    const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);\n    const scrollDown = scrollEditor('top', scrollPixelsPerInterval);\n    const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {\n      let overflowX = 0, overflowY = 0;\n      ghostElm.style.left = position.pageX + 'px';\n      ghostElm.style.top = position.pageY + 'px';\n      if (position.pageX + width > maxX) {\n        overflowX = position.pageX + width - maxX;\n      }\n      if (position.pageY + height > maxY) {\n        overflowY = position.pageY + height - maxY;\n      }\n      ghostElm.style.width = width - overflowX + 'px';\n      ghostElm.style.height = height - overflowY + 'px';\n      const clientHeight = contentAreaContainer.clientHeight;\n      const clientWidth = contentAreaContainer.clientWidth;\n      const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;\n      const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;\n      state.on(state => {\n        state.intervalId.clear();\n        if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {\n          if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {\n            state.intervalId.set(scrollDown(win));\n          } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {\n            state.intervalId.set(scrollUp(win));\n          } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {\n            state.intervalId.set(scrollRight(win));\n          } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {\n            state.intervalId.set(scrollLeft(win));\n          } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {\n            state.intervalId.set(scrollDown(window));\n          } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n            state.intervalId.set(scrollUp(window));\n          } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {\n            state.intervalId.set(scrollRight(window));\n          } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {\n            state.intervalId.set(scrollLeft(window));\n          }\n        }\n      });\n    };\n    const removeElement = elm => {\n      if (elm && elm.parentNode) {\n        elm.parentNode.removeChild(elm);\n      }\n    };\n    const removeElementWithPadding = (dom, elm) => {\n      const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);\n      removeElement(elm);\n      if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {\n        fillWithPaddingBr(SugarElement.fromDom(parentBlock));\n      }\n    };\n    const isLeftMouseButtonPressed = e => e.button === 0;\n    const applyRelPos = (state, position) => ({\n      pageX: position.pageX - state.relX,\n      pageY: position.pageY + 5\n    });\n    const start = (state, editor) => e => {\n      if (isLeftMouseButtonPressed(e)) {\n        const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);\n        if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {\n          const elmPos = editor.dom.getPos(ceElm);\n          const bodyElm = editor.getBody();\n          const docElm = editor.getDoc().documentElement;\n          state.set({\n            element: ceElm,\n            dataTransfer: createDataTransfer(),\n            dragging: false,\n            screenX: e.screenX,\n            screenY: e.screenY,\n            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\n            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\n            relX: e.pageX - elmPos.x,\n            relY: e.pageY - elmPos.y,\n            width: ceElm.offsetWidth,\n            height: ceElm.offsetHeight,\n            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),\n            intervalId: repeatable(scrollIntervalValue)\n          });\n        }\n      }\n    };\n    const placeCaretAt = (editor, clientX, clientY) => {\n      editor._selectionOverrides.hideFakeCaret();\n      closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), caretInfo => {\n        const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n        if (range) {\n          editor.selection.setRng(range);\n        } else {\n          editor.selection.placeCaretAt(clientX, clientY);\n        }\n      });\n    };\n    const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {\n      if (type === 'dragstart') {\n        setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));\n      }\n      const event = makeDragEvent(type, target, dataTransfer, mouseEvent);\n      const args = editor.dispatch(type, event);\n      return args;\n    };\n    const move = (state, editor) => {\n      const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);\n      editor.on('remove', throttledPlaceCaretAt.cancel);\n      const state_ = state;\n      return e => state.on(state => {\n        const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\n        if (!state.dragging && movement > 10) {\n          const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);\n          if (isNonNullable(args.dataTransfer)) {\n            state.dataTransfer = args.dataTransfer;\n          }\n          if (args.isDefaultPrevented()) {\n            return;\n          }\n          state.dragging = true;\n          editor.focus();\n        }\n        if (state.dragging) {\n          const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;\n          const targetPos = applyRelPos(state, calc(editor, e));\n          appendGhostToBody(state.ghost, editor.getBody());\n          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);\n          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\n        }\n      });\n    };\n    const getRawTarget = selection => {\n      const sel = selection.getSel();\n      if (isNonNullable(sel)) {\n        const rng = sel.getRangeAt(0);\n        const startContainer = rng.startContainer;\n        return isText$a(startContainer) ? startContainer.parentNode : startContainer;\n      } else {\n        return null;\n      }\n    };\n    const drop = (state, editor) => e => {\n      state.on(state => {\n        var _a;\n        state.intervalId.clear();\n        if (state.dragging) {\n          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\n            const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();\n            const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);\n            if (!args.isDefaultPrevented()) {\n              editor.undoManager.transact(() => {\n                removeElementWithPadding(editor.dom, state.element);\n                getHtmlData(state.dataTransfer).each(content => editor.insertContent(content));\n                editor._selectionOverrides.hideFakeCaret();\n              });\n            }\n          }\n          dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);\n        }\n      });\n      removeDragState(state);\n    };\n    const stopDragging = (state, editor, e) => {\n      state.on(state => {\n        state.intervalId.clear();\n        if (state.dragging) {\n          e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), mouseEvent => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));\n        }\n      });\n      removeDragState(state);\n    };\n    const stop = (state, editor) => e => stopDragging(state, editor, Optional.some(e));\n    const removeDragState = state => {\n      state.on(state => {\n        state.intervalId.clear();\n        removeElement(state.ghost);\n      });\n      state.clear();\n    };\n    const bindFakeDragEvents = editor => {\n      const state = value$2();\n      const pageDom = DOMUtils.DOM;\n      const rootDocument = document;\n      const dragStartHandler = start(state, editor);\n      const dragHandler = move(state, editor);\n      const dropHandler = drop(state, editor);\n      const dragEndHandler = stop(state, editor);\n      editor.on('mousedown', dragStartHandler);\n      editor.on('mousemove', dragHandler);\n      editor.on('mouseup', dropHandler);\n      pageDom.bind(rootDocument, 'mousemove', dragHandler);\n      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\n      editor.on('remove', () => {\n        pageDom.unbind(rootDocument, 'mousemove', dragHandler);\n        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\n      });\n      editor.on('keydown', e => {\n        if (e.keyCode === VK.ESC) {\n          stopDragging(state, editor, Optional.none());\n        }\n      });\n    };\n    const blockUnsupportedFileDrop = editor => {\n      const preventFileDrop = e => {\n        if (!e.isDefaultPrevented()) {\n          const dataTransfer = e.dataTransfer;\n          if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\n            e.preventDefault();\n            if (e.type === 'drop') {\n              displayError(editor, 'Dropped file type is not supported');\n            }\n          }\n        }\n      };\n      const preventFileDropIfUIElement = e => {\n        if (isUIElement(editor, e.target)) {\n          preventFileDrop(e);\n        }\n      };\n      const setup = () => {\n        const pageDom = DOMUtils.DOM;\n        const dom = editor.dom;\n        const doc = document;\n        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\n        const eventNames = [\n          'drop',\n          'dragover'\n        ];\n        each$e(eventNames, name => {\n          pageDom.bind(doc, name, preventFileDropIfUIElement);\n          dom.bind(editorRoot, name, preventFileDrop);\n        });\n        editor.on('remove', () => {\n          each$e(eventNames, name => {\n            pageDom.unbind(doc, name, preventFileDropIfUIElement);\n            dom.unbind(editorRoot, name, preventFileDrop);\n          });\n        });\n      };\n      editor.on('init', () => {\n        Delay.setEditorTimeout(editor, setup, 0);\n      });\n    };\n    const init$2 = editor => {\n      bindFakeDragEvents(editor);\n      if (shouldBlockUnsupportedDrop(editor)) {\n        blockUnsupportedFileDrop(editor);\n      }\n    };\n\n    const setup$4 = editor => {\n      const renderFocusCaret = first$1(() => {\n        if (!editor.removed && editor.getBody().contains(document.activeElement)) {\n          const rng = editor.selection.getRng();\n          if (rng.collapsed) {\n            const caretRange = renderRangeCaret(editor, rng, false);\n            editor.selection.setRng(caretRange);\n          }\n        }\n      }, 0);\n      editor.on('focus', () => {\n        renderFocusCaret.throttle();\n      });\n      editor.on('blur', () => {\n        renderFocusCaret.cancel();\n      });\n    };\n\n    const setup$3 = editor => {\n      editor.on('init', () => {\n        editor.on('focusin', e => {\n          const target = e.target;\n          if (isMedia$2(target)) {\n            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\n            const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;\n            if (editor.selection.getNode() !== node) {\n              selectNode(editor, node).each(rng => editor.selection.setRng(rng));\n            }\n          }\n        });\n      });\n    };\n\n    const isContentEditableFalse = isContentEditableFalse$b;\n    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\n    const SelectionOverrides = editor => {\n      const selection = editor.selection, dom = editor.dom;\n      const rootNode = editor.getBody();\n      const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));\n      const realSelectionId = 'sel-' + dom.uniqueId();\n      const elementSelectionAttr = 'data-mce-selected';\n      let selectedElement;\n      const isFakeSelectionElement = node => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');\n      const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);\n      const setRange = range => {\n        if (range) {\n          selection.setRng(range);\n        }\n      };\n      const showCaret = (direction, node, before, scrollIntoView = true) => {\n        const e = editor.dispatch('ShowCaret', {\n          target: node,\n          direction,\n          before\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        if (scrollIntoView) {\n          selection.scrollIntoView(node, direction === -1);\n        }\n        return fakeCaret.show(before, node);\n      };\n      const showBlockCaretContainer = blockCaretContainer => {\n        if (blockCaretContainer.hasAttribute('data-mce-caret')) {\n          showCaretContainerBlock(blockCaretContainer);\n          selection.scrollIntoView(blockCaretContainer);\n        }\n      };\n      const registerEvents = () => {\n        editor.on('click', e => {\n          if (!dom.isEditable(e.target)) {\n            e.preventDefault();\n            editor.focus();\n          }\n        });\n        editor.on('blur NewBlock', removeElementSelection);\n        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\n        editor.on('tap', e => {\n          const targetElm = e.target;\n          const contentEditableRoot = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(contentEditableRoot)) {\n            e.preventDefault();\n            selectNode(editor, contentEditableRoot).each(setElementSelection);\n          } else if (isFakeSelectionTargetElement(targetElm)) {\n            selectNode(editor, targetElm).each(setElementSelection);\n          }\n        }, true);\n        editor.on('mousedown', e => {\n          const targetElm = e.target;\n          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\n            return;\n          }\n          if (!isXYInContentArea(editor, e.clientX, e.clientY)) {\n            return;\n          }\n          removeElementSelection();\n          hideFakeCaret();\n          const closestContentEditable = getContentEditableRoot(editor, targetElm);\n          if (isContentEditableFalse(closestContentEditable)) {\n            e.preventDefault();\n            selectNode(editor, closestContentEditable).each(setElementSelection);\n          } else {\n            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\n              e.preventDefault();\n              const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\n              setRange(range);\n              if (isHTMLElement(closestContentEditable)) {\n                closestContentEditable.focus();\n              } else {\n                editor.getBody().focus();\n              }\n            });\n          }\n        });\n        editor.on('keypress', e => {\n          if (VK.modifierPressed(e)) {\n            return;\n          }\n          if (isContentEditableFalse(selection.getNode())) {\n            e.preventDefault();\n          }\n        });\n        editor.on('GetSelectionRange', e => {\n          let rng = e.range;\n          if (selectedElement) {\n            if (!selectedElement.parentNode) {\n              selectedElement = null;\n              return;\n            }\n            rng = rng.cloneRange();\n            rng.selectNode(selectedElement);\n            e.range = rng;\n          }\n        });\n        editor.on('SetSelectionRange', e => {\n          e.range = normalizeVoidElementSelection(e.range);\n          const rng = setElementSelection(e.range, e.forward);\n          if (rng) {\n            e.range = rng;\n          }\n        });\n        const isPasteBin = node => isElement$6(node) && node.id === 'mcepastebin';\n        editor.on('AfterSetSelectionRange', e => {\n          const rng = e.range;\n          const parent = rng.startContainer.parentElement;\n          if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {\n            hideFakeCaret();\n          }\n          if (!isFakeSelectionElement(parent)) {\n            removeElementSelection();\n          }\n        });\n        init$2(editor);\n        setup$4(editor);\n        setup$3(editor);\n      };\n      const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\n      const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\n      const normalizeVoidElementSelection = rng => {\n        const voidElements = editor.schema.getVoidElements();\n        const newRng = dom.createRng();\n        const startContainer = rng.startContainer;\n        const startOffset = rng.startOffset;\n        const endContainer = rng.endContainer;\n        const endOffset = rng.endOffset;\n        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\n          if (startOffset === 0) {\n            newRng.setStartBefore(startContainer);\n          } else {\n            newRng.setStartAfter(startContainer);\n          }\n        } else {\n          newRng.setStart(startContainer, startOffset);\n        }\n        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\n          if (endOffset === 0) {\n            newRng.setEndBefore(endContainer);\n          } else {\n            newRng.setEndAfter(endContainer);\n          }\n        } else {\n          newRng.setEnd(endContainer, endOffset);\n        }\n        return newRng;\n      };\n      const setupOffscreenSelection = (node, targetClone) => {\n        const body = SugarElement.fromDom(editor.getBody());\n        const doc = editor.getDoc();\n        const realSelectionContainer = descendant$1(body, '#' + realSelectionId).getOrThunk(() => {\n          const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\n          set$3(newContainer, 'id', realSelectionId);\n          append$1(body, newContainer);\n          return newContainer;\n        });\n        const newRange = dom.createRng();\n        empty(realSelectionContainer);\n        append(realSelectionContainer, [\n          SugarElement.fromText(nbsp, doc),\n          SugarElement.fromDom(targetClone),\n          SugarElement.fromText(nbsp, doc)\n        ]);\n        newRange.setStart(realSelectionContainer.dom.firstChild, 1);\n        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\n        setAll(realSelectionContainer, { top: dom.getPos(node, editor.getBody()).y + 'px' });\n        focus$1(realSelectionContainer);\n        const sel = selection.getSel();\n        if (sel) {\n          sel.removeAllRanges();\n          sel.addRange(newRange);\n        }\n        return newRange;\n      };\n      const selectElement = elm => {\n        const targetClone = elm.cloneNode(true);\n        const e = editor.dispatch('ObjectSelected', {\n          target: elm,\n          targetClone\n        });\n        if (e.isDefaultPrevented()) {\n          return null;\n        }\n        const range = setupOffscreenSelection(elm, e.targetClone);\n        const nodeElm = SugarElement.fromDom(elm);\n        each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${ elementSelectionAttr }]`), elm => {\n          if (!eq(nodeElm, elm)) {\n            remove$a(elm, elementSelectionAttr);\n          }\n        });\n        if (!dom.getAttrib(elm, elementSelectionAttr)) {\n          elm.setAttribute(elementSelectionAttr, '1');\n        }\n        selectedElement = elm;\n        hideFakeCaret();\n        return range;\n      };\n      const setElementSelection = (range, forward) => {\n        if (!range) {\n          return null;\n        }\n        if (range.collapsed) {\n          if (!isRangeInCaretContainer(range)) {\n            const dir = forward ? 1 : -1;\n            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\n            const beforeNode = caretPosition.getNode(!forward);\n            if (isNonNullable(beforeNode)) {\n              if (isFakeCaretTarget(beforeNode)) {\n                return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\n              }\n              if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {\n                const rng = dom.createRng();\n                rng.setStart(beforeNode, 0);\n                rng.setEnd(beforeNode, 0);\n                return rng;\n              }\n            }\n            const afterNode = caretPosition.getNode(forward);\n            if (isNonNullable(afterNode)) {\n              if (isFakeCaretTarget(afterNode)) {\n                return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\n              }\n              if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {\n                const rng = dom.createRng();\n                rng.setStart(afterNode, 1);\n                rng.setEnd(afterNode, 1);\n                return rng;\n              }\n            }\n          }\n          return null;\n        }\n        let startContainer = range.startContainer;\n        let startOffset = range.startOffset;\n        const endOffset = range.endOffset;\n        if (isText$a(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\n          startContainer = startContainer.parentNode;\n          startOffset = dom.nodeIndex(startContainer);\n          startContainer = startContainer.parentNode;\n        }\n        if (!isElement$6(startContainer)) {\n          return null;\n        }\n        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\n          const node = startContainer.childNodes[startOffset];\n          if (isFakeSelectionTargetElement(node)) {\n            return selectElement(node);\n          }\n        }\n        return null;\n      };\n      const removeElementSelection = () => {\n        if (selectedElement) {\n          selectedElement.removeAttribute(elementSelectionAttr);\n        }\n        descendant$1(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$5);\n        selectedElement = null;\n      };\n      const destroy = () => {\n        fakeCaret.destroy();\n        selectedElement = null;\n      };\n      const hideFakeCaret = () => {\n        fakeCaret.hide();\n      };\n      if (!isRtc(editor)) {\n        registerEvents();\n      }\n      return {\n        showCaret,\n        showBlockCaretContainer,\n        hideFakeCaret,\n        destroy\n      };\n    };\n\n    const getNormalizedTextOffset = (container, offset) => {\n      let normalizedOffset = offset;\n      for (let node = container.previousSibling; isText$a(node); node = node.previousSibling) {\n        normalizedOffset += node.data.length;\n      }\n      return normalizedOffset;\n    };\n    const generatePath = (dom, root, node, offset, normalized) => {\n      if (isText$a(node) && (offset < 0 || offset > node.data.length)) {\n        return [];\n      }\n      const p = normalized && isText$a(node) ? [getNormalizedTextOffset(node, offset)] : [offset];\n      let current = node;\n      while (current !== root && current.parentNode) {\n        p.push(dom.nodeIndex(current, normalized));\n        current = current.parentNode;\n      }\n      return current === root ? p.reverse() : [];\n    };\n    const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {\n      const start = generatePath(dom, root, startNode, startOffset, normalized);\n      const end = generatePath(dom, root, endNode, endOffset, normalized);\n      return {\n        start,\n        end\n      };\n    };\n    const resolvePath = (root, path) => {\n      const nodePath = path.slice();\n      const offset = nodePath.pop();\n      if (!isNumber(offset)) {\n        return Optional.none();\n      } else {\n        const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\n        return resolvedNode.bind(node => {\n          if (isText$a(node) && (offset < 0 || offset > node.data.length)) {\n            return Optional.none();\n          } else {\n            return Optional.some({\n              node,\n              offset\n            });\n          }\n        });\n      }\n    };\n    const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({\n      node: startNode,\n      offset: startOffset\n    }) => resolvePath(root, range.end).map(({\n      node: endNode,\n      offset: endOffset\n    }) => {\n      const rng = document.createRange();\n      rng.setStart(startNode, startOffset);\n      rng.setEnd(endNode, endOffset);\n      return rng;\n    }));\n    const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);\n\n    const cleanEmptyNodes = (dom, node, isRoot) => {\n      if (node && dom.isEmpty(node) && !isRoot(node)) {\n        const parent = node.parentNode;\n        dom.remove(node, isText$a(node.firstChild) && isWhitespaceText(node.firstChild.data));\n        cleanEmptyNodes(dom, parent, isRoot);\n      }\n    };\n    const deleteRng = (dom, rng, isRoot, clean = true) => {\n      const startParent = rng.startContainer.parentNode;\n      const endParent = rng.endContainer.parentNode;\n      rng.deleteContents();\n      if (clean && !isRoot(rng.startContainer)) {\n        if (isText$a(rng.startContainer) && rng.startContainer.data.length === 0) {\n          dom.remove(rng.startContainer);\n        }\n        if (isText$a(rng.endContainer) && rng.endContainer.data.length === 0) {\n          dom.remove(rng.endContainer);\n        }\n        cleanEmptyNodes(dom, startParent, isRoot);\n        if (startParent !== endParent) {\n          cleanEmptyNodes(dom, endParent, isRoot);\n        }\n      }\n    };\n    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\n    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {\n      const dynamicPatterns = patternSet.dynamicPatternsLookup({\n        text: beforeText,\n        block\n      });\n      return {\n        ...patternSet,\n        blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),\n        inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)\n      };\n    };\n    const getBeforeText = (dom, block, node, offset) => {\n      const rng = dom.createRng();\n      rng.setStart(block, 0);\n      rng.setEnd(node, offset);\n      return rng.toString();\n    };\n\n    const startsWithSingleSpace = s => /^\\s[^\\s]/.test(s);\n    const stripPattern = (dom, block, pattern) => {\n      const firstTextNode = textAfter(block, 0, block);\n      firstTextNode.each(spot => {\n        const node = spot.container;\n        scanRight(node, pattern.start.length, block).each(end => {\n          const rng = dom.createRng();\n          rng.setStart(node, 0);\n          rng.setEnd(end.container, end.offset);\n          deleteRng(dom, rng, e => e === block);\n        });\n        const text = SugarElement.fromDom(node);\n        const textContent = get$3(text);\n        if (startsWithSingleSpace(textContent)) {\n          set(text, textContent.slice(1));\n        }\n      });\n    };\n    const applyPattern$1 = (editor, match) => {\n      const dom = editor.dom;\n      const pattern = match.pattern;\n      const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\n      const isBlockFormatName = (name, formatter) => {\n        const formatSet = formatter.get(name);\n        return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\n      };\n      getParentBlock(editor, rng).each(block => {\n        if (pattern.type === 'block-format') {\n          if (isBlockFormatName(pattern.format, editor.formatter)) {\n            editor.undoManager.transact(() => {\n              stripPattern(editor.dom, block, pattern);\n              editor.formatter.apply(pattern.format);\n            });\n          }\n        } else if (pattern.type === 'block-command') {\n          editor.undoManager.transact(() => {\n            stripPattern(editor.dom, block, pattern);\n            editor.execCommand(pattern.cmd, false, pattern.value);\n          });\n        }\n      });\n      return true;\n    };\n    const sortPatterns$1 = patterns => sort(patterns, (a, b) => b.start.length - a.start.length);\n    const findPattern$1 = (patterns, text) => {\n      const sortedPatterns = sortPatterns$1(patterns);\n      const nuText = text.replace(nbsp, ' ');\n      return find$2(sortedPatterns, pattern => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\n    };\n    const findPatterns$1 = (editor, block, patternSet, normalizedMatches) => {\n      var _a;\n      const dom = editor.dom;\n      const forcedRootBlock = getForcedRootBlock(editor);\n      if (!dom.is(block, forcedRootBlock)) {\n        return [];\n      }\n      const blockText = (_a = block.textContent) !== null && _a !== void 0 ? _a : '';\n      return findPattern$1(patternSet.blockPatterns, blockText).map(pattern => {\n        if (Tools.trim(blockText).length === pattern.start.length) {\n          return [];\n        }\n        return [{\n            pattern,\n            range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)\n          }];\n      }).getOr([]);\n    };\n    const applyMatches$1 = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const bookmark = editor.selection.getBookmark();\n      each$e(matches, match => applyPattern$1(editor, match));\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const newMarker = (dom, id) => dom.create('span', {\n      'data-mce-type': 'bookmark',\n      id\n    });\n    const rangeFromMarker = (dom, marker) => {\n      const rng = dom.createRng();\n      rng.setStartAfter(marker.start);\n      rng.setEndBefore(marker.end);\n      return rng;\n    };\n    const createMarker = (dom, markerPrefix, pathRange) => {\n      const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\n      const startNode = rng.startContainer;\n      const endNode = rng.endContainer;\n      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\n      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\n      const startParentNode = textStart.parentNode;\n      const endParentNode = textEnd.parentNode;\n      return {\n        prefix: markerPrefix,\n        end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\n        start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\n      };\n    };\n    const removeMarker = (dom, marker, isRoot) => {\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\n    };\n\n    const isReplacementPattern = pattern => pattern.start.length === 0;\n    const matchesPattern = patternContent => (element, offset) => {\n      const text = element.data;\n      const searchText = text.substring(0, offset);\n      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\n      const startIndex = searchText.lastIndexOf(patternContent);\n      if (startIndex !== -1) {\n        return startIndex + patternContent.length;\n      } else if (startEndIndex !== -1) {\n        return startEndIndex + 1;\n      } else {\n        return -1;\n      }\n    };\n    const findPatternStartFromSpot = (dom, pattern, block, spot) => {\n      const startPattern = pattern.start;\n      const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\n      return startSpot.bind(spot => {\n        var _a, _b;\n        const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;\n        const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;\n        if (isCompleteMatch) {\n          const rng = dom.createRng();\n          rng.setStart(spot.container, spot.offset - startPattern.length);\n          rng.setEnd(spot.container, spot.offset);\n          return Optional.some(rng);\n        } else {\n          const offset = spot.offset - startPattern.length;\n          return scanLeft(spot.container, offset, block).map(nextSpot => {\n            const rng = dom.createRng();\n            rng.setStart(nextSpot.container, nextSpot.offset);\n            rng.setEnd(spot.container, spot.offset);\n            return rng;\n          }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\n        }\n      });\n    };\n    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {\n      if (pattern.start.length === 0 && !requireGap) {\n        const rng = dom.createRng();\n        rng.setStart(node, offset);\n        rng.setEnd(node, offset);\n        return Optional.some(rng);\n      }\n      return textBefore(node, offset, block).bind(spot => {\n        const start = findPatternStartFromSpot(dom, pattern, block, spot);\n        return start.bind(startRange => {\n          var _a;\n          if (requireGap) {\n            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\n              return Optional.none();\n            } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {\n              return Optional.none();\n            }\n          }\n          return Optional.some(startRange);\n        });\n      });\n    };\n    const findPattern = (editor, block, details, normalizedMatches) => {\n      const dom = editor.dom;\n      const root = dom.getRoot();\n      const pattern = details.pattern;\n      const endNode = details.position.container;\n      const endOffset = details.position.offset;\n      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\n        const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);\n        if (isReplacementPattern(pattern)) {\n          return Optional.some({\n            matches: [{\n                pattern,\n                startRng: endPathRng,\n                endRng: endPathRng\n              }],\n            position: spot\n          });\n        } else {\n          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);\n          const results = resultsOpt.getOr({\n            matches: [],\n            position: spot\n          });\n          const pos = results.position;\n          const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\n          return start.map(startRng => {\n            const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);\n            return {\n              matches: results.matches.concat([{\n                  pattern,\n                  startRng: startPathRng,\n                  endRng: endPathRng\n                }]),\n              position: point(startRng.startContainer, startRng.startOffset)\n            };\n          });\n        }\n      });\n    };\n    const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {\n      const dom = editor.dom;\n      return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\n        const text = getBeforeText(dom, block, node, offset);\n        for (let i = 0; i < patterns.length; i++) {\n          const pattern = patterns[i];\n          if (!endsWith(text, pattern.end)) {\n            continue;\n          }\n          const patternsWithoutCurrent = patterns.slice();\n          patternsWithoutCurrent.splice(i, 1);\n          const result = findPattern(editor, block, {\n            pattern,\n            remainingPatterns: patternsWithoutCurrent,\n            position: endSpot\n          }, normalizedMatches);\n          if (result.isNone() && offset > 0) {\n            return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);\n          }\n          if (result.isSome()) {\n            return result;\n          }\n        }\n        return Optional.none();\n      });\n    };\n    const applyPattern = (editor, pattern, patternRange) => {\n      editor.selection.setRng(patternRange);\n      if (pattern.type === 'inline-format') {\n        each$e(pattern.format, format => {\n          editor.formatter.apply(format);\n        });\n      } else {\n        editor.execCommand(pattern.cmd, false, pattern.value);\n      }\n    };\n    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\n      const markerRange = rangeFromMarker(editor.dom, marker);\n      deleteRng(editor.dom, markerRange, isRoot);\n      applyPattern(editor, pattern, markerRange);\n    };\n    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\n      const dom = editor.dom;\n      const markerEndRange = rangeFromMarker(dom, endMarker);\n      const markerStartRange = rangeFromMarker(dom, startMarker);\n      deleteRng(dom, markerStartRange, isRoot);\n      deleteRng(dom, markerEndRange, isRoot);\n      const patternMarker = {\n        prefix: startMarker.prefix,\n        start: startMarker.end,\n        end: endMarker.start\n      };\n      const patternRange = rangeFromMarker(dom, patternMarker);\n      applyPattern(editor, pattern, patternRange);\n    };\n    const addMarkers = (dom, matches) => {\n      const markerPrefix = generate$1('mce_textpattern');\n      const matchesWithEnds = foldr(matches, (acc, match) => {\n        const endMarker = createMarker(dom, markerPrefix + `_end${ acc.length }`, match.endRng);\n        return acc.concat([{\n            ...match,\n            endMarker\n          }]);\n      }, []);\n      return foldr(matchesWithEnds, (acc, match) => {\n        const idx = matchesWithEnds.length - acc.length - 1;\n        const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${ idx }`, match.startRng);\n        return acc.concat([{\n            ...match,\n            startMarker\n          }]);\n      }, []);\n    };\n    const sortPatterns = patterns => sort(patterns, (a, b) => b.end.length - a.end.length);\n    const getBestMatches = (matches, matchesWithSortedPatterns) => {\n      const hasSameMatches = forall(matches, match => exists(matchesWithSortedPatterns, sortedMatch => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));\n      if (matches.length === matchesWithSortedPatterns.length) {\n        if (hasSameMatches) {\n          return matches;\n        } else {\n          return matchesWithSortedPatterns;\n        }\n      }\n      return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;\n    };\n    const findPatterns = (editor, block, node, offset, patternSet, normalizedMatches) => {\n      const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n      const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\n      return getBestMatches(matches, matchesWithSortedPatterns);\n    };\n    const applyMatches = (editor, matches) => {\n      if (matches.length === 0) {\n        return;\n      }\n      const dom = editor.dom;\n      const bookmark = editor.selection.getBookmark();\n      const matchesWithMarkers = addMarkers(dom, matches);\n      each$e(matchesWithMarkers, match => {\n        const block = dom.getParent(match.startMarker.start, dom.isBlock);\n        const isRoot = node => node === block;\n        if (isReplacementPattern(match.pattern)) {\n          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\n        } else {\n          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\n        }\n        removeMarker(dom, match.endMarker, isRoot);\n        removeMarker(dom, match.startMarker, isRoot);\n      });\n      editor.selection.moveToBookmark(bookmark);\n    };\n\n    const handleEnter = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      return getParentBlock(editor, rng).map(block => {\n        var _a;\n        const offset = Math.max(0, rng.startOffset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');\n        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, true);\n        const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);\n        if (blockMatches.length > 0 || inlineMatches.length > 0) {\n          editor.undoManager.add();\n          editor.undoManager.extra(() => {\n            editor.execCommand('mceInsertNewLine');\n          }, () => {\n            insert$5(editor);\n            applyMatches(editor, inlineMatches);\n            applyMatches$1(editor, blockMatches);\n            const range = editor.selection.getRng();\n            const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\n            editor.execCommand('mceInsertNewLine');\n            spot.each(s => {\n              const node = s.container;\n              if (node.data.charAt(s.offset - 1) === zeroWidth) {\n                node.deleteData(s.offset - 1, 1);\n                cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\n              }\n            });\n          });\n          return true;\n        }\n        return false;\n      }).getOr(false);\n    };\n    const handleInlineKey = (editor, patternSet) => {\n      const rng = editor.selection.getRng();\n      getParentBlock(editor, rng).map(block => {\n        const offset = Math.max(0, rng.startOffset - 1);\n        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\n        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, false);\n        if (inlineMatches.length > 0) {\n          editor.undoManager.transact(() => {\n            applyMatches(editor, inlineMatches);\n          });\n        }\n      });\n    };\n    const checkKeyEvent = (codes, event, predicate) => {\n      for (let i = 0; i < codes.length; i++) {\n        if (predicate(codes[i], event)) {\n          return true;\n        }\n      }\n      return false;\n    };\n    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\n      return code === event.keyCode && !VK.modifierPressed(event);\n    });\n    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\n      return chr.charCodeAt(0) === event.charCode;\n    });\n\n    const setup$2 = editor => {\n      const charCodes = [\n        ',',\n        '.',\n        ';',\n        ':',\n        '!',\n        '?'\n      ];\n      const keyCodes = [32];\n      const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));\n      const hasDynamicPatterns = () => hasTextPatternsLookup(editor);\n      editor.on('keydown', e => {\n        if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed()) {\n          const patternSet = getPatternSet();\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns && handleEnter(editor, patternSet)) {\n            e.preventDefault();\n          }\n        }\n      }, true);\n      const handleInlineTrigger = () => {\n        if (editor.selection.isCollapsed()) {\n          const patternSet = getPatternSet();\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();\n          if (hasPatterns) {\n            handleInlineKey(editor, patternSet);\n          }\n        }\n      };\n      editor.on('keyup', e => {\n        if (checkKeyCode(keyCodes, e)) {\n          handleInlineTrigger();\n        }\n      });\n      editor.on('keypress', e => {\n        if (checkCharCode(charCodes, e)) {\n          Delay.setEditorTimeout(editor, handleInlineTrigger);\n        }\n      });\n    };\n\n    const setup$1 = editor => {\n      setup$2(editor);\n    };\n\n    const Quirks = editor => {\n      const each = Tools.each;\n      const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;\n      const browser = Env.browser;\n      const isGecko = browser.isFirefox();\n      const isWebKit = browser.isChromium() || browser.isSafari();\n      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      const setEditorCommandState = (cmd, state) => {\n        try {\n          editor.getDoc().execCommand(cmd, false, String(state));\n        } catch (ex) {\n        }\n      };\n      const isDefaultPrevented = e => {\n        return e.isDefaultPrevented();\n      };\n      const emptyEditorWhenDeleting = () => {\n        const serializeRng = rng => {\n          const body = dom.create('body');\n          const contents = rng.cloneContents();\n          body.appendChild(contents);\n          return selection.serializer.serialize(body, { format: 'html' });\n        };\n        const allContentsSelected = rng => {\n          const selection = serializeRng(rng);\n          const allRng = dom.createRng();\n          allRng.selectNode(editor.getBody());\n          const allSelection = serializeRng(allRng);\n          return selection === allSelection;\n        };\n        editor.on('keydown', e => {\n          const keyCode = e.keyCode;\n          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {\n            const isCollapsed = editor.selection.isCollapsed();\n            const body = editor.getBody();\n            if (isCollapsed && !isEmpty$2(SugarElement.fromDom(body))) {\n              return;\n            }\n            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\n              return;\n            }\n            e.preventDefault();\n            editor.setContent('');\n            if (body.firstChild && dom.isBlock(body.firstChild)) {\n              editor.selection.setCursorLocation(body.firstChild, 0);\n            } else {\n              editor.selection.setCursorLocation(body, 0);\n            }\n            editor.nodeChanged();\n          }\n        });\n      };\n      const selectAll = () => {\n        editor.shortcuts.add('meta+a', null, 'SelectAll');\n      };\n      const documentElementEditingFocus = () => {\n        if (!editor.inline) {\n          dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\n            let rng;\n            if (e.target === editor.getDoc().documentElement) {\n              rng = selection.getRng();\n              editor.getBody().focus();\n              if (e.type === 'mousedown') {\n                if (isCaretContainer$2(rng.startContainer)) {\n                  return;\n                }\n                selection.placeCaretAt(e.clientX, e.clientY);\n              } else {\n                selection.setRng(rng);\n              }\n            }\n          });\n        }\n      };\n      const removeHrOnBackspace = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (!editor.getBody().getElementsByTagName('hr').length) {\n              return;\n            }\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const node = selection.getNode();\n              const previousSibling = node.previousSibling;\n              if (node.nodeName === 'HR') {\n                dom.remove(node);\n                e.preventDefault();\n                return;\n              }\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\n                dom.remove(previousSibling);\n                e.preventDefault();\n              }\n            }\n          }\n        });\n      };\n      const focusBody = () => {\n        if (!Range.prototype.getClientRects) {\n          editor.on('mousedown', e => {\n            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\n              const body = editor.getBody();\n              body.blur();\n              Delay.setEditorTimeout(editor, () => {\n                body.focus();\n              });\n            }\n          });\n        }\n      };\n      const selectControlElements = () => {\n        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\n        editor.on('click', e => {\n          const target = e.target;\n          if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {\n            e.preventDefault();\n            editor.selection.select(target);\n            editor.nodeChanged();\n          }\n          if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {\n            e.preventDefault();\n            selection.select(target);\n          }\n        });\n      };\n      const removeStylesWhenDeletingAcrossBlockElements = () => {\n        const getAttributeApplyFunction = () => {\n          const template = dom.getAttribs(selection.getStart().cloneNode(false));\n          return () => {\n            const target = selection.getStart();\n            if (target !== editor.getBody()) {\n              dom.setAttrib(target, 'style', null);\n              each(template, attr => {\n                target.setAttributeNode(attr.cloneNode(true));\n              });\n            }\n          };\n        };\n        const isSelectionAcrossElements = () => {\n          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\n        };\n        editor.on('keypress', e => {\n          let applyAttributes;\n          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\n            applyAttributes = getAttributeApplyFunction();\n            editor.getDoc().execCommand('delete', false);\n            applyAttributes();\n            e.preventDefault();\n            return false;\n          } else {\n            return true;\n          }\n        });\n        dom.bind(editor.getDoc(), 'cut', e => {\n          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\n            const applyAttributes = getAttributeApplyFunction();\n            Delay.setEditorTimeout(editor, () => {\n              applyAttributes();\n            });\n          }\n        });\n      };\n      const disableBackspaceIntoATable = () => {\n        editor.on('keydown', e => {\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\n              const previousSibling = selection.getNode().previousSibling;\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\n                e.preventDefault();\n                return false;\n              }\n            }\n          }\n          return true;\n        });\n      };\n      const removeBlockQuoteOnBackSpace = () => {\n        editor.on('keydown', e => {\n          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\n            return;\n          }\n          let rng = selection.getRng();\n          const container = rng.startContainer;\n          const offset = rng.startOffset;\n          const root = dom.getRoot();\n          let parent = container;\n          if (!rng.collapsed || offset !== 0) {\n            return;\n          }\n          while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\n            parent = parent.parentNode;\n          }\n          if (parent.nodeName === 'BLOCKQUOTE') {\n            editor.formatter.toggle('blockquote', undefined, parent);\n            rng = dom.createRng();\n            rng.setStart(container, 0);\n            rng.setEnd(container, 0);\n            selection.setRng(rng);\n          }\n        });\n      };\n      const setGeckoEditingOptions = () => {\n        const setOpts = () => {\n          setEditorCommandState('StyleWithCSS', false);\n          setEditorCommandState('enableInlineTableEditing', false);\n          if (!getObjectResizing(editor)) {\n            setEditorCommandState('enableObjectResizing', false);\n          }\n        };\n        if (!isReadOnly$1(editor)) {\n          editor.on('BeforeExecCommand mousedown', setOpts);\n        }\n      };\n      const addBrAfterLastLinks = () => {\n        const fixLinks = () => {\n          each(dom.select('a:not([data-mce-block])'), node => {\n            var _a;\n            let parentNode = node.parentNode;\n            const root = dom.getRoot();\n            if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {\n              while (parentNode && !dom.isBlock(parentNode)) {\n                if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {\n                  return;\n                }\n                parentNode = parentNode.parentNode;\n              }\n              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });\n            }\n          });\n        };\n        editor.on('SetContent ExecCommand', e => {\n          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\n            fixLinks();\n          }\n        });\n      };\n      const setDefaultBlockType = () => {\n        editor.on('init', () => {\n          setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\n        });\n      };\n      const isAllContentSelected = editor => {\n        const body = editor.getBody();\n        const rng = editor.selection.getRng();\n        return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;\n      };\n      const normalizeSelection = () => {\n        editor.on('keyup focusin mouseup', e => {\n          if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {\n            selection.normalize();\n          }\n        }, true);\n      };\n      const showBrokenImageIcon = () => {\n        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\n      };\n      const restoreFocusOnKeyDown = () => {\n        if (!editor.inline) {\n          editor.on('keydown', () => {\n            if (document.activeElement === document.body) {\n              editor.getWin().focus();\n            }\n          });\n        }\n      };\n      const bodyHeight = () => {\n        if (!editor.inline) {\n          editor.contentStyles.push('body {min-height: 150px}');\n          editor.on('click', e => {\n            let rng;\n            if (e.target.nodeName === 'HTML') {\n              rng = editor.selection.getRng();\n              editor.getBody().focus();\n              editor.selection.setRng(rng);\n              editor.selection.normalize();\n              editor.nodeChanged();\n            }\n          });\n        }\n      };\n      const blockCmdArrowNavigation = () => {\n        if (isMac) {\n          editor.on('keydown', e => {\n            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\n              e.preventDefault();\n              const selection = editor.selection.getSel();\n              selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\n            }\n          });\n        }\n      };\n      const tapLinksAndImages = () => {\n        editor.on('click', e => {\n          let elm = e.target;\n          do {\n            if (elm.tagName === 'A') {\n              e.preventDefault();\n              return;\n            }\n          } while (elm = elm.parentNode);\n        });\n        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\n      };\n      const blockFormSubmitInsideEditor = () => {\n        editor.on('init', () => {\n          editor.dom.bind(editor.getBody(), 'submit', e => {\n            e.preventDefault();\n          });\n        });\n      };\n      const removeAppleInterchangeBrs = () => {\n        parser.addNodeFilter('br', nodes => {\n          let i = nodes.length;\n          while (i--) {\n            if (nodes[i].attr('class') === 'Apple-interchange-newline') {\n              nodes[i].remove();\n            }\n          }\n        });\n      };\n      const refreshContentEditable = noop;\n      const isHidden = () => {\n        if (!isGecko || editor.removed) {\n          return false;\n        }\n        const sel = editor.selection.getSel();\n        return !sel || !sel.rangeCount || sel.rangeCount === 0;\n      };\n      const setupRtc = () => {\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          blockFormSubmitInsideEditor();\n          selectAll();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          }\n        }\n        if (isGecko) {\n          focusBody();\n          setGeckoEditingOptions();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n        }\n      };\n      const dropDragEndEvent = () => {\n        editor.on('drop', event => {\n          var _a;\n          const data = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData('text/html');\n          if (isString(data) && /^<img[^>]*>$/.test(data)) {\n            editor.dispatch('dragend', new window.DragEvent('dragend', event));\n          }\n        });\n      };\n      const setup = () => {\n        removeBlockQuoteOnBackSpace();\n        emptyEditorWhenDeleting();\n        if (!Env.windowsPhone) {\n          normalizeSelection();\n        }\n        if (isWebKit) {\n          documentElementEditingFocus();\n          selectControlElements();\n          setDefaultBlockType();\n          blockFormSubmitInsideEditor();\n          disableBackspaceIntoATable();\n          removeAppleInterchangeBrs();\n          if (isiOS) {\n            restoreFocusOnKeyDown();\n            bodyHeight();\n            tapLinksAndImages();\n          } else {\n            selectAll();\n          }\n        }\n        if (isGecko) {\n          removeHrOnBackspace();\n          focusBody();\n          removeStylesWhenDeletingAcrossBlockElements();\n          setGeckoEditingOptions();\n          addBrAfterLastLinks();\n          showBrokenImageIcon();\n          blockCmdArrowNavigation();\n          disableBackspaceIntoATable();\n          dropDragEndEvent();\n        }\n      };\n      if (isRtc(editor)) {\n        setupRtc();\n      } else {\n        setup();\n      }\n      return {\n        refreshContentEditable,\n        isHidden\n      };\n    };\n\n    const DOM$6 = DOMUtils.DOM;\n    const appendStyle = (editor, text) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      const container = getStyleContainer(getRootNode(body));\n      const style = SugarElement.fromTag('style');\n      set$3(style, 'type', 'text/css');\n      append$1(style, SugarElement.fromText(text));\n      append$1(container, style);\n      editor.on('remove', () => {\n        remove$5(style);\n      });\n    };\n    const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\n    const removeUndefined = obj => filter$4(obj, v => isUndefined(v) === false);\n    const mkParserSettings = editor => {\n      const getOption = editor.options.get;\n      const blobCache = editor.editorUpload.blobCache;\n      return removeUndefined({\n        allow_conditional_comments: getOption('allow_conditional_comments'),\n        allow_html_data_urls: getOption('allow_html_data_urls'),\n        allow_svg_data_urls: getOption('allow_svg_data_urls'),\n        allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\n        allow_script_urls: getOption('allow_script_urls'),\n        allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\n        convert_unsafe_embeds: getOption('convert_unsafe_embeds'),\n        convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\n        fix_list_elements: getOption('fix_list_elements'),\n        font_size_legacy_values: getOption('font_size_legacy_values'),\n        forced_root_block: getOption('forced_root_block'),\n        forced_root_block_attrs: getOption('forced_root_block_attrs'),\n        preserve_cdata: getOption('preserve_cdata'),\n        inline_styles: getOption('inline_styles'),\n        root_name: getRootName(editor),\n        sandbox_iframes: getOption('sandbox_iframes'),\n        sanitize: getOption('xss_sanitization'),\n        validate: true,\n        blob_cache: blobCache,\n        document: editor.getDoc()\n      });\n    };\n    const mkSchemaSettings = editor => {\n      const getOption = editor.options.get;\n      return removeUndefined({\n        custom_elements: getOption('custom_elements'),\n        extended_valid_elements: getOption('extended_valid_elements'),\n        invalid_elements: getOption('invalid_elements'),\n        invalid_styles: getOption('invalid_styles'),\n        schema: getOption('schema'),\n        valid_children: getOption('valid_children'),\n        valid_classes: getOption('valid_classes'),\n        valid_elements: getOption('valid_elements'),\n        valid_styles: getOption('valid_styles'),\n        verify_html: getOption('verify_html'),\n        padd_empty_block_inline_children: getOption('format_empty_lines')\n      });\n    };\n    const mkSerializerSettings = editor => {\n      const getOption = editor.options.get;\n      return {\n        ...mkParserSettings(editor),\n        ...mkSchemaSettings(editor),\n        ...removeUndefined({\n          remove_trailing_brs: getOption('remove_trailing_brs'),\n          pad_empty_with_br: getOption('pad_empty_with_br'),\n          url_converter: getOption('url_converter'),\n          url_converter_scope: getOption('url_converter_scope'),\n          element_format: getOption('element_format'),\n          entities: getOption('entities'),\n          entity_encoding: getOption('entity_encoding'),\n          indent: getOption('indent'),\n          indent_after: getOption('indent_after'),\n          indent_before: getOption('indent_before')\n        })\n      };\n    };\n    const createParser = editor => {\n      const parser = DomParser(mkParserSettings(editor), editor.schema);\n      parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\n        const dom = editor.dom;\n        const internalName = 'data-mce-' + name;\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          let value = node.attr(name);\n          if (value && !node.attr(internalName)) {\n            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\n              continue;\n            }\n            if (name === 'style') {\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\n              if (!value.length) {\n                value = null;\n              }\n              node.attr(internalName, value);\n              node.attr(name, value);\n            } else if (name === 'tabindex') {\n              node.attr(internalName, value);\n              node.attr(name, null);\n            } else {\n              node.attr(internalName, editor.convertURL(value, name, node.name));\n            }\n          }\n        }\n      });\n      parser.addNodeFilter('script', nodes => {\n        let i = nodes.length;\n        while (i--) {\n          const node = nodes[i];\n          const type = node.attr('type') || 'no/type';\n          if (type.indexOf('mce-') !== 0) {\n            node.attr('type', 'mce-' + type);\n          }\n        }\n      });\n      if (shouldPreserveCData(editor)) {\n        parser.addNodeFilter('#cdata', nodes => {\n          var _a;\n          let i = nodes.length;\n          while (i--) {\n            const node = nodes[i];\n            node.type = 8;\n            node.name = '#comment';\n            node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';\n          }\n        });\n      }\n      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\n        let i = nodes.length;\n        const nonEmptyElements = editor.schema.getNonEmptyElements();\n        while (i--) {\n          const node = nodes[i];\n          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\n            node.append(new AstNode('br', 1));\n          }\n        }\n      });\n      return parser;\n    };\n    const autoFocus = editor => {\n      const autoFocus = getAutoFocus(editor);\n      if (autoFocus) {\n        Delay.setEditorTimeout(editor, () => {\n          let focusEditor;\n          if (autoFocus === true) {\n            focusEditor = editor;\n          } else {\n            focusEditor = editor.editorManager.get(autoFocus);\n          }\n          if (focusEditor && !focusEditor.destroyed) {\n            focusEditor.focus();\n            focusEditor.selection.scrollIntoView();\n          }\n        }, 100);\n      }\n    };\n    const moveSelectionToFirstCaretPosition = editor => {\n      const root = editor.dom.getRoot();\n      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\n        firstPositionIn(root).each(pos => {\n          const node = pos.getNode();\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\n          editor.selection.setRng(caretPos.toRange());\n        });\n      }\n    };\n    const initEditor = editor => {\n      editor.bindPendingEventDelegates();\n      editor.initialized = true;\n      fireInit(editor);\n      editor.focus(true);\n      moveSelectionToFirstCaretPosition(editor);\n      editor.nodeChanged({ initial: true });\n      const initInstanceCallback = getInitInstanceCallback(editor);\n      if (isFunction(initInstanceCallback)) {\n        initInstanceCallback.call(editor, editor);\n      }\n      autoFocus(editor);\n    };\n    const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\n    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\n      const {\n        pass: bundledCss,\n        fail: normalCss\n      } = partition$2(css, name => tinymce.Resource.has(toContentSkinResourceName(name)));\n      const bundledPromises = bundledCss.map(url => {\n        const css = tinymce.Resource.get(toContentSkinResourceName(url));\n        if (isString(css)) {\n          return Promise.resolve(getStyleSheetLoader$1(editor).loadRawCss(url, css));\n        }\n        return Promise.resolve();\n      });\n      const promises = [\n        ...bundledPromises,\n        getStyleSheetLoader$1(editor).loadAll(normalCss)\n      ];\n      if (editor.inline) {\n        return promises;\n      } else {\n        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\n      }\n    };\n    const loadContentCss = editor => {\n      const styleSheetLoader = getStyleSheetLoader$1(editor);\n      const fontCss = getFontCss(editor);\n      const css = editor.contentCSS;\n      const removeCss = () => {\n        styleSheetLoader.unloadAll(css);\n        if (!editor.inline) {\n          editor.ui.styleSheetLoader.unloadAll(fontCss);\n        }\n      };\n      const loaded = () => {\n        if (editor.removed) {\n          removeCss();\n        } else {\n          editor.on('remove', removeCss);\n        }\n      };\n      if (editor.contentStyles.length > 0) {\n        let contentCssText = '';\n        Tools.each(editor.contentStyles, style => {\n          contentCssText += style + '\\r\\n';\n        });\n        editor.dom.addStyle(contentCssText);\n      }\n      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\n      const contentStyle = getContentStyle(editor);\n      if (contentStyle) {\n        appendStyle(editor, contentStyle);\n      }\n      return allStylesheets;\n    };\n    const preInit = editor => {\n      const doc = editor.getDoc(), body = editor.getBody();\n      firePreInit(editor);\n      if (!shouldBrowserSpellcheck(editor)) {\n        doc.body.spellcheck = false;\n        DOM$6.setAttrib(body, 'spellcheck', 'false');\n      }\n      editor.quirks = Quirks(editor);\n      firePostRender(editor);\n      const directionality = getDirectionality(editor);\n      if (directionality !== undefined) {\n        body.dir = directionality;\n      }\n      const protect = getProtect(editor);\n      if (protect) {\n        editor.on('BeforeSetContent', e => {\n          Tools.each(protect, pattern => {\n            e.content = e.content.replace(pattern, str => {\n              return '<!--mce:protected ' + escape(str) + '-->';\n            });\n          });\n        });\n      }\n      editor.on('SetContent', () => {\n        editor.addVisual(editor.getBody());\n      });\n      editor.on('compositionstart compositionend', e => {\n        editor.composing = e.type === 'compositionstart';\n      });\n    };\n    const loadInitialContent = editor => {\n      if (!isRtc(editor)) {\n        editor.load({\n          initial: true,\n          format: 'html'\n        });\n      }\n      editor.startContent = editor.getContent({ format: 'raw' });\n    };\n    const initEditorWithInitialContent = editor => {\n      if (editor.removed !== true) {\n        loadInitialContent(editor);\n        initEditor(editor);\n      }\n    };\n    const startProgress = editor => {\n      let canceled = false;\n      const progressTimeout = setTimeout(() => {\n        if (!canceled) {\n          editor.setProgressState(true);\n        }\n      }, 500);\n      return () => {\n        clearTimeout(progressTimeout);\n        canceled = true;\n        editor.setProgressState(false);\n      };\n    };\n    const contentBodyLoaded = editor => {\n      const targetElm = editor.getElement();\n      let doc = editor.getDoc();\n      if (editor.inline) {\n        DOM$6.addClass(targetElm, 'mce-content-body');\n        editor.contentDocument = doc = document;\n        editor.contentWindow = window;\n        editor.bodyElement = targetElm;\n        editor.contentAreaContainer = targetElm;\n      }\n      const body = editor.getBody();\n      body.disabled = true;\n      editor.readonly = isReadOnly$1(editor);\n      editor._editableRoot = hasEditableRoot$1(editor);\n      if (!editor.readonly && editor.hasEditableRoot()) {\n        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\n          body.style.position = 'relative';\n        }\n        body.contentEditable = 'true';\n      }\n      body.disabled = false;\n      editor.editorUpload = EditorUpload(editor);\n      editor.schema = Schema(mkSchemaSettings(editor));\n      editor.dom = DOMUtils(doc, {\n        keep_values: true,\n        url_converter: editor.convertURL,\n        url_converter_scope: editor,\n        update_styles: true,\n        root_element: editor.inline ? editor.getBody() : null,\n        collect: editor.inline,\n        schema: editor.schema,\n        contentCssCors: shouldUseContentCssCors(editor),\n        referrerPolicy: getReferrerPolicy(editor),\n        onSetAttrib: e => {\n          editor.dispatch('SetAttrib', e);\n        },\n        force_hex_color: shouldForceHexColor(editor)\n      });\n      editor.parser = createParser(editor);\n      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\n      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\n      editor.annotator = Annotator(editor);\n      editor.formatter = Formatter(editor);\n      editor.undoManager = UndoManager(editor);\n      editor._nodeChangeDispatcher = new NodeChange(editor);\n      editor._selectionOverrides = SelectionOverrides(editor);\n      setup$p(editor);\n      setup$6(editor);\n      setup$n(editor);\n      if (!isRtc(editor)) {\n        setup$5(editor);\n        setup$1(editor);\n      }\n      const caret = setup$b(editor);\n      setup$q(editor, caret);\n      setup$o(editor);\n      setup$r(editor);\n      setup$7(editor);\n      const setupRtcThunk = setup$t(editor);\n      preInit(editor);\n      setupRtcThunk.fold(() => {\n        const cancelProgress = startProgress(editor);\n        loadContentCss(editor).then(() => {\n          initEditorWithInitialContent(editor);\n          cancelProgress();\n        });\n      }, setupRtc => {\n        editor.setProgressState(true);\n        loadContentCss(editor).then(() => {\n          setupRtc().then(_rtcMode => {\n            editor.setProgressState(false);\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          }, err => {\n            editor.notificationManager.open({\n              type: 'error',\n              text: String(err)\n            });\n            initEditorWithInitialContent(editor);\n            bindEvents(editor);\n          });\n        });\n      });\n    };\n\n    const filter = always;\n    const bind = (element, event, handler) => bind$2(element, event, filter, handler);\n\n    const DOM$5 = DOMUtils.DOM;\n    const createIframeElement = (id, title, customAttrs, tabindex) => {\n      const iframe = SugarElement.fromTag('iframe');\n      tabindex.each(t => set$3(iframe, 'tabindex', t));\n      setAll$1(iframe, customAttrs);\n      setAll$1(iframe, {\n        id: id + '_ifr',\n        frameBorder: '0',\n        allowTransparency: 'true',\n        title\n      });\n      add$2(iframe, 'tox-edit-area__iframe');\n      return iframe;\n    };\n    const getIframeHtml = editor => {\n      let iframeHTML = getDocType(editor) + '<html><head>';\n      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\n        iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\n      }\n      iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\n      const bodyId = getBodyId(editor);\n      const bodyClass = getBodyClass(editor);\n      const translatedAriaText = editor.translate(getIframeAriaText(editor));\n      if (getContentSecurityPolicy(editor)) {\n        iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\n      }\n      iframeHTML += '</head>' + `<body id=\"${ bodyId }\" class=\"mce-content-body ${ bodyClass }\" data-id=\"${ editor.id }\" aria-label=\"${ translatedAriaText }\">` + '<br>' + '</body></html>';\n      return iframeHTML;\n    };\n    const createIframe = (editor, boxInfo) => {\n      const iframeTitle = editor.translate('Rich Text Area');\n      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\n      const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;\n      ifr.onload = () => {\n        ifr.onload = null;\n        editor.dispatch('load');\n      };\n      editor.contentAreaContainer = boxInfo.iframeContainer;\n      editor.iframeElement = ifr;\n      editor.iframeHTML = getIframeHtml(editor);\n      DOM$5.add(boxInfo.iframeContainer, ifr);\n    };\n    const setupIframeBody = editor => {\n      const iframe = editor.iframeElement;\n      const ready = () => {\n        editor.contentDocument = iframe.contentDocument;\n        contentBodyLoaded(editor);\n      };\n      if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {\n        const doc = editor.getDoc();\n        doc.open();\n        doc.write(editor.iframeHTML);\n        doc.close();\n        ready();\n      } else {\n        const binder = bind(SugarElement.fromDom(iframe), 'load', () => {\n          binder.unbind();\n          ready();\n        });\n        iframe.srcdoc = editor.iframeHTML;\n      }\n    };\n    const init$1 = (editor, boxInfo) => {\n      createIframe(editor, boxInfo);\n      if (boxInfo.editorContainer) {\n        boxInfo.editorContainer.style.display = editor.orgDisplay;\n        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\n      }\n      editor.getElement().style.display = 'none';\n      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\n      editor.getElement().style.visibility = editor.orgVisibility;\n      setupIframeBody(editor);\n    };\n\n    const DOM$4 = DOMUtils.DOM;\n    const initPlugin = (editor, initializedPlugins, plugin) => {\n      const Plugin = PluginManager.get(plugin);\n      const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\n      plugin = Tools.trim(plugin);\n      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\n        if (editor.plugins[plugin]) {\n          return;\n        }\n        try {\n          const pluginInstance = Plugin(editor, pluginUrl) || {};\n          editor.plugins[plugin] = pluginInstance;\n          if (isFunction(pluginInstance.init)) {\n            pluginInstance.init(editor, pluginUrl);\n            initializedPlugins.push(plugin);\n          }\n        } catch (e) {\n          pluginInitError(editor, plugin, e);\n        }\n      }\n    };\n    const trimLegacyPrefix = name => {\n      return name.replace(/^\\-/, '');\n    };\n    const initPlugins = editor => {\n      const initializedPlugins = [];\n      each$e(getPlugins(editor), name => {\n        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\n      });\n    };\n    const initIcons = editor => {\n      const iconPackName = Tools.trim(getIconPackName(editor));\n      const currentIcons = editor.ui.registry.getAll().icons;\n      const loadIcons = {\n        ...IconManager.get('default').icons,\n        ...IconManager.get(iconPackName).icons\n      };\n      each$d(loadIcons, (svgData, icon) => {\n        if (!has$2(currentIcons, icon)) {\n          editor.ui.registry.addIcon(icon, svgData);\n        }\n      });\n    };\n    const initTheme = editor => {\n      const theme = getTheme(editor);\n      if (isString(theme)) {\n        const Theme = ThemeManager.get(theme);\n        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\n        if (isFunction(editor.theme.init)) {\n          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\n        }\n      } else {\n        editor.theme = {};\n      }\n    };\n    const initModel = editor => {\n      const model = getModel(editor);\n      const Model = ModelManager.get(model);\n      editor.model = Model(editor, ModelManager.urls[model]);\n    };\n    const renderFromLoadedTheme = editor => {\n      const render = editor.theme.renderUI;\n      return render ? render() : renderThemeFalse(editor);\n    };\n    const renderFromThemeFunc = editor => {\n      const elm = editor.getElement();\n      const theme = getTheme(editor);\n      const info = theme(editor, elm);\n      if (info.editorContainer.nodeType) {\n        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\n      }\n      if (info.iframeContainer && info.iframeContainer.nodeType) {\n        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\n      }\n      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\n      return info;\n    };\n    const createThemeFalseResult = (element, iframe) => {\n      return {\n        editorContainer: element,\n        iframeContainer: iframe,\n        api: {}\n      };\n    };\n    const renderThemeFalseIframe = targetElement => {\n      const iframeContainer = DOM$4.create('div');\n      DOM$4.insertAfter(iframeContainer, targetElement);\n      return createThemeFalseResult(iframeContainer, iframeContainer);\n    };\n    const renderThemeFalse = editor => {\n      const targetElement = editor.getElement();\n      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\n    };\n    const renderThemeUi = editor => {\n      const elm = editor.getElement();\n      editor.orgDisplay = elm.style.display;\n      if (isString(getTheme(editor))) {\n        return renderFromLoadedTheme(editor);\n      } else if (isFunction(getTheme(editor))) {\n        return renderFromThemeFunc(editor);\n      } else {\n        return renderThemeFalse(editor);\n      }\n    };\n    const augmentEditorUiApi = (editor, api) => {\n      const uiApiFacade = {\n        show: Optional.from(api.show).getOr(noop),\n        hide: Optional.from(api.hide).getOr(noop),\n        isEnabled: Optional.from(api.isEnabled).getOr(always),\n        setEnabled: state => {\n          if (!editor.mode.isReadOnly()) {\n            Optional.from(api.setEnabled).each(f => f(state));\n          }\n        }\n      };\n      editor.ui = {\n        ...editor.ui,\n        ...uiApiFacade\n      };\n    };\n    const init = async editor => {\n      editor.dispatch('ScriptsLoaded');\n      initIcons(editor);\n      initTheme(editor);\n      initModel(editor);\n      initPlugins(editor);\n      const renderInfo = await renderThemeUi(editor);\n      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\n      editor.editorContainer = renderInfo.editorContainer;\n      appendContentCssFromSettings(editor);\n      if (editor.inline) {\n        contentBodyLoaded(editor);\n      } else {\n        init$1(editor, {\n          editorContainer: renderInfo.editorContainer,\n          iframeContainer: renderInfo.iframeContainer\n        });\n      }\n    };\n\n    const DOM$3 = DOMUtils.DOM;\n    const hasSkipLoadPrefix = name => name.charAt(0) === '-';\n    const loadLanguage = (scriptLoader, editor) => {\n      const languageCode = getLanguageCode(editor);\n      const languageUrl = getLanguageUrl(editor);\n      if (!I18n.hasCode(languageCode) && languageCode !== 'en') {\n        const url = isNotEmpty(languageUrl) ? languageUrl : `${ editor.editorManager.baseURL }/langs/${ languageCode }.js`;\n        scriptLoader.add(url).catch(() => {\n          languageLoadError(editor, url, languageCode);\n        });\n      }\n    };\n    const loadTheme = (editor, suffix) => {\n      const theme = getTheme(editor);\n      if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\n        const themeUrl = getThemeUrl(editor);\n        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${ theme }/theme${ suffix }.js`;\n        ThemeManager.load(theme, url).catch(() => {\n          themeLoadError(editor, url, theme);\n        });\n      }\n    };\n    const loadModel = (editor, suffix) => {\n      const model = getModel(editor);\n      if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\n        const modelUrl = getModelUrl(editor);\n        const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${ model }/model${ suffix }.js`;\n        ModelManager.load(model, url).catch(() => {\n          modelLoadError(editor, url, model);\n        });\n      }\n    };\n    const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\n      url,\n      name: Optional.none()\n    }));\n    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\n      url: `${ editor.editorManager.baseURL }/icons/${ name }/icons${ suffix }.js`,\n      name: Optional.some(name)\n    }));\n    const loadIcons = (scriptLoader, editor, suffix) => {\n      const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\n      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\n      each$e(cat([\n        defaultIconsUrl,\n        customIconsUrl\n      ]), urlMeta => {\n        scriptLoader.add(urlMeta.url).catch(() => {\n          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\n        });\n      });\n    };\n    const loadPlugins = (editor, suffix) => {\n      const loadPlugin = (name, url) => {\n        PluginManager.load(name, url).catch(() => {\n          pluginLoadError(editor, url, name);\n        });\n      };\n      each$d(getExternalPlugins$1(editor), (url, name) => {\n        loadPlugin(name, url);\n        editor.options.set('plugins', getPlugins(editor).concat(name));\n      });\n      each$e(getPlugins(editor), plugin => {\n        plugin = Tools.trim(plugin);\n        if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\n          loadPlugin(plugin, `plugins/${ plugin }/plugin${ suffix }.js`);\n        }\n      });\n    };\n    const isThemeLoaded = editor => {\n      const theme = getTheme(editor);\n      return !isString(theme) || isNonNullable(ThemeManager.get(theme));\n    };\n    const isModelLoaded = editor => {\n      const model = getModel(editor);\n      return isNonNullable(ModelManager.get(model));\n    };\n    const loadScripts = (editor, suffix) => {\n      const scriptLoader = ScriptLoader.ScriptLoader;\n      const initEditor = () => {\n        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\n          init(editor);\n        }\n      };\n      loadTheme(editor, suffix);\n      loadModel(editor, suffix);\n      loadLanguage(scriptLoader, editor);\n      loadIcons(scriptLoader, editor, suffix);\n      loadPlugins(editor, suffix);\n      scriptLoader.loadQueue().then(initEditor, initEditor);\n    };\n    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\n      contentCssCors: hasContentCssCors(editor),\n      referrerPolicy: getReferrerPolicy(editor)\n    });\n    const render = editor => {\n      const id = editor.id;\n      I18n.setCode(getLanguageCode(editor));\n      const readyHandler = () => {\n        DOM$3.unbind(window, 'ready', readyHandler);\n        editor.render();\n      };\n      if (!EventUtils.Event.domLoaded) {\n        DOM$3.bind(window, 'ready', readyHandler);\n        return;\n      }\n      if (!editor.getElement()) {\n        return;\n      }\n      const element = SugarElement.fromDom(editor.getElement());\n      const snapshot = clone$4(element);\n      editor.on('remove', () => {\n        eachr(element.dom.attributes, attr => remove$a(element, attr.name));\n        setAll$1(element, snapshot);\n      });\n      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\n      if (!isInline$1(editor)) {\n        editor.orgVisibility = editor.getElement().style.visibility;\n        editor.getElement().style.visibility = 'hidden';\n      } else {\n        editor.inline = true;\n      }\n      const form = editor.getElement().form || DOM$3.getParent(id, 'form');\n      if (form) {\n        editor.formElement = form;\n        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\n          DOM$3.insertAfter(DOM$3.create('input', {\n            type: 'hidden',\n            name: id\n          }), id);\n          editor.hasHiddenInput = true;\n        }\n        editor.formEventDelegate = e => {\n          editor.dispatch(e.type, e);\n        };\n        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\n        editor.on('reset', () => {\n          editor.resetContent();\n        });\n        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\n          form._mceOldSubmit = form.submit;\n          form.submit = () => {\n            editor.editorManager.triggerSave();\n            editor.setDirty(false);\n            return form._mceOldSubmit(form);\n          };\n        }\n      }\n      editor.windowManager = WindowManager(editor);\n      editor.notificationManager = NotificationManager(editor);\n      if (isEncodingXml(editor)) {\n        editor.on('GetContent', e => {\n          if (e.save) {\n            e.content = DOM$3.encode(e.content);\n          }\n        });\n      }\n      if (shouldAddFormSubmitTrigger(editor)) {\n        editor.on('submit', () => {\n          if (editor.initialized) {\n            editor.save();\n          }\n        });\n      }\n      if (shouldAddUnloadTrigger(editor)) {\n        editor._beforeUnload = () => {\n          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\n            editor.save({\n              format: 'raw',\n              no_events: true,\n              set_dirty: false\n            });\n          }\n        };\n        editor.editorManager.on('BeforeUnload', editor._beforeUnload);\n      }\n      editor.editorManager.add(editor);\n      loadScripts(editor, editor.suffix);\n    };\n\n    const setEditableRoot = (editor, state) => {\n      if (editor._editableRoot !== state) {\n        editor._editableRoot = state;\n        if (!editor.readonly) {\n          editor.getBody().contentEditable = String(editor.hasEditableRoot());\n          editor.nodeChanged();\n        }\n        fireEditableRootStateChange(editor, state);\n      }\n    };\n    const hasEditableRoot = editor => editor._editableRoot;\n\n    const sectionResult = (sections, settings) => ({\n      sections: constant(sections),\n      options: constant(settings)\n    });\n    const deviceDetection = detect$2().deviceType;\n    const isPhone = deviceDetection.isPhone();\n    const isTablet = deviceDetection.isTablet();\n    const normalizePlugins = plugins => {\n      if (isNullable(plugins)) {\n        return [];\n      } else {\n        const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\n        const trimmedPlugins = map$3(pluginNames, trim$4);\n        return filter$5(trimmedPlugins, isNotEmpty);\n      }\n    };\n    const extractSections = (keys, options) => {\n      const result = bifilter(options, (value, key) => {\n        return contains$2(keys, key);\n      });\n      return sectionResult(result.t, result.f);\n    };\n    const getSection = (sectionResult, name, defaults = {}) => {\n      const sections = sectionResult.sections();\n      const sectionOptions = get$a(sections, name).getOr({});\n      return Tools.extend({}, defaults, sectionOptions);\n    };\n    const hasSection = (sectionResult, name) => {\n      return has$2(sectionResult.sections(), name);\n    };\n    const getSectionConfig = (sectionResult, name) => {\n      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\n    };\n    const getMobileOverrideOptions = (mobileOptions, isPhone) => {\n      const defaultMobileOptions = {\n        table_grid: false,\n        object_resizing: false,\n        resize: false,\n        toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\n        toolbar_sticky: false\n      };\n      const defaultPhoneOptions = { menubar: false };\n      return {\n        ...defaultMobileOptions,\n        ...isPhone ? defaultPhoneOptions : {}\n      };\n    };\n    const getExternalPlugins = (overrideOptions, options) => {\n      var _a;\n      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\n      if (overrideOptions && overrideOptions.external_plugins) {\n        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\n      } else {\n        return userDefinedExternalPlugins;\n      }\n    };\n    const combinePlugins = (forcedPlugins, plugins) => [\n      ...normalizePlugins(forcedPlugins),\n      ...normalizePlugins(plugins)\n    ];\n    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\n      if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\n        return mobilePlugins;\n      } else {\n        return desktopPlugins;\n      }\n    };\n    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\n      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\n      const desktopPlugins = normalizePlugins(options.plugins);\n      const mobileConfig = getSectionConfig(sectionResult, 'mobile');\n      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\n      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\n      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\n      return Tools.extend(options, {\n        forced_plugins: forcedPlugins,\n        plugins: combinedPlugins\n      });\n    };\n    const isOnMobile = (isMobileDevice, sectionResult) => {\n      return isMobileDevice && hasSection(sectionResult, 'mobile');\n    };\n    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\n      var _a;\n      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};\n      const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\n      const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options()) });\n      return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\n    };\n    const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);\n\n    const addVisual = (editor, elm) => addVisual$1(editor, elm);\n\n    const registerExecCommands$3 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      const toggleAlign = align => () => {\n        each$e('left,center,right,justify'.split(','), name => {\n          if (align !== name) {\n            editor.formatter.remove('align' + name);\n          }\n        });\n        if (align !== 'none') {\n          toggleFormat('align' + align);\n        }\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: toggleAlign('left'),\n        JustifyCenter: toggleAlign('center'),\n        JustifyRight: toggleAlign('right'),\n        JustifyFull: toggleAlign('justify'),\n        JustifyNone: toggleAlign('none')\n      });\n    };\n    const registerQueryStateCommands$1 = editor => {\n      const alignStates = name => () => {\n        const selection = editor.selection;\n        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\n        return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\n      };\n      editor.editorCommands.addCommands({\n        JustifyLeft: alignStates('alignleft'),\n        JustifyCenter: alignStates('aligncenter'),\n        JustifyRight: alignStates('alignright'),\n        JustifyFull: alignStates('alignjustify')\n      }, 'state');\n    };\n    const registerCommands$b = editor => {\n      registerExecCommands$3(editor);\n      registerQueryStateCommands$1(editor);\n    };\n\n    const registerCommands$a = editor => {\n      editor.editorCommands.addCommands({\n        'Cut,Copy,Paste': command => {\n          const doc = editor.getDoc();\n          let failed;\n          try {\n            doc.execCommand(command);\n          } catch (ex) {\n            failed = true;\n          }\n          if (command === 'paste' && !doc.queryCommandEnabled(command)) {\n            failed = true;\n          }\n          if (failed || !doc.queryCommandSupported(command)) {\n            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\n            if (Env.os.isMacOS() || Env.os.isiOS()) {\n              msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\n            }\n            editor.notificationManager.open({\n              text: msg,\n              type: 'error'\n            });\n          }\n        }\n      });\n    };\n\n    const trimOrPadLeftRight = (dom, rng, html, schema) => {\n      const root = SugarElement.fromDom(dom.getRoot());\n      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {\n        html = html.replace(/^ /, '&nbsp;');\n      } else {\n        html = html.replace(/^&nbsp;/, ' ');\n      }\n      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {\n        html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\n      } else {\n        html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\n      }\n      return html;\n    };\n\n    const processValue$1 = value => {\n      if (typeof value !== 'string') {\n        const details = Tools.extend({\n          paste: value.paste,\n          data: { paste: value.paste }\n        }, value);\n        return {\n          content: value.content,\n          details\n        };\n      }\n      return {\n        content: value,\n        details: {}\n      };\n    };\n    const trimOrPad = (editor, value) => {\n      const selection = editor.selection;\n      const dom = editor.dom;\n      if (/^ | $/.test(value)) {\n        return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);\n      } else {\n        return value;\n      }\n    };\n    const insertAtCaret = (editor, value) => {\n      if (editor.selection.isEditable()) {\n        const {content, details} = processValue$1(value);\n        preProcessSetContent(editor, {\n          ...details,\n          content: trimOrPad(editor, content),\n          format: 'html',\n          set: false,\n          selection: true\n        }).each(args => {\n          const insertedContent = insertContent$1(editor, args.content, details);\n          postProcessSetContent(editor, insertedContent, args);\n          editor.addVisual();\n        });\n      }\n    };\n\n    const registerCommands$9 = editor => {\n      editor.editorCommands.addCommands({\n        mceCleanup: () => {\n          const bm = editor.selection.getBookmark();\n          editor.setContent(editor.getContent());\n          editor.selection.moveToBookmark(bm);\n        },\n        insertImage: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));\n        },\n        insertHorizontalRule: () => {\n          editor.execCommand('mceInsertContent', false, '<hr>');\n        },\n        insertText: (_command, _ui, value) => {\n          insertAtCaret(editor, editor.dom.encode(value));\n        },\n        insertHTML: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceInsertContent: (_command, _ui, value) => {\n          insertAtCaret(editor, value);\n        },\n        mceSetContent: (_command, _ui, value) => {\n          editor.setContent(value);\n        },\n        mceReplaceContent: (_command, _ui, value) => {\n          editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({ format: 'text' })));\n        },\n        mceNewDocument: () => {\n          editor.setContent(getNewDocumentContent(editor));\n        }\n      });\n    };\n\n    const legacyPropNames = {\n      'font-size': 'size',\n      'font-family': 'face'\n    };\n    const isFont = isTag('font');\n    const getSpecifiedFontProp = (propName, rootElm, elm) => {\n      const getProperty = elm => getRaw(elm, propName).orThunk(() => {\n        if (isFont(elm)) {\n          return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\n        } else {\n          return Optional.none();\n        }\n      });\n      const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\n      return closest$1(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\n    };\n    const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\n    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\n    const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\n    const getFontSize = getFontProp('font-size');\n    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\n\n    const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).bind(caret => {\n      const container = caret.container();\n      return Optional.from(isText$a(container) ? container.parentNode : container);\n    });\n    const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\n      const root = editor.getBody();\n      const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\n      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\n    });\n    const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\n    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\n\n    const fromFontSizeNumber = (editor, value) => {\n      if (/^[0-9.]+$/.test(value)) {\n        const fontSizeNumber = parseInt(value, 10);\n        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\n          const fontSizes = getFontStyleValues(editor);\n          const fontClasses = getFontSizeClasses(editor);\n          if (fontClasses.length > 0) {\n            return fontClasses[fontSizeNumber - 1] || value;\n          } else {\n            return fontSizes[fontSizeNumber - 1] || value;\n          }\n        } else {\n          return value;\n        }\n      } else {\n        return value;\n      }\n    };\n    const normalizeFontNames = font => {\n      const fonts = font.split(/\\s*,\\s*/);\n      return map$3(fonts, font => {\n        if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\n          return `'${ font }'`;\n        } else {\n          return font;\n        }\n      }).join(',');\n    };\n    const fontNameAction = (editor, value) => {\n      const font = fromFontSizeNumber(editor, value);\n      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });\n      editor.nodeChanged();\n    };\n    const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\n    const fontSizeAction = (editor, value) => {\n      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });\n      editor.nodeChanged();\n    };\n    const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\n\n    const lineHeightQuery = editor => mapRange(editor, elm => {\n      const root = SugarElement.fromDom(editor.getBody());\n      const specifiedStyle = closest$1(elm, elm => getRaw(elm, 'line-height'), curry(eq, root));\n      const computedStyle = () => {\n        const lineHeight = parseFloat(get$7(elm, 'line-height'));\n        const fontSize = parseFloat(get$7(elm, 'font-size'));\n        return String(lineHeight / fontSize);\n      };\n      return specifiedStyle.getOrThunk(computedStyle);\n    }).getOr('');\n    const lineHeightAction = (editor, lineHeight) => {\n      editor.formatter.toggle('lineheight', { value: String(lineHeight) });\n      editor.nodeChanged();\n    };\n\n    const registerExecCommands$2 = editor => {\n      const toggleFormat = (name, value) => {\n        editor.formatter.toggle(name, value);\n        editor.nodeChanged();\n      };\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\n          toggleFormat(command);\n        },\n        'ForeColor,HiliteColor': (command, _ui, value) => {\n          toggleFormat(command, { value });\n        },\n        'BackColor': (_command, _ui, value) => {\n          toggleFormat('hilitecolor', { value });\n        },\n        'FontName': (_command, _ui, value) => {\n          fontNameAction(editor, value);\n        },\n        'FontSize': (_command, _ui, value) => {\n          fontSizeAction(editor, value);\n        },\n        'LineHeight': (_command, _ui, value) => {\n          lineHeightAction(editor, value);\n        },\n        'Lang': (command, _ui, lang) => {\n          var _a;\n          toggleFormat(command, {\n            value: lang.code,\n            customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null\n          });\n        },\n        'RemoveFormat': command => {\n          editor.formatter.remove(command);\n        },\n        'mceBlockQuote': () => {\n          toggleFormat('blockquote');\n        },\n        'FormatBlock': (_command, _ui, value) => {\n          toggleFormat(isString(value) ? value : 'p');\n        },\n        'mceToggleFormat': (_command, _ui, value) => {\n          toggleFormat(value);\n        }\n      });\n    };\n    const registerQueryValueCommands = editor => {\n      const isFormatMatch = name => editor.formatter.match(name);\n      editor.editorCommands.addCommands({\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\n        'mceBlockQuote': () => isFormatMatch('blockquote')\n      }, 'state');\n      editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\n      editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\n      editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\n    };\n    const registerCommands$8 = editor => {\n      registerExecCommands$2(editor);\n      registerQueryValueCommands(editor);\n    };\n\n    const registerCommands$7 = editor => {\n      editor.editorCommands.addCommands({\n        mceAddUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        mceEndUndoLevel: () => {\n          editor.undoManager.add();\n        },\n        Undo: () => {\n          editor.undoManager.undo();\n        },\n        Redo: () => {\n          editor.undoManager.redo();\n        }\n      });\n    };\n\n    const registerCommands$6 = editor => {\n      editor.editorCommands.addCommands({\n        Indent: () => {\n          indent(editor);\n        },\n        Outdent: () => {\n          outdent(editor);\n        }\n      });\n      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, 'state');\n    };\n\n    const registerCommands$5 = editor => {\n      const applyLinkToSelection = (_command, _ui, value) => {\n        const linkDetails = isString(value) ? { href: value } : value;\n        const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\n        if (isObject(linkDetails) && isString(linkDetails.href)) {\n          linkDetails.href = linkDetails.href.replace(/ /g, '%20');\n          if (!anchor || !linkDetails.href) {\n            editor.formatter.remove('link');\n          }\n          if (linkDetails.href) {\n            editor.formatter.apply('link', linkDetails, anchor);\n          }\n        }\n      };\n      editor.editorCommands.addCommands({\n        unlink: () => {\n          if (editor.selection.isEditable()) {\n            if (editor.selection.isCollapsed()) {\n              const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\n              if (elm) {\n                editor.dom.remove(elm, true);\n              }\n              return;\n            }\n            editor.formatter.remove('link');\n          }\n        },\n        mceInsertLink: applyLinkToSelection,\n        createLink: applyLinkToSelection\n      });\n    };\n\n    const registerExecCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        'InsertUnorderedList,InsertOrderedList': command => {\n          editor.getDoc().execCommand(command);\n          const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\n          if (listElm) {\n            const listParent = listElm.parentNode;\n            if (listParent && /^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\n              const bm = editor.selection.getBookmark();\n              editor.dom.split(listParent, listElm);\n              editor.selection.moveToBookmark(bm);\n            }\n          }\n        }\n      });\n    };\n    const registerQueryStateCommands = editor => {\n      editor.editorCommands.addCommands({\n        'InsertUnorderedList,InsertOrderedList': command => {\n          const list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');\n          return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');\n        }\n      }, 'state');\n    };\n    const registerCommands$4 = editor => {\n      registerExecCommands$1(editor);\n      registerQueryStateCommands(editor);\n    };\n\n    const getTopParentBlock = (editor, node, root, container) => {\n      const dom = editor.dom;\n      const selector = node => dom.isBlock(node) && node.parentElement === root;\n      const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);\n      return Optional.from(topParentBlock).map(SugarElement.fromDom);\n    };\n    const insert = (editor, before) => {\n      const dom = editor.dom;\n      const rng = editor.selection.getRng();\n      const node = before ? editor.selection.getStart() : editor.selection.getEnd();\n      const container = before ? rng.startContainer : rng.endContainer;\n      const root = getEditableRoot(dom, container);\n      if (!root || !root.isContentEditable) {\n        return;\n      }\n      const insertFn = before ? before$3 : after$4;\n      const newBlockName = getForcedRootBlock(editor);\n      getTopParentBlock(editor, node, root, container).each(parentBlock => {\n        const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);\n        insertFn(parentBlock, SugarElement.fromDom(newBlock));\n        editor.selection.setCursorLocation(newBlock, 0);\n        editor.dispatch('NewBlock', { newBlock });\n        fireInputEvent(editor, 'insertParagraph');\n      });\n    };\n    const insertBefore = editor => insert(editor, true);\n    const insertAfter = editor => insert(editor, false);\n\n    const registerCommands$3 = editor => {\n      editor.editorCommands.addCommands({\n        InsertNewBlockBefore: () => {\n          insertBefore(editor);\n        },\n        InsertNewBlockAfter: () => {\n          insertAfter(editor);\n        }\n      });\n    };\n\n    const registerCommands$2 = editor => {\n      editor.editorCommands.addCommands({\n        insertParagraph: () => {\n          insertBreak(blockbreak, editor);\n        },\n        mceInsertNewLine: (_command, _ui, value) => {\n          insert$1(editor, value);\n        },\n        InsertLineBreak: (_command, _ui, _value) => {\n          insertBreak(linebreak, editor);\n        }\n      });\n    };\n\n    const registerCommands$1 = editor => {\n      editor.editorCommands.addCommands({\n        mceSelectNodeDepth: (_command, _ui, value) => {\n          let counter = 0;\n          editor.dom.getParent(editor.selection.getNode(), node => {\n            if (isElement$6(node) && counter++ === value) {\n              editor.selection.select(node);\n              return false;\n            } else {\n              return true;\n            }\n          }, editor.getBody());\n        },\n        mceSelectNode: (_command, _ui, value) => {\n          editor.selection.select(value);\n        },\n        selectAll: () => {\n          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);\n          if (editingHost) {\n            const rng = editor.dom.createRng();\n            rng.selectNodeContents(editingHost);\n            editor.selection.setRng(rng);\n          }\n        }\n      });\n    };\n\n    const registerExecCommands = editor => {\n      editor.editorCommands.addCommands({\n        mceRemoveNode: (_command, _ui, value) => {\n          const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\n          if (node !== editor.getBody()) {\n            const bm = editor.selection.getBookmark();\n            editor.dom.remove(node, true);\n            editor.selection.moveToBookmark(bm);\n          }\n        },\n        mcePrint: () => {\n          editor.getWin().print();\n        },\n        mceFocus: (_command, _ui, value) => {\n          focus(editor, value === true);\n        },\n        mceToggleVisualAid: () => {\n          editor.hasVisual = !editor.hasVisual;\n          editor.addVisual();\n        }\n      });\n    };\n    const registerCommands = editor => {\n      registerCommands$b(editor);\n      registerCommands$a(editor);\n      registerCommands$7(editor);\n      registerCommands$1(editor);\n      registerCommands$9(editor);\n      registerCommands$5(editor);\n      registerCommands$6(editor);\n      registerCommands$3(editor);\n      registerCommands$2(editor);\n      registerCommands$4(editor);\n      registerCommands$8(editor);\n      registerExecCommands(editor);\n    };\n\n    const selectionSafeCommands = ['toggleview'];\n    const isSelectionSafeCommand = command => contains$2(selectionSafeCommands, command.toLowerCase());\n    class EditorCommands {\n      constructor(editor) {\n        this.commands = {\n          state: {},\n          exec: {},\n          value: {}\n        };\n        this.editor = editor;\n      }\n      execCommand(command, ui = false, value, args) {\n        const editor = this.editor;\n        const lowerCaseCommand = command.toLowerCase();\n        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\n        if (editor.removed) {\n          return false;\n        }\n        if (lowerCaseCommand !== 'mcefocus') {\n          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\n            editor.focus();\n          } else {\n            restore(editor);\n          }\n        }\n        const eventArgs = editor.dispatch('BeforeExecCommand', {\n          command,\n          ui,\n          value\n        });\n        if (eventArgs.isDefaultPrevented()) {\n          return false;\n        }\n        const func = this.commands.exec[lowerCaseCommand];\n        if (isFunction(func)) {\n          func(lowerCaseCommand, ui, value);\n          editor.dispatch('ExecCommand', {\n            command,\n            ui,\n            value\n          });\n          return true;\n        }\n        return false;\n      }\n      queryCommandState(command) {\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n          return false;\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.state[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return false;\n      }\n      queryCommandValue(command) {\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\n          return '';\n        }\n        const lowerCaseCommand = command.toLowerCase();\n        const func = this.commands.value[lowerCaseCommand];\n        if (isFunction(func)) {\n          return func(lowerCaseCommand);\n        }\n        return '';\n      }\n      addCommands(commandList, type = 'exec') {\n        const commands = this.commands;\n        each$d(commandList, (callback, command) => {\n          each$e(command.toLowerCase().split(','), command => {\n            commands[type][command] = callback;\n          });\n        });\n      }\n      addCommand(command, callback, scope) {\n        const lowerCaseCommand = command.toLowerCase();\n        this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\n      }\n      queryCommandSupported(command) {\n        const lowerCaseCommand = command.toLowerCase();\n        if (this.commands.exec[lowerCaseCommand]) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n      addQueryStateHandler(command, callback, scope) {\n        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n      addQueryValueHandler(command, callback, scope) {\n        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\n      }\n    }\n\n    const internalContentEditableAttr = 'data-mce-contenteditable';\n    const toggleClass = (elm, cls, state) => {\n      if (has(elm, cls) && !state) {\n        remove$7(elm, cls);\n      } else if (state) {\n        add$2(elm, cls);\n      }\n    };\n    const setEditorCommandState = (editor, cmd, state) => {\n      try {\n        editor.getDoc().execCommand(cmd, false, String(state));\n      } catch (ex) {\n      }\n    };\n    const setContentEditable = (elm, state) => {\n      elm.dom.contentEditable = state ? 'true' : 'false';\n    };\n    const switchOffContentEditableTrue = elm => {\n      each$e(descendants(elm, '*[contenteditable=\"true\"]'), elm => {\n        set$3(elm, internalContentEditableAttr, 'true');\n        setContentEditable(elm, false);\n      });\n    };\n    const switchOnContentEditableTrue = elm => {\n      each$e(descendants(elm, `*[${ internalContentEditableAttr }=\"true\"]`), elm => {\n        remove$a(elm, internalContentEditableAttr);\n        setContentEditable(elm, true);\n      });\n    };\n    const removeFakeSelection = editor => {\n      Optional.from(editor.selection.getNode()).each(elm => {\n        elm.removeAttribute('data-mce-selected');\n      });\n    };\n    const restoreFakeSelection = editor => {\n      editor.selection.setRng(editor.selection.getRng());\n    };\n    const toggleReadOnly = (editor, state) => {\n      const body = SugarElement.fromDom(editor.getBody());\n      toggleClass(body, 'mce-content-readonly', state);\n      if (state) {\n        editor.selection.controlSelection.hideResizeRect();\n        editor._selectionOverrides.hideFakeCaret();\n        removeFakeSelection(editor);\n        editor.readonly = true;\n        setContentEditable(body, false);\n        switchOffContentEditableTrue(body);\n      } else {\n        editor.readonly = false;\n        if (editor.hasEditableRoot()) {\n          setContentEditable(body, true);\n        }\n        switchOnContentEditableTrue(body);\n        setEditorCommandState(editor, 'StyleWithCSS', false);\n        setEditorCommandState(editor, 'enableInlineTableEditing', false);\n        setEditorCommandState(editor, 'enableObjectResizing', false);\n        if (hasEditorOrUiFocus(editor)) {\n          editor.focus();\n        }\n        restoreFakeSelection(editor);\n        editor.nodeChanged();\n      }\n    };\n    const isReadOnly = editor => editor.readonly;\n    const registerFilters = editor => {\n      editor.parser.addAttributeFilter('contenteditable', nodes => {\n        if (isReadOnly(editor)) {\n          each$e(nodes, node => {\n            node.attr(internalContentEditableAttr, node.attr('contenteditable'));\n            node.attr('contenteditable', 'false');\n          });\n        }\n      });\n      editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {\n        if (isReadOnly(editor)) {\n          each$e(nodes, node => {\n            node.attr('contenteditable', node.attr(internalContentEditableAttr));\n          });\n        }\n      });\n      editor.serializer.addTempAttr(internalContentEditableAttr);\n    };\n    const registerReadOnlyContentFilters = editor => {\n      if (editor.serializer) {\n        registerFilters(editor);\n      } else {\n        editor.on('PreInit', () => {\n          registerFilters(editor);\n        });\n      }\n    };\n    const isClickEvent = e => e.type === 'click';\n    const allowedEvents = ['copy'];\n    const isReadOnlyAllowedEvent = e => contains$2(allowedEvents, e.type);\n    const getAnchorHrefOpt = (editor, elm) => {\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\n      return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\n    };\n    const processReadonlyEvents = (editor, e) => {\n      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\n        const elm = SugarElement.fromDom(e.target);\n        getAnchorHrefOpt(editor, elm).each(href => {\n          e.preventDefault();\n          if (/^#/.test(href)) {\n            const targetEl = editor.dom.select(`${ href },[name=\"${ removeLeading(href, '#') }\"]`);\n            if (targetEl.length) {\n              editor.selection.scrollIntoView(targetEl[0], true);\n            }\n          } else {\n            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\n          }\n        });\n      } else if (isReadOnlyAllowedEvent(e)) {\n        editor.dispatch(e.type, e);\n      }\n    };\n    const registerReadOnlySelectionBlockers = editor => {\n      editor.on('ShowCaret', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n      editor.on('ObjectSelected', e => {\n        if (isReadOnly(editor)) {\n          e.preventDefault();\n        }\n      });\n    };\n\n    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\n    class EventDispatcher {\n      static isNative(name) {\n        return !!nativeEvents[name.toLowerCase()];\n      }\n      constructor(settings) {\n        this.bindings = {};\n        this.settings = settings || {};\n        this.scope = this.settings.scope || this;\n        this.toggleEvent = this.settings.toggleEvent || never;\n      }\n      fire(name, args) {\n        return this.dispatch(name, args);\n      }\n      dispatch(name, args) {\n        const lcName = name.toLowerCase();\n        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\n        if (this.settings.beforeFire) {\n          this.settings.beforeFire(event);\n        }\n        const handlers = this.bindings[lcName];\n        if (handlers) {\n          for (let i = 0, l = handlers.length; i < l; i++) {\n            const callback = handlers[i];\n            if (callback.removed) {\n              continue;\n            }\n            if (callback.once) {\n              this.off(lcName, callback.func);\n            }\n            if (event.isImmediatePropagationStopped()) {\n              return event;\n            }\n            if (callback.func.call(this.scope, event) === false) {\n              event.preventDefault();\n              return event;\n            }\n          }\n        }\n        return event;\n      }\n      on(name, callback, prepend, extra) {\n        if (callback === false) {\n          callback = never;\n        }\n        if (callback) {\n          const wrappedCallback = {\n            func: callback,\n            removed: false\n          };\n          if (extra) {\n            Tools.extend(wrappedCallback, extra);\n          }\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!handlers) {\n              handlers = [];\n              this.toggleEvent(currentName, true);\n            }\n            if (prepend) {\n              handlers = [\n                wrappedCallback,\n                ...handlers\n              ];\n            } else {\n              handlers = [\n                ...handlers,\n                wrappedCallback\n              ];\n            }\n            this.bindings[currentName] = handlers;\n          }\n        }\n        return this;\n      }\n      off(name, callback) {\n        if (name) {\n          const names = name.toLowerCase().split(' ');\n          let i = names.length;\n          while (i--) {\n            const currentName = names[i];\n            let handlers = this.bindings[currentName];\n            if (!currentName) {\n              each$d(this.bindings, (_value, bindingName) => {\n                this.toggleEvent(bindingName, false);\n                delete this.bindings[bindingName];\n              });\n              return this;\n            }\n            if (handlers) {\n              if (!callback) {\n                handlers.length = 0;\n              } else {\n                const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\n                handlers = filteredHandlers.fail;\n                this.bindings[currentName] = handlers;\n                each$e(filteredHandlers.pass, handler => {\n                  handler.removed = true;\n                });\n              }\n              if (!handlers.length) {\n                this.toggleEvent(name, false);\n                delete this.bindings[currentName];\n              }\n            }\n          }\n        } else {\n          each$d(this.bindings, (_value, name) => {\n            this.toggleEvent(name, false);\n          });\n          this.bindings = {};\n        }\n        return this;\n      }\n      once(name, callback, prepend) {\n        return this.on(name, callback, prepend, { once: true });\n      }\n      has(name) {\n        name = name.toLowerCase();\n        const binding = this.bindings[name];\n        return !(!binding || binding.length === 0);\n      }\n    }\n\n    const getEventDispatcher = obj => {\n      if (!obj._eventDispatcher) {\n        obj._eventDispatcher = new EventDispatcher({\n          scope: obj,\n          toggleEvent: (name, state) => {\n            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\n              obj.toggleNativeEvent(name, state);\n            }\n          }\n        });\n      }\n      return obj._eventDispatcher;\n    };\n    const Observable = {\n      fire(name, args, bubble) {\n        return this.dispatch(name, args, bubble);\n      },\n      dispatch(name, args, bubble) {\n        const self = this;\n        if (self.removed && name !== 'remove' && name !== 'detach') {\n          return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\n        }\n        const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\n        if (bubble !== false && self.parent) {\n          let parent = self.parent();\n          while (parent && !dispatcherArgs.isPropagationStopped()) {\n            parent.dispatch(name, dispatcherArgs, false);\n            parent = parent.parent ? parent.parent() : undefined;\n          }\n        }\n        return dispatcherArgs;\n      },\n      on(name, callback, prepend) {\n        return getEventDispatcher(this).on(name, callback, prepend);\n      },\n      off(name, callback) {\n        return getEventDispatcher(this).off(name, callback);\n      },\n      once(name, callback) {\n        return getEventDispatcher(this).once(name, callback);\n      },\n      hasEventListeners(name) {\n        return getEventDispatcher(this).has(name);\n      }\n    };\n\n    const DOM$2 = DOMUtils.DOM;\n    let customEventRootDelegates;\n    const getEventTarget = (editor, eventName) => {\n      if (eventName === 'selectionchange') {\n        return editor.getDoc();\n      }\n      if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {\n        return editor.getDoc().documentElement;\n      }\n      const eventRoot = getEventRoot(editor);\n      if (eventRoot) {\n        if (!editor.eventRoot) {\n          editor.eventRoot = DOM$2.select(eventRoot)[0];\n        }\n        return editor.eventRoot;\n      }\n      return editor.getBody();\n    };\n    const isListening = editor => !editor.hidden && !isReadOnly(editor);\n    const fireEvent = (editor, eventName, e) => {\n      if (isListening(editor)) {\n        editor.dispatch(eventName, e);\n      } else if (isReadOnly(editor)) {\n        processReadonlyEvents(editor, e);\n      }\n    };\n    const bindEventDelegate = (editor, eventName) => {\n      if (!editor.delegates) {\n        editor.delegates = {};\n      }\n      if (editor.delegates[eventName] || editor.removed) {\n        return;\n      }\n      const eventRootElm = getEventTarget(editor, eventName);\n      if (getEventRoot(editor)) {\n        if (!customEventRootDelegates) {\n          customEventRootDelegates = {};\n          editor.editorManager.on('removeEditor', () => {\n            if (!editor.editorManager.activeEditor) {\n              if (customEventRootDelegates) {\n                each$d(customEventRootDelegates, (_value, name) => {\n                  editor.dom.unbind(getEventTarget(editor, name));\n                });\n                customEventRootDelegates = null;\n              }\n            }\n          });\n        }\n        if (customEventRootDelegates[eventName]) {\n          return;\n        }\n        const delegate = e => {\n          const target = e.target;\n          const editors = editor.editorManager.get();\n          let i = editors.length;\n          while (i--) {\n            const body = editors[i].getBody();\n            if (body === target || DOM$2.isChildOf(target, body)) {\n              fireEvent(editors[i], eventName, e);\n            }\n          }\n        };\n        customEventRootDelegates[eventName] = delegate;\n        DOM$2.bind(eventRootElm, eventName, delegate);\n      } else {\n        const delegate = e => {\n          fireEvent(editor, eventName, e);\n        };\n        DOM$2.bind(eventRootElm, eventName, delegate);\n        editor.delegates[eventName] = delegate;\n      }\n    };\n    const EditorObservable = {\n      ...Observable,\n      bindPendingEventDelegates() {\n        const self = this;\n        Tools.each(self._pendingNativeEvents, name => {\n          bindEventDelegate(self, name);\n        });\n      },\n      toggleNativeEvent(name, state) {\n        const self = this;\n        if (name === 'focus' || name === 'blur') {\n          return;\n        }\n        if (self.removed) {\n          return;\n        }\n        if (state) {\n          if (self.initialized) {\n            bindEventDelegate(self, name);\n          } else {\n            if (!self._pendingNativeEvents) {\n              self._pendingNativeEvents = [name];\n            } else {\n              self._pendingNativeEvents.push(name);\n            }\n          }\n        } else if (self.initialized && self.delegates) {\n          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\n          delete self.delegates[name];\n        }\n      },\n      unbindAllNativeEvents() {\n        const self = this;\n        const body = self.getBody();\n        const dom = self.dom;\n        if (self.delegates) {\n          each$d(self.delegates, (value, name) => {\n            self.dom.unbind(getEventTarget(self, name), name, value);\n          });\n          delete self.delegates;\n        }\n        if (!self.inline && body && dom) {\n          body.onload = null;\n          dom.unbind(self.getWin());\n          dom.unbind(self.getDoc());\n        }\n        if (dom) {\n          dom.unbind(body);\n          dom.unbind(self.getContainer());\n        }\n      }\n    };\n\n    const stringListProcessor = value => {\n      if (isString(value)) {\n        return {\n          value: value.split(/[ ,]/),\n          valid: true\n        };\n      } else if (isArrayOf(value, isString)) {\n        return {\n          value,\n          valid: true\n        };\n      } else {\n        return {\n          valid: false,\n          message: `The value must be a string[] or a comma/space separated string.`\n        };\n      }\n    };\n    const getBuiltInProcessor = type => {\n      const validator = (() => {\n        switch (type) {\n        case 'array':\n          return isArray$1;\n        case 'boolean':\n          return isBoolean;\n        case 'function':\n          return isFunction;\n        case 'number':\n          return isNumber;\n        case 'object':\n          return isObject;\n        case 'string':\n          return isString;\n        case 'string[]':\n          return stringListProcessor;\n        case 'object[]':\n          return val => isArrayOf(val, isObject);\n        case 'regexp':\n          return val => is$4(val, RegExp);\n        default:\n          return always;\n        }\n      })();\n      return value => processValue(value, validator, `The value must be a ${ type }.`);\n    };\n    const isBuiltInSpec = spec => isString(spec.processor);\n    const getErrorMessage = (message, result) => {\n      const additionalText = isEmpty$3(result.message) ? '' : `. ${ result.message }`;\n      return message + additionalText;\n    };\n    const isValidResult = result => result.valid;\n    const processValue = (value, processor, message = '') => {\n      const result = processor(value);\n      if (isBoolean(result)) {\n        return result ? {\n          value: value,\n          valid: true\n        } : {\n          valid: false,\n          message\n        };\n      } else {\n        return result;\n      }\n    };\n    const processDefaultValue = (name, defaultValue, processor) => {\n      if (!isUndefined(defaultValue)) {\n        const result = processValue(defaultValue, processor);\n        if (isValidResult(result)) {\n          return result.value;\n        } else {\n          console.error(getErrorMessage(`Invalid default value passed for the \"${ name }\" option`, result));\n        }\n      }\n      return undefined;\n    };\n    const create$5 = (editor, initialOptions) => {\n      const registry = {};\n      const values = {};\n      const setValue = (name, value, processor) => {\n        const result = processValue(value, processor);\n        if (isValidResult(result)) {\n          values[name] = result.value;\n          return true;\n        } else {\n          console.warn(getErrorMessage(`Invalid value passed for the ${ name } option`, result));\n          return false;\n        }\n      };\n      const register = (name, spec) => {\n        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\n        const defaultValue = processDefaultValue(name, spec.default, processor);\n        registry[name] = {\n          ...spec,\n          default: defaultValue,\n          processor\n        };\n        const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\n        initValue.each(value => setValue(name, value, processor));\n      };\n      const isRegistered = name => has$2(registry, name);\n      const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\n      const set = (name, value) => {\n        if (!isRegistered(name)) {\n          console.warn(`\"${ name }\" is not a registered option. Ensure the option has been registered before setting a value.`);\n          return false;\n        } else {\n          const spec = registry[name];\n          if (spec.immutable) {\n            console.error(`\"${ name }\" is an immutable option and cannot be updated`);\n            return false;\n          } else {\n            return setValue(name, value, spec.processor);\n          }\n        }\n      };\n      const unset = name => {\n        const registered = isRegistered(name);\n        if (registered) {\n          delete values[name];\n        }\n        return registered;\n      };\n      const isSet = name => has$2(values, name);\n      return {\n        register,\n        isRegistered,\n        get,\n        set,\n        unset,\n        isSet\n      };\n    };\n\n    const defaultModes = [\n      'design',\n      'readonly'\n    ];\n    const switchToMode = (editor, activeMode, availableModes, mode) => {\n      const oldMode = availableModes[activeMode.get()];\n      const newMode = availableModes[mode];\n      try {\n        newMode.activate();\n      } catch (e) {\n        console.error(`problem while activating editor mode ${ mode }:`, e);\n        return;\n      }\n      oldMode.deactivate();\n      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\n        toggleReadOnly(editor, newMode.editorReadOnly);\n      }\n      activeMode.set(mode);\n      fireSwitchMode(editor, mode);\n    };\n    const setMode = (editor, availableModes, activeMode, mode) => {\n      if (mode === activeMode.get()) {\n        return;\n      } else if (!has$2(availableModes, mode)) {\n        throw new Error(`Editor mode '${ mode }' is invalid`);\n      }\n      if (editor.initialized) {\n        switchToMode(editor, activeMode, availableModes, mode);\n      } else {\n        editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\n      }\n    };\n    const registerMode = (availableModes, mode, api) => {\n      if (contains$2(defaultModes, mode)) {\n        throw new Error(`Cannot override default mode ${ mode }`);\n      }\n      return {\n        ...availableModes,\n        [mode]: {\n          ...api,\n          deactivate: () => {\n            try {\n              api.deactivate();\n            } catch (e) {\n              console.error(`problem while deactivating editor mode ${ mode }:`, e);\n            }\n          }\n        }\n      };\n    };\n\n    const create$4 = editor => {\n      const activeMode = Cell('design');\n      const availableModes = Cell({\n        design: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: false\n        },\n        readonly: {\n          activate: noop,\n          deactivate: noop,\n          editorReadOnly: true\n        }\n      });\n      registerReadOnlyContentFilters(editor);\n      registerReadOnlySelectionBlockers(editor);\n      return {\n        isReadOnly: () => isReadOnly(editor),\n        set: mode => setMode(editor, availableModes.get(), activeMode, mode),\n        get: () => activeMode.get(),\n        register: (mode, api) => {\n          availableModes.set(registerMode(availableModes.get(), mode, api));\n        }\n      };\n    };\n\n    const each$2 = Tools.each, explode = Tools.explode;\n    const keyCodeLookup = {\n      f1: 112,\n      f2: 113,\n      f3: 114,\n      f4: 115,\n      f5: 116,\n      f6: 117,\n      f7: 118,\n      f8: 119,\n      f9: 120,\n      f10: 121,\n      f11: 122,\n      f12: 123\n    };\n    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\n    const isModifier = key => key in modifierNames;\n    const parseShortcut = pattern => {\n      const shortcut = {};\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\n      each$2(explode(pattern.toLowerCase(), '+'), value => {\n        if (isModifier(value)) {\n          shortcut[value] = true;\n        } else {\n          if (/^[0-9]{2,}$/.test(value)) {\n            shortcut.keyCode = parseInt(value, 10);\n          } else {\n            shortcut.charCode = value.charCodeAt(0);\n            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\n          }\n        }\n      });\n      const id = [shortcut.keyCode];\n      let key;\n      for (key in modifierNames) {\n        if (shortcut[key]) {\n          id.push(key);\n        } else {\n          shortcut[key] = false;\n        }\n      }\n      shortcut.id = id.join(',');\n      if (shortcut.access) {\n        shortcut.alt = true;\n        if (isMac) {\n          shortcut.ctrl = true;\n        } else {\n          shortcut.shift = true;\n        }\n      }\n      if (shortcut.meta) {\n        if (isMac) {\n          shortcut.meta = true;\n        } else {\n          shortcut.ctrl = true;\n          shortcut.meta = false;\n        }\n      }\n      return shortcut;\n    };\n    class Shortcuts {\n      constructor(editor) {\n        this.shortcuts = {};\n        this.pendingPatterns = [];\n        this.editor = editor;\n        const self = this;\n        editor.on('keyup keypress keydown', e => {\n          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\n            each$2(self.shortcuts, shortcut => {\n              if (self.matchShortcut(e, shortcut)) {\n                self.pendingPatterns = shortcut.subpatterns.slice(0);\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(shortcut);\n                }\n              }\n            });\n            if (self.matchShortcut(e, self.pendingPatterns[0])) {\n              if (self.pendingPatterns.length === 1) {\n                if (e.type === 'keydown') {\n                  self.executeShortcutAction(self.pendingPatterns[0]);\n                }\n              }\n              self.pendingPatterns.shift();\n            }\n          }\n        });\n      }\n      add(pattern, desc, cmdFunc, scope) {\n        const self = this;\n        const func = self.normalizeCommandFunc(cmdFunc);\n        each$2(explode(Tools.trim(pattern)), pattern => {\n          const shortcut = self.createShortcut(pattern, desc, func, scope);\n          self.shortcuts[shortcut.id] = shortcut;\n        });\n        return true;\n      }\n      remove(pattern) {\n        const shortcut = this.createShortcut(pattern);\n        if (this.shortcuts[shortcut.id]) {\n          delete this.shortcuts[shortcut.id];\n          return true;\n        }\n        return false;\n      }\n      normalizeCommandFunc(cmdFunc) {\n        const self = this;\n        const cmd = cmdFunc;\n        if (typeof cmd === 'string') {\n          return () => {\n            self.editor.execCommand(cmd, false, null);\n          };\n        } else if (Tools.isArray(cmd)) {\n          return () => {\n            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\n          };\n        } else {\n          return cmd;\n        }\n      }\n      createShortcut(pattern, desc, cmdFunc, scope) {\n        const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\n        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\n          func: cmdFunc,\n          scope: scope || this.editor\n        });\n        return Tools.extend(shortcuts[0], {\n          desc: this.editor.translate(desc),\n          subpatterns: shortcuts.slice(1)\n        });\n      }\n      hasModifier(e) {\n        return e.altKey || e.ctrlKey || e.metaKey;\n      }\n      isFunctionKey(e) {\n        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\n      }\n      matchShortcut(e, shortcut) {\n        if (!shortcut) {\n          return false;\n        }\n        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\n          return false;\n        }\n        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\n          return false;\n        }\n        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\n          e.preventDefault();\n          return true;\n        }\n        return false;\n      }\n      executeShortcutAction(shortcut) {\n        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\n      }\n    }\n\n    const create$3 = () => {\n      const buttons = {};\n      const menuItems = {};\n      const popups = {};\n      const icons = {};\n      const contextMenus = {};\n      const contextToolbars = {};\n      const sidebars = {};\n      const views = {};\n      const add = (collection, type) => (name, spec) => {\n        collection[name.toLowerCase()] = {\n          ...spec,\n          type\n        };\n      };\n      const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\n      return {\n        addButton: add(buttons, 'button'),\n        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\n        addToggleButton: add(buttons, 'togglebutton'),\n        addMenuButton: add(buttons, 'menubutton'),\n        addSplitButton: add(buttons, 'splitbutton'),\n        addMenuItem: add(menuItems, 'menuitem'),\n        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\n        addToggleMenuItem: add(menuItems, 'togglemenuitem'),\n        addAutocompleter: add(popups, 'autocompleter'),\n        addContextMenu: add(contextMenus, 'contextmenu'),\n        addContextToolbar: add(contextToolbars, 'contexttoolbar'),\n        addContextForm: add(contextToolbars, 'contextform'),\n        addSidebar: add(sidebars, 'sidebar'),\n        addView: add(views, 'views'),\n        addIcon,\n        getAll: () => ({\n          buttons,\n          menuItems,\n          icons,\n          popups,\n          contextMenus,\n          contextToolbars,\n          sidebars,\n          views\n        })\n      };\n    };\n\n    const registry = () => {\n      const bridge = create$3();\n      return {\n        addAutocompleter: bridge.addAutocompleter,\n        addButton: bridge.addButton,\n        addContextForm: bridge.addContextForm,\n        addContextMenu: bridge.addContextMenu,\n        addContextToolbar: bridge.addContextToolbar,\n        addIcon: bridge.addIcon,\n        addMenuButton: bridge.addMenuButton,\n        addMenuItem: bridge.addMenuItem,\n        addNestedMenuItem: bridge.addNestedMenuItem,\n        addSidebar: bridge.addSidebar,\n        addSplitButton: bridge.addSplitButton,\n        addToggleButton: bridge.addToggleButton,\n        addGroupToolbarButton: bridge.addGroupToolbarButton,\n        addToggleMenuItem: bridge.addToggleMenuItem,\n        addView: bridge.addView,\n        getAll: bridge.getAll\n      };\n    };\n\n    const DOM$1 = DOMUtils.DOM;\n    const extend = Tools.extend, each$1 = Tools.each;\n    class Editor {\n      constructor(id, options, editorManager) {\n        this.plugins = {};\n        this.contentCSS = [];\n        this.contentStyles = [];\n        this.loadedCSS = {};\n        this.isNotDirty = false;\n        this.composing = false;\n        this.destroyed = false;\n        this.hasHiddenInput = false;\n        this.iframeElement = null;\n        this.initialized = false;\n        this.readonly = false;\n        this.removed = false;\n        this.startContent = '';\n        this._pendingNativeEvents = [];\n        this._skinLoaded = false;\n        this._editableRoot = true;\n        this.editorManager = editorManager;\n        this.documentBaseUrl = editorManager.documentBaseURL;\n        extend(this, EditorObservable);\n        const self = this;\n        this.id = id;\n        this.hidden = false;\n        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\n        this.options = create$5(self, normalizedOptions);\n        register$7(self);\n        const getOption = this.options.get;\n        if (getOption('deprecation_warnings')) {\n          logWarnings(options, normalizedOptions);\n        }\n        const suffix = getOption('suffix');\n        if (suffix) {\n          editorManager.suffix = suffix;\n        }\n        this.suffix = editorManager.suffix;\n        const baseUrl = getOption('base_url');\n        if (baseUrl) {\n          editorManager._setBaseUrl(baseUrl);\n        }\n        this.baseUri = editorManager.baseURI;\n        const referrerPolicy = getReferrerPolicy(self);\n        if (referrerPolicy) {\n          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\n          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\n        }\n        const contentCssCors = hasContentCssCors(self);\n        if (isNonNullable(contentCssCors)) {\n          DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);\n        }\n        AddOnManager.languageLoad = getOption('language_load');\n        AddOnManager.baseURL = editorManager.baseURL;\n        this.setDirty(false);\n        this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });\n        this.baseURI = this.baseUri;\n        this.inline = isInline$1(self);\n        this.hasVisual = isVisualAidsEnabled(self);\n        this.shortcuts = new Shortcuts(this);\n        this.editorCommands = new EditorCommands(this);\n        registerCommands(this);\n        const cacheSuffix = getOption('cache_suffix');\n        if (cacheSuffix) {\n          Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\n        }\n        this.ui = {\n          registry: registry(),\n          styleSheetLoader: undefined,\n          show: noop,\n          hide: noop,\n          setEnabled: noop,\n          isEnabled: always\n        };\n        this.mode = create$4(self);\n        editorManager.dispatch('SetupEditor', { editor: this });\n        const setupCallback = getSetupCallback(self);\n        if (isFunction(setupCallback)) {\n          setupCallback.call(self, self);\n        }\n      }\n      render() {\n        render(this);\n      }\n      focus(skipFocus) {\n        this.execCommand('mceFocus', false, skipFocus);\n      }\n      hasFocus() {\n        return hasFocus(this);\n      }\n      translate(text) {\n        return I18n.translate(text);\n      }\n      getParam(name, defaultVal, type) {\n        const options = this.options;\n        if (!options.isRegistered(name)) {\n          if (isNonNullable(type)) {\n            options.register(name, {\n              processor: type,\n              default: defaultVal\n            });\n          } else {\n            options.register(name, {\n              processor: always,\n              default: defaultVal\n            });\n          }\n        }\n        return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\n      }\n      hasPlugin(name, loaded) {\n        const hasPlugin = contains$2(getPlugins(this), name);\n        if (hasPlugin) {\n          return loaded ? PluginManager.get(name) !== undefined : true;\n        } else {\n          return false;\n        }\n      }\n      nodeChanged(args) {\n        this._nodeChangeDispatcher.nodeChanged(args);\n      }\n      addCommand(name, callback, scope) {\n        this.editorCommands.addCommand(name, callback, scope);\n      }\n      addQueryStateHandler(name, callback, scope) {\n        this.editorCommands.addQueryStateHandler(name, callback, scope);\n      }\n      addQueryValueHandler(name, callback, scope) {\n        this.editorCommands.addQueryValueHandler(name, callback, scope);\n      }\n      addShortcut(pattern, desc, cmdFunc, scope) {\n        this.shortcuts.add(pattern, desc, cmdFunc, scope);\n      }\n      execCommand(cmd, ui, value, args) {\n        return this.editorCommands.execCommand(cmd, ui, value, args);\n      }\n      queryCommandState(cmd) {\n        return this.editorCommands.queryCommandState(cmd);\n      }\n      queryCommandValue(cmd) {\n        return this.editorCommands.queryCommandValue(cmd);\n      }\n      queryCommandSupported(cmd) {\n        return this.editorCommands.queryCommandSupported(cmd);\n      }\n      show() {\n        const self = this;\n        if (self.hidden) {\n          self.hidden = false;\n          if (self.inline) {\n            self.getBody().contentEditable = 'true';\n          } else {\n            DOM$1.show(self.getContainer());\n            DOM$1.hide(self.id);\n          }\n          self.load();\n          self.dispatch('show');\n        }\n      }\n      hide() {\n        const self = this;\n        if (!self.hidden) {\n          self.save();\n          if (self.inline) {\n            self.getBody().contentEditable = 'false';\n            if (self === self.editorManager.focusedEditor) {\n              self.editorManager.focusedEditor = null;\n            }\n          } else {\n            DOM$1.hide(self.getContainer());\n            DOM$1.setStyle(self.id, 'display', self.orgDisplay);\n          }\n          self.hidden = true;\n          self.dispatch('hide');\n        }\n      }\n      isHidden() {\n        return this.hidden;\n      }\n      setProgressState(state, time) {\n        this.dispatch('ProgressState', {\n          state,\n          time\n        });\n      }\n      load(args = {}) {\n        const self = this;\n        const elm = self.getElement();\n        if (self.removed) {\n          return '';\n        }\n        if (elm) {\n          const loadArgs = {\n            ...args,\n            load: true\n          };\n          const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\n          const html = self.setContent(value, loadArgs);\n          if (!loadArgs.no_events) {\n            self.dispatch('LoadContent', {\n              ...loadArgs,\n              element: elm\n            });\n          }\n          return html;\n        } else {\n          return '';\n        }\n      }\n      save(args = {}) {\n        const self = this;\n        let elm = self.getElement();\n        if (!elm || !self.initialized || self.removed) {\n          return '';\n        }\n        const getArgs = {\n          ...args,\n          save: true,\n          element: elm\n        };\n        let html = self.getContent(getArgs);\n        const saveArgs = {\n          ...getArgs,\n          content: html\n        };\n        if (!saveArgs.no_events) {\n          self.dispatch('SaveContent', saveArgs);\n        }\n        if (saveArgs.format === 'raw') {\n          self.dispatch('RawSaveContent', saveArgs);\n        }\n        html = saveArgs.content;\n        if (!isTextareaOrInput(elm)) {\n          if (args.is_removing || !self.inline) {\n            elm.innerHTML = html;\n          }\n          const form = DOM$1.getParent(self.id, 'form');\n          if (form) {\n            each$1(form.elements, elm => {\n              if (elm.name === self.id) {\n                elm.value = html;\n                return false;\n              } else {\n                return true;\n              }\n            });\n          }\n        } else {\n          elm.value = html;\n        }\n        saveArgs.element = getArgs.element = elm = null;\n        if (saveArgs.set_dirty !== false) {\n          self.setDirty(false);\n        }\n        return html;\n      }\n      setContent(content, args) {\n        return setContent(this, content, args);\n      }\n      getContent(args) {\n        return getContent(this, args);\n      }\n      insertContent(content, args) {\n        if (args) {\n          content = extend({ content }, args);\n        }\n        this.execCommand('mceInsertContent', false, content);\n      }\n      resetContent(initialContent) {\n        if (initialContent === undefined) {\n          setContent(this, this.startContent, { format: 'raw' });\n        } else {\n          setContent(this, initialContent);\n        }\n        this.undoManager.reset();\n        this.setDirty(false);\n        this.nodeChanged();\n      }\n      isDirty() {\n        return !this.isNotDirty;\n      }\n      setDirty(state) {\n        const oldState = !this.isNotDirty;\n        this.isNotDirty = !state;\n        if (state && state !== oldState) {\n          this.dispatch('dirty');\n        }\n      }\n      getContainer() {\n        const self = this;\n        if (!self.container) {\n          self.container = self.editorContainer || DOM$1.get(self.id + '_parent');\n        }\n        return self.container;\n      }\n      getContentAreaContainer() {\n        return this.contentAreaContainer;\n      }\n      getElement() {\n        if (!this.targetElm) {\n          this.targetElm = DOM$1.get(this.id);\n        }\n        return this.targetElm;\n      }\n      getWin() {\n        const self = this;\n        if (!self.contentWindow) {\n          const elm = self.iframeElement;\n          if (elm) {\n            self.contentWindow = elm.contentWindow;\n          }\n        }\n        return self.contentWindow;\n      }\n      getDoc() {\n        const self = this;\n        if (!self.contentDocument) {\n          const win = self.getWin();\n          if (win) {\n            self.contentDocument = win.document;\n          }\n        }\n        return self.contentDocument;\n      }\n      getBody() {\n        var _a, _b;\n        const doc = this.getDoc();\n        return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;\n      }\n      convertURL(url, name, elm) {\n        const self = this, getOption = self.options.get;\n        const urlConverterCallback = getUrlConverterCallback(self);\n        if (isFunction(urlConverterCallback)) {\n          return urlConverterCallback.call(self, url, elm, true, name);\n        }\n        if (!getOption('convert_urls') || elm === 'link' || isObject(elm) && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\n          return url;\n        }\n        const urlObject = new URI(url);\n        if (urlObject.protocol !== 'http' && urlObject.protocol !== 'https' && urlObject.protocol !== '') {\n          return url;\n        }\n        if (getOption('relative_urls')) {\n          return self.documentBaseURI.toRelative(url);\n        }\n        url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\n        return url;\n      }\n      addVisual(elm) {\n        addVisual(this, elm);\n      }\n      setEditableRoot(state) {\n        setEditableRoot(this, state);\n      }\n      hasEditableRoot() {\n        return hasEditableRoot(this);\n      }\n      remove() {\n        remove$1(this);\n      }\n      destroy(automatic) {\n        destroy(this, automatic);\n      }\n      uploadImages() {\n        return this.editorUpload.uploadImages();\n      }\n      _scanForImages() {\n        return this.editorUpload.scanForImages();\n      }\n    }\n\n    const DOM = DOMUtils.DOM;\n    const each = Tools.each;\n    let boundGlobalEvents = false;\n    let beforeUnloadDelegate;\n    let editors = [];\n    const globalEventDelegate = e => {\n      const type = e.type;\n      each(EditorManager.get(), editor => {\n        switch (type) {\n        case 'scroll':\n          editor.dispatch('ScrollWindow', e);\n          break;\n        case 'resize':\n          editor.dispatch('ResizeWindow', e);\n          break;\n        }\n      });\n    };\n    const toggleGlobalEvents = state => {\n      if (state !== boundGlobalEvents) {\n        const DOM = DOMUtils.DOM;\n        if (state) {\n          DOM.bind(window, 'resize', globalEventDelegate);\n          DOM.bind(window, 'scroll', globalEventDelegate);\n        } else {\n          DOM.unbind(window, 'resize', globalEventDelegate);\n          DOM.unbind(window, 'scroll', globalEventDelegate);\n        }\n        boundGlobalEvents = state;\n      }\n    };\n    const removeEditorFromList = targetEditor => {\n      const oldEditors = editors;\n      editors = filter$5(editors, editor => {\n        return targetEditor !== editor;\n      });\n      if (EditorManager.activeEditor === targetEditor) {\n        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\n      }\n      if (EditorManager.focusedEditor === targetEditor) {\n        EditorManager.focusedEditor = null;\n      }\n      return oldEditors.length !== editors.length;\n    };\n    const purgeDestroyedEditor = editor => {\n      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\n        removeEditorFromList(editor);\n        editor.unbindAllNativeEvents();\n        editor.destroy(true);\n        editor.removed = true;\n      }\n    };\n    const isQuirksMode = document.compatMode !== 'CSS1Compat';\n    const EditorManager = {\n      ...Observable,\n      baseURI: null,\n      baseURL: null,\n      defaultOptions: {},\n      documentBaseURL: null,\n      suffix: null,\n      majorVersion: '6',\n      minorVersion: '8.3',\n      releaseDate: '2024-02-08',\n      i18n: I18n,\n      activeEditor: null,\n      focusedEditor: null,\n      setup() {\n        const self = this;\n        let baseURL = '';\n        let suffix = '';\n        let documentBaseURL = URI.getDocumentBaseUrl(document.location);\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\n          documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\n          if (!/[\\/\\\\]$/.test(documentBaseURL)) {\n            documentBaseURL += '/';\n          }\n        }\n        const preInit = window.tinymce || window.tinyMCEPreInit;\n        if (preInit) {\n          baseURL = preInit.base || preInit.baseURL;\n          suffix = preInit.suffix;\n        } else {\n          const scripts = document.getElementsByTagName('script');\n          for (let i = 0; i < scripts.length; i++) {\n            const src = scripts[i].src || '';\n            if (src === '') {\n              continue;\n            }\n            const srcScript = src.substring(src.lastIndexOf('/'));\n            if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\n              if (srcScript.indexOf('.min') !== -1) {\n                suffix = '.min';\n              }\n              baseURL = src.substring(0, src.lastIndexOf('/'));\n              break;\n            }\n          }\n          if (!baseURL && document.currentScript) {\n            const src = document.currentScript.src;\n            if (src.indexOf('.min') !== -1) {\n              suffix = '.min';\n            }\n            baseURL = src.substring(0, src.lastIndexOf('/'));\n          }\n        }\n        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\n        self.documentBaseURL = documentBaseURL;\n        self.baseURI = new URI(self.baseURL);\n        self.suffix = suffix;\n        setup$w(self);\n      },\n      overrideDefaults(defaultOptions) {\n        const baseUrl = defaultOptions.base_url;\n        if (baseUrl) {\n          this._setBaseUrl(baseUrl);\n        }\n        const suffix = defaultOptions.suffix;\n        if (suffix) {\n          this.suffix = suffix;\n        }\n        this.defaultOptions = defaultOptions;\n        const pluginBaseUrls = defaultOptions.plugin_base_urls;\n        if (pluginBaseUrls !== undefined) {\n          each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\n            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\n          });\n        }\n      },\n      init(options) {\n        const self = this;\n        let result;\n        const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\n        const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\n        const createId = elm => {\n          let id = elm.id;\n          if (!id) {\n            id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\n            elm.setAttribute('id', id);\n          }\n          return id;\n        };\n        const execCallback = name => {\n          const callback = options[name];\n          if (!callback) {\n            return;\n          }\n          return callback.apply(self, []);\n        };\n        const findTargets = options => {\n          if (Env.browser.isIE() || Env.browser.isEdge()) {\n            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers');\n            return [];\n          } else if (isQuirksMode) {\n            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\n            return [];\n          } else if (isString(options.selector)) {\n            return DOM.select(options.selector);\n          } else if (isNonNullable(options.target)) {\n            return [options.target];\n          } else {\n            return [];\n          }\n        };\n        let provideResults = editors => {\n          result = editors;\n        };\n        const initEditors = () => {\n          let initCount = 0;\n          const editors = [];\n          let targets;\n          const createEditor = (id, options, targetElm) => {\n            const editor = new Editor(id, options, self);\n            editors.push(editor);\n            editor.on('init', () => {\n              if (++initCount === targets.length) {\n                provideResults(editors);\n              }\n            });\n            editor.targetElm = editor.targetElm || targetElm;\n            editor.render();\n          };\n          DOM.unbind(window, 'ready', initEditors);\n          execCallback('onpageload');\n          targets = unique$1(findTargets(options));\n          Tools.each(targets, elm => {\n            purgeDestroyedEditor(self.get(elm.id));\n          });\n          targets = Tools.grep(targets, elm => {\n            return !self.get(elm.id);\n          });\n          if (targets.length === 0) {\n            provideResults([]);\n          } else {\n            each(targets, elm => {\n              if (isInvalidInlineTarget(options, elm)) {\n                initError('Could not initialize inline editor on invalid inline target element', elm);\n              } else {\n                createEditor(createId(elm), options, elm);\n              }\n            });\n          }\n        };\n        DOM.bind(window, 'ready', initEditors);\n        return new Promise(resolve => {\n          if (result) {\n            resolve(result);\n          } else {\n            provideResults = editors => {\n              resolve(editors);\n            };\n          }\n        });\n      },\n      get(id) {\n        if (arguments.length === 0) {\n          return editors.slice(0);\n        } else if (isString(id)) {\n          return find$2(editors, editor => {\n            return editor.id === id;\n          }).getOr(null);\n        } else if (isNumber(id)) {\n          return editors[id] ? editors[id] : null;\n        } else {\n          return null;\n        }\n      },\n      add(editor) {\n        const self = this;\n        const existingEditor = self.get(editor.id);\n        if (existingEditor === editor) {\n          return editor;\n        }\n        if (existingEditor === null) {\n          editors.push(editor);\n        }\n        toggleGlobalEvents(true);\n        self.activeEditor = editor;\n        self.dispatch('AddEditor', { editor });\n        if (!beforeUnloadDelegate) {\n          beforeUnloadDelegate = e => {\n            const event = self.dispatch('BeforeUnload');\n            if (event.returnValue) {\n              e.preventDefault();\n              e.returnValue = event.returnValue;\n              return event.returnValue;\n            }\n          };\n          window.addEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        return editor;\n      },\n      createEditor(id, options) {\n        return this.add(new Editor(id, options, this));\n      },\n      remove(selector) {\n        const self = this;\n        let editor;\n        if (!selector) {\n          for (let i = editors.length - 1; i >= 0; i--) {\n            self.remove(editors[i]);\n          }\n          return;\n        }\n        if (isString(selector)) {\n          each(DOM.select(selector), elm => {\n            editor = self.get(elm.id);\n            if (editor) {\n              self.remove(editor);\n            }\n          });\n          return;\n        }\n        editor = selector;\n        if (isNull(self.get(editor.id))) {\n          return null;\n        }\n        if (removeEditorFromList(editor)) {\n          self.dispatch('RemoveEditor', { editor });\n        }\n        if (editors.length === 0) {\n          window.removeEventListener('beforeunload', beforeUnloadDelegate);\n        }\n        editor.remove();\n        toggleGlobalEvents(editors.length > 0);\n        return editor;\n      },\n      execCommand(cmd, ui, value) {\n        var _a;\n        const self = this;\n        const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\n        switch (cmd) {\n        case 'mceAddEditor': {\n            if (!self.get(editorId)) {\n              const editorOptions = value.options;\n              new Editor(editorId, editorOptions, self).render();\n            }\n            return true;\n          }\n        case 'mceRemoveEditor': {\n            const editor = self.get(editorId);\n            if (editor) {\n              editor.remove();\n            }\n            return true;\n          }\n        case 'mceToggleEditor': {\n            const editor = self.get(editorId);\n            if (!editor) {\n              self.execCommand('mceAddEditor', false, value);\n              return true;\n            }\n            if (editor.isHidden()) {\n              editor.show();\n            } else {\n              editor.hide();\n            }\n            return true;\n          }\n        }\n        if (self.activeEditor) {\n          return self.activeEditor.execCommand(cmd, ui, value);\n        }\n        return false;\n      },\n      triggerSave: () => {\n        each(editors, editor => {\n          editor.save();\n        });\n      },\n      addI18n: (code, items) => {\n        I18n.add(code, items);\n      },\n      translate: text => {\n        return I18n.translate(text);\n      },\n      setActive(editor) {\n        const activeEditor = this.activeEditor;\n        if (this.activeEditor !== editor) {\n          if (activeEditor) {\n            activeEditor.dispatch('deactivate', { relatedTarget: editor });\n          }\n          editor.dispatch('activate', { relatedTarget: activeEditor });\n        }\n        this.activeEditor = editor;\n      },\n      _setBaseUrl(baseUrl) {\n        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\n        this.baseURI = new URI(this.baseURL);\n      }\n    };\n    EditorManager.setup();\n\n    const setup = () => {\n      const dataValue = value$2();\n      const FakeClipboardItem = items => ({\n        items,\n        types: keys(items),\n        getType: type => get$a(items, type).getOrUndefined()\n      });\n      const write = data => {\n        dataValue.set(data);\n      };\n      const read = () => dataValue.get().getOrUndefined();\n      const clear = dataValue.clear;\n      return {\n        FakeClipboardItem,\n        write,\n        read,\n        clear\n      };\n    };\n    const FakeClipboard = setup();\n\n    const min = Math.min, max = Math.max, round = Math.round;\n    const relativePosition = (rect, targetRect, rel) => {\n      let x = targetRect.x;\n      let y = targetRect.y;\n      const w = rect.w;\n      const h = rect.h;\n      const targetW = targetRect.w;\n      const targetH = targetRect.h;\n      const relChars = (rel || '').split('');\n      if (relChars[0] === 'b') {\n        y += targetH;\n      }\n      if (relChars[1] === 'r') {\n        x += targetW;\n      }\n      if (relChars[0] === 'c') {\n        y += round(targetH / 2);\n      }\n      if (relChars[1] === 'c') {\n        x += round(targetW / 2);\n      }\n      if (relChars[3] === 'b') {\n        y -= h;\n      }\n      if (relChars[4] === 'r') {\n        x -= w;\n      }\n      if (relChars[3] === 'c') {\n        y -= round(h / 2);\n      }\n      if (relChars[4] === 'c') {\n        x -= round(w / 2);\n      }\n      return create$2(x, y, w, h);\n    };\n    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\n      for (let i = 0; i < rels.length; i++) {\n        const pos = relativePosition(rect, targetRect, rels[i]);\n        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\n          return rels[i];\n        }\n      }\n      return null;\n    };\n    const inflate = (rect, w, h) => {\n      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\n    };\n    const intersect = (rect, cropRect) => {\n      const x1 = max(rect.x, cropRect.x);\n      const y1 = max(rect.y, cropRect.y);\n      const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\n      const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\n      if (x2 - x1 < 0 || y2 - y1 < 0) {\n        return null;\n      }\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const clamp = (rect, clampRect, fixedSize) => {\n      let x1 = rect.x;\n      let y1 = rect.y;\n      let x2 = rect.x + rect.w;\n      let y2 = rect.y + rect.h;\n      const cx2 = clampRect.x + clampRect.w;\n      const cy2 = clampRect.y + clampRect.h;\n      const underflowX1 = max(0, clampRect.x - x1);\n      const underflowY1 = max(0, clampRect.y - y1);\n      const overflowX2 = max(0, x2 - cx2);\n      const overflowY2 = max(0, y2 - cy2);\n      x1 += underflowX1;\n      y1 += underflowY1;\n      if (fixedSize) {\n        x2 += underflowX1;\n        y2 += underflowY1;\n        x1 -= overflowX2;\n        y1 -= overflowY2;\n      }\n      x2 -= overflowX2;\n      y2 -= overflowY2;\n      return create$2(x1, y1, x2 - x1, y2 - y1);\n    };\n    const create$2 = (x, y, w, h) => {\n      return {\n        x,\n        y,\n        w,\n        h\n      };\n    };\n    const fromClientRect = clientRect => {\n      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\n    };\n    const Rect = {\n      inflate,\n      relativePosition,\n      findBestRelativePosition,\n      intersect,\n      clamp,\n      create: create$2,\n      fromClientRect\n    };\n\n    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {\n      let done = false;\n      let timer = null;\n      const complete = completer => (...args) => {\n        if (!done) {\n          done = true;\n          if (timer !== null) {\n            clearTimeout(timer);\n            timer = null;\n          }\n          completer.apply(null, args);\n        }\n      };\n      const resolve = complete(resolveCb);\n      const reject = complete(rejectCb);\n      const start = (...args) => {\n        if (!done && timer === null) {\n          timer = setTimeout(() => reject.apply(null, args), timeout);\n        }\n      };\n      return {\n        start,\n        resolve,\n        reject\n      };\n    };\n    const create$1 = () => {\n      const tasks = {};\n      const resultFns = {};\n      const resources = {};\n      const load = (id, url) => {\n        const loadErrMsg = `Script at URL \"${ url }\" failed to load`;\n        const runErrMsg = `Script at URL \"${ url }\" did not call \\`tinymce.Resource.add('${ id }', data)\\` within 1 second`;\n        if (tasks[id] !== undefined) {\n          return tasks[id];\n        } else {\n          const task = new Promise((resolve, reject) => {\n            const waiter = awaiter(resolve, reject);\n            resultFns[id] = waiter.resolve;\n            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\n          });\n          tasks[id] = task;\n          return task;\n        }\n      };\n      const add = (id, data) => {\n        if (resultFns[id] !== undefined) {\n          resultFns[id](data);\n          delete resultFns[id];\n        }\n        tasks[id] = Promise.resolve(data);\n        resources[id] = data;\n      };\n      const has = id => {\n        return id in resources;\n      };\n      const unload = id => {\n        delete tasks[id];\n      };\n      const get = id => resources[id];\n      return {\n        load,\n        add,\n        has,\n        get,\n        unload\n      };\n    };\n    const Resource = create$1();\n\n    const create = () => (() => {\n      let data = {};\n      let keys = [];\n      const storage = {\n        getItem: key => {\n          const item = data[key];\n          return item ? item : null;\n        },\n        setItem: (key, value) => {\n          keys.push(key);\n          data[key] = String(value);\n        },\n        key: index => {\n          return keys[index];\n        },\n        removeItem: key => {\n          keys = keys.filter(k => k === key);\n          delete data[key];\n        },\n        clear: () => {\n          keys = [];\n          data = {};\n        },\n        length: 0\n      };\n      Object.defineProperty(storage, 'length', {\n        get: () => keys.length,\n        configurable: false,\n        enumerable: false\n      });\n      return storage;\n    })();\n\n    let localStorage;\n    try {\n      const test = '__storage_test__';\n      localStorage = window.localStorage;\n      localStorage.setItem(test, test);\n      localStorage.removeItem(test);\n    } catch (e) {\n      localStorage = create();\n    }\n    var LocalStorage = localStorage;\n\n    const publicApi = {\n      geom: { Rect },\n      util: {\n        Delay,\n        Tools,\n        VK,\n        URI,\n        EventDispatcher,\n        Observable,\n        I18n,\n        LocalStorage,\n        ImageUploader\n      },\n      dom: {\n        EventUtils,\n        TreeWalker: DomTreeWalker,\n        TextSeeker,\n        DOMUtils,\n        ScriptLoader,\n        RangeUtils,\n        Serializer: DomSerializer,\n        StyleSheetLoader,\n        ControlSelection,\n        BookmarkManager,\n        Selection: EditorSelection,\n        Event: EventUtils.Event\n      },\n      html: {\n        Styles,\n        Entities,\n        Node: AstNode,\n        Schema,\n        DomParser,\n        Writer,\n        Serializer: HtmlSerializer\n      },\n      Env,\n      AddOnManager,\n      Annotator,\n      Formatter,\n      UndoManager,\n      EditorCommands,\n      WindowManager,\n      NotificationManager,\n      EditorObservable,\n      Shortcuts,\n      Editor,\n      FocusManager,\n      EditorManager,\n      DOM: DOMUtils.DOM,\n      ScriptLoader: ScriptLoader.ScriptLoader,\n      PluginManager,\n      ThemeManager,\n      ModelManager,\n      IconManager,\n      Resource,\n      FakeClipboard,\n      trim: Tools.trim,\n      isArray: Tools.isArray,\n      is: Tools.is,\n      toArray: Tools.toArray,\n      makeMap: Tools.makeMap,\n      each: Tools.each,\n      map: Tools.map,\n      grep: Tools.grep,\n      inArray: Tools.inArray,\n      extend: Tools.extend,\n      walk: Tools.walk,\n      resolve: Tools.resolve,\n      explode: Tools.explode,\n      _addCacheSuffix: Tools._addCacheSuffix\n    };\n    const tinymce$1 = Tools.extend(EditorManager, publicApi);\n\n    const exportToModuleLoaders = tinymce => {\n      if (typeof module === 'object') {\n        try {\n          module.exports = tinymce;\n        } catch (_) {\n        }\n      }\n    };\n    const exportToWindowGlobal = tinymce => {\n      window.tinymce = tinymce;\n      window.tinyMCE = tinymce;\n    };\n    exportToWindowGlobal(tinymce$1);\n    exportToModuleLoaders(tinymce$1);\n\n})();\n"],"names":["typeOf$1","x","undefined","t","Array","prototype","isPrototypeOf","constructor","name","String","eq$2","f","eq","eqString","y","eqArray","eqa","length","len","i","eqSortedArray","compareFn","contramap","xs","slice","call","sort","sort$1","eqRecord","kx","Object","keys","ky","q","eqAny","tx","indexOf","isEquatableType","getPrototypeOf$2","getPrototypeOf","hasProto","v","predicate","_a","isType$1","type","value","isArray","o","proto","typeOf","isSimpleType","eq$1","a","is$4","isObject","isString","isPlainObject","isArray$1","isNull","isBoolean","isUndefined","isNullable","isNonNullable","isFunction","isNumber","isArrayOf","pred","noop","compose","fa","fb","args","apply","compose1","fbc","fab","constant","identity","tripleEquals","b","curry","fn","initialArgs","restArgs","all","concat","not","die","msg","Error","apply$1","never","always","Optional","tag","singletonNone","fold","onNone","onSome","this","isSome","isNone","map","mapper","some","none","bind","binder","exists","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","getOrNull","getOrUndefined","each","worker","toArray","toString","nativeSlice","nativeIndexOf","nativePush","push","rawIndexOf","ts","contains$2","map$3","r","each$e","eachr","partition$2","pass","fail","filter$5","foldr","acc","foldl","findUntil$1","until","find$2","findIndex$2","flatten","bind$3","reverse","difference","a1","a2","mapToObject","comparator","copy","get$b","head","last$3","from","findMap","arr","hasOwnProperty$1","hasOwnProperty","each$d","obj","props","k","map$2","tupleMap","tuple","objAcc","internalFilter","onTrue","onFalse","filter$4","mapToArray","values","get$a","key","has$2","hasNonNullableKey","stringArray","isArrayLike","each$c","cb","s","n","l","map$1","array","callback","out","item","index","filter$3","reduce","collection","iteratee","accumulator","thisArg","findIndex$1","last$2","cached","called","unknown$2","nu$3","major","minor","Version","nu","detect","versionRegexes","agent","cleanedAgent","toLowerCase","regexes","test","firstMatch","group","Number","replace","find$1","unknown","detect$4","candidates","userAgent","candidate","search","checkRange","str","substr","start","removeLeading","prefix","startsWith","numChars","substring","removeFromStart","contains$1","end","idx","endsWith","suffix","blank","trim$4","lTrim","rTrim","isNotEmpty","isEmpty$3","repeat","count","join","toInt","radix","num","parseInt","isNaN","normalVersionRegex","checkContains","target","uastring","browsers","brand","oses","PlatformInfo","nu$2","info","current","version","isBrowser","isEdge","isChromium","isIE","isOpera","isFirefox","isSafari","Browser","edge","chromium","ie","opera","firefox","safari","nu$1","isOS","isWindows","isiOS","isAndroid","isMacOS","isLinux","isSolaris","isFreeBSD","isChromeOS","OperatingSystem","windows","ios","android","linux","macos","solaris","freebsd","chromeos","PlatformDetection","userAgentDataOpt","mediaMatch","browser","userAgentData","brands","uaBrand","lcBrand","detectBrowser$1","detectBrowser","os","detectOs","deviceType","isiPad","isiPhone","isMobile","isTouch","isTablet","isPhone","iOSwebview","isDesktop","isWebView","DeviceType","query","window","matchMedia","matches","platform$4","navigator","detect$2","platform$3","browser$3","os$1","windowsPhone","Env","transparentSrc","documentMode","document","cacheSuffix","container","canHaveCSP","whiteSpaceRegExp$1","trim$3","walk$4","Tools","trim","is","makeMap","items","delim","resolvedItems","split","grep","inArray","hasOwn","extend","ext","walk","resolve","path","explode","d","_addCacheSuffix","url","is$2","lhs","rhs","left","equals","lift2","oa","ob","someIf","Global","Function","resolve$2","p","scope","parts","actual","unsafe","getPrototypeOf$1","sandHTMLElement","element","dom","nodeName","type$1","nodeType","isType","isHTMLElement$1","isElement$7","isText$b","isDocument$2","isDocumentFragment$1","isTag","e","rawSet","console","error","setAttribute","set$3","setAll$1","attrs","get$9","getAttribute","getOpt","has$1","hasAttribute","remove$a","removeAttribute","clone$4","attributes","attr","read$4","supports","classList","get$8","add$3","clazz","id","add$4","remove$8","remove$9","add$2","add","cleanClass","remove$7","remove","toggle$1","result","toggle","toggle$2","has","contains","fromDom$2","node","SugarElement","fromHtml","html","div","createElement","innerHTML","hasChildNodes","childNodes","fromTag","fromText","text","createTextNode","fromDom","fromPoint","docElm","elementFromPoint","recurse","cur","is$1","selector","elem","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","bypassSelector","childElementCount","e1","e2","d1","d2","owner$1","ownerDocument","documentOrOwner","dos","defaultView","parent","parentNode","parentElement","parents$1","isRoot","stop","ret","rawParent","siblings","children$1","elements","prevSibling","previousSibling","nextSibling","prevSiblings","nextSiblings","child$1","cs","firstChild","lastChild","childNodesCount","isShadowRoot","host","supported","Element","attachShadow","Node","getRootNode","isSupported$1","getStyleContainer","doc","getHead","getShadowHost","getOriginalEventTarget","event","el","isOpenShadowHost","composed","composedPath","shadowRoot","inBody","getShadowRoot","body","ClosestOrAncestor","ancestor","ancestor$4","closest$4","child","descendant$2","descend","res","ancestor$3","descendant$1","base","querySelector","one","closest$3","closest$2","isEditable$2","assumeEditable","isContentEditable","editable","getRaw$1","contentEditable","isSupported","style","getPropertyValue","internalSet","property","setProperty","set$2","setAll","css","get$7","getComputedStyle","getUnsafeProperty","getRaw","raw","getAllRaw","ruleName","remove$6","removeProperty","internalRemove","before$3","marker","insertBefore","after$4","append$1","prepend","appendChild","wrap$2","wrapper","append","empty","textContent","rogue","remove$5","removeChild","unwrap","children","fromDom$1","nodes","get$6","set$1","content","docDom","fragment","createDocumentFragment","contentElements","getOuter","clone","cloneNode","handle$1","handler","rawEvent","stopPropagation","prevent","preventDefault","kill","mkEvent","clientX","clientY","fromRawEvent","bind$2","useCapture","wrapped","addEventListener","unbind","removeEventListener","top","translate","SugarPosition","firstDefinedOrZero","viewport","offsetLeft","offsetTop","box","getBoundingClientRect","boxPosition","get$5","_DOC","scrollLeft","documentElement","scrollTop","to","win","scrollTo","intoView","alignToTop","scrollIntoViewIfNeeded","scrollIntoView","bounds","width","height","right","bottom","getBounds","_win","scroll","visualViewport","get$4","clientWidth","clientHeight","Math","max","pageLeft","pageTop","descendants$1","descendants","querySelectorAll","ancestor$2","DomTreeWalker","startNode","rootNode","next","prev","prev2","shallow","findSibling","findPreviousNode","startName","siblingName","sibling","isNodeType","isRestrictedNode","isElement$6","isHTMLElement","isSVGElement","namespaceURI","matchNodeName","lowerCasedName","matchNodeNames","names","lowerCasedNames","matchStyleValues","computed","attrName","isBogus$2","isTable$2","tagName","hasContentEditableState","isTextareaOrInput","isText$a","isCData","isPi","isComment","isDocument$1","isDocumentFragment","isBr$6","isImg","isContentEditableTrue$3","isContentEditableFalse$b","isTableCell$3","isTableCellOrCaption","isMedia$2","isListItem$2","isDetails","isSummary$1","isZwsp$2","char","api$1","getOption","nodeValue","get","set","NodeValue","get$3","lazyLookup","lookup","isBr$5","isTextBlock$2","isList","isListItem$1","isTableSection","isTableCell$2","isWsPreserveElement","removeTrailingBr","elm","allBrs","brs","rawNode","getLastChildren$1","createPaddingBr","br","fillWithPaddingBr","isZwsp$1","trim$2","isElement$5","isText$9","isCaretContainerBlock$1","isCaretContainerInline","data","isCaretContainer$2","hasContent","isBeforeInline","pos","charAt","offset","isAtStart","isAfterInline","isAtEnd","startsWithCaretContainer$1","endsWithCaretContainer$1","showCaretContainerBlock","caretContainer","getElementsByTagName","lastBr","trimBogusBr","isRangeInCaretContainerBlock","range","startContainer","isContentEditableTrue$2","isContentEditableFalse$a","isBr$4","isText$8","isInvalidTextElement","isAtomicInline","isTable","isCaretContainer$1","isCaretCandidate$3","isNonUiContentEditableFalse","isUnselectable","isEditableCaretCandidate$1","root","tempNode","isInEditable","whiteSpaceRegExp","isWhitespaceText","isZwsp","c","isCollapsibleWhitespace$1","isNewLineChar","isNewline","normalize$4","tabSpaces","isStartOfContent","isEndOfContent","tabSpace","normalizedText","pcIsSpace","isWhitespace$1","rootElement","hasWhitespacePreserveParent","isContent$1","isNamedAnchor","isBookmark","isBogus$1","isBogusAll","attrValue","hasNonEditableParent","isEmptyNode","targetNode","skipBogus","brCount","walker","isEmpty$2","isNonHtmlElementRootName","isNonHtmlElementRoot","toScopeType","namespaceElements","makeSelectorFromSchemaMap","elementNames","ns","updateTransparent","blocksSelector","transparent","updateBlockStateOnChildren","schema","transparentSelector","getTransparentElements","getBlockElements","trimEdge","leftSide","childPropertyName","splitInvalidChildren","transparentBlocks","blocksElements","isBlock","transparentBlock","parentBlock","invalidChildren","isValidChild","stateScope","parentElm","splitElm","createRange","setStartBefore","setEndBefore","beforeFragment","extractContents","setStartAfter","setEndAfter","afterFragment","split$2","updateChildren","isTransparentBlock","block","isTransparentInline","unwrapInvalidChildren","updateElement","isTransparentElement","hasBlockAttr","isTransparentElementName","isTransparentAstBlock","browser$2","firstElement","hasChild","getPos","rootElm","clientLeft","clientTop","offsetParent","castOffsetParent","caption","bodyTop","captionTop","captionHeight","offsetHeight","getTableCaptionDeltaY","StyleSheetLoader","documentOrShadowRoot","settings","idCount","loadedStates","edos","_setReferrerPolicy","referrerPolicy","_setContentCssCors","contentCssCors","addStyle","removeStyle","styleContainer","getOrCreateState","passed","failed","load","Promise","success","failure","link","urlWithSuffix","state","callbacks","status","onload","onerror","linkElem","rel","loadRawCss","styleElem","loadAll","urls","allSettled","then","results","reject","reason","unload","unloadRawCss","unloadAll","instance","WeakMap","forElement","referenceElement","rootDom","sl","create$d","isInlineContent","isInline","isBookmarkNode$2","isSpan","isKeepTextNode","prevIsInline","nextIsInline","surroundedByInlineContent","trimNode","currentChildren","isDocument","isKeepElement","makeMap$3","attrsCharsRegExp","textCharsRegExp","rawCharsRegExp","entityRegExp","asciiMap","baseEntities","reverseEntities","buildEntitiesLookup","itemList","chr","fromCharCode","entity","namedEntities","encodeRaw","encodeNumeric","charCodeAt","encodeNamed","entities","resolveEntities","Entities","encodeAllRaw","getEncodeFunc","entitiesMap","encodeNamedAndNumeric","encodeCustomNamed","nameMap","named","numeric","decode","innerText","nativeDecode","split$1","patternToRegExp","RegExp","parseCustomElementsRules","customElementRegExp","rule","exec","inline","cloneName","makeSchema","globalAttributes","phrasingContent","flowContent","blockContent","getElementSetsAsStrings","addElement","attributesOrder","childNames","ni","allAttributes","addAttrs","schemaItem","video","audio","table","script","parseValidChildrenRules","childRuleRegExp","operation","prefixToOperation","validChildren","parseValidElementsRules","globalElement","validElements","elementRuleRegExp","elementName","outputName","attrsPrefix","attrData","cloneAttributesInto","paddEmpty","removeEmpty","removeEmptyAttrs","targetElement","attrRuleRegExp","hasPatternsRegExp","attrType","attrPrefix","attributesRequired","required","splice","attributesDefault","defaultValue","attributesForced","forcedValue","validValues","attrPattern","attributePatterns","pattern","parseValidElementsAttrDataIntoElement","aliasName","mapCache","makeMap$2","each$b","extend$2","explode$2","createMap","extendWith","toUpperCase","getTextRootBlockElements","getTextBlockElements","compileElementMap","mode","styles","Schema","patternElements","customElementsMap","specialElements","createLookupTable","option","newValue","schemaType","schemaItems","verify_html","valid_elements","validStyles","valid_styles","invalidStyles","invalid_styles","validClasses","valid_classes","whitespaceElementsMap","selfClosingElementsMap","voidElementsMap","boolAttrMap","nonEmptyOrMoveCaretBeforeOnEnter","nonEmptyElementsMap","moveCaretBeforeOnEnterElementsMap","headings","textBlockElementsMap","blockElementsMap","textInlineElementsMap","transparentElementsMap","wrapBlockElementsMap","addValidElements","_ref","patternElement","setValidElements","addCustomElements","customElements","text_block_elements","block_elements","_ref2","customRule","elmName","addValidChildren","_ref3","getElementRule","_val","padd_empty_block_inline_children","paddInEmptyBlock","svg","custom_elements","valid_children","extended_valid_elements","dd","dt","li","td","th","tr","tbody","thead","tfoot","legend","area","param","parents","parentsRequired","invalid_elements","getValidStyles","getInvalidStyles","getValidClasses","getBoolAttrs","getTextInlineElements","getVoidElements","seal","getSelfClosingElements","getNonEmptyElements","getMoveCaretBeforeOnEnterElements","getWhitespaceElements","getWrapBlockElements","getSpecialElements","isValid","attrPatterns","isWrapper","getCustomElements","normalizeHex","hex","toHex","component","fromRgba","rgbaColour","hexColour","red","green","blue","rgbRegex","rgbaRegex","alpha","fromStringValues","g","parseFloat","fromString","rgbaString","rgbMatch","rgbaMatch","rgba","rgbaToHexString","color","h","Styles","urlOrStrRegExp","styleRegExp","trimRightRegExp","encodingLookup","invisibleChar","encodingItems","self","parse","isEncoded","urlConverter","url_converter","urlConverterScope","url_converter_scope","compress","noJoin","canCompress","encode","keepSlashes","decodeSingleHexSequence","escSeq","decodeHexSequences","processUrl","match","url2","url3","str2","allow_script_urls","scriptUrl","allow_svg_data_urls","lastIndex","force_hex_color","border","serialize","serializeStyles","elemName","validStyleList","styleList","styleMap","deprecated","keyLocation","layerX","layerY","returnValue","webkitMovementX","webkitMovementY","keyIdentifier","mozPressure","needsNormalizing","Event","initEvent","isNativeEvent","clone$3","originalEvent","getModifierState","keyArg","getTargetRanges","normalize$3","fallbackTarget","srcElement","defaultPrevented","isDefaultPrevented","cancelBubble","isPropagationStopped","stopImmediatePropagation","isImmediatePropagationStopped","hasIsDefaultPrevented","mouseEventRe","addEvent","capture","removeEvent","fix","isMouseEvent","pageX","eventDoc","mouseEvent","pageY","bindOnReady","eventUtils","domLoaded","readyHandler","readyState","EventUtils","events","expando","Date","hasFocusIn","callbackList","defaultNativeHandler","evt","executeHandlers","namesList","nativeHandler","fakeName","func","eventMap","ci","newCallbackList","ex","fire","dispatch","parentWindow","clean","destroy","cancel","each$a","numericalCssMap","legacySetAttribute","camelCaseToHyphens","findNodeIndex","normalized","lastNodeType","updateInternalStyleAttr","rawValue","applyStyle$1","$elm","cssName","cssValue","normalizedName","convertStyleToString","setupAttrHooks","getContext","keepValues","keep_values","keepUrlHook","sugarElm","attrHooks","href","src","DOMUtils","addedStyles","files","counter","stdMode","boxModel","styleSheetLoader","boundEvents","ownEvents","getElementById","_get","getAttrib","defaultVal","hook","getAttribs","setAttrib","run","val","originalValue","onSetAttrib","attrElm","deep","getRoot","root_element","getViewPort","argWin","vp","w","getPos$1","setStyle","update_styles","setStyles","stylesArg","getStyle","getSize","offsetWidth","getRect","size","elms","getParents","collect","resolvedRoot","selectorVal","getParent","_findSib","getNext","getPrev","isParentNode","select","_b","context","setAttribs","setHTML","create","newElm","createHTML","outHtml","createFragment","frag","keepChildren","$node","removeAllAttribs","removeAttributeNode","parseStyle","cssText","serializeStyle","DOM","styleElm","styleSheet","loadCSS","catch","toggleClass","cls","classes","addClass","removeClass","hasClass","show","hide","isHidden","uniqueId","getOuterHTML","outerHTML","setOuterHTML","insertAfter","reference","referenceNode","oldElm","replacee","replaceChild","rename","attrNode","findCommonAncestor","ps","pe","isNonEmptyElement","isEmpty","options","whitespaceElements","nonEmptyElements","bogusVal","includeZwsp","createRng","replacementElm","setStart","setEnd","rv","boundTarget","boundName","boundFunc","getContentEditable","getContentEditableParent","isEditable","_","isChildOf","dumpRng","startOffset","endContainer","endOffset","nodeIndex","DOM$b","ScriptLoader","states","queue","scriptLoadedCallbacks","queueLoadedCallbacks","loading","loadScript","cleanup","isDone","markDone","loadQueue","loadScripts","scripts","execCallbacks","processResults","failures","_ref4","processQueue","nextQueuedItem","shift","uniqueScripts","Cell","initial","currentCode","getLanguageData","I18n","getData","setCode","newCode","getCode","code","langData","lcNames","translation","lcName","firstIndex","isDuplicated","getLangData","textStr","removeContext","isTokenised","$1","$2","isRtl","dir","hasCode","AddOnManager","_listeners","runListeners","matchedListeners","listener","isLoaded","isAdded","loadLanguagePack","languages","language","waitFor","requireLangPack","languageLoad","addOn","createUrl","baseUrl","dep","resource","addOnUrl","urlString","baseURL","lastIndexOf","done","PluginManager","ThemeManager","ModelManager","repeatable","delay","intervalId","revoke","clearInterval","clear","isSet","functionToRepeat","setInterval","value$2","subject","doRevoke","singleton","on","first$1","rate","timer","clearTimeout","throttle","setTimeout","last$1","annotation","dataAnnotation","dataAnnotationId","dataAnnotationActive","dataAnnotationClasses","dataAnnotationAttributes","isRoot$1","identify","editor","annotationName","rng","selection","getRng","getBody","an","newStart","uid","findMarkers","isBogusElement","descendant","findAll","markers","directory","m","nodesAlready","setup$y","registry","changeCallbacks","initData","listeners","previous","withCallbacks","updateCallbacks","callbackMap","outputData","toggleActiveAttr","onNodeChange","annotations","getNames","fireNoAnnotation","_ref5","fireCallbacks","addListener","unique","generate$1","time","getTime","random","floor","clone$2","original","isDeep","shallow$1","deep$1","mutate","shallowAs","TextWalker","isBoundary","direction","TextSeeker","isBlockBoundary","process","newOffset","backwards","forwards","round$2","round","clone$1","rect","collapse","toStart","isValidOverflow","overflowY","rect1","rect2","min","isAbove$1","halfHeight","isBelow$1","distanceToRectEdgeFromXY","cx","cy","sqrt","getSelectedNode","getNode$1","safeOffset","clamp$2","extendingChars","isExtendingChar","ch","isElement$4","isCaretCandidate$2","isBlock$2","isFloated","isValidElementCaretCandidate","and","isNotPre","isText$7","isBr$3","nodeIndex$1","resolveIndex$1","createRange$1","isWhiteSpace$1","isRange","isHiddenWhiteSpaceRange","isZeroRect","getBoundingClientRect$1","clientRect","clientRects","getClientRects","brNode","nbsp$1","getBrClientRect","sc","ec","so","eo","newRng","cloneRange","getBoundingClientRectWebKitText","collapseAndInflateWidth","newClientRect","getCaretPositionClientRects","caretPosition","addUniqueAndValidRect","addCharacterOffset","beforeNode","CaretPosition","toRange","isVisible","isEqual","getNode","before","fromRangeStart","fromRangeEnd","after","isAbove","pos1","pos2","isBelow","isTextPosition","isElementPosition","trimEmptyTextNode$1","rangeInsertNode","insertNode","insertFragment","isText$6","isBogus","normalizedParent","getChildNodes","equal","createPathItem","numTextFragments","normalizedNodeIndex","create$b","outputOffset","normalizedTextOffset","parentsUntil$1","resolve$1","paths","resolvePathItem","nodeOffset","targetOffset","dataLen","findTextPosition","isContentEditableFalse$9","getPoint","point","trimmedOffset","getNormalizedTextOffset$1","findIndex","moveEndPoint$1","normalizeTableCellSelection","getOffsetBookmark","findAdjacentContentEditableFalseElm","forward","isForward","fakeCaret","isFakeCaret","isCollapsed","getLocation","getCaretBookmark","getRangeBookmark","createBookmarkSpan","filled","getPersistentBookmark","collapsed","rng2","endBookmarkNode","startBookmarkNode","moveToBookmark","keep","getUndoBookmark","value$1","applyHelper","constHelper","outputHelper","output","inner","_onError","onValue","isValue","isError","Result","mapError","toOptional","onError","_onValue","fromOption","optional","err","Adt","cases","constructors","adt","acase","keys$1","argLength","branches","branchKeys","reqKey","foldArgs","log","label","params","bothErrors","firstError","secondError","bothValues","isInlinePattern","isBlockPattern","normalizePattern","formatOrCmd","onFormat","onCommand","format","formats","cmd","command","commandValue","getBlockPatterns","patterns","getInlinePatterns","fromRawPatterns","errors","partition$1","deviceDetection$1","DOM$a","getHash","isRegExp","stringOrObjectProcessor","bodyOptionProcessor","valid","bodyObj","getIframeAttrs","getDocType","getDocumentBaseUrl","getBodyId","getBodyClass","getContentSecurityPolicy","shouldPutBrInPre$1","getForcedRootBlock","getForcedRootBlockAttrs","getNewlineBehavior","getBrNewLineSelector","getNoNewLineSelector","shouldKeepStyles","shouldEndContainerOnEmptyBlock","isAutomaticUploadsEnabled","shouldReuseFileName","shouldReplaceBlobUris","getIconPackName","getIconsUrl","getImageUploadUrl","getImageUploadBasePath","getImagesUploadCredentials","getImagesUploadHandler","shouldUseContentCssCors","getReferrerPolicy","getLanguageCode","getLanguageUrl","shouldIndentUseMargin","getIndentation","getContentCss","getContentStyle","getFontCss","getDirectionality","getInlineBoundarySelector","getObjectResizing","getResizeImgProportional","getPlaceholder","getEventRoot","getServiceMessage","getTheme","getThemeUrl","getModel","getModelUrl","isInlineBoundariesEnabled","getFormats","getPreviewStyles","canFormatEmptyLines","getFormatNoneditableSelector","getCustomUiSelector","isInline$1","hasHiddenInput","shouldPatchSubmit","shouldAddFormSubmitTrigger","shouldAddUnloadTrigger","getCustomUndoRedoLevels","shouldDisableNodeChange","isReadOnly$1","hasEditableRoot$1","hasContentCssCors","getPlugins","getExternalPlugins$1","shouldBlockUnsupportedDrop","isVisualAidsEnabled","getVisualAidsTableClass","getVisualAidsAnchorClass","getIframeAriaText","getSetupCallback","getInitInstanceCallback","getUrlConverterCallback","getAutoFocus","shouldBrowserSpellcheck","getProtect","shouldPasteBlockDrop","shouldPasteDataImages","getPastePreProcess","getPastePostProcess","getNewDocumentContent","getPasteWebkitStyles","shouldPasteRemoveWebKitStyles","shouldPasteMergeFormats","isSmartPasteEnabled","isPasteAsTextEnabled","getPasteTabSpaces","shouldAllowHtmlDataUrls","getTextPatterns","getTextPatternsLookup","getNonEditableClass","getEditableClass","getNonEditableRegExps","shouldPreserveCData","shouldHighlightOnFocus","shouldSanitizeXss","shouldUseDocumentWrite","getAllowedImageFileTypes","hasTableTabNavigation","getDetailsInitialState","getDetailsSerializedState","shouldForceHexColor","shouldSandboxIframes","isElement$3","isText$5","removeNode$1","trimCount","trimmedText","deleteZwspChars","deleteData","removeUnchanged","remove$3","removeElementAndReposition","newPosition","indexOf$1","removeTextCaretContainer","removeTextAndReposition","removeAndReposition","removeElementCaretContainer","caretContainerNode","isContentEditableFalse$8","isMedia$1","isTableCell$1","getAbsoluteClientRect","scrollX","scrollY","rootRect","margin","FakeCaret","hasFocus","lastVisualCaret","cursorInterval","caretBlock","fakeCaretTargetNodes","trimInlineCaretContainers","caretState","caret","startBlink","textNode","splitText","insertInline$1","isInlineFakeCaretTarget","blockName","blockNode","insertBlock","getCss","reposition","isFakeCaretTableBrowser","isFakeCaretTarget","isContentEditableTrue$1","isContentEditableFalse$7","isMedia","isBlockLike","isCaretContainer","isCaretContainerBlock","isElement$2","isText$4","isCaretCandidate$1","isForwards","isBackwards","skipCaretContainers","findNode","predicateFn","isCefOrCaretContainer","getParentBlock$3","isInSameBlock","caretPosition1","caretPosition2","getChildNodeAtRelativeOffset","relativeOffset","beforeAfter","isNodesInSameBlock","node1","node2","lean","before$2","after$2","normalizeRange","leanLeft","leanRight","location","getRelativeCefElm","getNormalizedRangeEndPoint","normalizedRange","getElementFromPosition","getVisualCaretPosition","walkFn","isMoveInsideSameBlock","inSameBlock","HDirection","isContentEditableFalse$6","isText$3","isElement$1","isBr$2","isCaretCandidate","isAtomic","isAtomicContentEditableFalse","isEditableCaretCandidate","nodeAtIndex","getCaretCandidatePosition","findCaretPosition$1","startPos","nextNode","innerNode","Forwards","moveForwardFromBr","rootContentEditableFalseElm","getParents$3","CaretWalker","Backwards","isBeforeOrStart","position","isAfterOrEnd","isBeforeAfterSameElement","shouldSkipPosition","fromPosition","navigate","navigateIgnore","ignoreFilter","positionIn","walkToPositionIn","nextPosition","prevPosition","firstPositionIn","lastPositionIn","isCaretNode","getParentCaretContainer","currentNode","isIndexBookmark","bookmark","isPathBookmark","isForwardBookmark","addBogus","tryFindRangePosition","padEmptyCaretContainer","isEmpty$1","insertZwsp","setEndPoint","isValidTextNode","restoreEndPoint","markerParent","otherMarker","appendData","resolvePaths","isStringPathBookmark","endPos","resolveCaretPositionBookmark","isIdBookmark","spos","epos","resolveId","selectNode","resolveIndex","isRangeBookmark","getBookmark$1","getBookmark$2","_ref6","setRng","isBookmarkNode$1","isNbsp","expected","isWhiteSpace","isContent","getRanges$1","ranges","rangeCount","getRangeAt","getCellsFromRanges","getSelectedNodes","getCellsFromElementOrRanges","selectedCells","getCellsFromEditor","getSel","getClosestTable","cell","getFirstChildren","getLastChildren","hasAllContentsSelected","getStartNode","getEndNode","endNode","moveEndPoint","hasAnyRanges","sel","runOnRanges","executor","fakeSelectionNodes","fakeNodeRng","preserve","fillBookmark","isNode","isElementNode$1","preserveSelection","action","shouldMoveStart","selectedNodeBeforeAction","isSelectedBeforeNodeNoneditable","getStart","moveStartToNearestText","selectedAttr","isElementDirectlySelected","isWhiteSpaceNode$1","getNonWhiteSpaceSibling","inc","nextName","isTextBlock$1","ed","allowSpaces","isWrappableNoneditable","formatNoneditableSelector","isWrapNoneditableTarget","replaceVars","vars","isEq$5","str1","normalizeStyleValue","strValue","getTextDecoration","decoration","getParents$2","isFormatPredicate","formatName","formatter","areSimilarFormats","otherFormatName","validKeys","filterObj","validKey","fmt1","filteredFmt1","fmt2","filteredFmt2","equal$1","isBlockFormat","isSelectorFormat","isInlineFormat","shouldExpandToSelector","expand","isCaretContainerEmpty","getEmptyCaretContainers","isEmptyCaretFormatElement","isBookmarkNode","getParents$1","isWhiteSpaceNode","isTextBlock","findParentContentEditable","walkText","findSpace","findContent","findWordEndPoint","includeTrailingSpaces","lastTextNode","textSeeker","textOffset","findSelectorEndPoint","formatList","curFormat","findBlockEndPoint","scopeRoot","isAtBlockBoundary$1","findParentContainer","block_expand","isSelfOrParentBookmark","expandRng","includeTrailingSpace","_ref7","_ref8","walk$3","exclude","firstNode","lastNode","collectSiblings","findEndPoint","walkBoundary","startPoint","endPoint","validBlocks","wrapName","isZeroWidth","isAnnotation","applyAnnotation","masterUId","decorate","directAnnotation","otherData","attributeNames","removeDirectAnnotation","customAttrNames","customClasses","makeAnnotation","eDoc","master","annotate","newWrappers","getDoc","finishWrapper","processElements","elems","processElement","processNodes","annotateWithBookmark","undoManager","transact","initialRng","hasFakeSelection","masterUid","applyWordGrab","selectionRng","Annotator","register","create$c","dataAnnotation$1","identifyParserNode","newClassList","serializer","addTempAttr","addAttributeFilter","persistent","setup$x","changes","removeAnnotations","annotationChanged","_ref9","getBookmark","removeAll","getAll","BookmarkManager","isXYWithinRange","containsXY","fireError","errorType","fireFormatApply","fireFormatRemove","fireSetContent","fireGetContent","firePastePlainTextToggle","VK","BACKSPACE","DELETE","DOWN","ENTER","ESC","LEFT","RIGHT","SPACEBAR","TAB","UP","PAGE_UP","PAGE_DOWN","END","HOME","modifierPressed","shiftKey","ctrlKey","altKey","metaKeyPressed","metaKey","abs","round$1","resizeHandles","nw","ne","se","sw","ControlSelection","editableDoc","rootDocument","selectedElm","selectedElmGhost","resizeHelper","selectedHandle","resizeBackdrop","startX","startY","startW","startH","ratio","resizeStarted","startScrollWidth","startScrollHeight","isImage","contextMenuSelectImage","isTouchEvent","touch","touches","isEventOnImageOutsideRange","getResizeTargets","firstElementChild","isResizable","setSizeProp","targets","setGhostElmSize","ghostElm","resizeGhostElement","deltaX","deltaY","proportional","resizeHelperX","resizeHelperY","screenX","screenY","display","selectedElmX","selectedElmY","scrollWidth","scrollHeight","origin","fireObjectResizeStart","endGhostResize","wasResizeStarted","showResizeRect","fireObjectResized","nodeChanged","targetElm","unbindResizeHandleEvents","targetWidth","targetHeight","hideResizeRect","handle","startDrag","handleElm","throttledShowResizeRect","removeSelected","isChildOrEqual","updateResizeRect","removed","composing","controlElm","selectedValue","img","disableGeckoResize","startElm","getEnd","execCommand","relativeToNative","startSitu","finishSitu","situ","setFinish","exactToNative","soffset","finish","foffset","adt$3","ltr","rtl","fromRange","diagnose","domRange","relative","exact","getRanges","rev","doDiagnose","SimRange","caretPositionFromPoint","offsetNode","caretRangeFromPoint","availableSearch","adt$2","Situ","cata","onBefore","onOn","onAfter","adt$1","SimSelection","exactFromRange","simRange","getWin","_finishSitu","_soffset","_finish","_foffset","getStart$1","beforeSpecial","name$1","preprocessRelative","preprocessExact","fromElements","toNative","getDomRange","filtered","preprocess","getAtPoint","fromPoint$1","isEq$4","rng1","hasParent$1","findParent","hasParentWithName","isCeFalseCaretContainer","hasBrBeforeAfter","findTextNodeRelative","isAfterNode","lastInlineElement","parentBlockContainer","normalizeEndPoint","directionLeft","hasContentEditableFalseParent","isPrevNode","normalize$2","normRng","newContainer","RangeUtils","rangeLike","newRange","normalize","normalizedRng","compareRanges","getCaretRangeFromPoint","api","getOffset","aggregate","properties","cumulativeInclusions","Dimension","getDocument","walkUp","navigation","view","owner","rest","Navigation","freeze","__proto__","frameElement","find","frames","pathTo","loc","excludeFromDescend","markerInfo","cleanupFun","pageYOffset","pageXOffset","absolute","get$2","createMarker$1","last","span","withMarker","preserveWith","_s","_e","applyWithMarker","withScrollEvents","fireScrollIntoViewEvent","fireAfterScrollIntoViewEvent","withElement","elementMarker","startElement","endElement","scrollToMarker","viewHeight","intoWindowIfNeeded","viewportBottom","markerTop","markerBottom","largerThanViewport","intoWindow","innerHeight","intoFrame","frameViewHeight","op","viewportBounds","rangeIntoWindow","elementIntoWindow","rangeIntoFrame","elementIntoFrame","scrollRangeIntoView","focus$1","preventScroll","focus","hasFocus$1","activeElement","active$1","clamp$1","normalizeRng","isOrContains","isRngInRoot","nativeRangeToSelectionRange","getSelection","readRange","bookmarkToNativeRng","store","newBookmark","shouldStore","validate","FocusManager","isEditorUIElement","className","Delay","setEditorTimeout","wrappedSetTimeout","setEditorInterval","wrappedSetInterval","register$6","throttledStore","mouseUpPage","registerPageMouseUp","registerMouseUp","selectionChange","isManualNodeChange","registerEditorEvents","documentFocusInHandler","DOM$9","isEditorContentAreaElement","isUIElement","customSelector","getActiveElement","getElement","registerEvents$1","editorManager","toggleContentAreaOnFocus","getContainer","focusedEditor","setActive","blurredEditor","activeEditor","unregisterDocumentEvents","getFocusInElement","getCollapsedNode","normalizeSelection","caretPos","focusBody","hasElementFocus","rawBody","hasInlineFocus","iframeElement","hasIframeFocus","hasEditorOrUiFocus","hasUiFocus","activateEditor","skipFocus","quirks","refreshContentEditable","bookmarkRng","contentEditableHost","getContentEditableHost","focusEditor","isEditableRange","getEndpointElement","real","getEnd$1","skipEmptyTextNodes","orig","processRanges","elementsWithCursorPosition","isCursorPosition","hasCursorPosition","isContentEditableFalse$5","descendantRtl","create$9","findIn","setCursorLocation","detect$1","typeLookup","walk$2","isEmptyTextNode","AstNode","insert","selfAttrs","cloneAttrs","selfAttr","wrap","refNode","whitespace","unescapedTextParents","containsZwsp","includes","getTemporaryNodeSelector","tempAttrs","createZwspCommentWalker","createTreeWalker","NodeFilter","SHOW_COMMENT","FILTER_ACCEPT","FILTER_SKIP","createUnescapedZwspTextWalker","SHOW_TEXT","hasZwspComment","hasUnescapedZwspText","hasTemporaryNode","trimTemporaryNodes","getTemporaryNodes","emptyAllNodeValuesInWalker","curr","emptyZwspComments","emptyUnescapedZwspTexts","trim$1","conditionalTrims","condition","trimmed","cloned","_ref10","cleanupBogusElements","bogusElements","cleanupInputNames","inputs","input","getPlainTextContent","offscreenDiv","getContentContainer","getContentFromBody","getTempAttrs","emptyRegExp","trimEmptyContents","makeMap$1","Writer","indent","indentBefore","indent_before","indentAfter","indent_after","entity_encoding","htmlOutput","element_format","cdata","comment","pi","doctype","reset","getContent","HtmlSerializer","writer","handlers","sortedAttrs","elementRule","nonInheritableStyles","Set","shorthandStyleProps","getStyleProps","hasInheritableStyles","isNonInheritableStyle","hasStyleConflict","nodeStyleProps","parentNodeStyleProps","valueMismatch","prop","parentValue","nodeStyleProp","propExists","longhandProps","isChar","delta","isBeforeSpace","isAfterSpace","isEmptyText","matchesElementPosition","isImageBlock","isCefNode","isBogusAll$1","isBeforeImageBlock","isAfterImageBlock","isBeforeMedia","isAfterMedia","isBeforeTable","isAfterTable","isBeforeContentEditableFalse","isAfterContentEditableFalse","parentsUntil","parentsAndSelf","navigateIgnoreEmptyTextNodes","getClosestBlock$1","isBlock$1","isAtBeforeAfterBlockBoundary","newPos","fromBlock","isAtBlockBoundary","isAtStartOfBlock","isAtEndOfBlock","isBeforeBlock","isAfterBlock","isBr$1","findBr","parentBlocks","isBeforeBr$1","isAfterBr","getElementFromPrevPosition","findPreviousBr","findNextBr","isInMiddleOfText","getClosestBlock","hasSpaceBefore","hasSpaceAfter","isInPre","isPreValue","isAtLineBoundary","isAtBeginningOfBody","isAtEndOfBody","isSiblingCefBlock","needsToHaveNbsp","needsToBeNbspLeft","prevPos","isPrevCefBlock","isAfterCefBlock","needsToBeNbspRight","nextPos","isNextCefBlock","isBeforeCefBlock","needsToBeNbsp","isNbspAt","isWhiteSpaceAt","normalizeNbspAtStart","makeNbsp","firstPos","normalizeNbspInMiddleOfTextNode","newText","chars","normalizeNbspMiddle","normalizeNbspAtEnd","lastPos","normalizeNbsps","hasNbsp","normalize$1","replaceData","normalizeWhitespaceAfter","whitespaceCount","normalizeWhitespaceBefore","mergeTextNodes","prevNode","normalizeWhitespace","mergeToPrev","whitespaceOffset","newNode","removeNode","insertData","needsReposition","getPreviousSiblingCaretPosition","getNextSiblingCaretPosition","findCaretPositionBackwards","findCaretPositionBackwardsFromElm","findCaretPositionForward","findCaretPositionForwardsFromElm","findCaretPosOutsideElmAfterDelete","findCaretPosition","setSelection$1","eqRawNode","paddEmptyBlock","preserveEmptyCaret","deleteNormalized","afterDeletePosOpt","prevTextOpt","nextTextOpt","oc","isInlineElement","deleteElement$2","moveCaret","afterDeletePos","normalizedAfterDeletePos","setContent","paddPos","strongRtl","isInlineTarget","hasStrongRtl","findRootInline","findInlineParents","normalizePosition","normalizeForwards","normalizeBackwards","execCommandIgnoreInputEvents","inputBlocker","off","execNativeDeleteCommand","isTextBlockOrListItem","getParentBlock$2","isBeforeRoot","paddEmptyBody","moveSelection","no_selection","willDeleteLastPositionInElement","fromPos","normalizedFirstPos","normalizedLastPos","normalizedFromPos","freefallRtl","deleteRangeContents","deleteContents","lastBlock","additionalCleanupNodes","sibling$1","getTableCells","getTable$1","adjustQuirksInDetails","details","startTable","endTable","isStartTableParentOfEndTable","isEndTableParentOfStartTable","isSameTable","isMultiTable","selectionInTableWithNestedTable","tableCellRng","deleteAction","singleCellTable","fullTable","partialTable","multiTable","getClosestCell$1","isExpandedCellRng","cellRng","getTableFromCellRng","startParentTable","endParentTable","getTableSelectionFromCellRng","cells","tableSelection","getTableSelections","selectionDetails","sameTableSelection","startCell","endCell","startTableSelection","getCellRangeFromStartTable","endTableSelection","getCellRangeFromEndTable","getCellIndex","getSelectedCells","startIndex","endIndex","isSingleCellTableContentSelected","optCellRng","rows","isSingleCellTable","unselectCells","otherContentRng","getActionFromRange","isRootFromElement","getCellRng","isStartInTable","isEndInTable","getTableDetailsFromRange","_ref12","startTableSelectedCells","endTableSelectedCells","handleMultiTable","_ref11","handleSingleTable","cleanCells","deleteContentInsideCell","isFirstCellInSelection","insideTableRng","deleteCellContents","collapseAndRestoreCellSelection","selectedNode","emptySingleTableCells","outsideDetails","editorRng","cellsToClean","_ref13","outsideBlock","getOutsideBlock","startInTable","emptyBlock","handleEmptyBlock","endPointCell","emptyMultiTableCells","startTableCells","endTableCells","betweenRng","startTableCellsToClean","endTableCellsToClean","deleteTableElement","deleteTableRange","getParentCaption","deleteCellRange","emptyElement","deleteCaptionRange","getParentCell","deleteCaretInsideCaption","fromCaption","first","isDeleteOfLastCharPos","emptyCaretCaption","toCaption","validateCaretCaption","deleteCaretCells","fromCell","toCell","deleteBetweenCells","isNearTable","deleteCaret$3","isBeforeOrAfterTable","deleteCaretCaption","backspaceDelete$a","deleteRange$3","getContentEditableRoot$1","internalAttributesPrefixes","each$9","ElementUtils","internalAttributes","isAttributeInternal","attributeName","compare","attribs","compareObjects","obj1","obj2","isHeading","isSummary","matchNode$1","nodeFilters","attributeFilters","nl","ai","al","findMatchingNodes","traverse","childNode","runFilters","matchRecord","filteringAttributes","filter$2","paddEmptyNode","pad_empty_with_br","astNode","hasOnlyChild","isPadded","findClosestEditingHost","editableNode","removeOrUnwrapInvalidNode","originalNodeParent","cleanInvalidNodes","onCreate","textBlockElements","nonSplittableElements","fixed","isSplittableElement","newParent","isInvalid","hasClosest","parentName","normalizeBlockSelectionRange","commonAncestorContainer","newEndPos","isPaddedEmptyBlock","hasOnlyOneChild$1","isPaddingNode","isListFragment","isEmptyFragmentElement","isListItemPadded","isPadding","trimListItems","getParentLi","findLastOf","newCaretPos","insertBefore$2","findFirstIn","insertAtCaret$1","domFragment","cleanupDomFragment","toDomFragment","liTarget","liElms","isAt","caretWalker","newPosNode","insertAfter$2","beforeRng","afterRng","cloneContents","getSplit","insertMiddle","mergeableWrappedElements","isTableCell","trimBrsFromTableCell","lastChildPrevSibling","trimBlockTrailingBr","moveSelectionToMarker","_c","nextRng","parentEditableElm","isCell","isPartOfFragment","findNextCaretRng","deleteSelectedContent","isTableCellContentSelected","insertHtmlAtCaret","parser","merge","bookmarkHtml","preserve_zwsp","caretElement","canHaveChildren","parserArgs","paste","isParentBlockLi","isPastingSingleElement","isWrappedElement","isPastingInTheSameBlockTag","isPastingInContentEditable","shouldPasteContentOnly","markFragmentElements","_selectionOverrides","showBlockCaretContainer","invalid","notHeadingsInSummary","markerNode","findMarkerNode","editingHost","toExtract","getNodeFilters","getAttributeFilters","no_events","validInsertion","textInlineElements","elementUtils","reduceInlineTextElements","caretParent","updateCaret","isTreeNode","setEditorHtml","noSelection","setContentInternal","trimmedHtml","setContentTree","padd","forcedRootBlockName","isRootContent","setContentString","ensureIsRoot","closest$1","transform","transformed","isEq$3","matchesUnInheritedFormatSelector","inherit","matchParents","similar","matchedNode","matchNode","matchName","matchItems","itemName","matchAttributes","onmatch","expectedValue","isEmptyValue","match$2","closest","rawElm","matchAllOnNode","formatNames","matchSimilar","isVariableValue","field","fieldValues","isVariableFormatName","findFirstTextNode","createCaretContainer","fill","removeCaretContainerNode","trimZwspFromCaretContainer","removeCaretContainer","appendNode","insertFormatNodesIntoCaretContainer","formatNodes","innerMostFormatNode","formatNode","removeCaretFormat","hasContentAfter","expandedRng","parentsAfter","newCaretContainer","insertCaretContainerNode","cleanedFormatNode","validFormats","matchedFormats","fmtName","clonedFormatNode","cleanFormatNode","caretTextNode","setup$v","keyCode","disableCaretContainer","createCaretFormat","innerMost","replaceWithCaretFormat","isFormatElement","inlineElements","postProcessHooks","isPre","addPostProcessHook","blocks","getSelectedBlocks","preBlocks","pre","hasPreSibling","pre1","pre2","sPre2","joinPre","listItemStyles","findExpandedListItemFormat","fmt","hasListStyles","getExpandedListItemFormat","isRngStartAtStartOfElement","isRngEndAtEndOfElement","isEditableListItem","getFullySelectedListItems","middle","getFullySelectedBlocks","getPartiallySelectedListItems","each$8","isElementNode","findElementSibling","mergeSiblingsNodes","isPrevEditable","isNextEditable","tmpSibling","mergeSiblings","merge_siblings","processChildElements","hasStyle","applyStyle","unwrapEmptySpan","removeResult","MCE_ATTR_RE","each$7","isEq$2","isChildOfInlineParent","lastIdx","normalizeTableSelection","isTableCellOrRow","wrap$1","wrapWithSiblings","rootBlockElm","forcedRootBlock","list_block","isMixedFormat","processFormatAttrOrStyle","removeEmptyStyleAttributeIfNeeded","removeStyles","compareNode","stylesModified","styleName","styleValue","normalizedStyleValue","remove_similar","removeNodeFormatInternal","ceFalseOverride","links","isColorFormatAndAnchor","preserveAttributes","preserve_attributes","attrsToPreserve","currentValue","valueOut","removeNodeFormatFromClone","newName","removeFormatInternal","splitToFormatRoot","formatRoot","findFormatRoot","lastClone","firstClone","formatRootParent","mixed","wrapAndSplit","removeFormatOnNode","removeNodeFormat","currentNodeMatches","textDecoration","isRemoveBookmarkNode","removeRngStyle","liFmt","removeListStyleFormats","removeFormat$1","each$6","mergeWithChildren","clear_child_styles","_value","clearChildStyles","each$5","applyStyles","styleVal","applyFormatAction","setElementFormat","onformat","applyNodeStyle","found","createWrapElement","wrapElm","applyRngStyle","nodeSpecific","isMatchingWrappingBlock","isWrappingBlockFormat","canRenameBlock","isEditableDescendant","isValidBlockFormatForNode","isNonWrappingBlockFormat","currentWrapElm","lastContentEditable","isWrappableNoneditableElm","contentEditableValue","validBRParentElements","hasCaretNodeSibling","canFormatBR","isValidWrapNode","isCaret","isCorrectFormatForNode","canWrapNode","childCount","isEmptyTextNode$1","getChildCount","childElement","mergeStyles","merge_with_parents","mergeWithParents","backgroundColor","hasFontSize","mergeBackgroundColorAndFontSize","processTextDecorationsAndColor","parentTextDecoration","mergeTextDecorationsAndColor","inverseTagDescendants","mergeSubSup","wordcharRegex","importNode","applyCaretFormat","fake","postProcess$1","applyFormat$1","hasVars","fallbackElement","matchingNode","matchingFormat","updateAndFireChangeCallbacks","registeredCallbacks","runIfChanged","spec","withSimilar","withoutSimilar","withVars","formatChangedInternal","registeredFormatListeners","formatChangeItems","getCurrent","toAppendTo","addListeners","removeListeners","explode$1","create$8","filters","addFilter","getFilters","removeFilter","newCallbacks","addFontToSpansFilter","domParser","fontSizes","addNodeFilter","face","removeAttrs","addFilters","convert_fonts_to_spans","font_size_legacy_values","convertToSTag","addStrikeFilter","register$5","inline_styles","htmlParser","blockElements","prevName","lastParent","parseDataUri","uri","base64Encoded","extractedData","extractBase64Data","decodeURIComponent","buildBlob","atob","Uint8Array","Blob","uriToBlob","fetch","ok","blob","uriType","blobUriToBlob","_ref14","blobToDataUri","reader","FileReader","onloadend","readAsDataURL","count$1","processDataUri","dataUri","base64Only","generateBlobInfo","_ref15","base64","btoa","createBlobInfo$1","blobCache","blobInfo","dataUriToBlobInfo","getByData","imageToBlobInfo","imageSrc","invalidDataUri","getByUri","registerBase64ImageFilter","blob_cache","processImage","inputSrc","isInternalImageSource","isBogusImage","blobUri","isMimeType","mime","register$4","remove_trailing_brs","addNoOpener","newRel","appendRel","allow_unsafe_link_target","allow_html_in_named_anchor","fix_list_elements","classValue","validClassesMap","convert_unsafe_embeds","sandboxIframes","embed","createSafeEmbed","sandbox_iframes","entries","setPrototypeOf","isFrozen","getOwnPropertyDescriptor","create$7","construct","Reflect","fun","thisValue","Func","arrayForEach","unapply","forEach","arrayPop","pop","arrayPush","stringToLowerCase","stringToString","stringMatch","stringReplace","stringIndexOf","stringTrim","regExpTest","typeErrorCreate","TypeError","_len2","arguments","_key2","_len","_key","addToSet","transformCaseFunc","_transformCaseFunc","lcElement","object","newObject","lookupGetter","desc","warn","html$1","svg$1","svgFilters","svgDisallowed","mathMl$1","mathMlDisallowed","mathMl","xml","MUSTACHE_EXPR","ERB_EXPR","TMPLIT_EXPR","DATA_ATTR","ARIA_ATTR","IS_ALLOWED_URI","IS_SCRIPT_OR_DATA","ATTR_WHITESPACE","DOCTYPE_NAME","EXPRESSIONS","getGlobal","_createTrustedTypesPolicy","trustedTypes","purifyHostElement","createPolicy","policyName","createScriptURL","purify","createDOMPurify","DOMPurify","originalDocument","currentScript","DocumentFragment","HTMLTemplateElement","NamedNodeMap","MozNamedAttrMap","HTMLFormElement","DOMParser","ElementPrototype","getNextSibling","getParentNode","template","trustedTypesPolicy","emptyHTML","implementation","createNodeIterator","hooks","createHTMLDocument","IS_ALLOWED_URI$1","ALLOWED_TAGS","DEFAULT_ALLOWED_TAGS","ALLOWED_ATTR","DEFAULT_ALLOWED_ATTR","CUSTOM_ELEMENT_HANDLING","tagNameCheck","writable","configurable","enumerable","attributeNameCheck","allowCustomizedBuiltInElements","FORBID_TAGS","FORBID_ATTR","ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","ALLOW_SELF_CLOSE_IN_ATTR","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","SET_CONFIG","FORCE_BODY","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_TRUSTED_TYPE","SANITIZE_DOM","SANITIZE_NAMED_PROPS","SANITIZE_NAMED_PROPS_PREFIX","KEEP_CONTENT","IN_PLACE","USE_PROFILES","FORBID_CONTENTS","DEFAULT_FORBID_CONTENTS","DATA_URI_TAGS","DEFAULT_DATA_URI_TAGS","URI_SAFE_ATTRIBUTES","DEFAULT_URI_SAFE_ATTRIBUTES","MATHML_NAMESPACE","SVG_NAMESPACE","HTML_NAMESPACE","NAMESPACE","IS_EMPTY_INPUT","ALLOWED_NAMESPACES","DEFAULT_ALLOWED_NAMESPACES","PARSER_MEDIA_TYPE","SUPPORTED_PARSER_MEDIA_TYPES","DEFAULT_PARSER_MEDIA_TYPE","CONFIG","formElement","isRegexOrFunction","testValue","_parseConfig","cfg","ADD_URI_SAFE_ATTR","ADD_DATA_URI_TAGS","ALLOWED_URI_REGEXP","ADD_TAGS","ADD_ATTR","TRUSTED_TYPES_POLICY","MATHML_TEXT_INTEGRATION_POINTS","HTML_INTEGRATION_POINTS","COMMON_SVG_AND_HTML_ELEMENTS","ALL_SVG_TAGS","ALL_MATHML_TAGS","_checkValidNamespace","parentTagName","Boolean","_forceRemove","_removeAttribute","attribute","getAttributeNode","_initDocument","dirty","leadingWhitespace","dirtyPayload","parseFromString","createDocument","_createIterator","SHOW_ELEMENT","_isClobbered","_isNode","_executeHook","entryPoint","_sanitizeElements","allowedTags","_basicCustomElementTest","_isValidAttribute","lcTag","_sanitizeAttributes","hookEvent","keepAttr","allowedAttributes","initValue","forceKeepAttr","getAttributeType","setAttributeNS","_sanitizeShadowDOM","shadowNode","shadowIterator","sanitize","importedNode","returnNode","nodeIterator","shadowroot","shadowrootmode","serializedHTML","setConfig","clearConfig","isValidAttribute","addHook","hookFunction","removeHook","removeHooks","removeAllHooks","each$4","queryParts","DEFAULT_PORTS","ftp","http","https","mailto","safeSvgDataUrlElements","isInvalidUri","decodedUri","encodedUri","unescape","decodeUri","allow_html_data_urls","allowSvgDataUrls","blockSvgDataUris","URI","uriComponents","protocol","pathname","baseUri","base_uri","source","isProtocolRelative","toAbsPath","urlMatch","part","userInfo","port","setPath","pathMatch","file","getURI","toRelative","relativeUri","tu","uu","toRelPath","anchor","toAbsolute","noHost","absoluteUri","isSameOrigin","defaultPort","breakPoint","normalizedBase","nb","normalizedPath","baseParts","pathParts","outPath","noProtoHost","filteredUrlAttrs","processNode","_d","allow_conditional_comments","lcTagName","isInternalElement","bogus","hasNone","shouldKeepAttribute","isRequiredAttributeOfInternalElement","ele","isBooleanAttribute","filterAttributes","setupPurify","namespaceTracker","purify$1","track","processAttr","sanitizeNamespaceElement","xlinkAttrs","config","getSanitizer","scopes","peek","currentScope","createNamespaceTracker","sanitizeHtmlElement","mimeType","getPurifyConfig","_mimeType","extend$1","transferChildren","nativeParent","nsSanitizer","isSpecial","nativeChild","walkTree","preprocessors","postprocessors","traverseOrder","postprocess","whitespaceCleaner","textRootBlockElements","allWhiteSpaceRegExp","startWhiteSpaceRegExp","endWhiteSpaceRegExp","hasWhitespaceParent","isAtEdgeOfBlock","neighbour","isLineBreakNode","isNodeEmpty","isTextRootBlockEmpty","isPaddedWithNbsp","getRootBlockName","forced_root_block","DomParser","nodeFilterRegistry","attributeFilterRegistry","defaultedSettings","root_name","sanitizer","parseAndSanitizeWithContext","rootName","isSpecialRoot","wrappedHtml","removeNodeFilter","removeAttributeFilter","findInvalidChildren","isWrappableNode","addRootBlocks","rootBlockName","rootBlockNode","rootBlock","forced_root_block_attrs","whitespacePre","whitespacePost","invalidFinder","matchFinder","topLevelChildren","otherChildren","exports","withSerializedContent","fireEvent","parserSettings","serializedContent","serializeContent","eventArgs","preProcessGetContent","fireBeforeGetContent","postProcessGetContent","processedEventArgs","preProcessSetContent","fireBeforeSetContent","postProcessSetContent","tableModel","tableRow","cellPosition","getSpan","cellExists","getWidth","row","findElementPos","extractRows","sx","sy","ey","newRows","tableElm","rowspan","colspan","y2","x2","fillout","skipCellsX","toDom","tableElement","tableBody","createDomTable","modelRowsToDomRows","subsection","subTable","getFullySelectedListWrappers","_li","findParentListContainer","listCont","listElm","listStyles","_style","getWrapElements","commonAnchorContainer","wrapElements","listWrappers","allWrappers","directListWrappers","emptyFragment","getFragmentFromRange","innerElm","getTableFragment","selectedTableCells","getParentTable","firstCell","lastCell","fullTableModel","sectionedTableModel","read$3","getSelectionFragment","isCollapsibleWhitespace","getInnerText","bin","extractSelectedContent","parentBlockOpt","contextNodeName","getContextNodeName","rangeContentClone","nonRenderedText","parentBlockText","textIndex","getTextContent","tmpElm","contextual","getSerializedContent","setupArgs$3","getInner","getOuterHtml","insertAt","write","fragments","diff","removeAt","applyDiff","vDown","vUp","buildScript","start1","end1","start2","end2","getMiddleSnake","diag","j","i2","buildSnake","snake","sum","lazyTempDocument","createFromEditor","hasIframes","trimZwsp","read$2","beforeBookmark","applyToEditor","level","getLevelContent","getCleanLevelContent","isEq$1","level1","level2","hasEqualContent","hasEqualCleanedContent","isUnlocked","locks","setTyping","typing","endTyping","makePlainAdaptor","init","bindEvents","beforeChange","beforeChange$1","currentLevel","newLevel","lastLevel","bm","customUndoRedoLevels","setDirty","addUndoLevel$1","undo","undo$1","redo","redo$1","clear$1","reset$1","hasUndo","hasUndo$1","hasRedo","hasRedo$1","ignore","transact$1","ignore$1","extra","callback1","callback2","extra$1","matchAll","matchedFormatNames","checkedMap","canApply","formatChanged","getContentInternal","insertContent","addVisual","matchedElm","hasVisual","addVisualInternal","defaultedArgs","updatedArgs","getSelectedContentInternal","autocompleter","addDecoration","removeDecoration","remove$2","isRtc","plugins","setup$t","editorCast","rtcPlugin","setup","getRtcSetup","rtcInstance","nul","makeNoopAdaptor","rtcEditor","defaultVars","_undoManager","_locks","_index","_node","_similar","_rfl","_details","_format","getRawModel","makeRtcAdaptor","rtc","isRemote","getRtcInstanceWithFallback","getRtcInstanceWithError","getContent$2","setContent$2","getSelectedContent","mergeAndNormalizeText","outerNode","outer","outerElm","oldLength","merge$1","innerTextNode","walkPastBookmark","normalizeTextIfRequired","rngSetContent","prevText","nextText","setupArgs$2","cleanContent","contextBlock","contextArgs","deleteFromCallbackMap","SelectorChanged","selectorChangedData","currentSelectors","findMatchingNode","selectorChangedWithUnbind","matchedSelectors","isAttachedToDom","EditorSelection","selectedRange","explicitRange","cleanedContent","createContextualFragment","setContent$1","getRng$1","tryCompareBoundaryPoints","how","sourceRange","destinationRange","compareBoundaryPoints","anchorNode","START_TO_START","END_TO_END","isValidRange","removeAllRanges","addRange","setBaseAndExtent","focusNode","anchorRange","focusRange","anchorOffset","focusOffset","getContent$1","bookmarkManager","compareEndPoints","fakeSelectedElements","setNode","endElm","selectedBlocks","selectorChanged","getScrollContainer","scrollContainer","scrollElementIntoView","placeCaretAt","controlSelection","process$1","hasEventListeners","shouldFireEvent","oldDoc","clonedNode","impl","firePreProcess","preProcess$1","getHtmlFromNode","parseHtml","isBr","brNode1","brNode2","trimTrailingBr","toHtml","serializeNode","outArgs","firePostProcess","postProcess","DomSerializerImpl","internalName","hasChildren","preserve_cdata","register$3","addRules","setRules","DomSerializer","domSerializer","setupArgs$1","setupArgs","removedOptions","deprecatedOptions","removedPlugins","deprecatedPlugins","replacedWith","getMatchingOptions","searchingFor","settingNames","setting","getRemovedOptions","getDeprecatedOptions","getMatchingPlugins","pluginNames","plugin","getRemovedPlugins","getDeprecatedPlugins","entry","getPluginDescription","logWarnings","rawOptions","normalizedOptions","hasRemovedPlugins","hasRemovedOptions","isLegacyMobileTheme","theme","listJoiner","themesMessage","pluginsMessage","optionsMessage","logRemovedWarnings","hasDeprecatedPlugins","hasDeprecatedOptions","logDeprecatedWarnings","DOM$8","safeDestroy","remove$1","editorUpload","save","is_removing","unbindAllNativeEvents","fireRemove","orgDisplay","restoreOriginalStyles","fireDetach","automatic","destroyed","_beforeUnload","form","_mceOldSubmit","submit","formEventDelegate","restoreForm","contentAreaContainer","editorContainer","bodyElement","contentDocument","contentWindow","clearDomReferences","IconManager","iconPack","icons","CreateIconManager","getProp","propName","getComputedSizeProp","getClientWidth","getClientHeight","getMarginTop","getMarginLeft","isXYInContentArea","bodyElm","transposedPoint","transpose","isInsideElementContentArea","isEditorAttachedToDom","rawContainer","getContentAreaContainer","NotificationManager","notifications","getImplementation","getNotificationManagerImpl","unimplemented","open","close","getArgs","NotificationManagerImpl","getTopNotification","progressBar","timeout","notification","addNotification","closeNotification","otherNotification","getEl","getNotifications","serviceMessage","requestAnimationFrame","registerEvents","WindowManager","dialogs","getWindowManagerImpl","openUrl","alert","confirm","WindowManagerImpl","funcBind","addDialog","dialog","fireOpenEvent","closeDialog","fireCloseEvent","otherDialog","storeSelectionAndOpenDialog","openDialog","ui","windowManagerImpl","displayNotification","notificationManager","displayError","_skinLoaded","logError","createLoadError","initError","toContentSkinResourceName","transformToUrls","cssLinks","skinUrl","contentCssFile","tinymce","Resource","isBundledCssSkinName","isContentCssSkinName","documentBaseURI","appendContentCssFromSettings","contentCSS","getContentCssUrls","getFontCssUrls","getAllImages","UploadStatus","blobUriStatuses","createStatus","resultUri","hasBlobUri","getResultUri","isPending","isUploaded","markPending","markUploaded","removeFailed","uuid","rnd","seed","Uploader","uploadStatus","pendingPromises","defaultHandler","progress","xhr","XMLHttpRequest","withCredentials","credentials","upload","onprogress","loaded","total","json","JSON","responseText","path1","path2","basePath","formData","FormData","filename","send","uploadHandler","handlerSuccess","handlerFailure","resolvePending","uploadBlobs","blobInfos","openNotification","pendingUploadBlobInfo","percent","uploadBlobInfo","createUploader","addPaddingToEmpty","isEmptyForPadding","EditorUpload","cache","toBlobInfo","URL","createObjectURL","findFirst","cachedBlobInfo","removeByUri","revokeObjectURL","BlobCache","uploader","imageScanner","urlFilters","aliveGuard","replaceString","replaceImageUrl","targetUrl","replacementUrl","replacementString","replaceUrlInUndoStack","uploadImages","scanForImages","imageInfos","imageInfo","imagesToRemove","shouldDispatchChange","filteredResult","uploadInfo","image","convertURL","replaceImageUriInView","uploadError","uploadUri","sugarElement","parentOpt","dispatchChange","uploadImagesAuto","isValidDataUriImage","imgElm","cachedPromises","images","promises","newPromise","ImageScanner","resultItem","replaceBlobUris","source_view","genericBase","cellBase","cellFormats","tablecellbackgroundcolor","tablecellverticalalign","tablecellbordercolor","borderColor","tablecellclass","tableclass","tablecellborderstyle","borderStyle","tablecellborderwidth","borderWidth","FormatRegistry","valigntop","verticalAlign","valignmiddle","valignbottom","alignleft","preview","textAlign","float","marginLeft","marginRight","aligncenter","alignright","alignjustify","bold","fontWeight","italic","fontStyle","underline","strikethrough","strike","forecolor","hilitecolor","fontname","fontFamily","fontsize","fontSize","lineheight","lineHeight","fontsize_class","class","blockquote","subscript","superscript","_fmt","_itemName","lang","customValue","removeformat","get$1","unregister","each$3","isPreviewItem","parsedSelectorToHtml","ancestry","sItem","wrapInHtml","ancestors","parentCandidate","ancestorName","parentRequired","elmRule","getRequiredParent","siblingElm","parentSiblings","parseSelectorItem","$0","$3","$4","getCssText","previewCss","previewStyles","removeVars","previewFrag","previewElm","rawParentFontSize","parentFontSize","Formatter","formatChangeState","addShortcut","setup$s","nodeOrRange","setup$u","applyFormat","removeFormat","toggleFormat","matchFormat","closestFormat","matchAllFormats","matchNodeFormat","canApplyFormat","shouldIgnoreCommand","UndoManager","addUndoLevel","isFirstTypedCharacter","addNonTypingUndoLevel","isMeta","isDirty","modKey","inputType","isInsertFromPasteOrDrop","addKeyboardShortcuts","nonTypingKeycodes","isKeyboardEvent","isDeleteEvent","setup$r","placeholder","updatePlaceholder","isNonTypingKeyboardEvent","showPlaceholder","isTypingKeyboardEvent","isVisuallyEmpty","firePlaceholderToggle","blockBoundary","getBlockPosition","containerElm","blockPosition","getClosestHost","readFromRange","fromBlockPos","toBlockPos","blockPos","lastPositionInBlock","skipLastBr","isDifferentBlocks","hasSameHost","isEditable$1","isValidBlock","hasValidBlocks","extractChildren","getChildrenUntilBlockBoundary","removeEmptyRoot","nestedBlockMerge","toBlock","insertionPoint","sidelongBlockMerge","getInlineToBlockDescendants","helper","newFromBlockDescendants","getInsertionPoint","parentsAndSelf$1","findInsertionPoint","trimBr","mergeBlockInto","mergeBlocks","block1","block2","backspaceDelete$9","read$1","isRawNodeInTable","isEverythingSelected","noPrevious","noNext","isSelectionInTable","deleteRange$2","emptyEditor","deleteRangeMergeBlocks","backspaceDelete$8","_forward","showCaret","getNodeRange","renderRangeCaret","caretPositionNode","caretPositionBeforeNode","ceRoot","renderCaretAtRange","isBeforeBoundary","isAfterBoundary","deleteContentAndShowCaret","peekCaretPosition","caretRange","deleteRange","trimEmptyTextNode","backspaceDelete$7","getNextPosFn","isBeforeFn","nextCaretPosition","normalizedNextCaretPosition","deleteBoundaryText","getEdgeCefPosition","atStart","isCefAtEdgeSelected","DeleteAction","moveToElement","moveToPosition","deleteEmptyBlockOrMoveToCef","toCefElm","blockElm","findCefPosition","isDeleteFromCefDifferentBlocks","getContentEditableAction","caretLocation","isAtContentEditableBlockCaret","getContentEditableBlockAction","skipMoveToActionFromInlineCefToContent","getAncestorCe","backspaceDeleteCaret","read","hideFakeCaret","deleteElement$1","backspaceDeleteRange","paddEmptyElement","backspaceDelete$6","backspaceDelete$5","deleteCaret$2","isText$2","startsWithCaretContainer","endsWithCaretContainer","createZwsp","insertInline","insertBefore$1","insertAfter$1","insertInlineBefore","insertInlineAfter","insertInlinePos","isPosCaretContainer","caretNode","renderCaret","evaluateUntil","fns","Location","rescope$1","nPos","isNotInsideFormatCaretContainer","findInsideRootInline","start$1","isValidLocation","readLocation","getName","outside","inside","betweenInlines","fromInline","toInline","hasSameParentBlock","skipNoMovement","fromLocation","toLocation","location2","location1","findLocationSimple","findLocation$1","findLocationTraverse","moveRel","modify","moveByWord","hasSelectionModifyApi","BreakType","flip","positions","walk$1","getBreakType","currentPos","Br","Block","Wrap","getPositionsUntil","breakType","breakAt","Eol","getAdjacentLinePositions","getPositionsUntilBreak","findClosestHorizontalPositionFromPoint","lastRect","newRect","lastDist","findClosestHorizontalPosition","targetRect","getPositionsUntilPreviousLine","getPositionsUntilNextLine","getPositionsAbove","getPositionsBelow","isAtFirstLine","isAtLastLine","getClosestPositionAbove","getClosestPositionBelow","isContentEditableFalse$4","distanceToRectLeft$1","distanceToRectRight$1","findClosestClientRect","oldClientRect","oldDistance","newDistance","getNodeClientRects","toArrayWithNode","VDirection","walkUntil","isAboveFn","isBeflowFn","line","targetClientRect","findUntil","upUntil","Up","downUntil","Down","getLastClientRect","isAboveLine","lineNumber","aboveLineNumber","isLine","isLineNumber","moveToRange","renderRangeCaretOpt","moveHorizontally","isBefore","isAfter","isElement","rangeIsInContainerBlock","moveVertically","caretClientRect","linePositions","nextLinePositions","nextLineRect","dist1","dist2","caretPositions","isBelowFn","positionsUntil","closestNextLineRect","getLineEndPoint","lineInfo","moveToLineEndPoint$3","setCaretPosition","setSelected","renderCaretLocation","findLocation","getPositionFromRange","isInlineTarget$1","safeRemoveCaretContainer","caretValue","isAtZwsp","move$3","moveWord","_caret","setupSelectedState","inlineBoundaries","selectedInlines","targetInlines","toggleInlines","inlines","_inline","renderInsideInlineCaret","moveNextWord","movePrevWord","moveToLineEndPoint$2","linePoint","outsideLoc","setCaretLocation","deleteFromTo","rangeFromPositions","backspaceDeleteCollapsed","rescope","toPosition","hasOnlyTwoOrLessPositionsLeft","backspaceDelete$4","getParentsUntil","hasOnlyOneChild","getParentInlinesUntilMultichildInline","hasMultipleChildren","getFormatNodes","parentInlines","isFormatElement$1","getFormatNodesAtStart","getParentInlines","deleteCaret$1","deleteLastPosition","createCaretFormatAtStart","isBrInEmptyElement","createCaretFormatAtStart$1","rangeStartsAtTextContainer","rangeEndsAtEndOfStartContainer","startParent","endParent","isEqualNode","rangeStartAndEndHaveSameParent","rangeEndsAtEndOfEndContainer","requiresDeleteRangeOverride","rangeStartsAtStartOfTextContainer","rangeStartParentIsFormatElement","rangeEndsAfterEndOfStartContainer","rangeEndsAtOrAfterEndOfStartContainer","deleteRange$1","updateFormats","missingFormats","updateCaretFormat","backspaceDelete$3","hasAncestorInlineCaret","ancestor$1","requiresRefreshCaretOverride","hasAncestorInlineCaretAtStart","refreshCaret","deleteElement","backspaceDelete$2","isNearMedia","deleteCaret","parseIndentValue","getIndentStyleName","useMargin","canOutdent","getBlocksToIndent","isReadOnly","indentStyleName","intentValue","validateBlocks","isListComponent","parentIsListComponent","indentation","indentUnit","indentValue","unit","parsedValue","indentElement","outdent","backspaceDelete$1","findAction","forwardDeleteCommand","execNativeForwardDeleteCommand","setup$q","addCommand","deleteCommand","getTouch","setup$p","startData","longpressFired","debounceLongpress","distX","distY","isFarEnough","isBlockElement","isValidTarget","shouldRemoveTextNode","createRootBlock","rootNodeName","hasBlockParent","restoreSelection","insertEmptyLine","checkClassName","replaceMatchWithSpan","prevChar","findStartTagIndex","setup$n","editClass","nonEditClass","hasEditClass","hasNonEditClass","nonEditableRegExps","convertRegExpsToNonEditable","blockCaretContainer","handleBlockContainer","findBlockCaretContainer","isContentEditableFalse$3","exitPreBlock","getVisualCaretPosition$1","newBlock","textBlock","createTextBlock","getHorizontalRange","moveToCeFalseHorizontally","getVerticalRange","down","moveToCeFalseVertically","moveH$2","flipDirection","moveV$4","moveToLineEndPoint$1","selectToEndPoint","curRng","isTarget","moveCaretToNewEmptyLine","getClosestTargetBlock","isAtFirstOrLastLine","moveV$3","move$2","moveDown","summary","moveUp","moveV$2","baseKeyPattern","matchesEvent","match$1","defaultPatterns","matchDelayed","defaultDelayedPatterns","execute","executeWithDelayedAction","moveH$1","moveV$1","moveToLineEndPoint","CellLocation","filterFirstLayer","tags","isRootOrUpperTable","lookup$1","isEligible","newIndex","getClosestCell","getYAxisValue","isTargetCorner","corners","tds","deflate","getCorners","corner","newCorner","oldCorner","oldDist","newDist","findClosestCorner","getClosestCellAbove","getClosestCellBelow","findClosestPositionInAboveCell","findClosestPositionInBelowCell","isAtTableCellLine","startsWithWrapBreak","startsWithBrBreak","breakPos","hasNextBreak","isAtFirstTableCellLine","isAtLastTableCellLine","navigateHorizontally","_td","isCaretAtStartOrEndOfTable","getTable","insertFn","renderBlock","navigateVertically","getClosestAbovePosition","getClosestBelowPosition","move$1","mover","moveH","moveV","tabGo","_current","getCellFirstCursorPosition","tabForward","tabBackward","handleTab","rootElements","model","clearSelectedCells","setup$l","isMac","executeKeydownOverride$4","DOM$7","alwaysNext","textBefore","scanLeft","scanRight","repeatLeft","isValidTextRange","getText","isWhitespace","stripTrigger","trigger","findTrigger","firstChar","findStart","initRange","minChars","buffer","findTriggerIndex","spot","toLast","isText$1","toLeaf","isStartOfWord","leaf","_element","isPreviousCharContent","getDatabase","database","triggers","getTriggerContext","lookupWithContext","fetchOptions","startText","autocompleters","lookupByTrigger","lookupData","ac","maxResults","matchText","columns","onAction","highlightOn","SimpleResultType","fold$1","stype","serror","svalue","Value","SimpleResult","formatObj","stringify","getErrorInfo","chooseFrom","branch","missingBranch","extract","choose$1","missingKey","chosen","baseMerge","merger","curObject","deepMerge","old","defaulted$1","fallback","mergeErrors","ResultCombine","objects","partitions","ifField","ifCustom","newKey","presence","instantiator","validator","custom","anyValue$1","requiredAccess","bundle","missingRequired","fallbackAccess","extractField","av","bundleAsOption","optValue","ov","optionAccess","optionDefaultedAccess","objOf","fields","extractFields","fieldStrings","_okey","_presence","_instantiator","arrOf","asRaw","errs","extractValue","formatError","errInfo","es","formatErrors","choose","anyValue","typedValue","expectedType","actualType","number","string","boolean","functionProcessor","customField","validateEnum","valueOf","requiredOf","requiredString","requiredFunction","optionOf","optionString","defaultedOf","defaultedNumber","defaultedStringEnum","defaultedBoolean","defaultedFunction","fetch$1","onSetup","optionalText","optionalIcon","optionalTooltip","optionalLabel","active","enabled","primary","defaultedType","defaultedString","autocompleterSchema","defaulted","defaultedArrayOf","baseToolbarButtonFields","baseToolbarToggleButtonFields","contextBarFields","contextButtonFields","contextToggleButtonFields","launchButtonFields","launchToggleButtonFields","toggleOrNormal","contextformbutton","contextformtogglebutton","requiredArrayOf","register$2","popups","dataset","popup","createAutocompleter","datasetValues","dv","setup$k","activeAutocompleter","uiActive","isActive","cancelIfNecessary","removeAutocompleterDecoration","fireAutocompleterEnd","commenceIfNecessary","addAutocompleterDecoration","matchLength","getAutocompleters","newContext","doLookup","lookupInfo","fireAutocompleterUpdate","fireAutocompleterStart","_ui","update","which","setupEditorInput","emptyNodeContents","isEntireNodeSelected","getParentDetailsElementAtPos","isInDetailsElement","isCaretAtStartOfSummary","detailsElements","startSummary","isCaretInTheBeginningOf","isCaretAtEndOfSummary","isCaretInTheEndOf","setCaretToPosition","moveCaretToDetailsPos","shouldPreventDeleteIntoDetails","granularity","parentDetailsAtCaret","inEmptyParentBlock","isFirstBlock","isLastBlock","parentDetailsAtNewPos","shouldPreventDeleteSummaryAction","detailElements","startInSummary","endInSummary","isPartiallySelectedDetailsElements","startDetails","endDetails","isPartialDelete","isCaretInLastPositionInBody","isCaretInFirstPositionInBody","shouldPreventDeleteAction","getDetailsElements","handleDeleteActionSafari","applySelection","appendAllChildNodes","backspaceDelete","createAndFireInputEvent","eventType","specifics","overrides","bubbles","isComposing","detail","currentTarget","eventPhase","AT_TARGET","originalTarget","explicitOriginalTarget","isTrusted","cancelable","InputEvent","fireInputEvent","fireBeforeInputEvent","platform$2","isMacOSOriOS","setup$j","isBackspaceKeydown","unmodifiedGranularity","getModifiedGranularity","isWord","applyAction","executeKeydownOverride$3","executeKeyupOverride","moveToCaretPosition","firstNonWhiteSpaceNodeSibling","getEditableRoot","editableRoot","getParentBlock$1","setForcedBlockAttrs","forcedRootBlockAttrs","attrStyles","newStyles","attrClassesOpt","attrClasses","currentClassesOpt","currentClasses","filteredClasses","newClasses","appliedAttrs","remainingAttrs","applyAttributes","createNewBlock","keepStyles","newBlockName","parentBlockName","isLastEmptyBlockInDetails","isAtDetailsEdge","insertNewLine","getDetailsRoot","hasParent","isListBlock","isListItem","getContainerBlock","containerBlock","containerBlockParent","isFirstOrLastLi","getStyles","insert$4","containerParent","parentBlockStyles","isFirstChild","tmpRng","hasFirstChild","previousChildren","isEmptyAnchor","containerAndSiblingName","canSplitBlock","normalizeZwspOffset","blockbreak","isAfterLastNodeInContainer","isCef","collapsedAndCef","createNewBlock$1","isCaretAtStartOrEndOfBlock","normalizedOffset","insertNewBlockAfter","containerBlockName","optionValue","shouldEndContainer","parentList","isWithinNonEditableList","startNodeName","startNodeParent","wrapSelfAndSiblingsInDefaultBlock","parentBlockParent","isNearChildren","includeZwspInRange","trimLeadingLineBreaks","firstChilds","trimInlineElementsOnLeftSideOfBlock","addBrToBlockIfNeeded","fakeEventName","moveSelectionToBr","brElm","extraBr","insertBrAtCaret","isControlKey","hasRightSideContent","insertBrBefore","insertBrAfter","hasBrAfter","isAnchorLink","isInsideAnchor","insertBrOutsideAnchor","linebreak","anchorLocation","readInlineAnchorLocation","matchesSelector","newLineAction","shouldBlockNewLine","_shiftKey","shouldBlockNewLine$1","inListBlock","requiredState","isListItemParentBlock","inBlock","getParentBlockName","inCefBlock","inPreBlock","shouldPutBrInPre","inBrContext","shouldInsertBr","hasShiftKey","_editor","canInsertIntoEditableRoot","rootEditable","isInRootWithEmptyOrCEF","isCefOpt","predicates","insertBreak","execEditorDeleteCommand","insert$1","logicalAction","getAction","platform$1","isIOSSafari","handleEnterKeyEvent","setup$i","iOSSafariKeydownBookmark","koreanCharRegex","isCaretAfterKoreanCharacter","iOSSafariKeydownOverride","iOSSafariKeyupOverride","setup$h","executeKeydownOverride$2","setup$g","normalizeNbspsInEditor","platform","isPageUpDown","setNodeChangeBlocker","blocked","setup$f","executeKeyupAction","insertTextAtPosition","insertNbspAtPosition","insertSpaceAtPosition","setSelection","insertSpaceOrNbspAtSelection","locationToCaretPosition","checkPos","insertInlineBoundarySpaceOrNbsp","insertSpaceInSummaryAtSelectionOnFirefox","domUtils","insertSpaceOrNbspAtPosition","setup$d","executeKeydownOverride$1","tableTabNavigation","setup$c","executeKeydownOverride","setup$b","setup$e","setup$m","NodeChange","lastRng","lastPath","nativeRng","fakeRng","isSameElementPath","initialized","currentPath","imageId","eventId","mkSetEventFn","transfer","setDragstartEvent","setDropEvent","setDragendEvent","isInDragStartEvent","modeId","mkSetModeFn","setMode$1","setReadWriteMode","setReadOnlyMode","setProtectedMode","checkMode","expectedMode","isInReadWriteMode","isInProtectedMode","validDropEffects","validEffectAlloweds","createDataTransfer","dataTransferImpl","DataTransfer","dropEffect","effectAllowed","dataTransfer","effect","allowed","itemsImpl","normalizeItems","types","setDragImage","imageData","setData","clearData","cloneDataTransfer","originalMode","getMode","getDragImage","getEvent","setEvent","setHtmlData","internalHtmlMime","mark","isMarked","toBlockElements","rootTag","rootAttrs","tagOpen","openContainer","tagClose","paragraphs","isPasteBin","isDefaultPasteBinContent","PasteBin","lastRngCell","pasteBinElm","create$6","pasteBinClone","getHtml","copyAndRemove","toElm","fromElm","pasteBinClones","dirtyWrappers","cleanWrapper","getLastRng","filter$1","trimHtml","s1","s2","processResult","cancelled","filterContent","internal","preProcessArgs","firePastePreProcess","filteredContent","preProcess","tempBody","postProcessArgs","firePastePostProcess","postProcessFilter","pasteHtml$1","isAbsoluteUrl","linkSelection","pasteHtmlFn","createLink","insertImage","isImageUrl","createImage","pasteAsText","smartInsertContent","createIdGenerator","createPasteDataTransfer","doPaste","shouldSimulateInputEvent","doPasteAction","pasteHtml","internalFlag","unmark","pasteText","encodedText","getDataTransferItems","contentType","hasContentType","clipboardContent","hasHtmlOrText","createBlobInfo","useFileName","extractFilename","allowedExtensions","extension","lowerExt","mimeOverrides","jpg","jpe","jfi","jif","jfif","pjpeg","pjp","getImageMimeType","pasteImageData","clipboardData","kind","getAsFile","getImagesFromDataTransfer","fileResults","imageItem","_ref16","existingBlobInfo","pasteImage","insertClipboardContent","plainTextMode","isInternal","isPlainTextHtml","isPlainText","isAbsoluteUrl$1","voidElements","ignoreElements","registerEventHandlers","pasteBin","pasteFormat","keyboardPastePlainTextState","isKeyboardPasteEvent","isBrokenAndroidClipboardEvent","registerEventsAndFilters","isWebKitFakeUrl","isDataUri","isPasteInsert","registerDataImageFilter","register$1","togglePlainTextPaste","setClipboardData","setHtml5Clipboard","contenteditable","overflow","offscreenRange","selectNodeContents","hasSelectedContent","isTableSelection","cut","getCaretRangeFromEvent","setFocusedRange","setup$a","draggingInternallyState","hasImage","dropContent","plainTextContent","isPlainTextFileUrl","internalContent","needsInternalDrop","parentTransparent","needsCustomInternalDrop","isInternalDrop","trimmedContent","hasNoSummary","brokenDetailElements","setupSummaryDeleteByDragFix","rgbRegExp","rgbToHex","removeWebKitStyles","webKitStylesOption","webKitStyles","inputStyles","outputStyles","inputValue","compareInput","outputStyle","setup$7","filterFunc","addPreProcessFilter","setup$8","processEvent","setup$9","setup$6","preventSummaryToggle","initialStateOption","serializedStateOption","filterDetails","isText","isContentEditableFalse$2","getClosestScope","isContentEditableTrue","getClosestCef","findEdgeCaretCandidate","onTripleClickSelect","startRng","clickNode","cef","findClosestBlockRange","FakeCaretPosition","distanceToRectLeft","distanceToRectRight","isOverlapping","r1","r2","overlap","overlapY","collidesY","splitRectsPerAxis","rects","prevRect","boundingClientRectFromRects","isInsideY","boundingRect","horizontal","vertical","horizontalDistance","_y","closestChildCaretCandidateNodeRect","findCloserTextNode","caretCandidateRect","findClosestCaretCandidateNodeRect","distance","sortedRects","sndClosest","tryFindSecondBestTextNode","horizontalRects","verticalRects","above","below","closestCaretCandidateNodeRect","ownerDoc","prevScope","childNodesWithoutGhost","uncheckedChildren","newScope","traverseUp","closestFakeCaretCandidate","Before","After","clientInfo","getAbsolutePosition","docElem","calc","calculatePosition","bodyPosition","getBodyPosition","scrollPosition","getScrollPosition","mousePosition","iframePosition","inlineScroll","iframeScroll","getBodyScroll","getMousePosition","getTargetProps","makeDragEvent","dataTransferForDispatch","makeDataTransferCopyForDragEvent","timeStamp","BUBBLING_PHASE","CAPTURING_PHASE","NONE","button","buttons","movementX","movementY","offsetX","offsetY","relatedTarget","initUIEvent","initMouseEvent","makeDndEvent","makeDndEventFromMouseEvent","isContentEditableFalse$1","createGhost","clonedElm","opacity","padding","boxSizing","scrollEditor","amount","behavior","scrollRight","scrollUp","scrollDown","removeElement","isLeftMouseButtonPressed","ceElm","isDraggable","elmPos","dragging","maxX","maxY","relX","relY","ghost","dispatchDragEvent","move","throttledPlaceCaretAt","caretInfo","state_","movement","mouseEventOriginatedFromWithinTheEditor","targetPos","applyRelPos","mouseY","mouseX","overflowX","outerMouseY","outerMouseX","innerWidth","moveGhost","drop","dragElement","isValidDropTarget","getRawTarget","dropTarget","removeElementWithPadding","getHtmlData","removeDragState","stopDragging","bindFakeDragEvents","pageDom","dragStartHandler","dragHandler","dropHandler","dragEndHandler","init$2","preventFileDrop","preventFileDropIfUIElement","editorRoot","eventNames","blockUnsupportedFileDrop","isContentEditableFalse","getContentEditableRoot","SelectionOverrides","realSelectionId","selectedElement","isFakeSelectionTargetElement","removeElementSelection","contentEditableRoot","setElementSelection","closestContentEditable","setRange","normalizeVoidElementSelection","isRangeInCaretContainer","isFakeSelectionElement","renderFocusCaret","setup$4","setup$3","isWithinCaretContainer","selectElement","targetClone","realSelectionContainer","setupOffscreenSelection","nodeElm","afterNode","getNormalizedTextOffset","generatePath","generatePathRange","resolvePath","nodePath","optNode","resolvePathRange","_ref17","_ref18","cleanEmptyNodes","deleteRng","getParentBlock","resolveFromDynamicPatterns","patternSet","beforeText","dynamicPatterns","dynamicPatternsLookup","blockPatterns","inlinePatterns","getBeforeText","stripPattern","firstTextNode","textAfter","applyPattern$1","formatSet","isBlockFormatName","findPattern$1","sortedPatterns","sortPatterns$1","nuText","newMarker","rangeFromMarker","createMarker","markerPrefix","pathRange","textEnd","textStart","startParentNode","removeMarker","isReplacementPattern","findPatternStartFromSpot","startPattern","patternContent","searchText","startEndIndex","startPatternIndex","nextSpot","findPattern","normalizedMatches","endPathRng","endRng","resultsOpt","findPatternsRec","remainingPatterns","requireGap","startRange","findPatternStart","startPathRng","generatePathRangeFromRange","endSpot","patternsWithoutCurrent","applyPattern","patternRange","findPatterns","matchesWithSortedPatterns","hasSameMatches","sortedMatch","getBestMatches","applyMatches","matchesWithMarkers","matchesWithEnds","endMarker","startMarker","addMarkers","markerRange","applyReplacementPattern","markerEndRange","markerStartRange","patternMarker","applyPatternWithContent","handleEnter","dynamicPatternSet","inlineMatches","blockMatches","blockText","findPatterns$1","insert$5","applyMatches$1","checkKeyEvent","codes","setup$2","charCodes","keyCodes","getPatternSet","createPatternSet","hasDynamicPatterns","hasTextPatternsLookup","handleInlineTrigger","handleInlineKey","charCode","Quirks","isGecko","isWebKit","setEditorCommandState","emptyEditorWhenDeleting","serializeRng","contents","allRng","allContentsSelected","selectAll","shortcuts","documentElementEditingFocus","Range","blur","selectControlElements","visualAidsAnchorClass","disableBackspaceIntoATable","setGeckoEditingOptions","setOpts","addBrAfterLastLinks","showBrokenImageIcon","contentStyles","restoreFocusOnKeyDown","bodyHeight","blockCmdArrowNavigation","tapLinksAndImages","blockFormSubmitInsideEditor","isAllContentSelected","getAttributeApplyFunction","setAttributeNode","isSelectionAcrossElements","removeStylesWhenDeletingAcrossBlockElements","DragEvent","DOM$6","getRootName","removeUndefined","mkParserSettings","mkSchemaSettings","initEditor","bindPendingEventDelegates","fireInit","moveSelectionToFirstCaretPosition","initInstanceCallback","autoFocus","getStyleSheetLoader$1","loadContentCss","fontCss","removeCss","contentCssText","allStylesheets","framedFonts","bundledCss","normalCss","bundledPromises","makeStylesheetLoadingPromises","contentStyle","appendStyle","initEditorWithInitialContent","startContent","loadInitialContent","contentBodyLoaded","disabled","readonly","_editableRoot","hasEditableRoot","createParser","mkSerializerSettings","annotator","_nodeChangeDispatcher","setup$5","setup$1","setup$o","setupRtcThunk","firePreInit","spellcheck","firePostRender","directionality","protect","escape","preInit","cancelProgress","canceled","progressTimeout","setProgressState","startProgress","setupRtc","_rtcMode","DOM$5","createIframe","boxInfo","iframeTitle","tabindex","ifr","title","customAttrs","iframe","frameBorder","allowTransparency","createIframeElement","iframeContainer","iframeHTML","documentBaseUrl","bodyId","bodyClass","translatedAriaText","getIframeHtml","setupIframeBody","ready","srcdoc","DOM$4","initPlugin","initializedPlugins","Plugin","pluginUrl","pluginInstance","pluginInitError","createThemeFalseResult","renderThemeFalse","renderThemeFalseIframe","renderThemeUi","render","renderUI","renderFromLoadedTheme","iframeHeight","renderFromThemeFunc","async","iconPackName","currentIcons","loadIcons","svgData","icon","addIcon","initIcons","Theme","initTheme","Model","initModel","trimLegacyPrefix","initPlugins","renderInfo","uiApiFacade","isEnabled","setEnabled","augmentEditorUiApi","hidden","visibility","orgVisibility","init$1","DOM$3","hasSkipLoadPrefix","loadLanguage","scriptLoader","languageCode","languageUrl","languageLoadError","loadTheme","themeUrl","themeLoadError","loadModel","modelUrl","modelLoadError","getIconsUrlMetaFromName","defaultIconsUrl","customIconsUrl","getIconsUrlMetaFromUrl","cat","urlMeta","iconsLoadError","loadPlugins","loadPlugin","pluginLoadError","isThemeLoaded","isModelLoaded","snapshot","getStyleSheetLoader","resetContent","triggerSave","windowManager","isEncodingXml","set_dirty","deviceDetection","normalizePlugins","trimmedPlugins","extractSections","bifilter","sections","hasSection","sectionResult","getMobileOverrideOptions","mobileOptions","table_grid","object_resizing","resize","toolbar_mode","toolbar_sticky","menubar","getExternalPlugins","overrideOptions","userDefinedExternalPlugins","external_plugins","processPlugins","isMobileDevice","defaultOverrideOptions","forcedPlugins","forced_plugins","desktopPlugins","mobileConfig","getSectionConfig","platformPlugins","mobilePlugins","getPlatformPlugins","combinedPlugins","combinePlugins","combineOptions","defaultOptions","deviceOverrideOptions","mobile","extendedOptions","isOnMobile","defaults","sectionOptions","getSection","addVisual$1","registerExecCommands$3","toggleAlign","align","editorCommands","addCommands","JustifyLeft","JustifyCenter","JustifyRight","JustifyFull","JustifyNone","registerCommands$b","alignStates","registerQueryStateCommands$1","trimOrPad","trimOrPadLeftRight","insertAtCaret","processValue$1","insertedContent","insertContent$1","legacyPropNames","isFont","getSpecifiedFontProp","legacyPropName","getProperty","getFontProp","getComputedFontProp","getFontSize","getFontFamily","findFirstCaretElement","bindRange","getCaretElement","mapRange","fromFontSizeNumber","fontSizeNumber","getFontStyleValues","fontClasses","getFontSizeClasses","normalizeFontNames","font","fonts","registerExecCommands$2","_command","fontNameAction","fontSizeAction","lineHeightAction","customCode","registerQueryValueCommands","isFormatMatch","addQueryValueHandler","fontNameQuery","fontSizeQuery","specifiedStyle","lineHeightQuery","registerCommands$6","Indent","Outdent","topParentBlock","getTopParentBlock","registerCommands$3","InsertNewBlockBefore","InsertNewBlockAfter","registerCommands","queryCommandEnabled","queryCommandSupported","registerCommands$a","mceAddUndoLevel","mceEndUndoLevel","Undo","Redo","registerCommands$7","mceSelectNodeDepth","mceSelectNode","registerCommands$1","mceCleanup","insertHorizontalRule","insertText","insertHTML","mceInsertContent","mceSetContent","mceReplaceContent","mceNewDocument","registerCommands$9","applyLinkToSelection","linkDetails","unlink","mceInsertLink","registerCommands$5","insertParagraph","mceInsertNewLine","InsertLineBreak","registerCommands$2","listParent","registerExecCommands$1","list","registerQueryStateCommands","registerCommands$4","registerCommands$8","mceRemoveNode","mcePrint","print","mceFocus","mceToggleVisualAid","registerExecCommands","selectionSafeCommands","isSelectionSafeCommand","EditorCommands","commands","lowerCaseCommand","skip_focus","restore","queryCommandState","queryCommandValue","commandList","addQueryStateHandler","setContentEditable","toggleReadOnly","removeFakeSelection","switchOnContentEditableTrue","restoreFakeSelection","registerFilters","allowedEvents","processReadonlyEvents","isClickEvent","getAnchorHrefOpt","targetEl","isReadOnlyAllowedEvent","nativeEvents","EventDispatcher","bindings","toggleEvent","beforeFire","once","wrappedCallback","currentName","bindingName","filteredHandlers","binding","getEventDispatcher","_eventDispatcher","isNative","toggleNativeEvent","Observable","bubble","dispatcherArgs","DOM$2","customEventRootDelegates","getEventTarget","eventName","eventRoot","isListening","bindEventDelegate","delegates","eventRootElm","delegate","editors","EditorObservable","_pendingNativeEvents","stringListProcessor","getErrorMessage","isValidResult","processValue","processor","create$5","initialOptions","setValue","isRegistered","isBuiltInSpec","getBuiltInProcessor","processDefaultValue","default","immutable","unset","registered","defaultModes","switchToMode","activeMode","availableModes","oldMode","newMode","activate","deactivate","editorReadOnly","fireSwitchMode","create$4","design","registerReadOnlyContentFilters","registerReadOnlySelectionBlockers","setMode","registerMode","each$2","keyCodeLookup","f1","f2","f3","f4","f5","f6","f7","f8","f9","f10","f11","f12","modifierNames","parseShortcut","shortcut","isModifier","access","alt","ctrl","meta","Shortcuts","pendingPatterns","hasModifier","isFunctionKey","matchShortcut","subpatterns","executeShortcutAction","cmdFunc","normalizeCommandFunc","createShortcut","bridge","menuItems","contextMenus","contextToolbars","sidebars","views","addButton","addGroupToolbarButton","addToggleButton","addMenuButton","addSplitButton","addMenuItem","addNestedMenuItem","addToggleMenuItem","addAutocompleter","addContextMenu","addContextToolbar","addContextForm","addSidebar","addView","create$3","DOM$1","each$1","Editor","loadedCSS","isNotDirty","documentBaseURL","normalizeOptions","registerOption","hasPlugin","lookupFn","ctx","rawPatterns","_ctx","register$7","_setBaseUrl","baseURI","setupCallback","getParam","loadArgs","saveArgs","initialContent","oldState","urlConverterCallback","urlObject","setEditableRoot","fireEditableRootStateChange","_scanForImages","beforeUnloadDelegate","boundGlobalEvents","globalEventDelegate","EditorManager","toggleGlobalEvents","removeEditorFromList","targetEditor","oldEditors","isQuirksMode","compatMode","majorVersion","minorVersion","releaseDate","i18n","tinyMCEPreInit","srcScript","overrideDefaults","base_url","pluginBaseUrls","plugin_base_urls","pluginBaseUrl","pluginName","invalidInlineTargets","provideResults","initEditors","initCount","execCallback","unique$1","findTargets","isInvalidInlineTarget","createEditor","createId","existingEditor","editorId","editorOptions","addI18n","FakeClipboard","dataValue","FakeClipboardItem","getType","relativePosition","targetW","targetH","relChars","create$2","Rect","inflate","findBestRelativePosition","constrainRect","rels","intersect","cropRect","x1","y1","clamp","clampRect","fixedSize","cx2","cy2","underflowX1","underflowY1","overflowX2","overflowY2","fromClientRect","tasks","resultFns","resources","loadErrMsg","runErrMsg","task","waiter","resolveCb","rejectCb","complete","completer","awaiter","create$1","localStorage","setItem","removeItem","storage","getItem","defineProperty","publicApi","geom","util","LocalStorage","ImageUploader","showNotification","TreeWalker","Serializer","Selection","tinymce$1","tinyMCE","exportToWindowGlobal","module","exportToModuleLoaders"],"mappings":"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A,OACA,KACA,WACA,SACA,SACA,IACA,UACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,UACA,SACA,SACA,QACA,SACA,SACA,OACA,SACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,WACA,QACA,KACA,QACA,OACA,KACA,QACA,KACA,IACA,KACA,MACA,QACA,QAEIk7B,MAAQl7B,OAAO,CACnB,MACA,IACA,WACA,cACA,eACA,eACA,gBACA,mBACA,SACA,WACA,OACA,OACA,UACA,SACA,OACA,IACA,QACA,WACA,QACA,QACA,OACA,iBACA,SACA,OACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,OACA,QACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,OACA,UAEIm7B,WAAan7B,OAAO,CACxB,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,eACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,iBAEIo7B,cAAgBp7B,OAAO,CAC3B,UACA,gBACA,SACA,UACA,YACA,mBACA,iBACA,gBACA,gBACA,gBACA,QACA,YACA,OACA,eACA,YACA,UACA,gBACA,SACA,MACA,aACA,UACA,QAEIq7B,SAAWr7B,OAAO,CACtB,OACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,gBACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,SACA,QACA,SACA,OACA,OACA,UACA,SACA,MACA,QACA,MACA,SACA,aACA,gBAEIs7B,iBAAmBt7B,OAAO,CAC9B,UACA,cACA,aACA,WACA,YACA,UACA,UACA,SACA,SACA,QACA,YACA,aACA,iBACA,cACA,SAEIt2D,KAAOs2D,OAAO,CAAC,UACf92D,KAAO82D,OAAO,CAClB,SACA,SACA,QACA,MACA,iBACA,eACA,uBACA,WACA,aACA,UACA,SACA,UACA,cACA,cACA,UACA,OACA,QACA,QACA,QACA,OACA,UACA,WACA,eACA,SACA,cACA,WACA,WACA,UACA,MACA,WACA,0BACA,wBACA,WACA,YACA,UACA,eACA,OACA,MACA,UACA,SACA,SACA,OACA,OACA,WACA,KACA,YACA,YACA,QACA,OACA,QACA,OACA,OACA,UACA,OACA,MACA,MACA,YACA,QACA,SACA,MACA,YACA,WACA,QACA,OACA,QACA,UACA,aACA,SACA,OACA,UACA,UACA,cACA,cACA,SACA,UACA,UACA,aACA,WACA,MACA,WACA,MACA,WACA,OACA,OACA,UACA,aACA,QACA,WACA,QACA,OACA,QACA,OACA,UACA,QACA,MACA,SACA,OACA,QACA,UACA,WACA,QACA,YACA,OACA,SACA,SACA,QACA,QACA,QACA,SAEI7vC,IAAM6vC,OAAO,CACjB,gBACA,aACA,WACA,qBACA,SACA,gBACA,gBACA,UACA,gBACA,iBACA,QACA,OACA,KACA,QACA,OACA,gBACA,YACA,YACA,QACA,sBACA,8BACA,gBACA,kBACA,KACA,KACA,IACA,KACA,KACA,kBACA,YACA,UACA,UACA,MACA,WACA,YACA,MACA,OACA,eACA,YACA,SACA,cACA,cACA,gBACA,cACA,YACA,mBACA,eACA,aACA,eACA,cACA,KACA,KACA,KACA,KACA,aACA,WACA,gBACA,oBACA,SACA,OACA,KACA,kBACA,KACA,MACA,IACA,KACA,KACA,KACA,KACA,UACA,YACA,aACA,WACA,OACA,eACA,iBACA,eACA,mBACA,iBACA,QACA,aACA,aACA,eACA,eACA,cACA,cACA,mBACA,YACA,MACA,OACA,QACA,SACA,OACA,MACA,OACA,aACA,SACA,WACA,UACA,QACA,SACA,cACA,SACA,WACA,cACA,OACA,aACA,sBACA,mBACA,eACA,SACA,gBACA,sBACA,iBACA,IACA,KACA,KACA,SACA,OACA,OACA,cACA,YACA,UACA,SACA,SACA,QACA,OACA,kBACA,mBACA,mBACA,eACA,cACA,eACA,cACA,aACA,eACA,mBACA,oBACA,iBACA,kBACA,oBACA,iBACA,SACA,eACA,QACA,eACA,iBACA,WACA,UACA,UACA,YACA,mBACA,cACA,kBACA,iBACA,aACA,OACA,KACA,KACA,UACA,SACA,UACA,aACA,UACA,aACA,gBACA,gBACA,QACA,eACA,OACA,eACA,mBACA,mBACA,IACA,KACA,KACA,QACA,IACA,KACA,KACA,IACA,eAEIu7B,OAASv7B,OAAO,CACpB,SACA,cACA,QACA,WACA,QACA,eACA,cACA,aACA,aACA,QACA,MACA,UACA,eACA,WACA,QACA,QACA,SACA,OACA,KACA,UACA,SACA,gBACA,SACA,SACA,iBACA,YACA,WACA,cACA,UACA,UACA,gBACA,WACA,WACA,OACA,WACA,WACA,aACA,UACA,SACA,SACA,cACA,gBACA,uBACA,YACA,YACA,aACA,WACA,iBACA,iBACA,YACA,UACA,QACA,UAEIw7B,IAAMx7B,OAAO,CACjB,aACA,SACA,cACA,YACA,gBAEIy7B,cAAgB7pE,KAAK,6BACrB8pE,SAAW9pE,KAAK,yBAChB+pE,YAAc/pE,KAAK,iBACnBgqE,UAAYhqE,KAAK,8BACjBiqE,UAAYjqE,KAAK,kBACjBkqE,eAAiBlqE,KAAK,6FACtBmqE,kBAAoBnqE,KAAK,yBACzBoqE,gBAAkBpqE,KAAK,+DACvBqqE,aAAerqE,KAAK,eACtBsqE,YAAc5sG,OAAO0wE,OAAO,CAC9BC,UAAW,KACXw7B,cAAeA,cACfC,SAAUA,SACVC,YAAaA,YACbC,UAAWA,UACXC,UAAWA,UACXC,eAAgBA,eAChBC,kBAAmBA,kBACnBC,gBAAiBA,gBACjBC,aAAcA,qBAEVE,UAAY,IAAwB,oBAAXn6F,OAAyB,KAAOA,OACzDo6F,0BAA4B,SAAmCC,aAAcC,sBACrD,iBAAjBD,cAAkE,mBAA9BA,aAAaE,oBACnD,SAEL3/F,OAAS,KAET0/F,mBAAqBA,kBAAkBn1F,aADzB,2BAEhBvK,OAAS0/F,kBAAkBt1F,aAFX,gCAIZw1F,WAAa,aAAe5/F,OAAS,IAAMA,OAAS,eAEjDy/F,aAAaE,aAAaC,WAAY,CAC3Cj9D,WAAWr2B,MACFA,KAETuzF,gBAAgB9mE,WACPA,YAGX,MAAOsN,UACPx8B,QAAQu0F,KAAK,uBAAyBwB,WAAa,0BAC5C,WAgwBPE,gBA7vBKC,sBACH36F,OAASo4F,UAAU3rG,OAAS,QAAsBf,IAAjB0sG,UAAU,GAAmBA,UAAU,GAAK+B,kBAC3ES,UAAY9/E,MAAQ6/E,gBAAgB7/E,SAC1C8/E,UAAUt+F,QAAU,QACpBs+F,UAAU/iC,QAAU,IACf73D,SAAWA,OAAOa,UAAyC,IAA7Bb,OAAOa,SAASkD,gBACjD62F,UAAUztF,aAAc,EACjBytF,gBAEHC,iBAAmB76F,OAAOa,SAC1Bi6F,cAAgBD,iBAAiBC,kBACnCj6F,SAACA,UAAYb,aACX+6F,iBAACA,iBAADC,oBAAmBA,oBAAnBnwF,KAAwCA,KAAxCF,QAA8CA,QAA9C48D,WAAuDA,WAAvD0zB,aAAmEA,aAAej7F,OAAOi7F,cAAgBj7F,OAAOk7F,gBAAhHC,gBAAiIA,gBAAjIC,UAAkJA,UAAlJf,aAA6JA,cAAgBr6F,OAC7Kq7F,iBAAmB1wF,QAAQ9e,UAC3BqkB,UAAY4oF,aAAauC,iBAAkB,aAC3CC,eAAiBxC,aAAauC,iBAAkB,eAChD1qD,cAAgBmoD,aAAauC,iBAAkB,cAC/CE,cAAgBzC,aAAauC,iBAAkB,iBAClB,mBAAxBL,oBAAoC,OACvCQ,SAAW36F,SAASuG,cAAc,YACpCo0F,SAAS7rF,SAAW6rF,SAAS7rF,QAAQ5G,gBACvClI,SAAW26F,SAAS7rF,QAAQ5G,mBAG5B0yF,mBACAC,UAAY,SACVC,eAACA,eAADC,mBAAiBA,mBAAjB9rF,uBAAqCA,uBAArC8J,qBAA6DA,sBAAwB/Y,UACrF+uF,WAACA,YAAciL,qBACjBgB,MAAQ,GACZjB,UAAUztF,YAAiC,mBAAZupF,SAAmD,mBAAlB6E,eAAgCI,qBAAwDjwG,IAAtCiwG,eAAeG,yBAC3HrC,cAACA,cAADC,SAAgBA,SAAhBC,YAA0BA,YAA1BC,UAAuCA,UAAvCC,UAAkDA,UAAlDE,kBAA6DA,kBAA7DC,gBAAgFA,iBAAmBE,gBACpGJ,eAAgBiC,kBAAoB7B,YACrC8B,aAAe,WACbC,qBAAuBzD,SAAS,GAAI,IACrCS,UACAC,SACAC,cACAE,YACA3xF,WAEDw0F,aAAe,WACbC,qBAAuB3D,SAAS,GAAI,IACrCtxF,QACAinB,OACAorE,UACAC,UAED4C,wBAA0B9uG,OAAOsiC,KAAKtiC,OAAO+vC,OAAO,KAAM,CAC5Dg/D,aAAc,CACZC,UAAU,EACVC,cAAc,EACdC,YAAY,EACZluG,MAAO,MAETmuG,mBAAoB,CAClBH,UAAU,EACVC,cAAc,EACdC,YAAY,EACZluG,MAAO,MAETouG,+BAAgC,CAC9BJ,UAAU,EACVC,cAAc,EACdC,YAAY,EACZluG,OAAO,MAGPquG,YAAc,KACdC,YAAc,KACdC,iBAAkB,EAClBC,iBAAkB,EAClBC,yBAA0B,EAC1BC,0BAA2B,EAC3BC,oBAAqB,EACrBC,gBAAiB,EACjBC,YAAa,EACbC,YAAa,EACbC,YAAa,EACbC,qBAAsB,EACtBC,qBAAsB,EACtBC,cAAe,EACfC,sBAAuB,QACrBC,4BAA8B,oBAChCC,cAAe,EACfC,UAAW,EACXC,aAAe,GACfC,gBAAkB,WAChBC,wBAA0BvF,SAAS,GAAI,CAC3C,iBACA,QACA,WACA,OACA,gBACA,OACA,SACA,OACA,KACA,KACA,KACA,KACA,QACA,UACA,WACA,WACA,YACA,SACA,QACA,MACA,WACA,QACA,QACA,QACA,YAEEwF,cAAgB,WACdC,sBAAwBzF,SAAS,GAAI,CACzC,QACA,QACA,MACA,SACA,QACA,cAEE0F,oBAAsB,WACpBC,4BAA8B3F,SAAS,GAAI,CAC/C,MACA,QACA,MACA,KACA,QACA,OACA,UACA,cACA,OACA,UACA,QACA,QACA,QACA,UAEI4F,iBAAmB,qCACnBC,cAAgB,6BAChBC,eAAiB,mCACnBC,UAAYD,eACZE,gBAAiB,EACjBC,mBAAqB,WACnBC,2BAA6BlG,SAAS,GAAI,CAC9C4F,iBACAC,cACAC,gBACC3G,oBACCgH,wBACEC,6BAA+B,CACnC,wBACA,aAEIC,0BAA4B,gBAC9BpG,kBACAqG,OAAS,WACPC,YAAcl+F,SAASuG,cAAc,QACrC43F,kBAAoB,SAA2BC,kBAC5CA,q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"}