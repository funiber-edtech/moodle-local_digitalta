{"version":3,"file":"tinymce.min.js","sources":["../src/tinymce.js"],"sourcesContent":["/**\r\n * TinyMCE version 6.8.3 (2024-02-08)\r\n */\r\n/* eslint-disable */\r\nconst tinymce = () => {\r\n    'use strict';\r\n\r\n    var typeOf$1 = function (x) {\r\n      if (x === null) {\r\n        return 'null';\r\n      }\r\n      if (x === undefined) {\r\n        return 'undefined';\r\n      }\r\n      var t = typeof x;\r\n      if (t === 'object' && (Array.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'Array')) {\r\n        return 'array';\r\n      }\r\n      if (t === 'object' && (String.prototype.isPrototypeOf(x) || x.constructor && x.constructor.name === 'String')) {\r\n        return 'string';\r\n      }\r\n      return t;\r\n    };\r\n    var isEquatableType = function (x) {\r\n      return [\r\n        'undefined',\r\n        'boolean',\r\n        'number',\r\n        'string',\r\n        'function',\r\n        'xml',\r\n        'null'\r\n      ].indexOf(x) !== -1;\r\n    };\r\n\r\n    var sort$1 = function (xs, compareFn) {\r\n      var clone = Array.prototype.slice.call(xs);\r\n      return clone.sort(compareFn);\r\n    };\r\n\r\n    var contramap = function (eqa, f) {\r\n      return eq$2(function (x, y) {\r\n        return eqa.eq(f(x), f(y));\r\n      });\r\n    };\r\n    var eq$2 = function (f) {\r\n      return { eq: f };\r\n    };\r\n    var tripleEq = eq$2(function (x, y) {\r\n      return x === y;\r\n    });\r\n    var eqString = tripleEq;\r\n    var eqArray = function (eqa) {\r\n      return eq$2(function (x, y) {\r\n        if (x.length !== y.length) {\r\n          return false;\r\n        }\r\n        var len = x.length;\r\n        for (var i = 0; i < len; i++) {\r\n          if (!eqa.eq(x[i], y[i])) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      });\r\n    };\r\n    var eqSortedArray = function (eqa, compareFn) {\r\n      return contramap(eqArray(eqa), function (xs) {\r\n        return sort$1(xs, compareFn);\r\n      });\r\n    };\r\n    var eqRecord = function (eqa) {\r\n      return eq$2(function (x, y) {\r\n        var kx = Object.keys(x);\r\n        var ky = Object.keys(y);\r\n        if (!eqSortedArray(eqString).eq(kx, ky)) {\r\n          return false;\r\n        }\r\n        var len = kx.length;\r\n        for (var i = 0; i < len; i++) {\r\n          var q = kx[i];\r\n          if (!eqa.eq(x[q], y[q])) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      });\r\n    };\r\n    var eqAny = eq$2(function (x, y) {\r\n      if (x === y) {\r\n        return true;\r\n      }\r\n      var tx = typeOf$1(x);\r\n      var ty = typeOf$1(y);\r\n      if (tx !== ty) {\r\n        return false;\r\n      }\r\n      if (isEquatableType(tx)) {\r\n        return x === y;\r\n      } else if (tx === 'array') {\r\n        return eqArray(eqAny).eq(x, y);\r\n      } else if (tx === 'object') {\r\n        return eqRecord(eqAny).eq(x, y);\r\n      }\r\n      return false;\r\n    });\r\n\r\n    const getPrototypeOf$2 = Object.getPrototypeOf;\r\n    const hasProto = (v, constructor, predicate) => {\r\n      var _a;\r\n      if (predicate(v, constructor.prototype)) {\r\n        return true;\r\n      } else {\r\n        return ((_a = v.constructor) === null || _a === void 0 ? void 0 : _a.name) === constructor.name;\r\n      }\r\n    };\r\n    const typeOf = x => {\r\n      const t = typeof x;\r\n      if (x === null) {\r\n        return 'null';\r\n      } else if (t === 'object' && Array.isArray(x)) {\r\n        return 'array';\r\n      } else if (t === 'object' && hasProto(x, String, (o, proto) => proto.isPrototypeOf(o))) {\r\n        return 'string';\r\n      } else {\r\n        return t;\r\n      }\r\n    };\r\n    const isType$1 = type => value => typeOf(value) === type;\r\n    const isSimpleType = type => value => typeof value === type;\r\n    const eq$1 = t => a => t === a;\r\n    const is$4 = (value, constructor) => isObject(value) && hasProto(value, constructor, (o, proto) => getPrototypeOf$2(o) === proto);\r\n    const isString = isType$1('string');\r\n    const isObject = isType$1('object');\r\n    const isPlainObject = value => is$4(value, Object);\r\n    const isArray$1 = isType$1('array');\r\n    const isNull = eq$1(null);\r\n    const isBoolean = isSimpleType('boolean');\r\n    const isUndefined = eq$1(undefined);\r\n    const isNullable = a => a === null || a === undefined;\r\n    const isNonNullable = a => !isNullable(a);\r\n    const isFunction = isSimpleType('function');\r\n    const isNumber = isSimpleType('number');\r\n    const isArrayOf = (value, pred) => {\r\n      if (isArray$1(value)) {\r\n        for (let i = 0, len = value.length; i < len; ++i) {\r\n          if (!pred(value[i])) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n      return false;\r\n    };\r\n\r\n    const noop = () => {\r\n    };\r\n    const compose = (fa, fb) => {\r\n      return (...args) => {\r\n        return fa(fb.apply(null, args));\r\n      };\r\n    };\r\n    const compose1 = (fbc, fab) => a => fbc(fab(a));\r\n    const constant = value => {\r\n      return () => {\r\n        return value;\r\n      };\r\n    };\r\n    const identity = x => {\r\n      return x;\r\n    };\r\n    const tripleEquals = (a, b) => {\r\n      return a === b;\r\n    };\r\n    function curry(fn, ...initialArgs) {\r\n      return (...restArgs) => {\r\n        const all = initialArgs.concat(restArgs);\r\n        return fn.apply(null, all);\r\n      };\r\n    }\r\n    const not = f => t => !f(t);\r\n    const die = msg => {\r\n      return () => {\r\n        throw new Error(msg);\r\n      };\r\n    };\r\n    const apply$1 = f => {\r\n      return f();\r\n    };\r\n    const call = f => {\r\n      f();\r\n    };\r\n    const never = constant(false);\r\n    const always = constant(true);\r\n\r\n    class Optional {\r\n      constructor(tag, value) {\r\n        this.tag = tag;\r\n        this.value = value;\r\n      }\r\n      static some(value) {\r\n        return new Optional(true, value);\r\n      }\r\n      static none() {\r\n        return Optional.singletonNone;\r\n      }\r\n      fold(onNone, onSome) {\r\n        if (this.tag) {\r\n          return onSome(this.value);\r\n        } else {\r\n          return onNone();\r\n        }\r\n      }\r\n      isSome() {\r\n        return this.tag;\r\n      }\r\n      isNone() {\r\n        return !this.tag;\r\n      }\r\n      map(mapper) {\r\n        if (this.tag) {\r\n          return Optional.some(mapper(this.value));\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      }\r\n      bind(binder) {\r\n        if (this.tag) {\r\n          return binder(this.value);\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      }\r\n      exists(predicate) {\r\n        return this.tag && predicate(this.value);\r\n      }\r\n      forall(predicate) {\r\n        return !this.tag || predicate(this.value);\r\n      }\r\n      filter(predicate) {\r\n        if (!this.tag || predicate(this.value)) {\r\n          return this;\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      }\r\n      getOr(replacement) {\r\n        return this.tag ? this.value : replacement;\r\n      }\r\n      or(replacement) {\r\n        return this.tag ? this : replacement;\r\n      }\r\n      getOrThunk(thunk) {\r\n        return this.tag ? this.value : thunk();\r\n      }\r\n      orThunk(thunk) {\r\n        return this.tag ? this : thunk();\r\n      }\r\n      getOrDie(message) {\r\n        if (!this.tag) {\r\n          throw new Error(message !== null && message !== void 0 ? message : 'Called getOrDie on None');\r\n        } else {\r\n          return this.value;\r\n        }\r\n      }\r\n      static from(value) {\r\n        return isNonNullable(value) ? Optional.some(value) : Optional.none();\r\n      }\r\n      getOrNull() {\r\n        return this.tag ? this.value : null;\r\n      }\r\n      getOrUndefined() {\r\n        return this.value;\r\n      }\r\n      each(worker) {\r\n        if (this.tag) {\r\n          worker(this.value);\r\n        }\r\n      }\r\n      toArray() {\r\n        return this.tag ? [this.value] : [];\r\n      }\r\n      toString() {\r\n        return this.tag ? `some(${ this.value })` : 'none()';\r\n      }\r\n    }\r\n    Optional.singletonNone = new Optional(false);\r\n\r\n    const nativeSlice = Array.prototype.slice;\r\n    const nativeIndexOf = Array.prototype.indexOf;\r\n    const nativePush = Array.prototype.push;\r\n    const rawIndexOf = (ts, t) => nativeIndexOf.call(ts, t);\r\n    const indexOf$1 = (xs, x) => {\r\n      const r = rawIndexOf(xs, x);\r\n      return r === -1 ? Optional.none() : Optional.some(r);\r\n    };\r\n    const contains$2 = (xs, x) => rawIndexOf(xs, x) > -1;\r\n    const exists = (xs, pred) => {\r\n      for (let i = 0, len = xs.length; i < len; i++) {\r\n        const x = xs[i];\r\n        if (pred(x, i)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    const map$3 = (xs, f) => {\r\n      const len = xs.length;\r\n      const r = new Array(len);\r\n      for (let i = 0; i < len; i++) {\r\n        const x = xs[i];\r\n        r[i] = f(x, i);\r\n      }\r\n      return r;\r\n    };\r\n    const each$e = (xs, f) => {\r\n      for (let i = 0, len = xs.length; i < len; i++) {\r\n        const x = xs[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    const eachr = (xs, f) => {\r\n      for (let i = xs.length - 1; i >= 0; i--) {\r\n        const x = xs[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    const partition$2 = (xs, pred) => {\r\n      const pass = [];\r\n      const fail = [];\r\n      for (let i = 0, len = xs.length; i < len; i++) {\r\n        const x = xs[i];\r\n        const arr = pred(x, i) ? pass : fail;\r\n        arr.push(x);\r\n      }\r\n      return {\r\n        pass,\r\n        fail\r\n      };\r\n    };\r\n    const filter$5 = (xs, pred) => {\r\n      const r = [];\r\n      for (let i = 0, len = xs.length; i < len; i++) {\r\n        const x = xs[i];\r\n        if (pred(x, i)) {\r\n          r.push(x);\r\n        }\r\n      }\r\n      return r;\r\n    };\r\n    const foldr = (xs, f, acc) => {\r\n      eachr(xs, (x, i) => {\r\n        acc = f(acc, x, i);\r\n      });\r\n      return acc;\r\n    };\r\n    const foldl = (xs, f, acc) => {\r\n      each$e(xs, (x, i) => {\r\n        acc = f(acc, x, i);\r\n      });\r\n      return acc;\r\n    };\r\n    const findUntil$1 = (xs, pred, until) => {\r\n      for (let i = 0, len = xs.length; i < len; i++) {\r\n        const x = xs[i];\r\n        if (pred(x, i)) {\r\n          return Optional.some(x);\r\n        } else if (until(x, i)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const find$2 = (xs, pred) => {\r\n      return findUntil$1(xs, pred, never);\r\n    };\r\n    const findIndex$2 = (xs, pred) => {\r\n      for (let i = 0, len = xs.length; i < len; i++) {\r\n        const x = xs[i];\r\n        if (pred(x, i)) {\r\n          return Optional.some(i);\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const flatten = xs => {\r\n      const r = [];\r\n      for (let i = 0, len = xs.length; i < len; ++i) {\r\n        if (!isArray$1(xs[i])) {\r\n          throw new Error('Arr.flatten item ' + i + ' was not an array, input: ' + xs);\r\n        }\r\n        nativePush.apply(r, xs[i]);\r\n      }\r\n      return r;\r\n    };\r\n    const bind$3 = (xs, f) => flatten(map$3(xs, f));\r\n    const forall = (xs, pred) => {\r\n      for (let i = 0, len = xs.length; i < len; ++i) {\r\n        const x = xs[i];\r\n        if (pred(x, i) !== true) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    const reverse = xs => {\r\n      const r = nativeSlice.call(xs, 0);\r\n      r.reverse();\r\n      return r;\r\n    };\r\n    const difference = (a1, a2) => filter$5(a1, x => !contains$2(a2, x));\r\n    const mapToObject = (xs, f) => {\r\n      const r = {};\r\n      for (let i = 0, len = xs.length; i < len; i++) {\r\n        const x = xs[i];\r\n        r[String(x)] = f(x, i);\r\n      }\r\n      return r;\r\n    };\r\n    const sort = (xs, comparator) => {\r\n      const copy = nativeSlice.call(xs, 0);\r\n      copy.sort(comparator);\r\n      return copy;\r\n    };\r\n    const get$b = (xs, i) => i >= 0 && i < xs.length ? Optional.some(xs[i]) : Optional.none();\r\n    const head = xs => get$b(xs, 0);\r\n    const last$3 = xs => get$b(xs, xs.length - 1);\r\n    const from = isFunction(Array.from) ? Array.from : x => nativeSlice.call(x);\r\n    const findMap = (arr, f) => {\r\n      for (let i = 0; i < arr.length; i++) {\r\n        const r = f(arr[i], i);\r\n        if (r.isSome()) {\r\n          return r;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const unique$1 = (xs, comparator) => {\r\n      const r = [];\r\n      const isDuplicated = isFunction(comparator) ? x => exists(r, i => comparator(i, x)) : x => contains$2(r, x);\r\n      for (let i = 0, len = xs.length; i < len; i++) {\r\n        const x = xs[i];\r\n        if (!isDuplicated(x)) {\r\n          r.push(x);\r\n        }\r\n      }\r\n      return r;\r\n    };\r\n\r\n    const keys = Object.keys;\r\n    const hasOwnProperty$1 = Object.hasOwnProperty;\r\n    const each$d = (obj, f) => {\r\n      const props = keys(obj);\r\n      for (let k = 0, len = props.length; k < len; k++) {\r\n        const i = props[k];\r\n        const x = obj[i];\r\n        f(x, i);\r\n      }\r\n    };\r\n    const map$2 = (obj, f) => {\r\n      return tupleMap(obj, (x, i) => ({\r\n        k: i,\r\n        v: f(x, i)\r\n      }));\r\n    };\r\n    const tupleMap = (obj, f) => {\r\n      const r = {};\r\n      each$d(obj, (x, i) => {\r\n        const tuple = f(x, i);\r\n        r[tuple.k] = tuple.v;\r\n      });\r\n      return r;\r\n    };\r\n    const objAcc = r => (x, i) => {\r\n      r[i] = x;\r\n    };\r\n    const internalFilter = (obj, pred, onTrue, onFalse) => {\r\n      each$d(obj, (x, i) => {\r\n        (pred(x, i) ? onTrue : onFalse)(x, i);\r\n      });\r\n    };\r\n    const bifilter = (obj, pred) => {\r\n      const t = {};\r\n      const f = {};\r\n      internalFilter(obj, pred, objAcc(t), objAcc(f));\r\n      return {\r\n        t,\r\n        f\r\n      };\r\n    };\r\n    const filter$4 = (obj, pred) => {\r\n      const t = {};\r\n      internalFilter(obj, pred, objAcc(t), noop);\r\n      return t;\r\n    };\r\n    const mapToArray = (obj, f) => {\r\n      const r = [];\r\n      each$d(obj, (value, name) => {\r\n        r.push(f(value, name));\r\n      });\r\n      return r;\r\n    };\r\n    const values = obj => {\r\n      return mapToArray(obj, identity);\r\n    };\r\n    const get$a = (obj, key) => {\r\n      return has$2(obj, key) ? Optional.from(obj[key]) : Optional.none();\r\n    };\r\n    const has$2 = (obj, key) => hasOwnProperty$1.call(obj, key);\r\n    const hasNonNullableKey = (obj, key) => has$2(obj, key) && obj[key] !== undefined && obj[key] !== null;\r\n    const equal$1 = (a1, a2, eq = eqAny) => eqRecord(eq).eq(a1, a2);\r\n\r\n    const stringArray = a => {\r\n      const all = {};\r\n      each$e(a, key => {\r\n        all[key] = {};\r\n      });\r\n      return keys(all);\r\n    };\r\n\r\n    const isArrayLike = o => o.length !== undefined;\r\n    const isArray = Array.isArray;\r\n    const toArray$1 = obj => {\r\n      if (!isArray(obj)) {\r\n        const array = [];\r\n        for (let i = 0, l = obj.length; i < l; i++) {\r\n          array[i] = obj[i];\r\n        }\r\n        return array;\r\n      } else {\r\n        return obj;\r\n      }\r\n    };\r\n    const each$c = (o, cb, s) => {\r\n      if (!o) {\r\n        return false;\r\n      }\r\n      s = s || o;\r\n      if (isArrayLike(o)) {\r\n        for (let n = 0, l = o.length; n < l; n++) {\r\n          if (cb.call(s, o[n], n, o) === false) {\r\n            return false;\r\n          }\r\n        }\r\n      } else {\r\n        for (const n in o) {\r\n          if (has$2(o, n)) {\r\n            if (cb.call(s, o[n], n, o) === false) {\r\n              return false;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    const map$1 = (array, callback) => {\r\n      const out = [];\r\n      each$c(array, (item, index) => {\r\n        out.push(callback(item, index, array));\r\n      });\r\n      return out;\r\n    };\r\n    const filter$3 = (a, f) => {\r\n      const o = [];\r\n      each$c(a, (v, index) => {\r\n        if (!f || f(v, index, a)) {\r\n          o.push(v);\r\n        }\r\n      });\r\n      return o;\r\n    };\r\n    const indexOf = (a, v) => {\r\n      if (a) {\r\n        for (let i = 0, l = a.length; i < l; i++) {\r\n          if (a[i] === v) {\r\n            return i;\r\n          }\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    const reduce = (collection, iteratee, accumulator, thisArg) => {\r\n      let acc = isUndefined(accumulator) ? collection[0] : accumulator;\r\n      for (let i = 0; i < collection.length; i++) {\r\n        acc = iteratee.call(thisArg, acc, collection[i], i);\r\n      }\r\n      return acc;\r\n    };\r\n    const findIndex$1 = (array, predicate, thisArg) => {\r\n      for (let i = 0, l = array.length; i < l; i++) {\r\n        if (predicate.call(thisArg, array[i], i, array)) {\r\n          return i;\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    const last$2 = collection => collection[collection.length - 1];\r\n\r\n    const cached = f => {\r\n      let called = false;\r\n      let r;\r\n      return (...args) => {\r\n        if (!called) {\r\n          called = true;\r\n          r = f.apply(null, args);\r\n        }\r\n        return r;\r\n      };\r\n    };\r\n\r\n    const DeviceType = (os, browser, userAgent, mediaMatch) => {\r\n      const isiPad = os.isiOS() && /ipad/i.test(userAgent) === true;\r\n      const isiPhone = os.isiOS() && !isiPad;\r\n      const isMobile = os.isiOS() || os.isAndroid();\r\n      const isTouch = isMobile || mediaMatch('(pointer:coarse)');\r\n      const isTablet = isiPad || !isiPhone && isMobile && mediaMatch('(min-device-width:768px)');\r\n      const isPhone = isiPhone || isMobile && !isTablet;\r\n      const iOSwebview = browser.isSafari() && os.isiOS() && /safari/i.test(userAgent) === false;\r\n      const isDesktop = !isPhone && !isTablet && !iOSwebview;\r\n      return {\r\n        isiPad: constant(isiPad),\r\n        isiPhone: constant(isiPhone),\r\n        isTablet: constant(isTablet),\r\n        isPhone: constant(isPhone),\r\n        isTouch: constant(isTouch),\r\n        isAndroid: os.isAndroid,\r\n        isiOS: os.isiOS,\r\n        isWebView: constant(iOSwebview),\r\n        isDesktop: constant(isDesktop)\r\n      };\r\n    };\r\n\r\n    const firstMatch = (regexes, s) => {\r\n      for (let i = 0; i < regexes.length; i++) {\r\n        const x = regexes[i];\r\n        if (x.test(s)) {\r\n          return x;\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n    const find$1 = (regexes, agent) => {\r\n      const r = firstMatch(regexes, agent);\r\n      if (!r) {\r\n        return {\r\n          major: 0,\r\n          minor: 0\r\n        };\r\n      }\r\n      const group = i => {\r\n        return Number(agent.replace(r, '$' + i));\r\n      };\r\n      return nu$3(group(1), group(2));\r\n    };\r\n    const detect$5 = (versionRegexes, agent) => {\r\n      const cleanedAgent = String(agent).toLowerCase();\r\n      if (versionRegexes.length === 0) {\r\n        return unknown$2();\r\n      }\r\n      return find$1(versionRegexes, cleanedAgent);\r\n    };\r\n    const unknown$2 = () => {\r\n      return nu$3(0, 0);\r\n    };\r\n    const nu$3 = (major, minor) => {\r\n      return {\r\n        major,\r\n        minor\r\n      };\r\n    };\r\n    const Version = {\r\n      nu: nu$3,\r\n      detect: detect$5,\r\n      unknown: unknown$2\r\n    };\r\n\r\n    const detectBrowser$1 = (browsers, userAgentData) => {\r\n      return findMap(userAgentData.brands, uaBrand => {\r\n        const lcBrand = uaBrand.brand.toLowerCase();\r\n        return find$2(browsers, browser => {\r\n          var _a;\r\n          return lcBrand === ((_a = browser.brand) === null || _a === void 0 ? void 0 : _a.toLowerCase());\r\n        }).map(info => ({\r\n          current: info.name,\r\n          version: Version.nu(parseInt(uaBrand.version, 10), 0)\r\n        }));\r\n      });\r\n    };\r\n\r\n    const detect$4 = (candidates, userAgent) => {\r\n      const agent = String(userAgent).toLowerCase();\r\n      return find$2(candidates, candidate => {\r\n        return candidate.search(agent);\r\n      });\r\n    };\r\n    const detectBrowser = (browsers, userAgent) => {\r\n      return detect$4(browsers, userAgent).map(browser => {\r\n        const version = Version.detect(browser.versionRegexes, userAgent);\r\n        return {\r\n          current: browser.name,\r\n          version\r\n        };\r\n      });\r\n    };\r\n    const detectOs = (oses, userAgent) => {\r\n      return detect$4(oses, userAgent).map(os => {\r\n        const version = Version.detect(os.versionRegexes, userAgent);\r\n        return {\r\n          current: os.name,\r\n          version\r\n        };\r\n      });\r\n    };\r\n\r\n    const removeFromStart = (str, numChars) => {\r\n      return str.substring(numChars);\r\n    };\r\n\r\n    const checkRange = (str, substr, start) => substr === '' || str.length >= substr.length && str.substr(start, start + substr.length) === substr;\r\n    const removeLeading = (str, prefix) => {\r\n      return startsWith(str, prefix) ? removeFromStart(str, prefix.length) : str;\r\n    };\r\n    const contains$1 = (str, substr, start = 0, end) => {\r\n      const idx = str.indexOf(substr, start);\r\n      if (idx !== -1) {\r\n        return isUndefined(end) ? true : idx + substr.length <= end;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const startsWith = (str, prefix) => {\r\n      return checkRange(str, prefix, 0);\r\n    };\r\n    const endsWith = (str, suffix) => {\r\n      return checkRange(str, suffix, str.length - suffix.length);\r\n    };\r\n    const blank = r => s => s.replace(r, '');\r\n    const trim$4 = blank(/^\\s+|\\s+$/g);\r\n    const lTrim = blank(/^\\s+/g);\r\n    const rTrim = blank(/\\s+$/g);\r\n    const isNotEmpty = s => s.length > 0;\r\n    const isEmpty$3 = s => !isNotEmpty(s);\r\n    const repeat = (s, count) => count <= 0 ? '' : new Array(count + 1).join(s);\r\n    const toInt = (value, radix = 10) => {\r\n      const num = parseInt(value, radix);\r\n      return isNaN(num) ? Optional.none() : Optional.some(num);\r\n    };\r\n\r\n    const normalVersionRegex = /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/;\r\n    const checkContains = target => {\r\n      return uastring => {\r\n        return contains$1(uastring, target);\r\n      };\r\n    };\r\n    const browsers = [\r\n      {\r\n        name: 'Edge',\r\n        versionRegexes: [/.*?edge\\/ ?([0-9]+)\\.([0-9]+)$/],\r\n        search: uastring => {\r\n          return contains$1(uastring, 'edge/') && contains$1(uastring, 'chrome') && contains$1(uastring, 'safari') && contains$1(uastring, 'applewebkit');\r\n        }\r\n      },\r\n      {\r\n        name: 'Chromium',\r\n        brand: 'Chromium',\r\n        versionRegexes: [\r\n          /.*?chrome\\/([0-9]+)\\.([0-9]+).*/,\r\n          normalVersionRegex\r\n        ],\r\n        search: uastring => {\r\n          return contains$1(uastring, 'chrome') && !contains$1(uastring, 'chromeframe');\r\n        }\r\n      },\r\n      {\r\n        name: 'IE',\r\n        versionRegexes: [\r\n          /.*?msie\\ ?([0-9]+)\\.([0-9]+).*/,\r\n          /.*?rv:([0-9]+)\\.([0-9]+).*/\r\n        ],\r\n        search: uastring => {\r\n          return contains$1(uastring, 'msie') || contains$1(uastring, 'trident');\r\n        }\r\n      },\r\n      {\r\n        name: 'Opera',\r\n        versionRegexes: [\r\n          normalVersionRegex,\r\n          /.*?opera\\/([0-9]+)\\.([0-9]+).*/\r\n        ],\r\n        search: checkContains('opera')\r\n      },\r\n      {\r\n        name: 'Firefox',\r\n        versionRegexes: [/.*?firefox\\/\\ ?([0-9]+)\\.([0-9]+).*/],\r\n        search: checkContains('firefox')\r\n      },\r\n      {\r\n        name: 'Safari',\r\n        versionRegexes: [\r\n          normalVersionRegex,\r\n          /.*?cpu os ([0-9]+)_([0-9]+).*/\r\n        ],\r\n        search: uastring => {\r\n          return (contains$1(uastring, 'safari') || contains$1(uastring, 'mobile/')) && contains$1(uastring, 'applewebkit');\r\n        }\r\n      }\r\n    ];\r\n    const oses = [\r\n      {\r\n        name: 'Windows',\r\n        search: checkContains('win'),\r\n        versionRegexes: [/.*?windows\\ nt\\ ?([0-9]+)\\.([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'iOS',\r\n        search: uastring => {\r\n          return contains$1(uastring, 'iphone') || contains$1(uastring, 'ipad');\r\n        },\r\n        versionRegexes: [\r\n          /.*?version\\/\\ ?([0-9]+)\\.([0-9]+).*/,\r\n          /.*cpu os ([0-9]+)_([0-9]+).*/,\r\n          /.*cpu iphone os ([0-9]+)_([0-9]+).*/\r\n        ]\r\n      },\r\n      {\r\n        name: 'Android',\r\n        search: checkContains('android'),\r\n        versionRegexes: [/.*?android\\ ?([0-9]+)\\.([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'macOS',\r\n        search: checkContains('mac os x'),\r\n        versionRegexes: [/.*?mac\\ os\\ x\\ ?([0-9]+)_([0-9]+).*/]\r\n      },\r\n      {\r\n        name: 'Linux',\r\n        search: checkContains('linux'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'Solaris',\r\n        search: checkContains('sunos'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'FreeBSD',\r\n        search: checkContains('freebsd'),\r\n        versionRegexes: []\r\n      },\r\n      {\r\n        name: 'ChromeOS',\r\n        search: checkContains('cros'),\r\n        versionRegexes: [/.*?chrome\\/([0-9]+)\\.([0-9]+).*/]\r\n      }\r\n    ];\r\n    const PlatformInfo = {\r\n      browsers: constant(browsers),\r\n      oses: constant(oses)\r\n    };\r\n\r\n    const edge = 'Edge';\r\n    const chromium = 'Chromium';\r\n    const ie = 'IE';\r\n    const opera = 'Opera';\r\n    const firefox = 'Firefox';\r\n    const safari = 'Safari';\r\n    const unknown$1 = () => {\r\n      return nu$2({\r\n        current: undefined,\r\n        version: Version.unknown()\r\n      });\r\n    };\r\n    const nu$2 = info => {\r\n      const current = info.current;\r\n      const version = info.version;\r\n      const isBrowser = name => () => current === name;\r\n      return {\r\n        current,\r\n        version,\r\n        isEdge: isBrowser(edge),\r\n        isChromium: isBrowser(chromium),\r\n        isIE: isBrowser(ie),\r\n        isOpera: isBrowser(opera),\r\n        isFirefox: isBrowser(firefox),\r\n        isSafari: isBrowser(safari)\r\n      };\r\n    };\r\n    const Browser = {\r\n      unknown: unknown$1,\r\n      nu: nu$2,\r\n      edge: constant(edge),\r\n      chromium: constant(chromium),\r\n      ie: constant(ie),\r\n      opera: constant(opera),\r\n      firefox: constant(firefox),\r\n      safari: constant(safari)\r\n    };\r\n\r\n    const windows = 'Windows';\r\n    const ios = 'iOS';\r\n    const android = 'Android';\r\n    const linux = 'Linux';\r\n    const macos = 'macOS';\r\n    const solaris = 'Solaris';\r\n    const freebsd = 'FreeBSD';\r\n    const chromeos = 'ChromeOS';\r\n    const unknown = () => {\r\n      return nu$1({\r\n        current: undefined,\r\n        version: Version.unknown()\r\n      });\r\n    };\r\n    const nu$1 = info => {\r\n      const current = info.current;\r\n      const version = info.version;\r\n      const isOS = name => () => current === name;\r\n      return {\r\n        current,\r\n        version,\r\n        isWindows: isOS(windows),\r\n        isiOS: isOS(ios),\r\n        isAndroid: isOS(android),\r\n        isMacOS: isOS(macos),\r\n        isLinux: isOS(linux),\r\n        isSolaris: isOS(solaris),\r\n        isFreeBSD: isOS(freebsd),\r\n        isChromeOS: isOS(chromeos)\r\n      };\r\n    };\r\n    const OperatingSystem = {\r\n      unknown,\r\n      nu: nu$1,\r\n      windows: constant(windows),\r\n      ios: constant(ios),\r\n      android: constant(android),\r\n      linux: constant(linux),\r\n      macos: constant(macos),\r\n      solaris: constant(solaris),\r\n      freebsd: constant(freebsd),\r\n      chromeos: constant(chromeos)\r\n    };\r\n\r\n    const detect$3 = (userAgent, userAgentDataOpt, mediaMatch) => {\r\n      const browsers = PlatformInfo.browsers();\r\n      const oses = PlatformInfo.oses();\r\n      const browser = userAgentDataOpt.bind(userAgentData => detectBrowser$1(browsers, userAgentData)).orThunk(() => detectBrowser(browsers, userAgent)).fold(Browser.unknown, Browser.nu);\r\n      const os = detectOs(oses, userAgent).fold(OperatingSystem.unknown, OperatingSystem.nu);\r\n      const deviceType = DeviceType(os, browser, userAgent, mediaMatch);\r\n      return {\r\n        browser,\r\n        os,\r\n        deviceType\r\n      };\r\n    };\r\n    const PlatformDetection = { detect: detect$3 };\r\n\r\n    const mediaMatch = query => window.matchMedia(query).matches;\r\n    let platform$4 = cached(() => PlatformDetection.detect(navigator.userAgent, Optional.from(navigator.userAgentData), mediaMatch));\r\n    const detect$2 = () => platform$4();\r\n\r\n    const userAgent = navigator.userAgent;\r\n    const platform$3 = detect$2();\r\n    const browser$3 = platform$3.browser;\r\n    const os$1 = platform$3.os;\r\n    const deviceType = platform$3.deviceType;\r\n    const windowsPhone = userAgent.indexOf('Windows Phone') !== -1;\r\n    const Env = {\r\n      transparentSrc: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7',\r\n      documentMode: browser$3.isIE() ? document.documentMode || 7 : 10,\r\n      cacheSuffix: null,\r\n      container: null,\r\n      canHaveCSP: !browser$3.isIE(),\r\n      windowsPhone,\r\n      browser: {\r\n        current: browser$3.current,\r\n        version: browser$3.version,\r\n        isChromium: browser$3.isChromium,\r\n        isEdge: browser$3.isEdge,\r\n        isFirefox: browser$3.isFirefox,\r\n        isIE: browser$3.isIE,\r\n        isOpera: browser$3.isOpera,\r\n        isSafari: browser$3.isSafari\r\n      },\r\n      os: {\r\n        current: os$1.current,\r\n        version: os$1.version,\r\n        isAndroid: os$1.isAndroid,\r\n        isChromeOS: os$1.isChromeOS,\r\n        isFreeBSD: os$1.isFreeBSD,\r\n        isiOS: os$1.isiOS,\r\n        isLinux: os$1.isLinux,\r\n        isMacOS: os$1.isMacOS,\r\n        isSolaris: os$1.isSolaris,\r\n        isWindows: os$1.isWindows\r\n      },\r\n      deviceType: {\r\n        isDesktop: deviceType.isDesktop,\r\n        isiPad: deviceType.isiPad,\r\n        isiPhone: deviceType.isiPhone,\r\n        isPhone: deviceType.isPhone,\r\n        isTablet: deviceType.isTablet,\r\n        isTouch: deviceType.isTouch,\r\n        isWebView: deviceType.isWebView\r\n      }\r\n    };\r\n\r\n    const whiteSpaceRegExp$1 = /^\\s*|\\s*$/g;\r\n    const trim$3 = str => {\r\n      return isNullable(str) ? '' : ('' + str).replace(whiteSpaceRegExp$1, '');\r\n    };\r\n    const is$3 = (obj, type) => {\r\n      if (!type) {\r\n        return obj !== undefined;\r\n      }\r\n      if (type === 'array' && isArray(obj)) {\r\n        return true;\r\n      }\r\n      return typeof obj === type;\r\n    };\r\n    const makeMap$4 = (items, delim, map = {}) => {\r\n      const resolvedItems = isString(items) ? items.split(delim || ',') : items || [];\r\n      let i = resolvedItems.length;\r\n      while (i--) {\r\n        map[resolvedItems[i]] = {};\r\n      }\r\n      return map;\r\n    };\r\n    const hasOwnProperty = has$2;\r\n    const extend$3 = (obj, ...exts) => {\r\n      for (let i = 0; i < exts.length; i++) {\r\n        const ext = exts[i];\r\n        for (const name in ext) {\r\n          if (has$2(ext, name)) {\r\n            const value = ext[name];\r\n            if (value !== undefined) {\r\n              obj[name] = value;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return obj;\r\n    };\r\n    const walk$4 = function (o, f, n, s) {\r\n      s = s || this;\r\n      if (o) {\r\n        if (n) {\r\n          o = o[n];\r\n        }\r\n        each$c(o, (o, i) => {\r\n          if (f.call(s, o, i, n) === false) {\r\n            return false;\r\n          } else {\r\n            walk$4(o, f, n, s);\r\n            return true;\r\n          }\r\n        });\r\n      }\r\n    };\r\n    const resolve$3 = (n, o = window) => {\r\n      const path = n.split('.');\r\n      for (let i = 0, l = path.length; i < l; i++) {\r\n        o = o[path[i]];\r\n        if (!o) {\r\n          break;\r\n        }\r\n      }\r\n      return o;\r\n    };\r\n    const explode$3 = (s, d) => {\r\n      if (isArray$1(s)) {\r\n        return s;\r\n      } else if (s === '') {\r\n        return [];\r\n      } else {\r\n        return map$1(s.split(d || ','), trim$3);\r\n      }\r\n    };\r\n    const _addCacheSuffix = url => {\r\n      const cacheSuffix = Env.cacheSuffix;\r\n      if (cacheSuffix) {\r\n        url += (url.indexOf('?') === -1 ? '?' : '&') + cacheSuffix;\r\n      }\r\n      return url;\r\n    };\r\n    const Tools = {\r\n      trim: trim$3,\r\n      isArray: isArray,\r\n      is: is$3,\r\n      toArray: toArray$1,\r\n      makeMap: makeMap$4,\r\n      each: each$c,\r\n      map: map$1,\r\n      grep: filter$3,\r\n      inArray: indexOf,\r\n      hasOwn: hasOwnProperty,\r\n      extend: extend$3,\r\n      walk: walk$4,\r\n      resolve: resolve$3,\r\n      explode: explode$3,\r\n      _addCacheSuffix\r\n    };\r\n\r\n    const is$2 = (lhs, rhs, comparator = tripleEquals) => lhs.exists(left => comparator(left, rhs));\r\n    const equals = (lhs, rhs, comparator = tripleEquals) => lift2(lhs, rhs, comparator).getOr(lhs.isNone() && rhs.isNone());\r\n    const cat = arr => {\r\n      const r = [];\r\n      const push = x => {\r\n        r.push(x);\r\n      };\r\n      for (let i = 0; i < arr.length; i++) {\r\n        arr[i].each(push);\r\n      }\r\n      return r;\r\n    };\r\n    const lift2 = (oa, ob, f) => oa.isSome() && ob.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie())) : Optional.none();\r\n    const lift3 = (oa, ob, oc, f) => oa.isSome() && ob.isSome() && oc.isSome() ? Optional.some(f(oa.getOrDie(), ob.getOrDie(), oc.getOrDie())) : Optional.none();\r\n    const someIf = (b, a) => b ? Optional.some(a) : Optional.none();\r\n\r\n    const Global = typeof window !== 'undefined' ? window : Function('return this;')();\r\n\r\n    const path = (parts, scope) => {\r\n      let o = scope !== undefined && scope !== null ? scope : Global;\r\n      for (let i = 0; i < parts.length && o !== undefined && o !== null; ++i) {\r\n        o = o[parts[i]];\r\n      }\r\n      return o;\r\n    };\r\n    const resolve$2 = (p, scope) => {\r\n      const parts = p.split('.');\r\n      return path(parts, scope);\r\n    };\r\n\r\n    const unsafe = (name, scope) => {\r\n      return resolve$2(name, scope);\r\n    };\r\n    const getOrDie = (name, scope) => {\r\n      const actual = unsafe(name, scope);\r\n      if (actual === undefined || actual === null) {\r\n        throw new Error(name + ' not available on this browser');\r\n      }\r\n      return actual;\r\n    };\r\n\r\n    const getPrototypeOf$1 = Object.getPrototypeOf;\r\n    const sandHTMLElement = scope => {\r\n      return getOrDie('HTMLElement', scope);\r\n    };\r\n    const isPrototypeOf = x => {\r\n      const scope = resolve$2('ownerDocument.defaultView', x);\r\n      return isObject(x) && (sandHTMLElement(scope).prototype.isPrototypeOf(x) || /^HTML\\w*Element$/.test(getPrototypeOf$1(x).constructor.name));\r\n    };\r\n\r\n    const COMMENT = 8;\r\n    const DOCUMENT = 9;\r\n    const DOCUMENT_FRAGMENT = 11;\r\n    const ELEMENT = 1;\r\n    const TEXT = 3;\r\n\r\n    const name = element => {\r\n      const r = element.dom.nodeName;\r\n      return r.toLowerCase();\r\n    };\r\n    const type$1 = element => element.dom.nodeType;\r\n    const isType = t => element => type$1(element) === t;\r\n    const isComment$1 = element => type$1(element) === COMMENT || name(element) === '#comment';\r\n    const isHTMLElement$1 = element => isElement$7(element) && isPrototypeOf(element.dom);\r\n    const isElement$7 = isType(ELEMENT);\r\n    const isText$b = isType(TEXT);\r\n    const isDocument$2 = isType(DOCUMENT);\r\n    const isDocumentFragment$1 = isType(DOCUMENT_FRAGMENT);\r\n    const isTag = tag => e => isElement$7(e) && name(e) === tag;\r\n\r\n    const rawSet = (dom, key, value) => {\r\n      if (isString(value) || isBoolean(value) || isNumber(value)) {\r\n        dom.setAttribute(key, value + '');\r\n      } else {\r\n        console.error('Invalid call to Attribute.set. Key ', key, ':: Value ', value, ':: Element ', dom);\r\n        throw new Error('Attribute value was not simple');\r\n      }\r\n    };\r\n    const set$3 = (element, key, value) => {\r\n      rawSet(element.dom, key, value);\r\n    };\r\n    const setAll$1 = (element, attrs) => {\r\n      const dom = element.dom;\r\n      each$d(attrs, (v, k) => {\r\n        rawSet(dom, k, v);\r\n      });\r\n    };\r\n    const get$9 = (element, key) => {\r\n      const v = element.dom.getAttribute(key);\r\n      return v === null ? undefined : v;\r\n    };\r\n    const getOpt = (element, key) => Optional.from(get$9(element, key));\r\n    const has$1 = (element, key) => {\r\n      const dom = element.dom;\r\n      return dom && dom.hasAttribute ? dom.hasAttribute(key) : false;\r\n    };\r\n    const remove$a = (element, key) => {\r\n      element.dom.removeAttribute(key);\r\n    };\r\n    const hasNone = element => {\r\n      const attrs = element.dom.attributes;\r\n      return attrs === undefined || attrs === null || attrs.length === 0;\r\n    };\r\n    const clone$4 = element => foldl(element.dom.attributes, (acc, attr) => {\r\n      acc[attr.name] = attr.value;\r\n      return acc;\r\n    }, {});\r\n\r\n    const read$4 = (element, attr) => {\r\n      const value = get$9(element, attr);\r\n      return value === undefined || value === '' ? [] : value.split(' ');\r\n    };\r\n    const add$4 = (element, attr, id) => {\r\n      const old = read$4(element, attr);\r\n      const nu = old.concat([id]);\r\n      set$3(element, attr, nu.join(' '));\r\n      return true;\r\n    };\r\n    const remove$9 = (element, attr, id) => {\r\n      const nu = filter$5(read$4(element, attr), v => v !== id);\r\n      if (nu.length > 0) {\r\n        set$3(element, attr, nu.join(' '));\r\n      } else {\r\n        remove$a(element, attr);\r\n      }\r\n      return false;\r\n    };\r\n\r\n    const supports = element => element.dom.classList !== undefined;\r\n    const get$8 = element => read$4(element, 'class');\r\n    const add$3 = (element, clazz) => add$4(element, 'class', clazz);\r\n    const remove$8 = (element, clazz) => remove$9(element, 'class', clazz);\r\n    const toggle$2 = (element, clazz) => {\r\n      if (contains$2(get$8(element), clazz)) {\r\n        return remove$8(element, clazz);\r\n      } else {\r\n        return add$3(element, clazz);\r\n      }\r\n    };\r\n\r\n    const add$2 = (element, clazz) => {\r\n      if (supports(element)) {\r\n        element.dom.classList.add(clazz);\r\n      } else {\r\n        add$3(element, clazz);\r\n      }\r\n    };\r\n    const cleanClass = element => {\r\n      const classList = supports(element) ? element.dom.classList : get$8(element);\r\n      if (classList.length === 0) {\r\n        remove$a(element, 'class');\r\n      }\r\n    };\r\n    const remove$7 = (element, clazz) => {\r\n      if (supports(element)) {\r\n        const classList = element.dom.classList;\r\n        classList.remove(clazz);\r\n      } else {\r\n        remove$8(element, clazz);\r\n      }\r\n      cleanClass(element);\r\n    };\r\n    const toggle$1 = (element, clazz) => {\r\n      const result = supports(element) ? element.dom.classList.toggle(clazz) : toggle$2(element, clazz);\r\n      cleanClass(element);\r\n      return result;\r\n    };\r\n    const has = (element, clazz) => supports(element) && element.dom.classList.contains(clazz);\r\n\r\n    const fromHtml$1 = (html, scope) => {\r\n      const doc = scope || document;\r\n      const div = doc.createElement('div');\r\n      div.innerHTML = html;\r\n      if (!div.hasChildNodes() || div.childNodes.length > 1) {\r\n        const message = 'HTML does not have a single root node';\r\n        console.error(message, html);\r\n        throw new Error(message);\r\n      }\r\n      return fromDom$2(div.childNodes[0]);\r\n    };\r\n    const fromTag = (tag, scope) => {\r\n      const doc = scope || document;\r\n      const node = doc.createElement(tag);\r\n      return fromDom$2(node);\r\n    };\r\n    const fromText = (text, scope) => {\r\n      const doc = scope || document;\r\n      const node = doc.createTextNode(text);\r\n      return fromDom$2(node);\r\n    };\r\n    const fromDom$2 = node => {\r\n      if (node === null || node === undefined) {\r\n        throw new Error('Node cannot be null or undefined');\r\n      }\r\n      return { dom: node };\r\n    };\r\n    const fromPoint$2 = (docElm, x, y) => Optional.from(docElm.dom.elementFromPoint(x, y)).map(fromDom$2);\r\n    const SugarElement = {\r\n      fromHtml: fromHtml$1,\r\n      fromTag,\r\n      fromText,\r\n      fromDom: fromDom$2,\r\n      fromPoint: fromPoint$2\r\n    };\r\n\r\n    const toArray = (target, f) => {\r\n      const r = [];\r\n      const recurse = e => {\r\n        r.push(e);\r\n        return f(e);\r\n      };\r\n      let cur = f(target);\r\n      do {\r\n        cur = cur.bind(recurse);\r\n      } while (cur.isSome());\r\n      return r;\r\n    };\r\n\r\n    const is$1 = (element, selector) => {\r\n      const dom = element.dom;\r\n      if (dom.nodeType !== ELEMENT) {\r\n        return false;\r\n      } else {\r\n        const elem = dom;\r\n        if (elem.matches !== undefined) {\r\n          return elem.matches(selector);\r\n        } else if (elem.msMatchesSelector !== undefined) {\r\n          return elem.msMatchesSelector(selector);\r\n        } else if (elem.webkitMatchesSelector !== undefined) {\r\n          return elem.webkitMatchesSelector(selector);\r\n        } else if (elem.mozMatchesSelector !== undefined) {\r\n          return elem.mozMatchesSelector(selector);\r\n        } else {\r\n          throw new Error('Browser lacks native selectors');\r\n        }\r\n      }\r\n    };\r\n    const bypassSelector = dom => dom.nodeType !== ELEMENT && dom.nodeType !== DOCUMENT && dom.nodeType !== DOCUMENT_FRAGMENT || dom.childElementCount === 0;\r\n    const all = (selector, scope) => {\r\n      const base = scope === undefined ? document : scope.dom;\r\n      return bypassSelector(base) ? [] : map$3(base.querySelectorAll(selector), SugarElement.fromDom);\r\n    };\r\n    const one = (selector, scope) => {\r\n      const base = scope === undefined ? document : scope.dom;\r\n      return bypassSelector(base) ? Optional.none() : Optional.from(base.querySelector(selector)).map(SugarElement.fromDom);\r\n    };\r\n\r\n    const eq = (e1, e2) => e1.dom === e2.dom;\r\n    const contains = (e1, e2) => {\r\n      const d1 = e1.dom;\r\n      const d2 = e2.dom;\r\n      return d1 === d2 ? false : d1.contains(d2);\r\n    };\r\n\r\n    const owner$1 = element => SugarElement.fromDom(element.dom.ownerDocument);\r\n    const documentOrOwner = dos => isDocument$2(dos) ? dos : owner$1(dos);\r\n    const documentElement = element => SugarElement.fromDom(documentOrOwner(element).dom.documentElement);\r\n    const defaultView = element => SugarElement.fromDom(documentOrOwner(element).dom.defaultView);\r\n    const parent = element => Optional.from(element.dom.parentNode).map(SugarElement.fromDom);\r\n    const parentElement = element => Optional.from(element.dom.parentElement).map(SugarElement.fromDom);\r\n    const parents$1 = (element, isRoot) => {\r\n      const stop = isFunction(isRoot) ? isRoot : never;\r\n      let dom = element.dom;\r\n      const ret = [];\r\n      while (dom.parentNode !== null && dom.parentNode !== undefined) {\r\n        const rawParent = dom.parentNode;\r\n        const p = SugarElement.fromDom(rawParent);\r\n        ret.push(p);\r\n        if (stop(p) === true) {\r\n          break;\r\n        } else {\r\n          dom = rawParent;\r\n        }\r\n      }\r\n      return ret;\r\n    };\r\n    const siblings = element => {\r\n      const filterSelf = elements => filter$5(elements, x => !eq(element, x));\r\n      return parent(element).map(children$1).map(filterSelf).getOr([]);\r\n    };\r\n    const prevSibling = element => Optional.from(element.dom.previousSibling).map(SugarElement.fromDom);\r\n    const nextSibling = element => Optional.from(element.dom.nextSibling).map(SugarElement.fromDom);\r\n    const prevSiblings = element => reverse(toArray(element, prevSibling));\r\n    const nextSiblings = element => toArray(element, nextSibling);\r\n    const children$1 = element => map$3(element.dom.childNodes, SugarElement.fromDom);\r\n    const child$1 = (element, index) => {\r\n      const cs = element.dom.childNodes;\r\n      return Optional.from(cs[index]).map(SugarElement.fromDom);\r\n    };\r\n    const firstChild = element => child$1(element, 0);\r\n    const lastChild = element => child$1(element, element.dom.childNodes.length - 1);\r\n    const childNodesCount = element => element.dom.childNodes.length;\r\n    const hasChildNodes = element => element.dom.hasChildNodes();\r\n\r\n    const getHead = doc => {\r\n      const b = doc.dom.head;\r\n      if (b === null || b === undefined) {\r\n        throw new Error('Head is not available yet');\r\n      }\r\n      return SugarElement.fromDom(b);\r\n    };\r\n\r\n    const isShadowRoot = dos => isDocumentFragment$1(dos) && isNonNullable(dos.dom.host);\r\n    const supported = isFunction(Element.prototype.attachShadow) && isFunction(Node.prototype.getRootNode);\r\n    const isSupported$1 = constant(supported);\r\n    const getRootNode = supported ? e => SugarElement.fromDom(e.dom.getRootNode()) : documentOrOwner;\r\n    const getStyleContainer = dos => isShadowRoot(dos) ? dos : getHead(documentOrOwner(dos));\r\n    const getContentContainer = dos => isShadowRoot(dos) ? dos : SugarElement.fromDom(documentOrOwner(dos).dom.body);\r\n    const getShadowRoot = e => {\r\n      const r = getRootNode(e);\r\n      return isShadowRoot(r) ? Optional.some(r) : Optional.none();\r\n    };\r\n    const getShadowHost = e => SugarElement.fromDom(e.dom.host);\r\n    const getOriginalEventTarget = event => {\r\n      if (isSupported$1() && isNonNullable(event.target)) {\r\n        const el = SugarElement.fromDom(event.target);\r\n        if (isElement$7(el) && isOpenShadowHost(el)) {\r\n          if (event.composed && event.composedPath) {\r\n            const composedPath = event.composedPath();\r\n            if (composedPath) {\r\n              return head(composedPath);\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return Optional.from(event.target);\r\n    };\r\n    const isOpenShadowHost = element => isNonNullable(element.dom.shadowRoot);\r\n\r\n    const inBody = element => {\r\n      const dom = isText$b(element) ? element.dom.parentNode : element.dom;\r\n      if (dom === undefined || dom === null || dom.ownerDocument === null) {\r\n        return false;\r\n      }\r\n      const doc = dom.ownerDocument;\r\n      return getShadowRoot(SugarElement.fromDom(dom)).fold(() => doc.body.contains(dom), compose1(inBody, getShadowHost));\r\n    };\r\n\r\n    var ClosestOrAncestor = (is, ancestor, scope, a, isRoot) => {\r\n      if (is(scope, a)) {\r\n        return Optional.some(scope);\r\n      } else if (isFunction(isRoot) && isRoot(scope)) {\r\n        return Optional.none();\r\n      } else {\r\n        return ancestor(scope, a, isRoot);\r\n      }\r\n    };\r\n\r\n    const ancestor$4 = (scope, predicate, isRoot) => {\r\n      let element = scope.dom;\r\n      const stop = isFunction(isRoot) ? isRoot : never;\r\n      while (element.parentNode) {\r\n        element = element.parentNode;\r\n        const el = SugarElement.fromDom(element);\r\n        if (predicate(el)) {\r\n          return Optional.some(el);\r\n        } else if (stop(el)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const closest$4 = (scope, predicate, isRoot) => {\r\n      const is = (s, test) => test(s);\r\n      return ClosestOrAncestor(is, ancestor$4, scope, predicate, isRoot);\r\n    };\r\n    const sibling$1 = (scope, predicate) => {\r\n      const element = scope.dom;\r\n      if (!element.parentNode) {\r\n        return Optional.none();\r\n      }\r\n      return child(SugarElement.fromDom(element.parentNode), x => !eq(scope, x) && predicate(x));\r\n    };\r\n    const child = (scope, predicate) => {\r\n      const pred = node => predicate(SugarElement.fromDom(node));\r\n      const result = find$2(scope.dom.childNodes, pred);\r\n      return result.map(SugarElement.fromDom);\r\n    };\r\n    const descendant$2 = (scope, predicate) => {\r\n      const descend = node => {\r\n        for (let i = 0; i < node.childNodes.length; i++) {\r\n          const child = SugarElement.fromDom(node.childNodes[i]);\r\n          if (predicate(child)) {\r\n            return Optional.some(child);\r\n          }\r\n          const res = descend(node.childNodes[i]);\r\n          if (res.isSome()) {\r\n            return res;\r\n          }\r\n        }\r\n        return Optional.none();\r\n      };\r\n      return descend(scope.dom);\r\n    };\r\n\r\n    const ancestor$3 = (scope, selector, isRoot) => ancestor$4(scope, e => is$1(e, selector), isRoot);\r\n    const descendant$1 = (scope, selector) => one(selector, scope);\r\n    const closest$3 = (scope, selector, isRoot) => {\r\n      const is = (element, selector) => is$1(element, selector);\r\n      return ClosestOrAncestor(is, ancestor$3, scope, selector, isRoot);\r\n    };\r\n\r\n    const closest$2 = target => closest$3(target, '[contenteditable]');\r\n    const isEditable$2 = (element, assumeEditable = false) => {\r\n      if (inBody(element)) {\r\n        return element.dom.isContentEditable;\r\n      } else {\r\n        return closest$2(element).fold(constant(assumeEditable), editable => getRaw$1(editable) === 'true');\r\n      }\r\n    };\r\n    const getRaw$1 = element => element.dom.contentEditable;\r\n\r\n    const isSupported = dom => dom.style !== undefined && isFunction(dom.style.getPropertyValue);\r\n\r\n    const internalSet = (dom, property, value) => {\r\n      if (!isString(value)) {\r\n        console.error('Invalid call to CSS.set. Property ', property, ':: Value ', value, ':: Element ', dom);\r\n        throw new Error('CSS value must be a string: ' + value);\r\n      }\r\n      if (isSupported(dom)) {\r\n        dom.style.setProperty(property, value);\r\n      }\r\n    };\r\n    const internalRemove = (dom, property) => {\r\n      if (isSupported(dom)) {\r\n        dom.style.removeProperty(property);\r\n      }\r\n    };\r\n    const set$2 = (element, property, value) => {\r\n      const dom = element.dom;\r\n      internalSet(dom, property, value);\r\n    };\r\n    const setAll = (element, css) => {\r\n      const dom = element.dom;\r\n      each$d(css, (v, k) => {\r\n        internalSet(dom, k, v);\r\n      });\r\n    };\r\n    const get$7 = (element, property) => {\r\n      const dom = element.dom;\r\n      const styles = window.getComputedStyle(dom);\r\n      const r = styles.getPropertyValue(property);\r\n      return r === '' && !inBody(element) ? getUnsafeProperty(dom, property) : r;\r\n    };\r\n    const getUnsafeProperty = (dom, property) => isSupported(dom) ? dom.style.getPropertyValue(property) : '';\r\n    const getRaw = (element, property) => {\r\n      const dom = element.dom;\r\n      const raw = getUnsafeProperty(dom, property);\r\n      return Optional.from(raw).filter(r => r.length > 0);\r\n    };\r\n    const getAllRaw = element => {\r\n      const css = {};\r\n      const dom = element.dom;\r\n      if (isSupported(dom)) {\r\n        for (let i = 0; i < dom.style.length; i++) {\r\n          const ruleName = dom.style.item(i);\r\n          css[ruleName] = dom.style[ruleName];\r\n        }\r\n      }\r\n      return css;\r\n    };\r\n    const remove$6 = (element, property) => {\r\n      const dom = element.dom;\r\n      internalRemove(dom, property);\r\n      if (is$2(getOpt(element, 'style').map(trim$4), '')) {\r\n        remove$a(element, 'style');\r\n      }\r\n    };\r\n    const reflow = e => e.dom.offsetWidth;\r\n\r\n    const before$3 = (marker, element) => {\r\n      const parent$1 = parent(marker);\r\n      parent$1.each(v => {\r\n        v.dom.insertBefore(element.dom, marker.dom);\r\n      });\r\n    };\r\n    const after$4 = (marker, element) => {\r\n      const sibling = nextSibling(marker);\r\n      sibling.fold(() => {\r\n        const parent$1 = parent(marker);\r\n        parent$1.each(v => {\r\n          append$1(v, element);\r\n        });\r\n      }, v => {\r\n        before$3(v, element);\r\n      });\r\n    };\r\n    const prepend = (parent, element) => {\r\n      const firstChild$1 = firstChild(parent);\r\n      firstChild$1.fold(() => {\r\n        append$1(parent, element);\r\n      }, v => {\r\n        parent.dom.insertBefore(element.dom, v.dom);\r\n      });\r\n    };\r\n    const append$1 = (parent, element) => {\r\n      parent.dom.appendChild(element.dom);\r\n    };\r\n    const wrap$2 = (element, wrapper) => {\r\n      before$3(element, wrapper);\r\n      append$1(wrapper, element);\r\n    };\r\n\r\n    const after$3 = (marker, elements) => {\r\n      each$e(elements, (x, i) => {\r\n        const e = i === 0 ? marker : elements[i - 1];\r\n        after$4(e, x);\r\n      });\r\n    };\r\n    const append = (parent, elements) => {\r\n      each$e(elements, x => {\r\n        append$1(parent, x);\r\n      });\r\n    };\r\n\r\n    const empty = element => {\r\n      element.dom.textContent = '';\r\n      each$e(children$1(element), rogue => {\r\n        remove$5(rogue);\r\n      });\r\n    };\r\n    const remove$5 = element => {\r\n      const dom = element.dom;\r\n      if (dom.parentNode !== null) {\r\n        dom.parentNode.removeChild(dom);\r\n      }\r\n    };\r\n    const unwrap = wrapper => {\r\n      const children = children$1(wrapper);\r\n      if (children.length > 0) {\r\n        after$3(wrapper, children);\r\n      }\r\n      remove$5(wrapper);\r\n    };\r\n\r\n    const fromHtml = (html, scope) => {\r\n      const doc = scope || document;\r\n      const div = doc.createElement('div');\r\n      div.innerHTML = html;\r\n      return children$1(SugarElement.fromDom(div));\r\n    };\r\n    const fromDom$1 = nodes => map$3(nodes, SugarElement.fromDom);\r\n\r\n    const get$6 = element => element.dom.innerHTML;\r\n    const set$1 = (element, content) => {\r\n      const owner = owner$1(element);\r\n      const docDom = owner.dom;\r\n      const fragment = SugarElement.fromDom(docDom.createDocumentFragment());\r\n      const contentElements = fromHtml(content, docDom);\r\n      append(fragment, contentElements);\r\n      empty(element);\r\n      append$1(element, fragment);\r\n    };\r\n    const getOuter = element => {\r\n      const container = SugarElement.fromTag('div');\r\n      const clone = SugarElement.fromDom(element.dom.cloneNode(true));\r\n      append$1(container, clone);\r\n      return get$6(container);\r\n    };\r\n\r\n    const mkEvent = (target, x, y, stop, prevent, kill, raw) => ({\r\n      target,\r\n      x,\r\n      y,\r\n      stop,\r\n      prevent,\r\n      kill,\r\n      raw\r\n    });\r\n    const fromRawEvent = rawEvent => {\r\n      const target = SugarElement.fromDom(getOriginalEventTarget(rawEvent).getOr(rawEvent.target));\r\n      const stop = () => rawEvent.stopPropagation();\r\n      const prevent = () => rawEvent.preventDefault();\r\n      const kill = compose(prevent, stop);\r\n      return mkEvent(target, rawEvent.clientX, rawEvent.clientY, stop, prevent, kill, rawEvent);\r\n    };\r\n    const handle$1 = (filter, handler) => rawEvent => {\r\n      if (filter(rawEvent)) {\r\n        handler(fromRawEvent(rawEvent));\r\n      }\r\n    };\r\n    const binder = (element, event, filter, handler, useCapture) => {\r\n      const wrapped = handle$1(filter, handler);\r\n      element.dom.addEventListener(event, wrapped, useCapture);\r\n      return { unbind: curry(unbind, element, event, wrapped, useCapture) };\r\n    };\r\n    const bind$2 = (element, event, filter, handler) => binder(element, event, filter, handler, false);\r\n    const unbind = (element, event, handler, useCapture) => {\r\n      element.dom.removeEventListener(event, handler, useCapture);\r\n    };\r\n\r\n    const r = (left, top) => {\r\n      const translate = (x, y) => r(left + x, top + y);\r\n      return {\r\n        left,\r\n        top,\r\n        translate\r\n      };\r\n    };\r\n    const SugarPosition = r;\r\n\r\n    const boxPosition = dom => {\r\n      const box = dom.getBoundingClientRect();\r\n      return SugarPosition(box.left, box.top);\r\n    };\r\n    const firstDefinedOrZero = (a, b) => {\r\n      if (a !== undefined) {\r\n        return a;\r\n      } else {\r\n        return b !== undefined ? b : 0;\r\n      }\r\n    };\r\n    const absolute = element => {\r\n      const doc = element.dom.ownerDocument;\r\n      const body = doc.body;\r\n      const win = doc.defaultView;\r\n      const html = doc.documentElement;\r\n      if (body === element.dom) {\r\n        return SugarPosition(body.offsetLeft, body.offsetTop);\r\n      }\r\n      const scrollTop = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageYOffset, html.scrollTop);\r\n      const scrollLeft = firstDefinedOrZero(win === null || win === void 0 ? void 0 : win.pageXOffset, html.scrollLeft);\r\n      const clientTop = firstDefinedOrZero(html.clientTop, body.clientTop);\r\n      const clientLeft = firstDefinedOrZero(html.clientLeft, body.clientLeft);\r\n      return viewport(element).translate(scrollLeft - clientLeft, scrollTop - clientTop);\r\n    };\r\n    const viewport = element => {\r\n      const dom = element.dom;\r\n      const doc = dom.ownerDocument;\r\n      const body = doc.body;\r\n      if (body === dom) {\r\n        return SugarPosition(body.offsetLeft, body.offsetTop);\r\n      }\r\n      if (!inBody(element)) {\r\n        return SugarPosition(0, 0);\r\n      }\r\n      return boxPosition(dom);\r\n    };\r\n\r\n    const get$5 = _DOC => {\r\n      const doc = _DOC !== undefined ? _DOC.dom : document;\r\n      const x = doc.body.scrollLeft || doc.documentElement.scrollLeft;\r\n      const y = doc.body.scrollTop || doc.documentElement.scrollTop;\r\n      return SugarPosition(x, y);\r\n    };\r\n    const to = (x, y, _DOC) => {\r\n      const doc = _DOC !== undefined ? _DOC.dom : document;\r\n      const win = doc.defaultView;\r\n      if (win) {\r\n        win.scrollTo(x, y);\r\n      }\r\n    };\r\n    const intoView = (element, alignToTop) => {\r\n      const isSafari = detect$2().browser.isSafari();\r\n      if (isSafari && isFunction(element.dom.scrollIntoViewIfNeeded)) {\r\n        element.dom.scrollIntoViewIfNeeded(false);\r\n      } else {\r\n        element.dom.scrollIntoView(alignToTop);\r\n      }\r\n    };\r\n\r\n    const get$4 = _win => {\r\n      const win = _win === undefined ? window : _win;\r\n      if (detect$2().browser.isFirefox()) {\r\n        return Optional.none();\r\n      } else {\r\n        return Optional.from(win.visualViewport);\r\n      }\r\n    };\r\n    const bounds = (x, y, width, height) => ({\r\n      x,\r\n      y,\r\n      width,\r\n      height,\r\n      right: x + width,\r\n      bottom: y + height\r\n    });\r\n    const getBounds = _win => {\r\n      const win = _win === undefined ? window : _win;\r\n      const doc = win.document;\r\n      const scroll = get$5(SugarElement.fromDom(doc));\r\n      return get$4(win).fold(() => {\r\n        const html = win.document.documentElement;\r\n        const width = html.clientWidth;\r\n        const height = html.clientHeight;\r\n        return bounds(scroll.left, scroll.top, width, height);\r\n      }, visualViewport => bounds(Math.max(visualViewport.pageLeft, scroll.left), Math.max(visualViewport.pageTop, scroll.top), visualViewport.width, visualViewport.height));\r\n    };\r\n\r\n    const children = (scope, predicate) => filter$5(children$1(scope), predicate);\r\n    const descendants$1 = (scope, predicate) => {\r\n      let result = [];\r\n      each$e(children$1(scope), x => {\r\n        if (predicate(x)) {\r\n          result = result.concat([x]);\r\n        }\r\n        result = result.concat(descendants$1(x, predicate));\r\n      });\r\n      return result;\r\n    };\r\n\r\n    const descendants = (scope, selector) => all(selector, scope);\r\n\r\n    const ancestor$2 = (scope, selector, isRoot) => ancestor$3(scope, selector, isRoot).isSome();\r\n\r\n    class DomTreeWalker {\r\n      constructor(startNode, rootNode) {\r\n        this.node = startNode;\r\n        this.rootNode = rootNode;\r\n        this.current = this.current.bind(this);\r\n        this.next = this.next.bind(this);\r\n        this.prev = this.prev.bind(this);\r\n        this.prev2 = this.prev2.bind(this);\r\n      }\r\n      current() {\r\n        return this.node;\r\n      }\r\n      next(shallow) {\r\n        this.node = this.findSibling(this.node, 'firstChild', 'nextSibling', shallow);\r\n        return this.node;\r\n      }\r\n      prev(shallow) {\r\n        this.node = this.findSibling(this.node, 'lastChild', 'previousSibling', shallow);\r\n        return this.node;\r\n      }\r\n      prev2(shallow) {\r\n        this.node = this.findPreviousNode(this.node, shallow);\r\n        return this.node;\r\n      }\r\n      findSibling(node, startName, siblingName, shallow) {\r\n        if (node) {\r\n          if (!shallow && node[startName]) {\r\n            return node[startName];\r\n          }\r\n          if (node !== this.rootNode) {\r\n            let sibling = node[siblingName];\r\n            if (sibling) {\r\n              return sibling;\r\n            }\r\n            for (let parent = node.parentNode; parent && parent !== this.rootNode; parent = parent.parentNode) {\r\n              sibling = parent[siblingName];\r\n              if (sibling) {\r\n                return sibling;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return undefined;\r\n      }\r\n      findPreviousNode(node, shallow) {\r\n        if (node) {\r\n          const sibling = node.previousSibling;\r\n          if (this.rootNode && sibling === this.rootNode) {\r\n            return;\r\n          }\r\n          if (sibling) {\r\n            if (!shallow) {\r\n              for (let child = sibling.lastChild; child; child = child.lastChild) {\r\n                if (!child.lastChild) {\r\n                  return child;\r\n                }\r\n              }\r\n            }\r\n            return sibling;\r\n          }\r\n          const parent = node.parentNode;\r\n          if (parent && parent !== this.rootNode) {\r\n            return parent;\r\n          }\r\n        }\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    const isNodeType = type => {\r\n      return node => {\r\n        return !!node && node.nodeType === type;\r\n      };\r\n    };\r\n    const isRestrictedNode = node => !!node && !Object.getPrototypeOf(node);\r\n    const isElement$6 = isNodeType(1);\r\n    const isHTMLElement = node => isElement$6(node) && isHTMLElement$1(SugarElement.fromDom(node));\r\n    const isSVGElement = node => isElement$6(node) && node.namespaceURI === 'http://www.w3.org/2000/svg';\r\n    const matchNodeName = name => {\r\n      const lowerCasedName = name.toLowerCase();\r\n      return node => isNonNullable(node) && node.nodeName.toLowerCase() === lowerCasedName;\r\n    };\r\n    const matchNodeNames = names => {\r\n      const lowerCasedNames = names.map(s => s.toLowerCase());\r\n      return node => {\r\n        if (node && node.nodeName) {\r\n          const nodeName = node.nodeName.toLowerCase();\r\n          return contains$2(lowerCasedNames, nodeName);\r\n        }\r\n        return false;\r\n      };\r\n    };\r\n    const matchStyleValues = (name, values) => {\r\n      const items = values.toLowerCase().split(' ');\r\n      return node => {\r\n        if (isElement$6(node)) {\r\n          const win = node.ownerDocument.defaultView;\r\n          if (win) {\r\n            for (let i = 0; i < items.length; i++) {\r\n              const computed = win.getComputedStyle(node, null);\r\n              const cssValue = computed ? computed.getPropertyValue(name) : null;\r\n              if (cssValue === items[i]) {\r\n                return true;\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n    };\r\n    const hasAttribute = attrName => {\r\n      return node => {\r\n        return isElement$6(node) && node.hasAttribute(attrName);\r\n      };\r\n    };\r\n    const hasAttributeValue = (attrName, attrValue) => {\r\n      return node => {\r\n        return isElement$6(node) && node.getAttribute(attrName) === attrValue;\r\n      };\r\n    };\r\n    const isBogus$2 = node => isElement$6(node) && node.hasAttribute('data-mce-bogus');\r\n    const isBogusAll$1 = node => isElement$6(node) && node.getAttribute('data-mce-bogus') === 'all';\r\n    const isTable$2 = node => isElement$6(node) && node.tagName === 'TABLE';\r\n    const hasContentEditableState = value => {\r\n      return node => {\r\n        if (isHTMLElement(node)) {\r\n          if (node.contentEditable === value) {\r\n            return true;\r\n          }\r\n          if (node.getAttribute('data-mce-contenteditable') === value) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n    };\r\n    const isTextareaOrInput = matchNodeNames([\r\n      'textarea',\r\n      'input'\r\n    ]);\r\n    const isText$a = isNodeType(3);\r\n    const isCData = isNodeType(4);\r\n    const isPi = isNodeType(7);\r\n    const isComment = isNodeType(8);\r\n    const isDocument$1 = isNodeType(9);\r\n    const isDocumentFragment = isNodeType(11);\r\n    const isBr$6 = matchNodeName('br');\r\n    const isImg = matchNodeName('img');\r\n    const isContentEditableTrue$3 = hasContentEditableState('true');\r\n    const isContentEditableFalse$b = hasContentEditableState('false');\r\n    const isTableCell$3 = matchNodeNames([\r\n      'td',\r\n      'th'\r\n    ]);\r\n    const isTableCellOrCaption = matchNodeNames([\r\n      'td',\r\n      'th',\r\n      'caption'\r\n    ]);\r\n    const isMedia$2 = matchNodeNames([\r\n      'video',\r\n      'audio',\r\n      'object',\r\n      'embed'\r\n    ]);\r\n    const isListItem$2 = matchNodeName('li');\r\n    const isDetails = matchNodeName('details');\r\n    const isSummary$1 = matchNodeName('summary');\r\n\r\n    const zeroWidth = '\\uFEFF';\r\n    const nbsp = '\\xA0';\r\n    const isZwsp$2 = char => char === zeroWidth;\r\n    const removeZwsp = s => s.replace(/\\uFEFF/g, '');\r\n\r\n    const NodeValue = (is, name) => {\r\n      const get = element => {\r\n        if (!is(element)) {\r\n          throw new Error('Can only get ' + name + ' value of a ' + name + ' node');\r\n        }\r\n        return getOption(element).getOr('');\r\n      };\r\n      const getOption = element => is(element) ? Optional.from(element.dom.nodeValue) : Optional.none();\r\n      const set = (element, value) => {\r\n        if (!is(element)) {\r\n          throw new Error('Can only set raw ' + name + ' value of a ' + name + ' node');\r\n        }\r\n        element.dom.nodeValue = value;\r\n      };\r\n      return {\r\n        get,\r\n        getOption,\r\n        set\r\n      };\r\n    };\r\n\r\n    const api$1 = NodeValue(isText$b, 'text');\r\n    const get$3 = element => api$1.get(element);\r\n    const getOption = element => api$1.getOption(element);\r\n    const set = (element, value) => api$1.set(element, value);\r\n\r\n    const tableCells = [\r\n      'td',\r\n      'th'\r\n    ];\r\n    const tableSections = [\r\n      'thead',\r\n      'tbody',\r\n      'tfoot'\r\n    ];\r\n    const textBlocks = [\r\n      'h1',\r\n      'h2',\r\n      'h3',\r\n      'h4',\r\n      'h5',\r\n      'h6',\r\n      'p',\r\n      'div',\r\n      'address',\r\n      'pre',\r\n      'form',\r\n      'blockquote',\r\n      'center',\r\n      'dir',\r\n      'fieldset',\r\n      'header',\r\n      'footer',\r\n      'article',\r\n      'section',\r\n      'hgroup',\r\n      'aside',\r\n      'nav',\r\n      'figure'\r\n    ];\r\n    const listItems$1 = [\r\n      'li',\r\n      'dd',\r\n      'dt'\r\n    ];\r\n    const lists = [\r\n      'ul',\r\n      'ol',\r\n      'dl'\r\n    ];\r\n    const wsElements = [\r\n      'pre',\r\n      'script',\r\n      'textarea',\r\n      'style'\r\n    ];\r\n    const lazyLookup = items => {\r\n      let lookup;\r\n      return node => {\r\n        lookup = lookup ? lookup : mapToObject(items, always);\r\n        return has$2(lookup, name(node));\r\n      };\r\n    };\r\n    const isTable$1 = node => name(node) === 'table';\r\n    const isBr$5 = node => isElement$7(node) && name(node) === 'br';\r\n    const isTextBlock$2 = lazyLookup(textBlocks);\r\n    const isList = lazyLookup(lists);\r\n    const isListItem$1 = lazyLookup(listItems$1);\r\n    const isTableSection = lazyLookup(tableSections);\r\n    const isTableCell$2 = lazyLookup(tableCells);\r\n    const isWsPreserveElement = lazyLookup(wsElements);\r\n\r\n    const getLastChildren$1 = elm => {\r\n      const children = [];\r\n      let rawNode = elm.dom;\r\n      while (rawNode) {\r\n        children.push(SugarElement.fromDom(rawNode));\r\n        rawNode = rawNode.lastChild;\r\n      }\r\n      return children;\r\n    };\r\n    const removeTrailingBr = elm => {\r\n      const allBrs = descendants(elm, 'br');\r\n      const brs = filter$5(getLastChildren$1(elm).slice(-1), isBr$5);\r\n      if (allBrs.length === brs.length) {\r\n        each$e(brs, remove$5);\r\n      }\r\n    };\r\n    const createPaddingBr = () => {\r\n      const br = SugarElement.fromTag('br');\r\n      set$3(br, 'data-mce-bogus', '1');\r\n      return br;\r\n    };\r\n    const fillWithPaddingBr = elm => {\r\n      empty(elm);\r\n      append$1(elm, createPaddingBr());\r\n    };\r\n    const trimBlockTrailingBr = (elm, schema) => {\r\n      lastChild(elm).each(lastChild => {\r\n        prevSibling(lastChild).each(lastChildPrevSibling => {\r\n          if (schema.isBlock(name(elm)) && isBr$5(lastChild) && schema.isBlock(name(lastChildPrevSibling))) {\r\n            remove$5(lastChild);\r\n          }\r\n        });\r\n      });\r\n    };\r\n\r\n    const ZWSP$1 = zeroWidth;\r\n    const isZwsp$1 = isZwsp$2;\r\n    const trim$2 = removeZwsp;\r\n    const insert$5 = editor => editor.insertContent(ZWSP$1, { preserve_zwsp: true });\r\n\r\n    const isElement$5 = isElement$6;\r\n    const isText$9 = isText$a;\r\n    const isCaretContainerBlock$1 = node => {\r\n      if (isText$9(node)) {\r\n        node = node.parentNode;\r\n      }\r\n      return isElement$5(node) && node.hasAttribute('data-mce-caret');\r\n    };\r\n    const isCaretContainerInline = node => isText$9(node) && isZwsp$1(node.data);\r\n    const isCaretContainer$2 = node => isCaretContainerBlock$1(node) || isCaretContainerInline(node);\r\n    const hasContent = node => node.firstChild !== node.lastChild || !isBr$6(node.firstChild);\r\n    const insertInline$1 = (node, before) => {\r\n      var _a;\r\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\r\n      const textNode = doc.createTextNode(ZWSP$1);\r\n      const parentNode = node.parentNode;\r\n      if (!before) {\r\n        const sibling = node.nextSibling;\r\n        if (isText$9(sibling)) {\r\n          if (isCaretContainer$2(sibling)) {\r\n            return sibling;\r\n          }\r\n          if (startsWithCaretContainer$1(sibling)) {\r\n            sibling.splitText(1);\r\n            return sibling;\r\n          }\r\n        }\r\n        if (node.nextSibling) {\r\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node.nextSibling);\r\n        } else {\r\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(textNode);\r\n        }\r\n      } else {\r\n        const sibling = node.previousSibling;\r\n        if (isText$9(sibling)) {\r\n          if (isCaretContainer$2(sibling)) {\r\n            return sibling;\r\n          }\r\n          if (endsWithCaretContainer$1(sibling)) {\r\n            return sibling.splitText(sibling.data.length - 1);\r\n          }\r\n        }\r\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(textNode, node);\r\n      }\r\n      return textNode;\r\n    };\r\n    const isBeforeInline = pos => {\r\n      const container = pos.container();\r\n      if (!isText$a(container)) {\r\n        return false;\r\n      }\r\n      return container.data.charAt(pos.offset()) === ZWSP$1 || pos.isAtStart() && isCaretContainerInline(container.previousSibling);\r\n    };\r\n    const isAfterInline = pos => {\r\n      const container = pos.container();\r\n      if (!isText$a(container)) {\r\n        return false;\r\n      }\r\n      return container.data.charAt(pos.offset() - 1) === ZWSP$1 || pos.isAtEnd() && isCaretContainerInline(container.nextSibling);\r\n    };\r\n    const insertBlock = (blockName, node, before) => {\r\n      var _a;\r\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\r\n      const blockNode = doc.createElement(blockName);\r\n      blockNode.setAttribute('data-mce-caret', before ? 'before' : 'after');\r\n      blockNode.setAttribute('data-mce-bogus', 'all');\r\n      blockNode.appendChild(createPaddingBr().dom);\r\n      const parentNode = node.parentNode;\r\n      if (!before) {\r\n        if (node.nextSibling) {\r\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node.nextSibling);\r\n        } else {\r\n          parentNode === null || parentNode === void 0 ? void 0 : parentNode.appendChild(blockNode);\r\n        }\r\n      } else {\r\n        parentNode === null || parentNode === void 0 ? void 0 : parentNode.insertBefore(blockNode, node);\r\n      }\r\n      return blockNode;\r\n    };\r\n    const startsWithCaretContainer$1 = node => isText$9(node) && node.data[0] === ZWSP$1;\r\n    const endsWithCaretContainer$1 = node => isText$9(node) && node.data[node.data.length - 1] === ZWSP$1;\r\n    const trimBogusBr = elm => {\r\n      var _a;\r\n      const brs = elm.getElementsByTagName('br');\r\n      const lastBr = brs[brs.length - 1];\r\n      if (isBogus$2(lastBr)) {\r\n        (_a = lastBr.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(lastBr);\r\n      }\r\n    };\r\n    const showCaretContainerBlock = caretContainer => {\r\n      if (caretContainer && caretContainer.hasAttribute('data-mce-caret')) {\r\n        trimBogusBr(caretContainer);\r\n        caretContainer.removeAttribute('data-mce-caret');\r\n        caretContainer.removeAttribute('data-mce-bogus');\r\n        caretContainer.removeAttribute('style');\r\n        caretContainer.removeAttribute('data-mce-style');\r\n        caretContainer.removeAttribute('_moz_abspos');\r\n        return caretContainer;\r\n      }\r\n      return null;\r\n    };\r\n    const isRangeInCaretContainerBlock = range => isCaretContainerBlock$1(range.startContainer);\r\n\r\n    const isContentEditableTrue$2 = isContentEditableTrue$3;\r\n    const isContentEditableFalse$a = isContentEditableFalse$b;\r\n    const isBr$4 = isBr$6;\r\n    const isText$8 = isText$a;\r\n    const isInvalidTextElement = matchNodeNames([\r\n      'script',\r\n      'style',\r\n      'textarea'\r\n    ]);\r\n    const isAtomicInline = matchNodeNames([\r\n      'img',\r\n      'input',\r\n      'textarea',\r\n      'hr',\r\n      'iframe',\r\n      'video',\r\n      'audio',\r\n      'object',\r\n      'embed'\r\n    ]);\r\n    const isTable = matchNodeNames(['table']);\r\n    const isCaretContainer$1 = isCaretContainer$2;\r\n    const isCaretCandidate$3 = node => {\r\n      if (isCaretContainer$1(node)) {\r\n        return false;\r\n      }\r\n      if (isText$8(node)) {\r\n        return !isInvalidTextElement(node.parentNode);\r\n      }\r\n      return isAtomicInline(node) || isBr$4(node) || isTable(node) || isNonUiContentEditableFalse(node);\r\n    };\r\n    const isUnselectable = node => isElement$6(node) && node.getAttribute('unselectable') === 'true';\r\n    const isNonUiContentEditableFalse = node => !isUnselectable(node) && isContentEditableFalse$a(node);\r\n    const isInEditable = (node, root) => {\r\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\r\n        if (isNonUiContentEditableFalse(tempNode)) {\r\n          return false;\r\n        }\r\n        if (isContentEditableTrue$2(tempNode)) {\r\n          return true;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    const isAtomicContentEditableFalse = node => {\r\n      if (!isNonUiContentEditableFalse(node)) {\r\n        return false;\r\n      }\r\n      return !foldl(from(node.getElementsByTagName('*')), (result, elm) => {\r\n        return result || isContentEditableTrue$2(elm);\r\n      }, false);\r\n    };\r\n    const isAtomic$1 = node => isAtomicInline(node) || isAtomicContentEditableFalse(node);\r\n    const isEditableCaretCandidate$1 = (node, root) => isCaretCandidate$3(node) && isInEditable(node, root);\r\n\r\n    const whiteSpaceRegExp = /^[ \\t\\r\\n]*$/;\r\n    const isWhitespaceText = text => whiteSpaceRegExp.test(text);\r\n    const isZwsp = text => {\r\n      for (const c of text) {\r\n        if (!isZwsp$2(c)) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    const isCollapsibleWhitespace$1 = c => ' \\f\\t\\x0B'.indexOf(c) !== -1;\r\n    const isNewLineChar = c => c === '\\n' || c === '\\r';\r\n    const isNewline = (text, idx) => idx < text.length && idx >= 0 ? isNewLineChar(text[idx]) : false;\r\n    const normalize$4 = (text, tabSpaces = 4, isStartOfContent = true, isEndOfContent = true) => {\r\n      const tabSpace = repeat(' ', tabSpaces);\r\n      const normalizedText = text.replace(/\\t/g, tabSpace);\r\n      const result = foldl(normalizedText, (acc, c) => {\r\n        if (isCollapsibleWhitespace$1(c) || c === nbsp) {\r\n          if (acc.pcIsSpace || acc.str === '' && isStartOfContent || acc.str.length === normalizedText.length - 1 && isEndOfContent || isNewline(normalizedText, acc.str.length + 1)) {\r\n            return {\r\n              pcIsSpace: false,\r\n              str: acc.str + nbsp\r\n            };\r\n          } else {\r\n            return {\r\n              pcIsSpace: true,\r\n              str: acc.str + ' '\r\n            };\r\n          }\r\n        } else {\r\n          return {\r\n            pcIsSpace: isNewLineChar(c),\r\n            str: acc.str + c\r\n          };\r\n        }\r\n      }, {\r\n        pcIsSpace: false,\r\n        str: ''\r\n      });\r\n      return result.str;\r\n    };\r\n\r\n    const hasWhitespacePreserveParent = (node, rootNode) => {\r\n      const rootElement = SugarElement.fromDom(rootNode);\r\n      const startNode = SugarElement.fromDom(node);\r\n      return ancestor$2(startNode, 'pre,code', curry(eq, rootElement));\r\n    };\r\n    const isWhitespace$1 = (node, rootNode) => {\r\n      return isText$a(node) && isWhitespaceText(node.data) && !hasWhitespacePreserveParent(node, rootNode);\r\n    };\r\n    const isNamedAnchor = node => {\r\n      return isElement$6(node) && node.nodeName === 'A' && !node.hasAttribute('href') && (node.hasAttribute('name') || node.hasAttribute('id'));\r\n    };\r\n    const isContent$1 = (node, rootNode) => {\r\n      return isCaretCandidate$3(node) && !isWhitespace$1(node, rootNode) || isNamedAnchor(node) || isBookmark(node);\r\n    };\r\n    const isBookmark = hasAttribute('data-mce-bookmark');\r\n    const isBogus$1 = hasAttribute('data-mce-bogus');\r\n    const isBogusAll = hasAttributeValue('data-mce-bogus', 'all');\r\n    const hasNonEditableParent = node => parentElement(SugarElement.fromDom(node)).exists(parent => !isEditable$2(parent));\r\n    const isEmptyNode = (targetNode, skipBogus) => {\r\n      let brCount = 0;\r\n      if (isContent$1(targetNode, targetNode)) {\r\n        return false;\r\n      } else {\r\n        let node = targetNode.firstChild;\r\n        if (!node) {\r\n          return true;\r\n        }\r\n        const walker = new DomTreeWalker(node, targetNode);\r\n        do {\r\n          if (skipBogus) {\r\n            if (isBogusAll(node)) {\r\n              node = walker.next(true);\r\n              continue;\r\n            }\r\n            if (isBogus$1(node)) {\r\n              node = walker.next();\r\n              continue;\r\n            }\r\n          }\r\n          if (isContentEditableTrue$3(node) && hasNonEditableParent(node)) {\r\n            return false;\r\n          }\r\n          if (isBr$6(node)) {\r\n            brCount++;\r\n            node = walker.next();\r\n            continue;\r\n          }\r\n          if (isContent$1(node, targetNode)) {\r\n            return false;\r\n          }\r\n          node = walker.next();\r\n        } while (node);\r\n        return brCount <= 1;\r\n      }\r\n    };\r\n    const isEmpty$2 = (elm, skipBogus = true) => isEmptyNode(elm.dom, skipBogus);\r\n\r\n    const isNonHtmlElementRootName = name => name.toLowerCase() === 'svg';\r\n    const isNonHtmlElementRoot = node => isNonHtmlElementRootName(node.nodeName);\r\n    const toScopeType = node => (node === null || node === void 0 ? void 0 : node.nodeName) === 'svg' ? 'svg' : 'html';\r\n    const namespaceElements = ['svg'];\r\n    const createNamespaceTracker = () => {\r\n      let scopes = [];\r\n      const peek = () => scopes[scopes.length - 1];\r\n      const track = node => {\r\n        if (isNonHtmlElementRoot(node)) {\r\n          scopes.push(node);\r\n        }\r\n        let currentScope = peek();\r\n        if (currentScope && !currentScope.contains(node)) {\r\n          scopes.pop();\r\n          currentScope = peek();\r\n        }\r\n        return toScopeType(currentScope);\r\n      };\r\n      const current = () => toScopeType(peek());\r\n      const reset = () => {\r\n        scopes = [];\r\n      };\r\n      return {\r\n        track,\r\n        current,\r\n        reset\r\n      };\r\n    };\r\n\r\n    const transparentBlockAttr = 'data-mce-block';\r\n    const elementNames = map => filter$5(keys(map), key => !/[A-Z]/.test(key));\r\n    const makeSelectorFromSchemaMap = map => map$3(elementNames(map), name => {\r\n      return `${ name }:` + map$3(namespaceElements, ns => `not(${ ns } ${ name })`).join(':');\r\n    }).join(',');\r\n    const updateTransparent = (blocksSelector, transparent) => {\r\n      if (isNonNullable(transparent.querySelector(blocksSelector))) {\r\n        transparent.setAttribute(transparentBlockAttr, 'true');\r\n        if (transparent.getAttribute('data-mce-selected') === 'inline-boundary') {\r\n          transparent.removeAttribute('data-mce-selected');\r\n        }\r\n        return true;\r\n      } else {\r\n        transparent.removeAttribute(transparentBlockAttr);\r\n        return false;\r\n      }\r\n    };\r\n    const updateBlockStateOnChildren = (schema, scope) => {\r\n      const transparentSelector = makeSelectorFromSchemaMap(schema.getTransparentElements());\r\n      const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\r\n      return filter$5(scope.querySelectorAll(transparentSelector), transparent => updateTransparent(blocksSelector, transparent));\r\n    };\r\n    const trimEdge = (el, leftSide) => {\r\n      var _a;\r\n      const childPropertyName = leftSide ? 'lastChild' : 'firstChild';\r\n      for (let child = el[childPropertyName]; child; child = child[childPropertyName]) {\r\n        if (isEmpty$2(SugarElement.fromDom(child))) {\r\n          (_a = child.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(child);\r\n          return;\r\n        }\r\n      }\r\n    };\r\n    const split$2 = (parentElm, splitElm) => {\r\n      const range = document.createRange();\r\n      const parentNode = parentElm.parentNode;\r\n      if (parentNode) {\r\n        range.setStartBefore(parentElm);\r\n        range.setEndBefore(splitElm);\r\n        const beforeFragment = range.extractContents();\r\n        trimEdge(beforeFragment, true);\r\n        range.setStartAfter(splitElm);\r\n        range.setEndAfter(parentElm);\r\n        const afterFragment = range.extractContents();\r\n        trimEdge(afterFragment, false);\r\n        if (!isEmpty$2(SugarElement.fromDom(beforeFragment))) {\r\n          parentNode.insertBefore(beforeFragment, parentElm);\r\n        }\r\n        if (!isEmpty$2(SugarElement.fromDom(splitElm))) {\r\n          parentNode.insertBefore(splitElm, parentElm);\r\n        }\r\n        if (!isEmpty$2(SugarElement.fromDom(afterFragment))) {\r\n          parentNode.insertBefore(afterFragment, parentElm);\r\n        }\r\n        parentNode.removeChild(parentElm);\r\n      }\r\n    };\r\n    const splitInvalidChildren = (schema, scope, transparentBlocks) => {\r\n      const blocksElements = schema.getBlockElements();\r\n      const rootNode = SugarElement.fromDom(scope);\r\n      const isBlock = el => name(el) in blocksElements;\r\n      const isRoot = el => eq(el, rootNode);\r\n      each$e(fromDom$1(transparentBlocks), transparentBlock => {\r\n        ancestor$4(transparentBlock, isBlock, isRoot).each(parentBlock => {\r\n          const invalidChildren = children(transparentBlock, el => isBlock(el) && !schema.isValidChild(name(parentBlock), name(el)));\r\n          if (invalidChildren.length > 0) {\r\n            const stateScope = parentElement(parentBlock);\r\n            each$e(invalidChildren, child => {\r\n              ancestor$4(child, isBlock, isRoot).each(parentBlock => {\r\n                split$2(parentBlock.dom, child.dom);\r\n              });\r\n            });\r\n            stateScope.each(scope => updateBlockStateOnChildren(schema, scope.dom));\r\n          }\r\n        });\r\n      });\r\n    };\r\n    const unwrapInvalidChildren = (schema, scope, transparentBlocks) => {\r\n      each$e([\r\n        ...transparentBlocks,\r\n        ...isTransparentBlock(schema, scope) ? [scope] : []\r\n      ], block => each$e(descendants(SugarElement.fromDom(block), block.nodeName.toLowerCase()), elm => {\r\n        if (isTransparentInline(schema, elm.dom)) {\r\n          unwrap(elm);\r\n        }\r\n      }));\r\n    };\r\n    const updateChildren = (schema, scope) => {\r\n      const transparentBlocks = updateBlockStateOnChildren(schema, scope);\r\n      splitInvalidChildren(schema, scope, transparentBlocks);\r\n      unwrapInvalidChildren(schema, scope, transparentBlocks);\r\n    };\r\n    const updateElement = (schema, target) => {\r\n      if (isTransparentElement(schema, target)) {\r\n        const blocksSelector = makeSelectorFromSchemaMap(schema.getBlockElements());\r\n        updateTransparent(blocksSelector, target);\r\n      }\r\n    };\r\n    const updateCaret = (schema, root, caretParent) => {\r\n      const isRoot = el => eq(el, SugarElement.fromDom(root));\r\n      const parents = parents$1(SugarElement.fromDom(caretParent), isRoot);\r\n      get$b(parents, parents.length - 2).filter(isElement$7).fold(() => updateChildren(schema, root), scope => updateChildren(schema, scope.dom));\r\n    };\r\n    const hasBlockAttr = el => el.hasAttribute(transparentBlockAttr);\r\n    const isTransparentElementName = (schema, name) => has$2(schema.getTransparentElements(), name);\r\n    const isTransparentElement = (schema, node) => isElement$6(node) && isTransparentElementName(schema, node.nodeName);\r\n    const isTransparentBlock = (schema, node) => isTransparentElement(schema, node) && hasBlockAttr(node);\r\n    const isTransparentInline = (schema, node) => isTransparentElement(schema, node) && !hasBlockAttr(node);\r\n    const isTransparentAstBlock = (schema, node) => node.type === 1 && isTransparentElementName(schema, node.name) && isString(node.attr(transparentBlockAttr));\r\n\r\n    const browser$2 = detect$2().browser;\r\n    const firstElement = nodes => find$2(nodes, isElement$7);\r\n    const getTableCaptionDeltaY = elm => {\r\n      if (browser$2.isFirefox() && name(elm) === 'table') {\r\n        return firstElement(children$1(elm)).filter(elm => {\r\n          return name(elm) === 'caption';\r\n        }).bind(caption => {\r\n          return firstElement(nextSiblings(caption)).map(body => {\r\n            const bodyTop = body.dom.offsetTop;\r\n            const captionTop = caption.dom.offsetTop;\r\n            const captionHeight = caption.dom.offsetHeight;\r\n            return bodyTop <= captionTop ? -captionHeight : 0;\r\n          });\r\n        }).getOr(0);\r\n      } else {\r\n        return 0;\r\n      }\r\n    };\r\n    const hasChild = (elm, child) => elm.children && contains$2(elm.children, child);\r\n    const getPos = (body, elm, rootElm) => {\r\n      let x = 0, y = 0;\r\n      const doc = body.ownerDocument;\r\n      rootElm = rootElm ? rootElm : body;\r\n      if (elm) {\r\n        if (rootElm === body && elm.getBoundingClientRect && get$7(SugarElement.fromDom(body), 'position') === 'static') {\r\n          const pos = elm.getBoundingClientRect();\r\n          x = pos.left + (doc.documentElement.scrollLeft || body.scrollLeft) - doc.documentElement.clientLeft;\r\n          y = pos.top + (doc.documentElement.scrollTop || body.scrollTop) - doc.documentElement.clientTop;\r\n          return {\r\n            x,\r\n            y\r\n          };\r\n        }\r\n        let offsetParent = elm;\r\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\r\n          const castOffsetParent = offsetParent;\r\n          x += castOffsetParent.offsetLeft || 0;\r\n          y += castOffsetParent.offsetTop || 0;\r\n          offsetParent = castOffsetParent.offsetParent;\r\n        }\r\n        offsetParent = elm.parentNode;\r\n        while (offsetParent && offsetParent !== rootElm && offsetParent.nodeType && !hasChild(offsetParent, rootElm)) {\r\n          x -= offsetParent.scrollLeft || 0;\r\n          y -= offsetParent.scrollTop || 0;\r\n          offsetParent = offsetParent.parentNode;\r\n        }\r\n        y += getTableCaptionDeltaY(SugarElement.fromDom(elm));\r\n      }\r\n      return {\r\n        x,\r\n        y\r\n      };\r\n    };\r\n\r\n    const StyleSheetLoader = (documentOrShadowRoot, settings = {}) => {\r\n      let idCount = 0;\r\n      const loadedStates = {};\r\n      const edos = SugarElement.fromDom(documentOrShadowRoot);\r\n      const doc = documentOrOwner(edos);\r\n      const _setReferrerPolicy = referrerPolicy => {\r\n        settings.referrerPolicy = referrerPolicy;\r\n      };\r\n      const _setContentCssCors = contentCssCors => {\r\n        settings.contentCssCors = contentCssCors;\r\n      };\r\n      const addStyle = element => {\r\n        append$1(getStyleContainer(edos), element);\r\n      };\r\n      const removeStyle = id => {\r\n        const styleContainer = getStyleContainer(edos);\r\n        descendant$1(styleContainer, '#' + id).each(remove$5);\r\n      };\r\n      const getOrCreateState = url => get$a(loadedStates, url).getOrThunk(() => ({\r\n        id: 'mce-u' + idCount++,\r\n        passed: [],\r\n        failed: [],\r\n        count: 0\r\n      }));\r\n      const load = url => new Promise((success, failure) => {\r\n        let link;\r\n        const urlWithSuffix = Tools._addCacheSuffix(url);\r\n        const state = getOrCreateState(urlWithSuffix);\r\n        loadedStates[urlWithSuffix] = state;\r\n        state.count++;\r\n        const resolve = (callbacks, status) => {\r\n          each$e(callbacks, call);\r\n          state.status = status;\r\n          state.passed = [];\r\n          state.failed = [];\r\n          if (link) {\r\n            link.onload = null;\r\n            link.onerror = null;\r\n            link = null;\r\n          }\r\n        };\r\n        const passed = () => resolve(state.passed, 2);\r\n        const failed = () => resolve(state.failed, 3);\r\n        if (success) {\r\n          state.passed.push(success);\r\n        }\r\n        if (failure) {\r\n          state.failed.push(failure);\r\n        }\r\n        if (state.status === 1) {\r\n          return;\r\n        }\r\n        if (state.status === 2) {\r\n          passed();\r\n          return;\r\n        }\r\n        if (state.status === 3) {\r\n          failed();\r\n          return;\r\n        }\r\n        state.status = 1;\r\n        const linkElem = SugarElement.fromTag('link', doc.dom);\r\n        setAll$1(linkElem, {\r\n          rel: 'stylesheet',\r\n          type: 'text/css',\r\n          id: state.id\r\n        });\r\n        if (settings.contentCssCors) {\r\n          set$3(linkElem, 'crossOrigin', 'anonymous');\r\n        }\r\n        if (settings.referrerPolicy) {\r\n          set$3(linkElem, 'referrerpolicy', settings.referrerPolicy);\r\n        }\r\n        link = linkElem.dom;\r\n        link.onload = passed;\r\n        link.onerror = failed;\r\n        addStyle(linkElem);\r\n        set$3(linkElem, 'href', urlWithSuffix);\r\n      });\r\n      const loadRawCss = (key, css) => {\r\n        const state = getOrCreateState(key);\r\n        loadedStates[key] = state;\r\n        state.count++;\r\n        const styleElem = SugarElement.fromTag('style', doc.dom);\r\n        setAll$1(styleElem, {\r\n          rel: 'stylesheet',\r\n          type: 'text/css',\r\n          id: state.id\r\n        });\r\n        styleElem.dom.innerHTML = css;\r\n        addStyle(styleElem);\r\n      };\r\n      const loadAll = urls => {\r\n        const loadedUrls = Promise.allSettled(map$3(urls, url => load(url).then(constant(url))));\r\n        return loadedUrls.then(results => {\r\n          const parts = partition$2(results, r => r.status === 'fulfilled');\r\n          if (parts.fail.length > 0) {\r\n            return Promise.reject(map$3(parts.fail, result => result.reason));\r\n          } else {\r\n            return map$3(parts.pass, result => result.value);\r\n          }\r\n        });\r\n      };\r\n      const unload = url => {\r\n        const urlWithSuffix = Tools._addCacheSuffix(url);\r\n        get$a(loadedStates, urlWithSuffix).each(state => {\r\n          const count = --state.count;\r\n          if (count === 0) {\r\n            delete loadedStates[urlWithSuffix];\r\n            removeStyle(state.id);\r\n          }\r\n        });\r\n      };\r\n      const unloadRawCss = key => {\r\n        get$a(loadedStates, key).each(state => {\r\n          const count = --state.count;\r\n          if (count === 0) {\r\n            delete loadedStates[key];\r\n            removeStyle(state.id);\r\n          }\r\n        });\r\n      };\r\n      const unloadAll = urls => {\r\n        each$e(urls, url => {\r\n          unload(url);\r\n        });\r\n      };\r\n      return {\r\n        load,\r\n        loadRawCss,\r\n        loadAll,\r\n        unload,\r\n        unloadRawCss,\r\n        unloadAll,\r\n        _setReferrerPolicy,\r\n        _setContentCssCors\r\n      };\r\n    };\r\n\r\n    const create$d = () => {\r\n      const map = new WeakMap();\r\n      const forElement = (referenceElement, settings) => {\r\n        const root = getRootNode(referenceElement);\r\n        const rootDom = root.dom;\r\n        return Optional.from(map.get(rootDom)).getOrThunk(() => {\r\n          const sl = StyleSheetLoader(rootDom, settings);\r\n          map.set(rootDom, sl);\r\n          return sl;\r\n        });\r\n      };\r\n      return { forElement };\r\n    };\r\n    const instance = create$d();\r\n\r\n    const isSpan = node => node.nodeName.toLowerCase() === 'span';\r\n    const isInlineContent = (node, root, schema) => isNonNullable(node) && (isContent$1(node, root) || schema.isInline(node.nodeName.toLowerCase()));\r\n    const surroundedByInlineContent = (node, root, schema) => {\r\n      const prev = new DomTreeWalker(node, root).prev(false);\r\n      const next = new DomTreeWalker(node, root).next(false);\r\n      const prevIsInline = isUndefined(prev) || isInlineContent(prev, root, schema);\r\n      const nextIsInline = isUndefined(next) || isInlineContent(next, root, schema);\r\n      return prevIsInline && nextIsInline;\r\n    };\r\n    const isBookmarkNode$2 = node => isSpan(node) && node.getAttribute('data-mce-type') === 'bookmark';\r\n    const isKeepTextNode = (node, root, schema) => isText$a(node) && node.data.length > 0 && surroundedByInlineContent(node, root, schema);\r\n    const isKeepElement = node => isElement$6(node) ? node.childNodes.length > 0 : false;\r\n    const isDocument = node => isDocumentFragment(node) || isDocument$1(node);\r\n    const trimNode = (dom, node, schema, root) => {\r\n      var _a;\r\n      const rootNode = root || node;\r\n      if (isElement$6(node) && isBookmarkNode$2(node)) {\r\n        return node;\r\n      }\r\n      const children = node.childNodes;\r\n      for (let i = children.length - 1; i >= 0; i--) {\r\n        trimNode(dom, children[i], schema, rootNode);\r\n      }\r\n      if (isElement$6(node)) {\r\n        const currentChildren = node.childNodes;\r\n        if (currentChildren.length === 1 && isBookmarkNode$2(currentChildren[0])) {\r\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(currentChildren[0], node);\r\n        }\r\n      }\r\n      if (!isDocument(node) && !isContent$1(node, rootNode) && !isKeepElement(node) && !isKeepTextNode(node, rootNode, schema)) {\r\n        dom.remove(node);\r\n      }\r\n      return node;\r\n    };\r\n\r\n    const makeMap$3 = Tools.makeMap;\r\n    const attrsCharsRegExp = /[&<>\\\"\\u0060\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\r\n    const textCharsRegExp = /[<>&\\u007E-\\uD7FF\\uE000-\\uFFEF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\r\n    const rawCharsRegExp = /[<>&\\\"\\']/g;\r\n    const entityRegExp = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi;\r\n    const asciiMap = {\r\n      128: '\\u20AC',\r\n      130: '\\u201A',\r\n      131: '\\u0192',\r\n      132: '\\u201E',\r\n      133: '\\u2026',\r\n      134: '\\u2020',\r\n      135: '\\u2021',\r\n      136: '\\u02c6',\r\n      137: '\\u2030',\r\n      138: '\\u0160',\r\n      139: '\\u2039',\r\n      140: '\\u0152',\r\n      142: '\\u017d',\r\n      145: '\\u2018',\r\n      146: '\\u2019',\r\n      147: '\\u201C',\r\n      148: '\\u201D',\r\n      149: '\\u2022',\r\n      150: '\\u2013',\r\n      151: '\\u2014',\r\n      152: '\\u02DC',\r\n      153: '\\u2122',\r\n      154: '\\u0161',\r\n      155: '\\u203A',\r\n      156: '\\u0153',\r\n      158: '\\u017e',\r\n      159: '\\u0178'\r\n    };\r\n    const baseEntities = {\r\n      '\"': '&quot;',\r\n      '\\'': '&#39;',\r\n      '<': '&lt;',\r\n      '>': '&gt;',\r\n      '&': '&amp;',\r\n      '`': '&#96;'\r\n    };\r\n    const reverseEntities = {\r\n      '&lt;': '<',\r\n      '&gt;': '>',\r\n      '&amp;': '&',\r\n      '&quot;': '\"',\r\n      '&apos;': `'`\r\n    };\r\n    const nativeDecode = text => {\r\n      const elm = SugarElement.fromTag('div').dom;\r\n      elm.innerHTML = text;\r\n      return elm.textContent || elm.innerText || text;\r\n    };\r\n    const buildEntitiesLookup = (items, radix) => {\r\n      const lookup = {};\r\n      if (items) {\r\n        const itemList = items.split(',');\r\n        radix = radix || 10;\r\n        for (let i = 0; i < itemList.length; i += 2) {\r\n          const chr = String.fromCharCode(parseInt(itemList[i], radix));\r\n          if (!baseEntities[chr]) {\r\n            const entity = '&' + itemList[i + 1] + ';';\r\n            lookup[chr] = entity;\r\n            lookup[entity] = chr;\r\n          }\r\n        }\r\n        return lookup;\r\n      } else {\r\n        return undefined;\r\n      }\r\n    };\r\n    const namedEntities = buildEntitiesLookup('50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,' + '5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,' + '5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,' + '5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,' + '68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,' + '6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,' + '6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,' + '75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,' + '7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,' + '7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,' + 'sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,' + 'st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,' + 't9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,' + 'tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,' + 'u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,' + '81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,' + '8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,' + '8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,' + '8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,' + '8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,' + 'nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,' + 'rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,' + 'Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,' + '80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,' + '811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro', 32);\r\n    const encodeRaw = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\r\n      return baseEntities[chr] || chr;\r\n    });\r\n    const encodeAllRaw = text => ('' + text).replace(rawCharsRegExp, chr => {\r\n      return baseEntities[chr] || chr;\r\n    });\r\n    const encodeNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\r\n      if (chr.length > 1) {\r\n        return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\r\n      }\r\n      return baseEntities[chr] || '&#' + chr.charCodeAt(0) + ';';\r\n    });\r\n    const encodeNamed = (text, attr, entities) => {\r\n      const resolveEntities = entities || namedEntities;\r\n      return text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\r\n        return baseEntities[chr] || resolveEntities[chr] || chr;\r\n      });\r\n    };\r\n    const getEncodeFunc = (name, entities) => {\r\n      const entitiesMap = buildEntitiesLookup(entities) || namedEntities;\r\n      const encodeNamedAndNumeric = (text, attr) => text.replace(attr ? attrsCharsRegExp : textCharsRegExp, chr => {\r\n        if (baseEntities[chr] !== undefined) {\r\n          return baseEntities[chr];\r\n        }\r\n        if (entitiesMap[chr] !== undefined) {\r\n          return entitiesMap[chr];\r\n        }\r\n        if (chr.length > 1) {\r\n          return '&#' + ((chr.charCodeAt(0) - 55296) * 1024 + (chr.charCodeAt(1) - 56320) + 65536) + ';';\r\n        }\r\n        return '&#' + chr.charCodeAt(0) + ';';\r\n      });\r\n      const encodeCustomNamed = (text, attr) => {\r\n        return encodeNamed(text, attr, entitiesMap);\r\n      };\r\n      const nameMap = makeMap$3(name.replace(/\\+/g, ','));\r\n      if (nameMap.named && nameMap.numeric) {\r\n        return encodeNamedAndNumeric;\r\n      }\r\n      if (nameMap.named) {\r\n        if (entities) {\r\n          return encodeCustomNamed;\r\n        }\r\n        return encodeNamed;\r\n      }\r\n      if (nameMap.numeric) {\r\n        return encodeNumeric;\r\n      }\r\n      return encodeRaw;\r\n    };\r\n    const decode = text => text.replace(entityRegExp, (all, numeric) => {\r\n      if (numeric) {\r\n        if (numeric.charAt(0).toLowerCase() === 'x') {\r\n          numeric = parseInt(numeric.substr(1), 16);\r\n        } else {\r\n          numeric = parseInt(numeric, 10);\r\n        }\r\n        if (numeric > 65535) {\r\n          numeric -= 65536;\r\n          return String.fromCharCode(55296 + (numeric >> 10), 56320 + (numeric & 1023));\r\n        }\r\n        return asciiMap[numeric] || String.fromCharCode(numeric);\r\n      }\r\n      return reverseEntities[all] || namedEntities[all] || nativeDecode(all);\r\n    });\r\n    const Entities = {\r\n      encodeRaw,\r\n      encodeAllRaw,\r\n      encodeNumeric,\r\n      encodeNamed,\r\n      getEncodeFunc,\r\n      decode\r\n    };\r\n\r\n    const split$1 = (items, delim) => {\r\n      items = Tools.trim(items);\r\n      return items ? items.split(delim || ' ') : [];\r\n    };\r\n    const patternToRegExp = str => new RegExp('^' + str.replace(/([?+*])/g, '.$1') + '$');\r\n\r\n    const parseCustomElementsRules = value => {\r\n      const customElementRegExp = /^(~)?(.+)$/;\r\n      return bind$3(split$1(value, ','), rule => {\r\n        const matches = customElementRegExp.exec(rule);\r\n        if (matches) {\r\n          const inline = matches[1] === '~';\r\n          const cloneName = inline ? 'span' : 'div';\r\n          const name = matches[2];\r\n          return [{\r\n              inline,\r\n              cloneName,\r\n              name\r\n            }];\r\n        } else {\r\n          return [];\r\n        }\r\n      });\r\n    };\r\n\r\n    const getElementSetsAsStrings = type => {\r\n      let globalAttributes, blockContent;\r\n      let phrasingContent;\r\n      globalAttributes = 'id accesskey class dir lang style tabindex title role';\r\n      blockContent = 'address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul';\r\n      phrasingContent = 'a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd ' + 'label map noscript object q s samp script select small span strong sub sup ' + 'textarea u var #text #comment';\r\n      if (type !== 'html4') {\r\n        const transparentContent = 'a ins del canvas map';\r\n        globalAttributes += ' contenteditable contextmenu draggable dropzone ' + 'hidden spellcheck translate';\r\n        blockContent += ' article aside details dialog figure main header footer hgroup section nav ' + transparentContent;\r\n        phrasingContent += ' audio canvas command datalist mark meter output picture ' + 'progress time wbr video ruby bdi keygen svg';\r\n      }\r\n      if (type !== 'html5-strict') {\r\n        globalAttributes += ' xml:lang';\r\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\r\n        phrasingContent = [\r\n          phrasingContent,\r\n          html4PhrasingContent\r\n        ].join(' ');\r\n        const html4BlockContent = 'center dir isindex noframes';\r\n        blockContent = [\r\n          blockContent,\r\n          html4BlockContent\r\n        ].join(' ');\r\n      }\r\n      const flowContent = [\r\n        blockContent,\r\n        phrasingContent\r\n      ].join(' ');\r\n      return {\r\n        globalAttributes,\r\n        blockContent,\r\n        phrasingContent,\r\n        flowContent\r\n      };\r\n    };\r\n\r\n    const makeSchema = type => {\r\n      const {globalAttributes, phrasingContent, flowContent} = getElementSetsAsStrings(type);\r\n      const schema = {};\r\n      const addElement = (name, attributes, children) => {\r\n        schema[name] = {\r\n          attributes: mapToObject(attributes, constant({})),\r\n          attributesOrder: attributes,\r\n          children: mapToObject(children, constant({}))\r\n        };\r\n      };\r\n      const add = (name, attributes = '', children = '') => {\r\n        const childNames = split$1(children);\r\n        const names = split$1(name);\r\n        let ni = names.length;\r\n        const allAttributes = split$1([\r\n          globalAttributes,\r\n          attributes\r\n        ].join(' '));\r\n        while (ni--) {\r\n          addElement(names[ni], allAttributes.slice(), childNames);\r\n        }\r\n      };\r\n      const addAttrs = (name, attributes) => {\r\n        const names = split$1(name);\r\n        const attrs = split$1(attributes);\r\n        let ni = names.length;\r\n        while (ni--) {\r\n          const schemaItem = schema[names[ni]];\r\n          for (let i = 0, l = attrs.length; i < l; i++) {\r\n            schemaItem.attributes[attrs[i]] = {};\r\n            schemaItem.attributesOrder.push(attrs[i]);\r\n          }\r\n        }\r\n      };\r\n      if (type !== 'html5-strict') {\r\n        const html4PhrasingContent = 'acronym applet basefont big font strike tt';\r\n        each$e(split$1(html4PhrasingContent), name => {\r\n          add(name, '', phrasingContent);\r\n        });\r\n        const html4BlockContent = 'center dir isindex noframes';\r\n        each$e(split$1(html4BlockContent), name => {\r\n          add(name, '', flowContent);\r\n        });\r\n      }\r\n      add('html', 'manifest', 'head body');\r\n      add('head', '', 'base command link meta noscript script style title');\r\n      add('title hr noscript br');\r\n      add('base', 'href target');\r\n      add('link', 'href rel media hreflang type sizes hreflang');\r\n      add('meta', 'name http-equiv content charset');\r\n      add('style', 'media type scoped');\r\n      add('script', 'src async defer type charset');\r\n      add('body', 'onafterprint onbeforeprint onbeforeunload onblur onerror onfocus ' + 'onhashchange onload onmessage onoffline ononline onpagehide onpageshow ' + 'onpopstate onresize onscroll onstorage onunload', flowContent);\r\n      add('dd div', '', flowContent);\r\n      add('address dt caption', '', type === 'html4' ? phrasingContent : flowContent);\r\n      add('h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn', '', phrasingContent);\r\n      add('blockquote', 'cite', flowContent);\r\n      add('ol', 'reversed start type', 'li');\r\n      add('ul', '', 'li');\r\n      add('li', 'value', flowContent);\r\n      add('dl', '', 'dt dd');\r\n      add('a', 'href target rel media hreflang type', type === 'html4' ? phrasingContent : flowContent);\r\n      add('q', 'cite', phrasingContent);\r\n      add('ins del', 'cite datetime', flowContent);\r\n      add('img', 'src sizes srcset alt usemap ismap width height');\r\n      add('iframe', 'src name width height', flowContent);\r\n      add('embed', 'src type width height');\r\n      add('object', 'data type typemustmatch name usemap form width height', [\r\n        flowContent,\r\n        'param'\r\n      ].join(' '));\r\n      add('param', 'name value');\r\n      add('map', 'name', [\r\n        flowContent,\r\n        'area'\r\n      ].join(' '));\r\n      add('area', 'alt coords shape href target rel media hreflang type');\r\n      add('table', 'border', 'caption colgroup thead tfoot tbody tr' + (type === 'html4' ? ' col' : ''));\r\n      add('colgroup', 'span', 'col');\r\n      add('col', 'span');\r\n      add('tbody thead tfoot', '', 'tr');\r\n      add('tr', '', 'td th');\r\n      add('td', 'colspan rowspan headers', flowContent);\r\n      add('th', 'colspan rowspan headers scope abbr', flowContent);\r\n      add('form', 'accept-charset action autocomplete enctype method name novalidate target', flowContent);\r\n      add('fieldset', 'disabled form name', [\r\n        flowContent,\r\n        'legend'\r\n      ].join(' '));\r\n      add('label', 'form for', phrasingContent);\r\n      add('input', 'accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate ' + 'formtarget height list max maxlength min multiple name pattern readonly required size src step type value width');\r\n      add('button', 'disabled form formaction formenctype formmethod formnovalidate formtarget name type value', type === 'html4' ? flowContent : phrasingContent);\r\n      add('select', 'disabled form multiple name required size', 'option optgroup');\r\n      add('optgroup', 'disabled label', 'option');\r\n      add('option', 'disabled label selected value');\r\n      add('textarea', 'cols dirname disabled form maxlength name readonly required rows wrap');\r\n      add('menu', 'type label', [\r\n        flowContent,\r\n        'li'\r\n      ].join(' '));\r\n      add('noscript', '', flowContent);\r\n      if (type !== 'html4') {\r\n        add('wbr');\r\n        add('ruby', '', [\r\n          phrasingContent,\r\n          'rt rp'\r\n        ].join(' '));\r\n        add('figcaption', '', flowContent);\r\n        add('mark rt rp bdi', '', phrasingContent);\r\n        add('summary', '', [\r\n          phrasingContent,\r\n          'h1 h2 h3 h4 h5 h6'\r\n        ].join(' '));\r\n        add('canvas', 'width height', flowContent);\r\n        add('video', 'src crossorigin poster preload autoplay mediagroup loop ' + 'muted controls width height buffered', [\r\n          flowContent,\r\n          'track source'\r\n        ].join(' '));\r\n        add('audio', 'src crossorigin preload autoplay mediagroup loop muted controls ' + 'buffered volume', [\r\n          flowContent,\r\n          'track source'\r\n        ].join(' '));\r\n        add('picture', '', 'img source');\r\n        add('source', 'src srcset type media sizes');\r\n        add('track', 'kind src srclang label default');\r\n        add('datalist', '', [\r\n          phrasingContent,\r\n          'option'\r\n        ].join(' '));\r\n        add('article section nav aside main header footer', '', flowContent);\r\n        add('hgroup', '', 'h1 h2 h3 h4 h5 h6');\r\n        add('figure', '', [\r\n          flowContent,\r\n          'figcaption'\r\n        ].join(' '));\r\n        add('time', 'datetime', phrasingContent);\r\n        add('dialog', 'open', flowContent);\r\n        add('command', 'type label icon disabled checked radiogroup command');\r\n        add('output', 'for form name', phrasingContent);\r\n        add('progress', 'value max', phrasingContent);\r\n        add('meter', 'value min max low high optimum', phrasingContent);\r\n        add('details', 'open', [\r\n          flowContent,\r\n          'summary'\r\n        ].join(' '));\r\n        add('keygen', 'autofocus challenge disabled form keytype name');\r\n        addElement('svg', 'id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform'.split(' '), []);\r\n      }\r\n      if (type !== 'html5-strict') {\r\n        addAttrs('script', 'language xml:space');\r\n        addAttrs('style', 'xml:space');\r\n        addAttrs('object', 'declare classid code codebase codetype archive standby align border hspace vspace');\r\n        addAttrs('embed', 'align name hspace vspace');\r\n        addAttrs('param', 'valuetype type');\r\n        addAttrs('a', 'charset name rev shape coords');\r\n        addAttrs('br', 'clear');\r\n        addAttrs('applet', 'codebase archive code object alt name width height align hspace vspace');\r\n        addAttrs('img', 'name longdesc align border hspace vspace');\r\n        addAttrs('iframe', 'longdesc frameborder marginwidth marginheight scrolling align');\r\n        addAttrs('font basefont', 'size color face');\r\n        addAttrs('input', 'usemap align');\r\n        addAttrs('select');\r\n        addAttrs('textarea');\r\n        addAttrs('h1 h2 h3 h4 h5 h6 div p legend caption', 'align');\r\n        addAttrs('ul', 'type compact');\r\n        addAttrs('li', 'type');\r\n        addAttrs('ol dl menu dir', 'compact');\r\n        addAttrs('pre', 'width xml:space');\r\n        addAttrs('hr', 'align noshade size width');\r\n        addAttrs('isindex', 'prompt');\r\n        addAttrs('table', 'summary width frame rules cellspacing cellpadding align bgcolor');\r\n        addAttrs('col', 'width align char charoff valign');\r\n        addAttrs('colgroup', 'width align char charoff valign');\r\n        addAttrs('thead', 'align char charoff valign');\r\n        addAttrs('tr', 'align char charoff valign bgcolor');\r\n        addAttrs('th', 'axis align char charoff valign nowrap bgcolor width height');\r\n        addAttrs('form', 'accept');\r\n        addAttrs('td', 'abbr axis scope align char charoff valign nowrap bgcolor width height');\r\n        addAttrs('tfoot', 'align char charoff valign');\r\n        addAttrs('tbody', 'align char charoff valign');\r\n        addAttrs('area', 'nohref');\r\n        addAttrs('body', 'background bgcolor text link vlink alink');\r\n      }\r\n      if (type !== 'html4') {\r\n        addAttrs('input button select textarea', 'autofocus');\r\n        addAttrs('input textarea', 'placeholder');\r\n        addAttrs('a', 'download');\r\n        addAttrs('link script img', 'crossorigin');\r\n        addAttrs('img', 'loading');\r\n        addAttrs('iframe', 'sandbox seamless allow allowfullscreen loading');\r\n      }\r\n      if (type !== 'html4') {\r\n        each$e([\r\n          schema.video,\r\n          schema.audio\r\n        ], item => {\r\n          delete item.children.audio;\r\n          delete item.children.video;\r\n        });\r\n      }\r\n      each$e(split$1('a form meter progress dfn'), name => {\r\n        if (schema[name]) {\r\n          delete schema[name].children[name];\r\n        }\r\n      });\r\n      delete schema.caption.children.table;\r\n      delete schema.script;\r\n      return schema;\r\n    };\r\n\r\n    const prefixToOperation = prefix => prefix === '-' ? 'remove' : 'add';\r\n    const parseValidChildrenRules = value => {\r\n      const childRuleRegExp = /^([+\\-]?)([A-Za-z0-9_\\-.\\u00b7\\u00c0-\\u00d6\\u00d8-\\u00f6\\u00f8-\\u037d\\u037f-\\u1fff\\u200c-\\u200d\\u203f-\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]+)\\[([^\\]]+)]$/;\r\n      return bind$3(split$1(value, ','), rule => {\r\n        const matches = childRuleRegExp.exec(rule);\r\n        if (matches) {\r\n          const prefix = matches[1];\r\n          const operation = prefix ? prefixToOperation(prefix) : 'replace';\r\n          const name = matches[2];\r\n          const validChildren = split$1(matches[3], '|');\r\n          return [{\r\n              operation,\r\n              name,\r\n              validChildren\r\n            }];\r\n        } else {\r\n          return [];\r\n        }\r\n      });\r\n    };\r\n\r\n    const parseValidElementsAttrDataIntoElement = (attrData, targetElement) => {\r\n      const attrRuleRegExp = /^([!\\-])?(\\w+[\\\\:]:\\w+|[^=~<]+)?(?:([=~<])(.*))?$/;\r\n      const hasPatternsRegExp = /[*?+]/;\r\n      const {attributes, attributesOrder} = targetElement;\r\n      return each$e(split$1(attrData, '|'), rule => {\r\n        const matches = attrRuleRegExp.exec(rule);\r\n        if (matches) {\r\n          const attr = {};\r\n          const attrType = matches[1];\r\n          const attrName = matches[2].replace(/[\\\\:]:/g, ':');\r\n          const attrPrefix = matches[3];\r\n          const value = matches[4];\r\n          if (attrType === '!') {\r\n            targetElement.attributesRequired = targetElement.attributesRequired || [];\r\n            targetElement.attributesRequired.push(attrName);\r\n            attr.required = true;\r\n          }\r\n          if (attrType === '-') {\r\n            delete attributes[attrName];\r\n            attributesOrder.splice(Tools.inArray(attributesOrder, attrName), 1);\r\n            return;\r\n          }\r\n          if (attrPrefix) {\r\n            if (attrPrefix === '=') {\r\n              targetElement.attributesDefault = targetElement.attributesDefault || [];\r\n              targetElement.attributesDefault.push({\r\n                name: attrName,\r\n                value\r\n              });\r\n              attr.defaultValue = value;\r\n            } else if (attrPrefix === '~') {\r\n              targetElement.attributesForced = targetElement.attributesForced || [];\r\n              targetElement.attributesForced.push({\r\n                name: attrName,\r\n                value\r\n              });\r\n              attr.forcedValue = value;\r\n            } else if (attrPrefix === '<') {\r\n              attr.validValues = Tools.makeMap(value, '?');\r\n            }\r\n          }\r\n          if (hasPatternsRegExp.test(attrName)) {\r\n            const attrPattern = attr;\r\n            targetElement.attributePatterns = targetElement.attributePatterns || [];\r\n            attrPattern.pattern = patternToRegExp(attrName);\r\n            targetElement.attributePatterns.push(attrPattern);\r\n          } else {\r\n            if (!attributes[attrName]) {\r\n              attributesOrder.push(attrName);\r\n            }\r\n            attributes[attrName] = attr;\r\n          }\r\n        }\r\n      });\r\n    };\r\n    const cloneAttributesInto = (from, to) => {\r\n      each$d(from.attributes, (value, key) => {\r\n        to.attributes[key] = value;\r\n      });\r\n      to.attributesOrder.push(...from.attributesOrder);\r\n    };\r\n    const parseValidElementsRules = (globalElement, validElements) => {\r\n      const elementRuleRegExp = /^([#+\\-])?([^\\[!\\/]+)(?:\\/([^\\[!]+))?(?:(!?)\\[([^\\]]+)])?$/;\r\n      return bind$3(split$1(validElements, ','), rule => {\r\n        const matches = elementRuleRegExp.exec(rule);\r\n        if (matches) {\r\n          const prefix = matches[1];\r\n          const elementName = matches[2];\r\n          const outputName = matches[3];\r\n          const attrsPrefix = matches[4];\r\n          const attrData = matches[5];\r\n          const element = {\r\n            attributes: {},\r\n            attributesOrder: []\r\n          };\r\n          globalElement.each(el => cloneAttributesInto(el, element));\r\n          if (prefix === '#') {\r\n            element.paddEmpty = true;\r\n          } else if (prefix === '-') {\r\n            element.removeEmpty = true;\r\n          }\r\n          if (attrsPrefix === '!') {\r\n            element.removeEmptyAttrs = true;\r\n          }\r\n          if (attrData) {\r\n            parseValidElementsAttrDataIntoElement(attrData, element);\r\n          }\r\n          if (outputName) {\r\n            element.outputName = elementName;\r\n          }\r\n          if (elementName === '@') {\r\n            if (globalElement.isNone()) {\r\n              globalElement = Optional.some(element);\r\n            } else {\r\n              return [];\r\n            }\r\n          }\r\n          return [outputName ? {\r\n              name: elementName,\r\n              element,\r\n              aliasName: outputName\r\n            } : {\r\n              name: elementName,\r\n              element\r\n            }];\r\n        } else {\r\n          return [];\r\n        }\r\n      });\r\n    };\r\n\r\n    const mapCache = {};\r\n    const makeMap$2 = Tools.makeMap, each$b = Tools.each, extend$2 = Tools.extend, explode$2 = Tools.explode;\r\n    const createMap = (defaultValue, extendWith = {}) => {\r\n      const value = makeMap$2(defaultValue, ' ', makeMap$2(defaultValue.toUpperCase(), ' '));\r\n      return extend$2(value, extendWith);\r\n    };\r\n    const getTextRootBlockElements = schema => createMap('td th li dt dd figcaption caption details summary', schema.getTextBlockElements());\r\n    const compileElementMap = (value, mode) => {\r\n      if (value) {\r\n        const styles = {};\r\n        if (isString(value)) {\r\n          value = { '*': value };\r\n        }\r\n        each$b(value, (value, key) => {\r\n          styles[key] = styles[key.toUpperCase()] = mode === 'map' ? makeMap$2(value, /[, ]/) : explode$2(value, /[, ]/);\r\n        });\r\n        return styles;\r\n      } else {\r\n        return undefined;\r\n      }\r\n    };\r\n    const Schema = (settings = {}) => {\r\n      var _a;\r\n      const elements = {};\r\n      const children = {};\r\n      let patternElements = [];\r\n      const customElementsMap = {};\r\n      const specialElements = {};\r\n      const createLookupTable = (option, defaultValue, extendWith) => {\r\n        const value = settings[option];\r\n        if (!value) {\r\n          let newValue = mapCache[option];\r\n          if (!newValue) {\r\n            newValue = createMap(defaultValue, extendWith);\r\n            mapCache[option] = newValue;\r\n          }\r\n          return newValue;\r\n        } else {\r\n          return makeMap$2(value, /[, ]/, makeMap$2(value.toUpperCase(), /[, ]/));\r\n        }\r\n      };\r\n      const schemaType = (_a = settings.schema) !== null && _a !== void 0 ? _a : 'html5';\r\n      const schemaItems = makeSchema(schemaType);\r\n      if (settings.verify_html === false) {\r\n        settings.valid_elements = '*[*]';\r\n      }\r\n      const validStyles = compileElementMap(settings.valid_styles);\r\n      const invalidStyles = compileElementMap(settings.invalid_styles, 'map');\r\n      const validClasses = compileElementMap(settings.valid_classes, 'map');\r\n      const whitespaceElementsMap = createLookupTable('whitespace_elements', 'pre script noscript style textarea video audio iframe object code');\r\n      const selfClosingElementsMap = createLookupTable('self_closing_elements', 'colgroup dd dt li option p td tfoot th thead tr');\r\n      const voidElementsMap = createLookupTable('void_elements', 'area base basefont br col frame hr img input isindex link ' + 'meta param embed source wbr track');\r\n      const boolAttrMap = createLookupTable('boolean_attributes', 'checked compact declare defer disabled ismap multiple nohref noresize ' + 'noshade nowrap readonly selected autoplay loop controls allowfullscreen');\r\n      const nonEmptyOrMoveCaretBeforeOnEnter = 'td th iframe video audio object script code';\r\n      const nonEmptyElementsMap = createLookupTable('non_empty_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' pre svg', voidElementsMap);\r\n      const moveCaretBeforeOnEnterElementsMap = createLookupTable('move_caret_before_on_enter_elements', nonEmptyOrMoveCaretBeforeOnEnter + ' table', voidElementsMap);\r\n      const headings = 'h1 h2 h3 h4 h5 h6';\r\n      const textBlockElementsMap = createLookupTable('text_block_elements', headings + ' p div address pre form ' + 'blockquote center dir fieldset header footer article section hgroup aside main nav figure');\r\n      const blockElementsMap = createLookupTable('block_elements', 'hr table tbody thead tfoot ' + 'th tr td li ol ul caption dl dt dd noscript menu isindex option ' + 'datalist select optgroup figcaption details summary html body multicol listing', textBlockElementsMap);\r\n      const textInlineElementsMap = createLookupTable('text_inline_elements', 'span strong b em i font s strike u var cite ' + 'dfn code mark q sup sub samp');\r\n      const transparentElementsMap = createLookupTable('transparent_elements', 'a ins del canvas map');\r\n      const wrapBlockElementsMap = createLookupTable('wrap_block_elements', 'pre ' + headings);\r\n      each$b('script noscript iframe noframes noembed title style textarea xmp plaintext'.split(' '), name => {\r\n        specialElements[name] = new RegExp('</' + name + '[^>]*>', 'gi');\r\n      });\r\n      const addValidElements = validElements => {\r\n        const globalElement = Optional.from(elements['@']);\r\n        const hasPatternsRegExp = /[*?+]/;\r\n        each$e(parseValidElementsRules(globalElement, validElements !== null && validElements !== void 0 ? validElements : ''), ({name, element, aliasName}) => {\r\n          if (aliasName) {\r\n            elements[aliasName] = element;\r\n          }\r\n          if (hasPatternsRegExp.test(name)) {\r\n            const patternElement = element;\r\n            patternElement.pattern = patternToRegExp(name);\r\n            patternElements.push(patternElement);\r\n          } else {\r\n            elements[name] = element;\r\n          }\r\n        });\r\n      };\r\n      const setValidElements = validElements => {\r\n        patternElements = [];\r\n        each$e(keys(elements), name => {\r\n          delete elements[name];\r\n        });\r\n        addValidElements(validElements);\r\n      };\r\n      const addCustomElements = customElements => {\r\n        delete mapCache.text_block_elements;\r\n        delete mapCache.block_elements;\r\n        each$e(parseCustomElementsRules(customElements !== null && customElements !== void 0 ? customElements : ''), ({inline, name, cloneName}) => {\r\n          children[name] = children[cloneName];\r\n          customElementsMap[name] = cloneName;\r\n          nonEmptyElementsMap[name.toUpperCase()] = {};\r\n          nonEmptyElementsMap[name] = {};\r\n          if (!inline) {\r\n            blockElementsMap[name.toUpperCase()] = {};\r\n            blockElementsMap[name] = {};\r\n          }\r\n          if (!elements[name]) {\r\n            let customRule = elements[cloneName];\r\n            customRule = extend$2({}, customRule);\r\n            delete customRule.removeEmptyAttrs;\r\n            delete customRule.removeEmpty;\r\n            elements[name] = customRule;\r\n          }\r\n          each$d(children, (element, elmName) => {\r\n            if (element[cloneName]) {\r\n              children[elmName] = element = extend$2({}, children[elmName]);\r\n              element[name] = element[cloneName];\r\n            }\r\n          });\r\n        });\r\n      };\r\n      const addValidChildren = validChildren => {\r\n        each$e(parseValidChildrenRules(validChildren !== null && validChildren !== void 0 ? validChildren : ''), ({operation, name, validChildren}) => {\r\n          const parent = operation === 'replace' ? { '#comment': {} } : children[name];\r\n          each$e(validChildren, child => {\r\n            if (operation === 'remove') {\r\n              delete parent[child];\r\n            } else {\r\n              parent[child] = {};\r\n            }\r\n          });\r\n          children[name] = parent;\r\n        });\r\n      };\r\n      const getElementRule = name => {\r\n        const element = elements[name];\r\n        if (element) {\r\n          return element;\r\n        }\r\n        let i = patternElements.length;\r\n        while (i--) {\r\n          const patternElement = patternElements[i];\r\n          if (patternElement.pattern.test(name)) {\r\n            return patternElement;\r\n          }\r\n        }\r\n        return undefined;\r\n      };\r\n      if (!settings.valid_elements) {\r\n        each$b(schemaItems, (element, name) => {\r\n          elements[name] = {\r\n            attributes: element.attributes,\r\n            attributesOrder: element.attributesOrder\r\n          };\r\n          children[name] = element.children;\r\n        });\r\n        each$b(split$1('strong/b em/i'), item => {\r\n          const items = split$1(item, '/');\r\n          elements[items[1]].outputName = items[0];\r\n        });\r\n        each$b(textInlineElementsMap, (_val, name) => {\r\n          if (elements[name]) {\r\n            if (settings.padd_empty_block_inline_children) {\r\n              elements[name].paddInEmptyBlock = true;\r\n            }\r\n            elements[name].removeEmpty = true;\r\n          }\r\n        });\r\n        each$b(split$1('ol ul blockquote a table tbody'), name => {\r\n          if (elements[name]) {\r\n            elements[name].removeEmpty = true;\r\n          }\r\n        });\r\n        each$b(split$1('p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary'), name => {\r\n          if (elements[name]) {\r\n            elements[name].paddEmpty = true;\r\n          }\r\n        });\r\n        each$b(split$1('span'), name => {\r\n          elements[name].removeEmptyAttrs = true;\r\n        });\r\n      } else {\r\n        setValidElements(settings.valid_elements);\r\n        each$b(schemaItems, (element, name) => {\r\n          children[name] = element.children;\r\n        });\r\n      }\r\n      delete elements.svg;\r\n      addCustomElements(settings.custom_elements);\r\n      addValidChildren(settings.valid_children);\r\n      addValidElements(settings.extended_valid_elements);\r\n      addValidChildren('+ol[ul|ol],+ul[ul|ol]');\r\n      each$b({\r\n        dd: 'dl',\r\n        dt: 'dl',\r\n        li: 'ul ol',\r\n        td: 'tr',\r\n        th: 'tr',\r\n        tr: 'tbody thead tfoot',\r\n        tbody: 'table',\r\n        thead: 'table',\r\n        tfoot: 'table',\r\n        legend: 'fieldset',\r\n        area: 'map',\r\n        param: 'video audio object'\r\n      }, (parents, item) => {\r\n        if (elements[item]) {\r\n          elements[item].parentsRequired = split$1(parents);\r\n        }\r\n      });\r\n      if (settings.invalid_elements) {\r\n        each$b(explode$2(settings.invalid_elements), item => {\r\n          if (elements[item]) {\r\n            delete elements[item];\r\n          }\r\n        });\r\n      }\r\n      if (!getElementRule('span')) {\r\n        addValidElements('span[!data-mce-type|*]');\r\n      }\r\n      const getValidStyles = constant(validStyles);\r\n      const getInvalidStyles = constant(invalidStyles);\r\n      const getValidClasses = constant(validClasses);\r\n      const getBoolAttrs = constant(boolAttrMap);\r\n      const getBlockElements = constant(blockElementsMap);\r\n      const getTextBlockElements = constant(textBlockElementsMap);\r\n      const getTextInlineElements = constant(textInlineElementsMap);\r\n      const getVoidElements = constant(Object.seal(voidElementsMap));\r\n      const getSelfClosingElements = constant(selfClosingElementsMap);\r\n      const getNonEmptyElements = constant(nonEmptyElementsMap);\r\n      const getMoveCaretBeforeOnEnterElements = constant(moveCaretBeforeOnEnterElementsMap);\r\n      const getWhitespaceElements = constant(whitespaceElementsMap);\r\n      const getTransparentElements = constant(transparentElementsMap);\r\n      const getWrapBlockElements = constant(wrapBlockElementsMap);\r\n      const getSpecialElements = constant(Object.seal(specialElements));\r\n      const isValidChild = (name, child) => {\r\n        const parent = children[name.toLowerCase()];\r\n        return !!(parent && parent[child.toLowerCase()]);\r\n      };\r\n      const isValid = (name, attr) => {\r\n        const rule = getElementRule(name);\r\n        if (rule) {\r\n          if (attr) {\r\n            if (rule.attributes[attr]) {\r\n              return true;\r\n            }\r\n            const attrPatterns = rule.attributePatterns;\r\n            if (attrPatterns) {\r\n              let i = attrPatterns.length;\r\n              while (i--) {\r\n                if (attrPatterns[i].pattern.test(attr)) {\r\n                  return true;\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      const isBlock = name => has$2(getBlockElements(), name);\r\n      const isInline = name => !startsWith(name, '#') && isValid(name) && !isBlock(name);\r\n      const isWrapper = name => has$2(getWrapBlockElements(), name) || isInline(name);\r\n      const getCustomElements = constant(customElementsMap);\r\n      return {\r\n        type: schemaType,\r\n        children,\r\n        elements,\r\n        getValidStyles,\r\n        getValidClasses,\r\n        getBlockElements,\r\n        getInvalidStyles,\r\n        getVoidElements,\r\n        getTextBlockElements,\r\n        getTextInlineElements,\r\n        getBoolAttrs,\r\n        getElementRule,\r\n        getSelfClosingElements,\r\n        getNonEmptyElements,\r\n        getMoveCaretBeforeOnEnterElements,\r\n        getWhitespaceElements,\r\n        getTransparentElements,\r\n        getSpecialElements,\r\n        isValidChild,\r\n        isValid,\r\n        isBlock,\r\n        isInline,\r\n        isWrapper,\r\n        getCustomElements,\r\n        addValidElements,\r\n        setValidElements,\r\n        addCustomElements,\r\n        addValidChildren\r\n      };\r\n    };\r\n\r\n    const hexColour = value => ({ value: normalizeHex(value) });\r\n    const normalizeHex = hex => removeLeading(hex, '#').toUpperCase();\r\n    const toHex = component => {\r\n      const hex = component.toString(16);\r\n      return (hex.length === 1 ? '0' + hex : hex).toUpperCase();\r\n    };\r\n    const fromRgba = rgbaColour => {\r\n      const value = toHex(rgbaColour.red) + toHex(rgbaColour.green) + toHex(rgbaColour.blue);\r\n      return hexColour(value);\r\n    };\r\n\r\n    const rgbRegex = /^\\s*rgb\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)\\s*$/i;\r\n    const rgbaRegex = /^\\s*rgba\\s*\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d?(?:\\.\\d+)?)\\s*\\)\\s*$/i;\r\n    const rgbaColour = (red, green, blue, alpha) => ({\r\n      red,\r\n      green,\r\n      blue,\r\n      alpha\r\n    });\r\n    const fromStringValues = (red, green, blue, alpha) => {\r\n      const r = parseInt(red, 10);\r\n      const g = parseInt(green, 10);\r\n      const b = parseInt(blue, 10);\r\n      const a = parseFloat(alpha);\r\n      return rgbaColour(r, g, b, a);\r\n    };\r\n    const fromString = rgbaString => {\r\n      if (rgbaString === 'transparent') {\r\n        return Optional.some(rgbaColour(0, 0, 0, 0));\r\n      }\r\n      const rgbMatch = rgbRegex.exec(rgbaString);\r\n      if (rgbMatch !== null) {\r\n        return Optional.some(fromStringValues(rgbMatch[1], rgbMatch[2], rgbMatch[3], '1'));\r\n      }\r\n      const rgbaMatch = rgbaRegex.exec(rgbaString);\r\n      if (rgbaMatch !== null) {\r\n        return Optional.some(fromStringValues(rgbaMatch[1], rgbaMatch[2], rgbaMatch[3], rgbaMatch[4]));\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const toString = rgba => `rgba(${ rgba.red },${ rgba.green },${ rgba.blue },${ rgba.alpha })`;\r\n\r\n    const rgbaToHexString = color => fromString(color).map(fromRgba).map(h => '#' + h.value).getOr(color);\r\n\r\n    const Styles = (settings = {}, schema) => {\r\n      const urlOrStrRegExp = /(?:url(?:(?:\\(\\s*\\\"([^\\\"]+)\\\"\\s*\\))|(?:\\(\\s*\\'([^\\']+)\\'\\s*\\))|(?:\\(\\s*([^)\\s]+)\\s*\\))))|(?:\\'([^\\']+)\\')|(?:\\\"([^\\\"]+)\\\")/gi;\r\n      const styleRegExp = /\\s*([^:]+):\\s*([^;]+);?/g;\r\n      const trimRightRegExp = /\\s+$/;\r\n      const encodingLookup = {};\r\n      let validStyles;\r\n      let invalidStyles;\r\n      const invisibleChar = zeroWidth;\r\n      if (schema) {\r\n        validStyles = schema.getValidStyles();\r\n        invalidStyles = schema.getInvalidStyles();\r\n      }\r\n      const encodingItems = (`\\\\\" \\\\' \\\\; \\\\: ; : ` + invisibleChar).split(' ');\r\n      for (let i = 0; i < encodingItems.length; i++) {\r\n        encodingLookup[encodingItems[i]] = invisibleChar + i;\r\n        encodingLookup[invisibleChar + i] = encodingItems[i];\r\n      }\r\n      const self = {\r\n        parse: css => {\r\n          const styles = {};\r\n          let isEncoded = false;\r\n          const urlConverter = settings.url_converter;\r\n          const urlConverterScope = settings.url_converter_scope || self;\r\n          const compress = (prefix, suffix, noJoin) => {\r\n            const top = styles[prefix + '-top' + suffix];\r\n            if (!top) {\r\n              return;\r\n            }\r\n            const right = styles[prefix + '-right' + suffix];\r\n            if (!right) {\r\n              return;\r\n            }\r\n            const bottom = styles[prefix + '-bottom' + suffix];\r\n            if (!bottom) {\r\n              return;\r\n            }\r\n            const left = styles[prefix + '-left' + suffix];\r\n            if (!left) {\r\n              return;\r\n            }\r\n            const box = [\r\n              top,\r\n              right,\r\n              bottom,\r\n              left\r\n            ];\r\n            let i = box.length - 1;\r\n            while (i--) {\r\n              if (box[i] !== box[i + 1]) {\r\n                break;\r\n              }\r\n            }\r\n            if (i > -1 && noJoin) {\r\n              return;\r\n            }\r\n            styles[prefix + suffix] = i === -1 ? box[0] : box.join(' ');\r\n            delete styles[prefix + '-top' + suffix];\r\n            delete styles[prefix + '-right' + suffix];\r\n            delete styles[prefix + '-bottom' + suffix];\r\n            delete styles[prefix + '-left' + suffix];\r\n          };\r\n          const canCompress = key => {\r\n            const value = styles[key];\r\n            if (!value) {\r\n              return;\r\n            }\r\n            const values = value.indexOf(',') > -1 ? [value] : value.split(' ');\r\n            let i = values.length;\r\n            while (i--) {\r\n              if (values[i] !== values[0]) {\r\n                return false;\r\n              }\r\n            }\r\n            styles[key] = values[0];\r\n            return true;\r\n          };\r\n          const compress2 = (target, a, b, c) => {\r\n            if (!canCompress(a)) {\r\n              return;\r\n            }\r\n            if (!canCompress(b)) {\r\n              return;\r\n            }\r\n            if (!canCompress(c)) {\r\n              return;\r\n            }\r\n            styles[target] = styles[a] + ' ' + styles[b] + ' ' + styles[c];\r\n            delete styles[a];\r\n            delete styles[b];\r\n            delete styles[c];\r\n          };\r\n          const encode = str => {\r\n            isEncoded = true;\r\n            return encodingLookup[str];\r\n          };\r\n          const decode = (str, keepSlashes) => {\r\n            if (isEncoded) {\r\n              str = str.replace(/\\uFEFF[0-9]/g, str => {\r\n                return encodingLookup[str];\r\n              });\r\n            }\r\n            if (!keepSlashes) {\r\n              str = str.replace(/\\\\([\\'\\\";:])/g, '$1');\r\n            }\r\n            return str;\r\n          };\r\n          const decodeSingleHexSequence = escSeq => {\r\n            return String.fromCharCode(parseInt(escSeq.slice(1), 16));\r\n          };\r\n          const decodeHexSequences = value => {\r\n            return value.replace(/\\\\[0-9a-f]+/gi, decodeSingleHexSequence);\r\n          };\r\n          const processUrl = (match, url, url2, url3, str, str2) => {\r\n            str = str || str2;\r\n            if (str) {\r\n              str = decode(str);\r\n              return `'` + str.replace(/\\'/g, `\\\\'`) + `'`;\r\n            }\r\n            url = decode(url || url2 || url3 || '');\r\n            if (!settings.allow_script_urls) {\r\n              const scriptUrl = url.replace(/[\\s\\r\\n]+/g, '');\r\n              if (/(java|vb)script:/i.test(scriptUrl)) {\r\n                return '';\r\n              }\r\n              if (!settings.allow_svg_data_urls && /^data:image\\/svg/i.test(scriptUrl)) {\r\n                return '';\r\n              }\r\n            }\r\n            if (urlConverter) {\r\n              url = urlConverter.call(urlConverterScope, url, 'style');\r\n            }\r\n            return `url('` + url.replace(/\\'/g, `\\\\'`) + `')`;\r\n          };\r\n          if (css) {\r\n            css = css.replace(/[\\u0000-\\u001F]/g, '');\r\n            css = css.replace(/\\\\[\\\"\\';:\\uFEFF]/g, encode).replace(/\\\"[^\\\"]+\\\"|\\'[^\\']+\\'/g, str => {\r\n              return str.replace(/[;:]/g, encode);\r\n            });\r\n            let matches;\r\n            while (matches = styleRegExp.exec(css)) {\r\n              styleRegExp.lastIndex = matches.index + matches[0].length;\r\n              let name = matches[1].replace(trimRightRegExp, '').toLowerCase();\r\n              let value = matches[2].replace(trimRightRegExp, '');\r\n              if (name && value) {\r\n                name = decodeHexSequences(name);\r\n                value = decodeHexSequences(value);\r\n                if (name.indexOf(invisibleChar) !== -1 || name.indexOf('\"') !== -1) {\r\n                  continue;\r\n                }\r\n                if (!settings.allow_script_urls && (name === 'behavior' || /expression\\s*\\(|\\/\\*|\\*\\//.test(value))) {\r\n                  continue;\r\n                }\r\n                if (name === 'font-weight' && value === '700') {\r\n                  value = 'bold';\r\n                } else if (name === 'color' || name === 'background-color') {\r\n                  value = value.toLowerCase();\r\n                }\r\n                if (isString(settings.force_hex_color) && settings.force_hex_color !== 'off') {\r\n                  fromString(value).each(rgba => {\r\n                    if (settings.force_hex_color === 'always' || rgba.alpha === 1) {\r\n                      value = rgbaToHexString(toString(rgba));\r\n                    }\r\n                  });\r\n                }\r\n                value = value.replace(urlOrStrRegExp, processUrl);\r\n                styles[name] = isEncoded ? decode(value, true) : value;\r\n              }\r\n            }\r\n            compress('border', '', true);\r\n            compress('border', '-width');\r\n            compress('border', '-color');\r\n            compress('border', '-style');\r\n            compress('padding', '');\r\n            compress('margin', '');\r\n            compress2('border', 'border-width', 'border-style', 'border-color');\r\n            if (styles.border === 'medium none') {\r\n              delete styles.border;\r\n            }\r\n            if (styles['border-image'] === 'none') {\r\n              delete styles['border-image'];\r\n            }\r\n          }\r\n          return styles;\r\n        },\r\n        serialize: (styles, elementName) => {\r\n          let css = '';\r\n          const serializeStyles = (elemName, validStyleList) => {\r\n            const styleList = validStyleList[elemName];\r\n            if (styleList) {\r\n              for (let i = 0, l = styleList.length; i < l; i++) {\r\n                const name = styleList[i];\r\n                const value = styles[name];\r\n                if (value) {\r\n                  css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\r\n                }\r\n              }\r\n            }\r\n          };\r\n          const isValid = (name, elemName) => {\r\n            if (!invalidStyles || !elemName) {\r\n              return true;\r\n            }\r\n            let styleMap = invalidStyles['*'];\r\n            if (styleMap && styleMap[name]) {\r\n              return false;\r\n            }\r\n            styleMap = invalidStyles[elemName];\r\n            return !(styleMap && styleMap[name]);\r\n          };\r\n          if (elementName && validStyles) {\r\n            serializeStyles('*', validStyles);\r\n            serializeStyles(elementName, validStyles);\r\n          } else {\r\n            each$d(styles, (value, name) => {\r\n              if (value && isValid(name, elementName)) {\r\n                css += (css.length > 0 ? ' ' : '') + name + ': ' + value + ';';\r\n              }\r\n            });\r\n          }\r\n          return css;\r\n        }\r\n      };\r\n      return self;\r\n    };\r\n\r\n    const deprecated = {\r\n      keyLocation: true,\r\n      layerX: true,\r\n      layerY: true,\r\n      returnValue: true,\r\n      webkitMovementX: true,\r\n      webkitMovementY: true,\r\n      keyIdentifier: true,\r\n      mozPressure: true\r\n    };\r\n    const isNativeEvent = event => event instanceof Event || isFunction(event.initEvent);\r\n    const hasIsDefaultPrevented = event => event.isDefaultPrevented === always || event.isDefaultPrevented === never;\r\n    const needsNormalizing = event => isNullable(event.preventDefault) || isNativeEvent(event);\r\n    const clone$3 = (originalEvent, data) => {\r\n      const event = data !== null && data !== void 0 ? data : {};\r\n      for (const name in originalEvent) {\r\n        if (!has$2(deprecated, name)) {\r\n          event[name] = originalEvent[name];\r\n        }\r\n      }\r\n      if (isNonNullable(originalEvent.composedPath)) {\r\n        event.composedPath = () => originalEvent.composedPath();\r\n      }\r\n      if (isNonNullable(originalEvent.getModifierState)) {\r\n        event.getModifierState = keyArg => originalEvent.getModifierState(keyArg);\r\n      }\r\n      if (isNonNullable(originalEvent.getTargetRanges)) {\r\n        event.getTargetRanges = () => originalEvent.getTargetRanges();\r\n      }\r\n      return event;\r\n    };\r\n    const normalize$3 = (type, originalEvent, fallbackTarget, data) => {\r\n      var _a;\r\n      const event = clone$3(originalEvent, data);\r\n      event.type = type;\r\n      if (isNullable(event.target)) {\r\n        event.target = (_a = event.srcElement) !== null && _a !== void 0 ? _a : fallbackTarget;\r\n      }\r\n      if (needsNormalizing(originalEvent)) {\r\n        event.preventDefault = () => {\r\n          event.defaultPrevented = true;\r\n          event.isDefaultPrevented = always;\r\n          if (isFunction(originalEvent.preventDefault)) {\r\n            originalEvent.preventDefault();\r\n          }\r\n        };\r\n        event.stopPropagation = () => {\r\n          event.cancelBubble = true;\r\n          event.isPropagationStopped = always;\r\n          if (isFunction(originalEvent.stopPropagation)) {\r\n            originalEvent.stopPropagation();\r\n          }\r\n        };\r\n        event.stopImmediatePropagation = () => {\r\n          event.isImmediatePropagationStopped = always;\r\n          event.stopPropagation();\r\n        };\r\n        if (!hasIsDefaultPrevented(event)) {\r\n          event.isDefaultPrevented = event.defaultPrevented === true ? always : never;\r\n          event.isPropagationStopped = event.cancelBubble === true ? always : never;\r\n          event.isImmediatePropagationStopped = never;\r\n        }\r\n      }\r\n      return event;\r\n    };\r\n\r\n    const eventExpandoPrefix = 'mce-data-';\r\n    const mouseEventRe = /^(?:mouse|contextmenu)|click/;\r\n    const addEvent = (target, name, callback, capture) => {\r\n      target.addEventListener(name, callback, capture || false);\r\n    };\r\n    const removeEvent = (target, name, callback, capture) => {\r\n      target.removeEventListener(name, callback, capture || false);\r\n    };\r\n    const isMouseEvent = event => isNonNullable(event) && mouseEventRe.test(event.type);\r\n    const fix = (originalEvent, data) => {\r\n      const event = normalize$3(originalEvent.type, originalEvent, document, data);\r\n      if (isMouseEvent(originalEvent) && isUndefined(originalEvent.pageX) && !isUndefined(originalEvent.clientX)) {\r\n        const eventDoc = event.target.ownerDocument || document;\r\n        const doc = eventDoc.documentElement;\r\n        const body = eventDoc.body;\r\n        const mouseEvent = event;\r\n        mouseEvent.pageX = originalEvent.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);\r\n        mouseEvent.pageY = originalEvent.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);\r\n      }\r\n      return event;\r\n    };\r\n    const bindOnReady = (win, callback, eventUtils) => {\r\n      const doc = win.document, event = { type: 'ready' };\r\n      if (eventUtils.domLoaded) {\r\n        callback(event);\r\n        return;\r\n      }\r\n      const isDocReady = () => {\r\n        return doc.readyState === 'complete' || doc.readyState === 'interactive' && doc.body;\r\n      };\r\n      const readyHandler = () => {\r\n        removeEvent(win, 'DOMContentLoaded', readyHandler);\r\n        removeEvent(win, 'load', readyHandler);\r\n        if (!eventUtils.domLoaded) {\r\n          eventUtils.domLoaded = true;\r\n          callback(event);\r\n        }\r\n        win = null;\r\n      };\r\n      if (isDocReady()) {\r\n        readyHandler();\r\n      } else {\r\n        addEvent(win, 'DOMContentLoaded', readyHandler);\r\n      }\r\n      if (!eventUtils.domLoaded) {\r\n        addEvent(win, 'load', readyHandler);\r\n      }\r\n    };\r\n    class EventUtils {\r\n      constructor() {\r\n        this.domLoaded = false;\r\n        this.events = {};\r\n        this.count = 1;\r\n        this.expando = eventExpandoPrefix + (+new Date()).toString(32);\r\n        this.hasFocusIn = 'onfocusin' in document.documentElement;\r\n        this.count = 1;\r\n      }\r\n      bind(target, names, callback, scope) {\r\n        const self = this;\r\n        let callbackList;\r\n        const win = window;\r\n        const defaultNativeHandler = evt => {\r\n          self.executeHandlers(fix(evt || win.event), id);\r\n        };\r\n        if (!target || isText$a(target) || isComment(target)) {\r\n          return callback;\r\n        }\r\n        let id;\r\n        if (!target[self.expando]) {\r\n          id = self.count++;\r\n          target[self.expando] = id;\r\n          self.events[id] = {};\r\n        } else {\r\n          id = target[self.expando];\r\n        }\r\n        scope = scope || target;\r\n        const namesList = names.split(' ');\r\n        let i = namesList.length;\r\n        while (i--) {\r\n          let name = namesList[i];\r\n          let nativeHandler = defaultNativeHandler;\r\n          let capture = false;\r\n          let fakeName = false;\r\n          if (name === 'DOMContentLoaded') {\r\n            name = 'ready';\r\n          }\r\n          if (self.domLoaded && name === 'ready' && target.readyState === 'complete') {\r\n            callback.call(scope, fix({ type: name }));\r\n            continue;\r\n          }\r\n          if (!self.hasFocusIn && (name === 'focusin' || name === 'focusout')) {\r\n            capture = true;\r\n            fakeName = name === 'focusin' ? 'focus' : 'blur';\r\n            nativeHandler = evt => {\r\n              const event = fix(evt || win.event);\r\n              event.type = event.type === 'focus' ? 'focusin' : 'focusout';\r\n              self.executeHandlers(event, id);\r\n            };\r\n          }\r\n          callbackList = self.events[id][name];\r\n          if (!callbackList) {\r\n            self.events[id][name] = callbackList = [{\r\n                func: callback,\r\n                scope\r\n              }];\r\n            callbackList.fakeName = fakeName;\r\n            callbackList.capture = capture;\r\n            callbackList.nativeHandler = nativeHandler;\r\n            if (name === 'ready') {\r\n              bindOnReady(target, nativeHandler, self);\r\n            } else {\r\n              addEvent(target, fakeName || name, nativeHandler, capture);\r\n            }\r\n          } else {\r\n            if (name === 'ready' && self.domLoaded) {\r\n              callback(fix({ type: name }));\r\n            } else {\r\n              callbackList.push({\r\n                func: callback,\r\n                scope\r\n              });\r\n            }\r\n          }\r\n        }\r\n        target = callbackList = null;\r\n        return callback;\r\n      }\r\n      unbind(target, names, callback) {\r\n        if (!target || isText$a(target) || isComment(target)) {\r\n          return this;\r\n        }\r\n        const id = target[this.expando];\r\n        if (id) {\r\n          let eventMap = this.events[id];\r\n          if (names) {\r\n            const namesList = names.split(' ');\r\n            let i = namesList.length;\r\n            while (i--) {\r\n              const name = namesList[i];\r\n              const callbackList = eventMap[name];\r\n              if (callbackList) {\r\n                if (callback) {\r\n                  let ci = callbackList.length;\r\n                  while (ci--) {\r\n                    if (callbackList[ci].func === callback) {\r\n                      const nativeHandler = callbackList.nativeHandler;\r\n                      const fakeName = callbackList.fakeName, capture = callbackList.capture;\r\n                      const newCallbackList = callbackList.slice(0, ci).concat(callbackList.slice(ci + 1));\r\n                      newCallbackList.nativeHandler = nativeHandler;\r\n                      newCallbackList.fakeName = fakeName;\r\n                      newCallbackList.capture = capture;\r\n                      eventMap[name] = newCallbackList;\r\n                    }\r\n                  }\r\n                }\r\n                if (!callback || callbackList.length === 0) {\r\n                  delete eventMap[name];\r\n                  removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            each$d(eventMap, (callbackList, name) => {\r\n              removeEvent(target, callbackList.fakeName || name, callbackList.nativeHandler, callbackList.capture);\r\n            });\r\n            eventMap = {};\r\n          }\r\n          for (const name in eventMap) {\r\n            if (has$2(eventMap, name)) {\r\n              return this;\r\n            }\r\n          }\r\n          delete this.events[id];\r\n          try {\r\n            delete target[this.expando];\r\n          } catch (ex) {\r\n            target[this.expando] = null;\r\n          }\r\n        }\r\n        return this;\r\n      }\r\n      fire(target, name, args) {\r\n        return this.dispatch(target, name, args);\r\n      }\r\n      dispatch(target, name, args) {\r\n        if (!target || isText$a(target) || isComment(target)) {\r\n          return this;\r\n        }\r\n        const event = fix({\r\n          type: name,\r\n          target\r\n        }, args);\r\n        do {\r\n          const id = target[this.expando];\r\n          if (id) {\r\n            this.executeHandlers(event, id);\r\n          }\r\n          target = target.parentNode || target.ownerDocument || target.defaultView || target.parentWindow;\r\n        } while (target && !event.isPropagationStopped());\r\n        return this;\r\n      }\r\n      clean(target) {\r\n        if (!target || isText$a(target) || isComment(target)) {\r\n          return this;\r\n        }\r\n        if (target[this.expando]) {\r\n          this.unbind(target);\r\n        }\r\n        if (!target.getElementsByTagName) {\r\n          target = target.document;\r\n        }\r\n        if (target && target.getElementsByTagName) {\r\n          this.unbind(target);\r\n          const children = target.getElementsByTagName('*');\r\n          let i = children.length;\r\n          while (i--) {\r\n            target = children[i];\r\n            if (target[this.expando]) {\r\n              this.unbind(target);\r\n            }\r\n          }\r\n        }\r\n        return this;\r\n      }\r\n      destroy() {\r\n        this.events = {};\r\n      }\r\n      cancel(e) {\r\n        if (e) {\r\n          e.preventDefault();\r\n          e.stopImmediatePropagation();\r\n        }\r\n        return false;\r\n      }\r\n      executeHandlers(evt, id) {\r\n        const container = this.events[id];\r\n        const callbackList = container && container[evt.type];\r\n        if (callbackList) {\r\n          for (let i = 0, l = callbackList.length; i < l; i++) {\r\n            const callback = callbackList[i];\r\n            if (callback && callback.func.call(callback.scope, evt) === false) {\r\n              evt.preventDefault();\r\n            }\r\n            if (evt.isImmediatePropagationStopped()) {\r\n              return;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    EventUtils.Event = new EventUtils();\r\n\r\n    const each$a = Tools.each;\r\n    const grep = Tools.grep;\r\n    const internalStyleName = 'data-mce-style';\r\n    const numericalCssMap = Tools.makeMap('fill-opacity font-weight line-height opacity orphans widows z-index zoom', ' ');\r\n    const legacySetAttribute = (elm, name, value) => {\r\n      if (isNullable(value) || value === '') {\r\n        remove$a(elm, name);\r\n      } else {\r\n        set$3(elm, name, value);\r\n      }\r\n    };\r\n    const camelCaseToHyphens = name => name.replace(/[A-Z]/g, v => '-' + v.toLowerCase());\r\n    const findNodeIndex = (node, normalized) => {\r\n      let idx = 0;\r\n      if (node) {\r\n        for (let lastNodeType = node.nodeType, tempNode = node.previousSibling; tempNode; tempNode = tempNode.previousSibling) {\r\n          const nodeType = tempNode.nodeType;\r\n          if (normalized && isText$a(tempNode)) {\r\n            if (nodeType === lastNodeType || !tempNode.data.length) {\r\n              continue;\r\n            }\r\n          }\r\n          idx++;\r\n          lastNodeType = nodeType;\r\n        }\r\n      }\r\n      return idx;\r\n    };\r\n    const updateInternalStyleAttr = (styles, elm) => {\r\n      const rawValue = get$9(elm, 'style');\r\n      const value = styles.serialize(styles.parse(rawValue), name(elm));\r\n      legacySetAttribute(elm, internalStyleName, value);\r\n    };\r\n    const convertStyleToString = (cssValue, cssName) => {\r\n      if (isNumber(cssValue)) {\r\n        return has$2(numericalCssMap, cssName) ? cssValue + '' : cssValue + 'px';\r\n      } else {\r\n        return cssValue;\r\n      }\r\n    };\r\n    const applyStyle$1 = ($elm, cssName, cssValue) => {\r\n      const normalizedName = camelCaseToHyphens(cssName);\r\n      if (isNullable(cssValue) || cssValue === '') {\r\n        remove$6($elm, normalizedName);\r\n      } else {\r\n        set$2($elm, normalizedName, convertStyleToString(cssValue, normalizedName));\r\n      }\r\n    };\r\n    const setupAttrHooks = (styles, settings, getContext) => {\r\n      const keepValues = settings.keep_values;\r\n      const keepUrlHook = {\r\n        set: (elm, value, name) => {\r\n          const sugarElm = SugarElement.fromDom(elm);\r\n          if (isFunction(settings.url_converter) && isNonNullable(value)) {\r\n            value = settings.url_converter.call(settings.url_converter_scope || getContext(), String(value), name, elm);\r\n          }\r\n          const internalName = 'data-mce-' + name;\r\n          legacySetAttribute(sugarElm, internalName, value);\r\n          legacySetAttribute(sugarElm, name, value);\r\n        },\r\n        get: (elm, name) => {\r\n          const sugarElm = SugarElement.fromDom(elm);\r\n          return get$9(sugarElm, 'data-mce-' + name) || get$9(sugarElm, name);\r\n        }\r\n      };\r\n      const attrHooks = {\r\n        style: {\r\n          set: (elm, value) => {\r\n            const sugarElm = SugarElement.fromDom(elm);\r\n            if (keepValues) {\r\n              legacySetAttribute(sugarElm, internalStyleName, value);\r\n            }\r\n            remove$a(sugarElm, 'style');\r\n            if (isString(value)) {\r\n              setAll(sugarElm, styles.parse(value));\r\n            }\r\n          },\r\n          get: elm => {\r\n            const sugarElm = SugarElement.fromDom(elm);\r\n            const value = get$9(sugarElm, internalStyleName) || get$9(sugarElm, 'style');\r\n            return styles.serialize(styles.parse(value), name(sugarElm));\r\n          }\r\n        }\r\n      };\r\n      if (keepValues) {\r\n        attrHooks.href = attrHooks.src = keepUrlHook;\r\n      }\r\n      return attrHooks;\r\n    };\r\n    const DOMUtils = (doc, settings = {}) => {\r\n      const addedStyles = {};\r\n      const win = window;\r\n      const files = {};\r\n      let counter = 0;\r\n      const stdMode = true;\r\n      const boxModel = true;\r\n      const styleSheetLoader = instance.forElement(SugarElement.fromDom(doc), {\r\n        contentCssCors: settings.contentCssCors,\r\n        referrerPolicy: settings.referrerPolicy\r\n      });\r\n      const boundEvents = [];\r\n      const schema = settings.schema ? settings.schema : Schema({});\r\n      const styles = Styles({\r\n        url_converter: settings.url_converter,\r\n        url_converter_scope: settings.url_converter_scope,\r\n        force_hex_color: settings.force_hex_color\r\n      }, settings.schema);\r\n      const events = settings.ownEvents ? new EventUtils() : EventUtils.Event;\r\n      const blockElementsMap = schema.getBlockElements();\r\n      const isBlock = node => {\r\n        if (isString(node)) {\r\n          return has$2(blockElementsMap, node);\r\n        } else {\r\n          return isElement$6(node) && (has$2(blockElementsMap, node.nodeName) || isTransparentBlock(schema, node));\r\n        }\r\n      };\r\n      const get = elm => elm && doc && isString(elm) ? doc.getElementById(elm) : elm;\r\n      const _get = elm => {\r\n        const value = get(elm);\r\n        return isNonNullable(value) ? SugarElement.fromDom(value) : null;\r\n      };\r\n      const getAttrib = (elm, name, defaultVal = '') => {\r\n        let value;\r\n        const $elm = _get(elm);\r\n        if (isNonNullable($elm) && isElement$7($elm)) {\r\n          const hook = attrHooks[name];\r\n          if (hook && hook.get) {\r\n            value = hook.get($elm.dom, name);\r\n          } else {\r\n            value = get$9($elm, name);\r\n          }\r\n        }\r\n        return isNonNullable(value) ? value : defaultVal;\r\n      };\r\n      const getAttribs = elm => {\r\n        const node = get(elm);\r\n        return isNullable(node) ? [] : node.attributes;\r\n      };\r\n      const setAttrib = (elm, name, value) => {\r\n        run(elm, e => {\r\n          if (isElement$6(e)) {\r\n            const $elm = SugarElement.fromDom(e);\r\n            const val = value === '' ? null : value;\r\n            const originalValue = get$9($elm, name);\r\n            const hook = attrHooks[name];\r\n            if (hook && hook.set) {\r\n              hook.set($elm.dom, val, name);\r\n            } else {\r\n              legacySetAttribute($elm, name, val);\r\n            }\r\n            if (originalValue !== val && settings.onSetAttrib) {\r\n              settings.onSetAttrib({\r\n                attrElm: $elm.dom,\r\n                attrName: name,\r\n                attrValue: val\r\n              });\r\n            }\r\n          }\r\n        });\r\n      };\r\n      const clone = (node, deep) => {\r\n        return node.cloneNode(deep);\r\n      };\r\n      const getRoot = () => settings.root_element || doc.body;\r\n      const getViewPort = argWin => {\r\n        const vp = getBounds(argWin);\r\n        return {\r\n          x: vp.x,\r\n          y: vp.y,\r\n          w: vp.width,\r\n          h: vp.height\r\n        };\r\n      };\r\n      const getPos$1 = (elm, rootElm) => getPos(doc.body, get(elm), rootElm);\r\n      const setStyle = (elm, name, value) => {\r\n        run(elm, e => {\r\n          const $elm = SugarElement.fromDom(e);\r\n          applyStyle$1($elm, name, value);\r\n          if (settings.update_styles) {\r\n            updateInternalStyleAttr(styles, $elm);\r\n          }\r\n        });\r\n      };\r\n      const setStyles = (elm, stylesArg) => {\r\n        run(elm, e => {\r\n          const $elm = SugarElement.fromDom(e);\r\n          each$d(stylesArg, (v, n) => {\r\n            applyStyle$1($elm, n, v);\r\n          });\r\n          if (settings.update_styles) {\r\n            updateInternalStyleAttr(styles, $elm);\r\n          }\r\n        });\r\n      };\r\n      const getStyle = (elm, name, computed) => {\r\n        const $elm = get(elm);\r\n        if (isNullable($elm) || !isHTMLElement($elm) && !isSVGElement($elm)) {\r\n          return undefined;\r\n        }\r\n        if (computed) {\r\n          return get$7(SugarElement.fromDom($elm), camelCaseToHyphens(name));\r\n        } else {\r\n          name = name.replace(/-(\\D)/g, (a, b) => b.toUpperCase());\r\n          if (name === 'float') {\r\n            name = 'cssFloat';\r\n          }\r\n          return $elm.style ? $elm.style[name] : undefined;\r\n        }\r\n      };\r\n      const getSize = elm => {\r\n        const $elm = get(elm);\r\n        if (!$elm) {\r\n          return {\r\n            w: 0,\r\n            h: 0\r\n          };\r\n        }\r\n        let w = getStyle($elm, 'width');\r\n        let h = getStyle($elm, 'height');\r\n        if (!w || w.indexOf('px') === -1) {\r\n          w = '0';\r\n        }\r\n        if (!h || h.indexOf('px') === -1) {\r\n          h = '0';\r\n        }\r\n        return {\r\n          w: parseInt(w, 10) || $elm.offsetWidth || $elm.clientWidth,\r\n          h: parseInt(h, 10) || $elm.offsetHeight || $elm.clientHeight\r\n        };\r\n      };\r\n      const getRect = elm => {\r\n        const $elm = get(elm);\r\n        const pos = getPos$1($elm);\r\n        const size = getSize($elm);\r\n        return {\r\n          x: pos.x,\r\n          y: pos.y,\r\n          w: size.w,\r\n          h: size.h\r\n        };\r\n      };\r\n      const is = (elm, selector) => {\r\n        if (!elm) {\r\n          return false;\r\n        }\r\n        const elms = isArray$1(elm) ? elm : [elm];\r\n        return exists(elms, e => {\r\n          return is$1(SugarElement.fromDom(e), selector);\r\n        });\r\n      };\r\n      const getParents = (elm, selector, root, collect) => {\r\n        const result = [];\r\n        let node = get(elm);\r\n        collect = collect === undefined;\r\n        const resolvedRoot = root || (getRoot().nodeName !== 'BODY' ? getRoot().parentNode : null);\r\n        if (isString(selector)) {\r\n          if (selector === '*') {\r\n            selector = isElement$6;\r\n          } else {\r\n            const selectorVal = selector;\r\n            selector = node => is(node, selectorVal);\r\n          }\r\n        }\r\n        while (node) {\r\n          if (node === resolvedRoot || isNullable(node.nodeType) || isDocument$1(node) || isDocumentFragment(node)) {\r\n            break;\r\n          }\r\n          if (!selector || selector(node)) {\r\n            if (collect) {\r\n              result.push(node);\r\n            } else {\r\n              return [node];\r\n            }\r\n          }\r\n          node = node.parentNode;\r\n        }\r\n        return collect ? result : null;\r\n      };\r\n      const getParent = (node, selector, root) => {\r\n        const parents = getParents(node, selector, root, false);\r\n        return parents && parents.length > 0 ? parents[0] : null;\r\n      };\r\n      const _findSib = (node, selector, name) => {\r\n        let func = selector;\r\n        if (node) {\r\n          if (isString(selector)) {\r\n            func = node => {\r\n              return is(node, selector);\r\n            };\r\n          }\r\n          for (let tempNode = node[name]; tempNode; tempNode = tempNode[name]) {\r\n            if (isFunction(func) && func(tempNode)) {\r\n              return tempNode;\r\n            }\r\n          }\r\n        }\r\n        return null;\r\n      };\r\n      const getNext = (node, selector) => _findSib(node, selector, 'nextSibling');\r\n      const getPrev = (node, selector) => _findSib(node, selector, 'previousSibling');\r\n      const isParentNode = node => isFunction(node.querySelectorAll);\r\n      const select = (selector, scope) => {\r\n        var _a, _b;\r\n        const elm = (_b = (_a = get(scope)) !== null && _a !== void 0 ? _a : settings.root_element) !== null && _b !== void 0 ? _b : doc;\r\n        return isParentNode(elm) ? from(elm.querySelectorAll(selector)) : [];\r\n      };\r\n      const run = function (elm, func, scope) {\r\n        const context = scope !== null && scope !== void 0 ? scope : this;\r\n        if (isArray$1(elm)) {\r\n          const result = [];\r\n          each$a(elm, (e, i) => {\r\n            const node = get(e);\r\n            if (node) {\r\n              result.push(func.call(context, node, i));\r\n            }\r\n          });\r\n          return result;\r\n        } else {\r\n          const node = get(elm);\r\n          return !node ? false : func.call(context, node);\r\n        }\r\n      };\r\n      const setAttribs = (elm, attrs) => {\r\n        run(elm, $elm => {\r\n          each$d(attrs, (value, name) => {\r\n            setAttrib($elm, name, value);\r\n          });\r\n        });\r\n      };\r\n      const setHTML = (elm, html) => {\r\n        run(elm, e => {\r\n          const $elm = SugarElement.fromDom(e);\r\n          set$1($elm, html);\r\n        });\r\n      };\r\n      const add = (parentElm, name, attrs, html, create) => run(parentElm, parentElm => {\r\n        const newElm = isString(name) ? doc.createElement(name) : name;\r\n        if (isNonNullable(attrs)) {\r\n          setAttribs(newElm, attrs);\r\n        }\r\n        if (html) {\r\n          if (!isString(html) && html.nodeType) {\r\n            newElm.appendChild(html);\r\n          } else if (isString(html)) {\r\n            setHTML(newElm, html);\r\n          }\r\n        }\r\n        return !create ? parentElm.appendChild(newElm) : newElm;\r\n      });\r\n      const create = (name, attrs, html) => add(doc.createElement(name), name, attrs, html, true);\r\n      const decode = Entities.decode;\r\n      const encode = Entities.encodeAllRaw;\r\n      const createHTML = (name, attrs, html = '') => {\r\n        let outHtml = '<' + name;\r\n        for (const key in attrs) {\r\n          if (hasNonNullableKey(attrs, key)) {\r\n            outHtml += ' ' + key + '=\"' + encode(attrs[key]) + '\"';\r\n          }\r\n        }\r\n        if (isEmpty$3(html) && has$2(schema.getVoidElements(), name)) {\r\n          return outHtml + ' />';\r\n        } else {\r\n          return outHtml + '>' + html + '</' + name + '>';\r\n        }\r\n      };\r\n      const createFragment = html => {\r\n        const container = doc.createElement('div');\r\n        const frag = doc.createDocumentFragment();\r\n        frag.appendChild(container);\r\n        if (html) {\r\n          container.innerHTML = html;\r\n        }\r\n        let node;\r\n        while (node = container.firstChild) {\r\n          frag.appendChild(node);\r\n        }\r\n        frag.removeChild(container);\r\n        return frag;\r\n      };\r\n      const remove = (node, keepChildren) => {\r\n        return run(node, n => {\r\n          const $node = SugarElement.fromDom(n);\r\n          if (keepChildren) {\r\n            each$e(children$1($node), child => {\r\n              if (isText$b(child) && child.dom.length === 0) {\r\n                remove$5(child);\r\n              } else {\r\n                before$3($node, child);\r\n              }\r\n            });\r\n          }\r\n          remove$5($node);\r\n          return $node.dom;\r\n        });\r\n      };\r\n      const removeAllAttribs = e => run(e, e => {\r\n        const attrs = e.attributes;\r\n        for (let i = attrs.length - 1; i >= 0; i--) {\r\n          e.removeAttributeNode(attrs.item(i));\r\n        }\r\n      });\r\n      const parseStyle = cssText => styles.parse(cssText);\r\n      const serializeStyle = (stylesArg, name) => styles.serialize(stylesArg, name);\r\n      const addStyle = cssText => {\r\n        if (self !== DOMUtils.DOM && doc === document) {\r\n          if (addedStyles[cssText]) {\r\n            return;\r\n          }\r\n          addedStyles[cssText] = true;\r\n        }\r\n        let styleElm = doc.getElementById('mceDefaultStyles');\r\n        if (!styleElm) {\r\n          styleElm = doc.createElement('style');\r\n          styleElm.id = 'mceDefaultStyles';\r\n          styleElm.type = 'text/css';\r\n          const head = doc.head;\r\n          if (head.firstChild) {\r\n            head.insertBefore(styleElm, head.firstChild);\r\n          } else {\r\n            head.appendChild(styleElm);\r\n          }\r\n        }\r\n        if (styleElm.styleSheet) {\r\n          styleElm.styleSheet.cssText += cssText;\r\n        } else {\r\n          styleElm.appendChild(doc.createTextNode(cssText));\r\n        }\r\n      };\r\n      const loadCSS = urls => {\r\n        if (!urls) {\r\n          urls = '';\r\n        }\r\n        each$e(urls.split(','), url => {\r\n          files[url] = true;\r\n          styleSheetLoader.load(url).catch(noop);\r\n        });\r\n      };\r\n      const toggleClass = (elm, cls, state) => {\r\n        run(elm, e => {\r\n          if (isElement$6(e)) {\r\n            const $elm = SugarElement.fromDom(e);\r\n            const classes = cls.split(' ');\r\n            each$e(classes, c => {\r\n              if (isNonNullable(state)) {\r\n                const fn = state ? add$2 : remove$7;\r\n                fn($elm, c);\r\n              } else {\r\n                toggle$1($elm, c);\r\n              }\r\n            });\r\n          }\r\n        });\r\n      };\r\n      const addClass = (elm, cls) => {\r\n        toggleClass(elm, cls, true);\r\n      };\r\n      const removeClass = (elm, cls) => {\r\n        toggleClass(elm, cls, false);\r\n      };\r\n      const hasClass = (elm, cls) => {\r\n        const $elm = _get(elm);\r\n        const classes = cls.split(' ');\r\n        return isNonNullable($elm) && forall(classes, c => has($elm, c));\r\n      };\r\n      const show = elm => {\r\n        run(elm, e => remove$6(SugarElement.fromDom(e), 'display'));\r\n      };\r\n      const hide = elm => {\r\n        run(elm, e => set$2(SugarElement.fromDom(e), 'display', 'none'));\r\n      };\r\n      const isHidden = elm => {\r\n        const $elm = _get(elm);\r\n        return isNonNullable($elm) && is$2(getRaw($elm, 'display'), 'none');\r\n      };\r\n      const uniqueId = prefix => (!prefix ? 'mce_' : prefix) + counter++;\r\n      const getOuterHTML = elm => {\r\n        const $elm = _get(elm);\r\n        if (isNonNullable($elm)) {\r\n          return isElement$6($elm.dom) ? $elm.dom.outerHTML : getOuter($elm);\r\n        } else {\r\n          return '';\r\n        }\r\n      };\r\n      const setOuterHTML = (elm, html) => {\r\n        run(elm, $elm => {\r\n          if (isElement$6($elm)) {\r\n            $elm.outerHTML = html;\r\n          }\r\n        });\r\n      };\r\n      const insertAfter = (node, reference) => {\r\n        const referenceNode = get(reference);\r\n        return run(node, node => {\r\n          const parent = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.parentNode;\r\n          const nextSibling = referenceNode === null || referenceNode === void 0 ? void 0 : referenceNode.nextSibling;\r\n          if (parent) {\r\n            if (nextSibling) {\r\n              parent.insertBefore(node, nextSibling);\r\n            } else {\r\n              parent.appendChild(node);\r\n            }\r\n          }\r\n          return node;\r\n        });\r\n      };\r\n      const replace = (newElm, oldElm, keepChildren) => run(oldElm, elm => {\r\n        var _a;\r\n        const replacee = isArray$1(oldElm) ? newElm.cloneNode(true) : newElm;\r\n        if (keepChildren) {\r\n          each$a(grep(elm.childNodes), node => {\r\n            replacee.appendChild(node);\r\n          });\r\n        }\r\n        (_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(replacee, elm);\r\n        return elm;\r\n      });\r\n      const rename = (elm, name) => {\r\n        if (elm.nodeName !== name.toUpperCase()) {\r\n          const newElm = create(name);\r\n          each$a(getAttribs(elm), attrNode => {\r\n            setAttrib(newElm, attrNode.nodeName, getAttrib(elm, attrNode.nodeName));\r\n          });\r\n          replace(newElm, elm, true);\r\n          return newElm;\r\n        } else {\r\n          return elm;\r\n        }\r\n      };\r\n      const findCommonAncestor = (a, b) => {\r\n        let ps = a;\r\n        while (ps) {\r\n          let pe = b;\r\n          while (pe && ps !== pe) {\r\n            pe = pe.parentNode;\r\n          }\r\n          if (ps === pe) {\r\n            break;\r\n          }\r\n          ps = ps.parentNode;\r\n        }\r\n        if (!ps && a.ownerDocument) {\r\n          return a.ownerDocument.documentElement;\r\n        } else {\r\n          return ps;\r\n        }\r\n      };\r\n      const isNonEmptyElement = node => {\r\n        if (isElement$6(node)) {\r\n          const isNamedAnchor = node.nodeName.toLowerCase() === 'a' && !getAttrib(node, 'href') && getAttrib(node, 'id');\r\n          if (getAttrib(node, 'name') || getAttrib(node, 'data-mce-bookmark') || isNamedAnchor) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      const isEmpty = (node, elements, options) => {\r\n        let brCount = 0;\r\n        if (isNonEmptyElement(node)) {\r\n          return false;\r\n        }\r\n        const firstChild = node.firstChild;\r\n        if (firstChild) {\r\n          const walker = new DomTreeWalker(firstChild, node);\r\n          const whitespaceElements = schema ? schema.getWhitespaceElements() : {};\r\n          const nonEmptyElements = elements || (schema ? schema.getNonEmptyElements() : null);\r\n          let tempNode = firstChild;\r\n          do {\r\n            if (isElement$6(tempNode)) {\r\n              const bogusVal = tempNode.getAttribute('data-mce-bogus');\r\n              if (bogusVal) {\r\n                tempNode = walker.next(bogusVal === 'all');\r\n                continue;\r\n              }\r\n              const name = tempNode.nodeName.toLowerCase();\r\n              if (nonEmptyElements && nonEmptyElements[name]) {\r\n                if (name === 'br') {\r\n                  brCount++;\r\n                  tempNode = walker.next();\r\n                  continue;\r\n                }\r\n                return false;\r\n              }\r\n              if (isNonEmptyElement(tempNode)) {\r\n                return false;\r\n              }\r\n            }\r\n            if (isComment(tempNode)) {\r\n              return false;\r\n            }\r\n            if (isText$a(tempNode) && !isWhitespaceText(tempNode.data) && (!(options === null || options === void 0 ? void 0 : options.includeZwsp) || !isZwsp(tempNode.data))) {\r\n              return false;\r\n            }\r\n            if (isText$a(tempNode) && tempNode.parentNode && whitespaceElements[tempNode.parentNode.nodeName] && isWhitespaceText(tempNode.data)) {\r\n              return false;\r\n            }\r\n            tempNode = walker.next();\r\n          } while (tempNode);\r\n        }\r\n        return brCount <= 1;\r\n      };\r\n      const createRng = () => doc.createRange();\r\n      const split = (parentElm, splitElm, replacementElm) => {\r\n        let range = createRng();\r\n        let beforeFragment;\r\n        let afterFragment;\r\n        if (parentElm && splitElm && parentElm.parentNode && splitElm.parentNode) {\r\n          const parentNode = parentElm.parentNode;\r\n          range.setStart(parentNode, findNodeIndex(parentElm));\r\n          range.setEnd(splitElm.parentNode, findNodeIndex(splitElm));\r\n          beforeFragment = range.extractContents();\r\n          range = createRng();\r\n          range.setStart(splitElm.parentNode, findNodeIndex(splitElm) + 1);\r\n          range.setEnd(parentNode, findNodeIndex(parentElm) + 1);\r\n          afterFragment = range.extractContents();\r\n          parentNode.insertBefore(trimNode(self, beforeFragment, schema), parentElm);\r\n          if (replacementElm) {\r\n            parentNode.insertBefore(replacementElm, parentElm);\r\n          } else {\r\n            parentNode.insertBefore(splitElm, parentElm);\r\n          }\r\n          parentNode.insertBefore(trimNode(self, afterFragment, schema), parentElm);\r\n          remove(parentElm);\r\n          return replacementElm || splitElm;\r\n        } else {\r\n          return undefined;\r\n        }\r\n      };\r\n      const bind = (target, name, func, scope) => {\r\n        if (isArray$1(target)) {\r\n          let i = target.length;\r\n          const rv = [];\r\n          while (i--) {\r\n            rv[i] = bind(target[i], name, func, scope);\r\n          }\r\n          return rv;\r\n        } else {\r\n          if (settings.collect && (target === doc || target === win)) {\r\n            boundEvents.push([\r\n              target,\r\n              name,\r\n              func,\r\n              scope\r\n            ]);\r\n          }\r\n          return events.bind(target, name, func, scope || self);\r\n        }\r\n      };\r\n      const unbind = (target, name, func) => {\r\n        if (isArray$1(target)) {\r\n          let i = target.length;\r\n          const rv = [];\r\n          while (i--) {\r\n            rv[i] = unbind(target[i], name, func);\r\n          }\r\n          return rv;\r\n        } else {\r\n          if (boundEvents.length > 0 && (target === doc || target === win)) {\r\n            let i = boundEvents.length;\r\n            while (i--) {\r\n              const [boundTarget, boundName, boundFunc] = boundEvents[i];\r\n              if (target === boundTarget && (!name || name === boundName) && (!func || func === boundFunc)) {\r\n                events.unbind(boundTarget, boundName, boundFunc);\r\n              }\r\n            }\r\n          }\r\n          return events.unbind(target, name, func);\r\n        }\r\n      };\r\n      const dispatch = (target, name, evt) => events.dispatch(target, name, evt);\r\n      const fire = (target, name, evt) => events.dispatch(target, name, evt);\r\n      const getContentEditable = node => {\r\n        if (node && isHTMLElement(node)) {\r\n          const contentEditable = node.getAttribute('data-mce-contenteditable');\r\n          if (contentEditable && contentEditable !== 'inherit') {\r\n            return contentEditable;\r\n          }\r\n          return node.contentEditable !== 'inherit' ? node.contentEditable : null;\r\n        } else {\r\n          return null;\r\n        }\r\n      };\r\n      const getContentEditableParent = node => {\r\n        const root = getRoot();\r\n        let state = null;\r\n        for (let tempNode = node; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\r\n          state = getContentEditable(tempNode);\r\n          if (state !== null) {\r\n            break;\r\n          }\r\n        }\r\n        return state;\r\n      };\r\n      const isEditable = node => {\r\n        if (isNonNullable(node)) {\r\n          const scope = isElement$6(node) ? node : node.parentElement;\r\n          return isNonNullable(scope) && isHTMLElement(scope) && isEditable$2(SugarElement.fromDom(scope));\r\n        } else {\r\n          return false;\r\n        }\r\n      };\r\n      const destroy = () => {\r\n        if (boundEvents.length > 0) {\r\n          let i = boundEvents.length;\r\n          while (i--) {\r\n            const [boundTarget, boundName, boundFunc] = boundEvents[i];\r\n            events.unbind(boundTarget, boundName, boundFunc);\r\n          }\r\n        }\r\n        each$d(files, (_, url) => {\r\n          styleSheetLoader.unload(url);\r\n          delete files[url];\r\n        });\r\n      };\r\n      const isChildOf = (node, parent) => {\r\n        return node === parent || parent.contains(node);\r\n      };\r\n      const dumpRng = r => 'startContainer: ' + r.startContainer.nodeName + ', startOffset: ' + r.startOffset + ', endContainer: ' + r.endContainer.nodeName + ', endOffset: ' + r.endOffset;\r\n      const self = {\r\n        doc,\r\n        settings,\r\n        win,\r\n        files,\r\n        stdMode,\r\n        boxModel,\r\n        styleSheetLoader,\r\n        boundEvents,\r\n        styles,\r\n        schema,\r\n        events,\r\n        isBlock: isBlock,\r\n        root: null,\r\n        clone,\r\n        getRoot,\r\n        getViewPort,\r\n        getRect,\r\n        getSize,\r\n        getParent,\r\n        getParents: getParents,\r\n        get,\r\n        getNext,\r\n        getPrev,\r\n        select,\r\n        is,\r\n        add,\r\n        create,\r\n        createHTML,\r\n        createFragment,\r\n        remove,\r\n        setStyle,\r\n        getStyle: getStyle,\r\n        setStyles,\r\n        removeAllAttribs,\r\n        setAttrib,\r\n        setAttribs,\r\n        getAttrib,\r\n        getPos: getPos$1,\r\n        parseStyle,\r\n        serializeStyle,\r\n        addStyle,\r\n        loadCSS,\r\n        addClass,\r\n        removeClass,\r\n        hasClass,\r\n        toggleClass,\r\n        show,\r\n        hide,\r\n        isHidden,\r\n        uniqueId,\r\n        setHTML,\r\n        getOuterHTML,\r\n        setOuterHTML,\r\n        decode,\r\n        encode,\r\n        insertAfter,\r\n        replace,\r\n        rename,\r\n        findCommonAncestor,\r\n        run,\r\n        getAttribs,\r\n        isEmpty,\r\n        createRng,\r\n        nodeIndex: findNodeIndex,\r\n        split,\r\n        bind: bind,\r\n        unbind: unbind,\r\n        fire,\r\n        dispatch,\r\n        getContentEditable,\r\n        getContentEditableParent,\r\n        isEditable,\r\n        destroy,\r\n        isChildOf,\r\n        dumpRng\r\n      };\r\n      const attrHooks = setupAttrHooks(styles, settings, constant(self));\r\n      return self;\r\n    };\r\n    DOMUtils.DOM = DOMUtils(document);\r\n    DOMUtils.nodeIndex = findNodeIndex;\r\n\r\n    const DOM$b = DOMUtils.DOM;\r\n    const QUEUED = 0;\r\n    const LOADING = 1;\r\n    const LOADED = 2;\r\n    const FAILED = 3;\r\n    class ScriptLoader {\r\n      constructor(settings = {}) {\r\n        this.states = {};\r\n        this.queue = [];\r\n        this.scriptLoadedCallbacks = {};\r\n        this.queueLoadedCallbacks = [];\r\n        this.loading = false;\r\n        this.settings = settings;\r\n      }\r\n      _setReferrerPolicy(referrerPolicy) {\r\n        this.settings.referrerPolicy = referrerPolicy;\r\n      }\r\n      loadScript(url) {\r\n        return new Promise((resolve, reject) => {\r\n          const dom = DOM$b;\r\n          let elm;\r\n          const cleanup = () => {\r\n            dom.remove(id);\r\n            if (elm) {\r\n              elm.onerror = elm.onload = elm = null;\r\n            }\r\n          };\r\n          const done = () => {\r\n            cleanup();\r\n            resolve();\r\n          };\r\n          const error = () => {\r\n            cleanup();\r\n            reject('Failed to load script: ' + url);\r\n          };\r\n          const id = dom.uniqueId();\r\n          elm = document.createElement('script');\r\n          elm.id = id;\r\n          elm.type = 'text/javascript';\r\n          elm.src = Tools._addCacheSuffix(url);\r\n          if (this.settings.referrerPolicy) {\r\n            dom.setAttrib(elm, 'referrerpolicy', this.settings.referrerPolicy);\r\n          }\r\n          elm.onload = done;\r\n          elm.onerror = error;\r\n          (document.getElementsByTagName('head')[0] || document.body).appendChild(elm);\r\n        });\r\n      }\r\n      isDone(url) {\r\n        return this.states[url] === LOADED;\r\n      }\r\n      markDone(url) {\r\n        this.states[url] = LOADED;\r\n      }\r\n      add(url) {\r\n        const self = this;\r\n        self.queue.push(url);\r\n        const state = self.states[url];\r\n        if (state === undefined) {\r\n          self.states[url] = QUEUED;\r\n        }\r\n        return new Promise((resolve, reject) => {\r\n          if (!self.scriptLoadedCallbacks[url]) {\r\n            self.scriptLoadedCallbacks[url] = [];\r\n          }\r\n          self.scriptLoadedCallbacks[url].push({\r\n            resolve,\r\n            reject\r\n          });\r\n        });\r\n      }\r\n      load(url) {\r\n        return this.add(url);\r\n      }\r\n      remove(url) {\r\n        delete this.states[url];\r\n        delete this.scriptLoadedCallbacks[url];\r\n      }\r\n      loadQueue() {\r\n        const queue = this.queue;\r\n        this.queue = [];\r\n        return this.loadScripts(queue);\r\n      }\r\n      loadScripts(scripts) {\r\n        const self = this;\r\n        const execCallbacks = (name, url) => {\r\n          get$a(self.scriptLoadedCallbacks, url).each(callbacks => {\r\n            each$e(callbacks, callback => callback[name](url));\r\n          });\r\n          delete self.scriptLoadedCallbacks[url];\r\n        };\r\n        const processResults = results => {\r\n          const failures = filter$5(results, result => result.status === 'rejected');\r\n          if (failures.length > 0) {\r\n            return Promise.reject(bind$3(failures, ({reason}) => isArray$1(reason) ? reason : [reason]));\r\n          } else {\r\n            return Promise.resolve();\r\n          }\r\n        };\r\n        const load = urls => Promise.allSettled(map$3(urls, url => {\r\n          if (self.states[url] === LOADED) {\r\n            execCallbacks('resolve', url);\r\n            return Promise.resolve();\r\n          } else if (self.states[url] === FAILED) {\r\n            execCallbacks('reject', url);\r\n            return Promise.reject(url);\r\n          } else {\r\n            self.states[url] = LOADING;\r\n            return self.loadScript(url).then(() => {\r\n              self.states[url] = LOADED;\r\n              execCallbacks('resolve', url);\r\n              const queue = self.queue;\r\n              if (queue.length > 0) {\r\n                self.queue = [];\r\n                return load(queue).then(processResults);\r\n              } else {\r\n                return Promise.resolve();\r\n              }\r\n            }, () => {\r\n              self.states[url] = FAILED;\r\n              execCallbacks('reject', url);\r\n              return Promise.reject(url);\r\n            });\r\n          }\r\n        }));\r\n        const processQueue = urls => {\r\n          self.loading = true;\r\n          return load(urls).then(results => {\r\n            self.loading = false;\r\n            const nextQueuedItem = self.queueLoadedCallbacks.shift();\r\n            Optional.from(nextQueuedItem).each(call);\r\n            return processResults(results);\r\n          });\r\n        };\r\n        const uniqueScripts = stringArray(scripts);\r\n        if (self.loading) {\r\n          return new Promise((resolve, reject) => {\r\n            self.queueLoadedCallbacks.push(() => {\r\n              processQueue(uniqueScripts).then(resolve, reject);\r\n            });\r\n          });\r\n        } else {\r\n          return processQueue(uniqueScripts);\r\n        }\r\n      }\r\n    }\r\n    ScriptLoader.ScriptLoader = new ScriptLoader();\r\n\r\n    const Cell = initial => {\r\n      let value = initial;\r\n      const get = () => {\r\n        return value;\r\n      };\r\n      const set = v => {\r\n        value = v;\r\n      };\r\n      return {\r\n        get,\r\n        set\r\n      };\r\n    };\r\n\r\n    const isDuplicated = (items, item) => {\r\n      const firstIndex = items.indexOf(item);\r\n      return firstIndex !== -1 && items.indexOf(item, firstIndex + 1) > firstIndex;\r\n    };\r\n    const isRaw = str => isObject(str) && has$2(str, 'raw');\r\n    const isTokenised = str => isArray$1(str) && str.length > 1;\r\n    const data = {};\r\n    const currentCode = Cell('en');\r\n    const getLanguageData = () => get$a(data, currentCode.get());\r\n    const getData$1 = () => map$2(data, value => ({ ...value }));\r\n    const setCode = newCode => {\r\n      if (newCode) {\r\n        currentCode.set(newCode);\r\n      }\r\n    };\r\n    const getCode = () => currentCode.get();\r\n    const add$1 = (code, items) => {\r\n      let langData = data[code];\r\n      if (!langData) {\r\n        data[code] = langData = {};\r\n      }\r\n      const lcNames = map$3(keys(items), name => name.toLowerCase());\r\n      each$d(items, (translation, name) => {\r\n        const lcName = name.toLowerCase();\r\n        if (lcName !== name && isDuplicated(lcNames, lcName)) {\r\n          if (!has$2(items, lcName)) {\r\n            langData[lcName] = translation;\r\n          }\r\n          langData[name] = translation;\r\n        } else {\r\n          langData[lcName] = translation;\r\n        }\r\n      });\r\n    };\r\n    const translate = text => {\r\n      const langData = getLanguageData().getOr({});\r\n      const toString = obj => {\r\n        if (isFunction(obj)) {\r\n          return Object.prototype.toString.call(obj);\r\n        }\r\n        return !isEmpty(obj) ? '' + obj : '';\r\n      };\r\n      const isEmpty = text => text === '' || text === null || text === undefined;\r\n      const getLangData = text => {\r\n        const textStr = toString(text);\r\n        return has$2(langData, textStr) ? toString(langData[textStr]) : get$a(langData, textStr.toLowerCase()).map(toString).getOr(textStr);\r\n      };\r\n      const removeContext = str => str.replace(/{context:\\w+}$/, '');\r\n      if (isEmpty(text)) {\r\n        return '';\r\n      }\r\n      if (isRaw(text)) {\r\n        return toString(text.raw);\r\n      }\r\n      if (isTokenised(text)) {\r\n        const values = text.slice(1);\r\n        const substitued = getLangData(text[0]).replace(/\\{([0-9]+)\\}/g, ($1, $2) => has$2(values, $2) ? toString(values[$2]) : $1);\r\n        return removeContext(substitued);\r\n      }\r\n      return removeContext(getLangData(text));\r\n    };\r\n    const isRtl$1 = () => getLanguageData().bind(items => get$a(items, '_dir')).exists(dir => dir === 'rtl');\r\n    const hasCode = code => has$2(data, code);\r\n    const I18n = {\r\n      getData: getData$1,\r\n      setCode,\r\n      getCode,\r\n      add: add$1,\r\n      translate,\r\n      isRtl: isRtl$1,\r\n      hasCode\r\n    };\r\n\r\n    const AddOnManager = () => {\r\n      const items = [];\r\n      const urls = {};\r\n      const lookup = {};\r\n      const _listeners = [];\r\n      const runListeners = (name, state) => {\r\n        const matchedListeners = filter$5(_listeners, listener => listener.name === name && listener.state === state);\r\n        each$e(matchedListeners, listener => listener.resolve());\r\n      };\r\n      const isLoaded = name => has$2(urls, name);\r\n      const isAdded = name => has$2(lookup, name);\r\n      const get = name => {\r\n        if (lookup[name]) {\r\n          return lookup[name].instance;\r\n        }\r\n        return undefined;\r\n      };\r\n      const loadLanguagePack = (name, languages) => {\r\n        const language = I18n.getCode();\r\n        const wrappedLanguages = ',' + (languages || '') + ',';\r\n        if (!language || languages && wrappedLanguages.indexOf(',' + language + ',') === -1) {\r\n          return;\r\n        }\r\n        ScriptLoader.ScriptLoader.add(urls[name] + '/langs/' + language + '.js');\r\n      };\r\n      const requireLangPack = (name, languages) => {\r\n        if (AddOnManager.languageLoad !== false) {\r\n          if (isLoaded(name)) {\r\n            loadLanguagePack(name, languages);\r\n          } else {\r\n            waitFor(name, 'loaded').then(() => loadLanguagePack(name, languages));\r\n          }\r\n        }\r\n      };\r\n      const add = (id, addOn) => {\r\n        items.push(addOn);\r\n        lookup[id] = { instance: addOn };\r\n        runListeners(id, 'added');\r\n        return addOn;\r\n      };\r\n      const remove = name => {\r\n        delete urls[name];\r\n        delete lookup[name];\r\n      };\r\n      const createUrl = (baseUrl, dep) => {\r\n        if (isString(dep)) {\r\n          return isString(baseUrl) ? {\r\n            prefix: '',\r\n            resource: dep,\r\n            suffix: ''\r\n          } : {\r\n            prefix: baseUrl.prefix,\r\n            resource: dep,\r\n            suffix: baseUrl.suffix\r\n          };\r\n        } else {\r\n          return dep;\r\n        }\r\n      };\r\n      const load = (name, addOnUrl) => {\r\n        if (urls[name]) {\r\n          return Promise.resolve();\r\n        }\r\n        let urlString = isString(addOnUrl) ? addOnUrl : addOnUrl.prefix + addOnUrl.resource + addOnUrl.suffix;\r\n        if (urlString.indexOf('/') !== 0 && urlString.indexOf('://') === -1) {\r\n          urlString = AddOnManager.baseURL + '/' + urlString;\r\n        }\r\n        urls[name] = urlString.substring(0, urlString.lastIndexOf('/'));\r\n        const done = () => {\r\n          runListeners(name, 'loaded');\r\n          return Promise.resolve();\r\n        };\r\n        if (lookup[name]) {\r\n          return done();\r\n        } else {\r\n          return ScriptLoader.ScriptLoader.add(urlString).then(done);\r\n        }\r\n      };\r\n      const waitFor = (name, state = 'added') => {\r\n        if (state === 'added' && isAdded(name)) {\r\n          return Promise.resolve();\r\n        } else if (state === 'loaded' && isLoaded(name)) {\r\n          return Promise.resolve();\r\n        } else {\r\n          return new Promise(resolve => {\r\n            _listeners.push({\r\n              name,\r\n              state,\r\n              resolve\r\n            });\r\n          });\r\n        }\r\n      };\r\n      return {\r\n        items,\r\n        urls,\r\n        lookup,\r\n        get,\r\n        requireLangPack,\r\n        add,\r\n        remove,\r\n        createUrl,\r\n        load,\r\n        waitFor\r\n      };\r\n    };\r\n    AddOnManager.languageLoad = true;\r\n    AddOnManager.baseURL = '';\r\n    AddOnManager.PluginManager = AddOnManager();\r\n    AddOnManager.ThemeManager = AddOnManager();\r\n    AddOnManager.ModelManager = AddOnManager();\r\n\r\n    const singleton = doRevoke => {\r\n      const subject = Cell(Optional.none());\r\n      const revoke = () => subject.get().each(doRevoke);\r\n      const clear = () => {\r\n        revoke();\r\n        subject.set(Optional.none());\r\n      };\r\n      const isSet = () => subject.get().isSome();\r\n      const get = () => subject.get();\r\n      const set = s => {\r\n        revoke();\r\n        subject.set(Optional.some(s));\r\n      };\r\n      return {\r\n        clear,\r\n        isSet,\r\n        get,\r\n        set\r\n      };\r\n    };\r\n    const repeatable = delay => {\r\n      const intervalId = Cell(Optional.none());\r\n      const revoke = () => intervalId.get().each(id => clearInterval(id));\r\n      const clear = () => {\r\n        revoke();\r\n        intervalId.set(Optional.none());\r\n      };\r\n      const isSet = () => intervalId.get().isSome();\r\n      const get = () => intervalId.get();\r\n      const set = functionToRepeat => {\r\n        revoke();\r\n        intervalId.set(Optional.some(setInterval(functionToRepeat, delay)));\r\n      };\r\n      return {\r\n        clear,\r\n        isSet,\r\n        get,\r\n        set\r\n      };\r\n    };\r\n    const value$2 = () => {\r\n      const subject = singleton(noop);\r\n      const on = f => subject.get().each(f);\r\n      return {\r\n        ...subject,\r\n        on\r\n      };\r\n    };\r\n\r\n    const first$1 = (fn, rate) => {\r\n      let timer = null;\r\n      const cancel = () => {\r\n        if (!isNull(timer)) {\r\n          clearTimeout(timer);\r\n          timer = null;\r\n        }\r\n      };\r\n      const throttle = (...args) => {\r\n        if (isNull(timer)) {\r\n          timer = setTimeout(() => {\r\n            timer = null;\r\n            fn.apply(null, args);\r\n          }, rate);\r\n        }\r\n      };\r\n      return {\r\n        cancel,\r\n        throttle\r\n      };\r\n    };\r\n    const last$1 = (fn, rate) => {\r\n      let timer = null;\r\n      const cancel = () => {\r\n        if (!isNull(timer)) {\r\n          clearTimeout(timer);\r\n          timer = null;\r\n        }\r\n      };\r\n      const throttle = (...args) => {\r\n        cancel();\r\n        timer = setTimeout(() => {\r\n          timer = null;\r\n          fn.apply(null, args);\r\n        }, rate);\r\n      };\r\n      return {\r\n        cancel,\r\n        throttle\r\n      };\r\n    };\r\n\r\n    const annotation = constant('mce-annotation');\r\n    const dataAnnotation = constant('data-mce-annotation');\r\n    const dataAnnotationId = constant('data-mce-annotation-uid');\r\n    const dataAnnotationActive = constant('data-mce-annotation-active');\r\n    const dataAnnotationClasses = constant('data-mce-annotation-classes');\r\n    const dataAnnotationAttributes = constant('data-mce-annotation-attrs');\r\n\r\n    const isRoot$1 = root => node => eq(node, root);\r\n    const identify = (editor, annotationName) => {\r\n      const rng = editor.selection.getRng();\r\n      const start = SugarElement.fromDom(rng.startContainer);\r\n      const root = SugarElement.fromDom(editor.getBody());\r\n      const selector = annotationName.fold(() => '.' + annotation(), an => `[${ dataAnnotation() }=\"${ an }\"]`);\r\n      const newStart = child$1(start, rng.startOffset).getOr(start);\r\n      const closest = closest$3(newStart, selector, isRoot$1(root));\r\n      return closest.bind(c => getOpt(c, `${ dataAnnotationId() }`).bind(uid => getOpt(c, `${ dataAnnotation() }`).map(name => {\r\n        const elements = findMarkers(editor, uid);\r\n        return {\r\n          uid,\r\n          name,\r\n          elements\r\n        };\r\n      })));\r\n    };\r\n    const isAnnotation = elem => isElement$7(elem) && has(elem, annotation());\r\n    const isBogusElement = (elem, root) => has$1(elem, 'data-mce-bogus') || ancestor$2(elem, '[data-mce-bogus=\"all\"]', isRoot$1(root));\r\n    const findMarkers = (editor, uid) => {\r\n      const body = SugarElement.fromDom(editor.getBody());\r\n      const descendants$1 = descendants(body, `[${ dataAnnotationId() }=\"${ uid }\"]`);\r\n      return filter$5(descendants$1, descendant => !isBogusElement(descendant, body));\r\n    };\r\n    const findAll = (editor, name) => {\r\n      const body = SugarElement.fromDom(editor.getBody());\r\n      const markers = descendants(body, `[${ dataAnnotation() }=\"${ name }\"]`);\r\n      const directory = {};\r\n      each$e(markers, m => {\r\n        if (!isBogusElement(m, body)) {\r\n          const uid = get$9(m, dataAnnotationId());\r\n          const nodesAlready = get$a(directory, uid).getOr([]);\r\n          directory[uid] = nodesAlready.concat([m]);\r\n        }\r\n      });\r\n      return directory;\r\n    };\r\n\r\n    const setup$y = (editor, registry) => {\r\n      const changeCallbacks = Cell({});\r\n      const initData = () => ({\r\n        listeners: [],\r\n        previous: value$2()\r\n      });\r\n      const withCallbacks = (name, f) => {\r\n        updateCallbacks(name, data => {\r\n          f(data);\r\n          return data;\r\n        });\r\n      };\r\n      const updateCallbacks = (name, f) => {\r\n        const callbackMap = changeCallbacks.get();\r\n        const data = get$a(callbackMap, name).getOrThunk(initData);\r\n        const outputData = f(data);\r\n        callbackMap[name] = outputData;\r\n        changeCallbacks.set(callbackMap);\r\n      };\r\n      const fireCallbacks = (name, uid, elements) => {\r\n        withCallbacks(name, data => {\r\n          each$e(data.listeners, f => f(true, name, {\r\n            uid,\r\n            nodes: map$3(elements, elem => elem.dom)\r\n          }));\r\n        });\r\n      };\r\n      const fireNoAnnotation = name => {\r\n        withCallbacks(name, data => {\r\n          each$e(data.listeners, f => f(false, name));\r\n        });\r\n      };\r\n      const toggleActiveAttr = (uid, state) => {\r\n        each$e(findMarkers(editor, uid), elem => {\r\n          if (state) {\r\n            set$3(elem, dataAnnotationActive(), 'true');\r\n          } else {\r\n            remove$a(elem, dataAnnotationActive());\r\n          }\r\n        });\r\n      };\r\n      const onNodeChange = last$1(() => {\r\n        const annotations = sort(registry.getNames());\r\n        each$e(annotations, name => {\r\n          updateCallbacks(name, data => {\r\n            const prev = data.previous.get();\r\n            identify(editor, Optional.some(name)).fold(() => {\r\n              prev.each(uid => {\r\n                fireNoAnnotation(name);\r\n                data.previous.clear();\r\n                toggleActiveAttr(uid, false);\r\n              });\r\n            }, ({uid, name, elements}) => {\r\n              if (!is$2(prev, uid)) {\r\n                prev.each(uid => toggleActiveAttr(uid, false));\r\n                fireCallbacks(name, uid, elements);\r\n                data.previous.set(uid);\r\n                toggleActiveAttr(uid, true);\r\n              }\r\n            });\r\n            return {\r\n              previous: data.previous,\r\n              listeners: data.listeners\r\n            };\r\n          });\r\n        });\r\n      }, 30);\r\n      editor.on('remove', () => {\r\n        onNodeChange.cancel();\r\n      });\r\n      editor.on('NodeChange', () => {\r\n        onNodeChange.throttle();\r\n      });\r\n      const addListener = (name, f) => {\r\n        updateCallbacks(name, data => ({\r\n          previous: data.previous,\r\n          listeners: data.listeners.concat([f])\r\n        }));\r\n      };\r\n      return { addListener };\r\n    };\r\n\r\n    const setup$x = (editor, registry) => {\r\n      const dataAnnotation$1 = dataAnnotation();\r\n      const identifyParserNode = node => Optional.from(node.attr(dataAnnotation$1)).bind(registry.lookup);\r\n      const removeDirectAnnotation = node => {\r\n        var _a, _b;\r\n        node.attr(dataAnnotationId(), null);\r\n        node.attr(dataAnnotation(), null);\r\n        node.attr(dataAnnotationActive(), null);\r\n        const customAttrNames = Optional.from(node.attr(dataAnnotationAttributes())).map(names => names.split(',')).getOr([]);\r\n        const customClasses = Optional.from(node.attr(dataAnnotationClasses())).map(names => names.split(',')).getOr([]);\r\n        each$e(customAttrNames, name => node.attr(name, null));\r\n        const classList = (_b = (_a = node.attr('class')) === null || _a === void 0 ? void 0 : _a.split(' ')) !== null && _b !== void 0 ? _b : [];\r\n        const newClassList = difference(classList, [annotation()].concat(customClasses));\r\n        node.attr('class', newClassList.length > 0 ? newClassList.join(' ') : null);\r\n        node.attr(dataAnnotationClasses(), null);\r\n        node.attr(dataAnnotationAttributes(), null);\r\n      };\r\n      editor.serializer.addTempAttr(dataAnnotationActive());\r\n      editor.serializer.addAttributeFilter(dataAnnotation$1, nodes => {\r\n        for (const node of nodes) {\r\n          identifyParserNode(node).each(settings => {\r\n            if (settings.persistent === false) {\r\n              if (node.name === 'span') {\r\n                node.unwrap();\r\n              } else {\r\n                removeDirectAnnotation(node);\r\n              }\r\n            }\r\n          });\r\n        }\r\n      });\r\n    };\r\n\r\n    const create$c = () => {\r\n      const annotations = {};\r\n      const register = (name, settings) => {\r\n        annotations[name] = {\r\n          name,\r\n          settings\r\n        };\r\n      };\r\n      const lookup = name => get$a(annotations, name).map(a => a.settings);\r\n      const getNames = () => keys(annotations);\r\n      return {\r\n        register,\r\n        lookup,\r\n        getNames\r\n      };\r\n    };\r\n\r\n    let unique = 0;\r\n    const generate$1 = prefix => {\r\n      const date = new Date();\r\n      const time = date.getTime();\r\n      const random = Math.floor(Math.random() * 1000000000);\r\n      unique++;\r\n      return prefix + '_' + random + unique + String(time);\r\n    };\r\n\r\n    const add = (element, classes) => {\r\n      each$e(classes, x => {\r\n        add$2(element, x);\r\n      });\r\n    };\r\n    const remove$4 = (element, classes) => {\r\n      each$e(classes, x => {\r\n        remove$7(element, x);\r\n      });\r\n    };\r\n\r\n    const clone$2 = (original, isDeep) => SugarElement.fromDom(original.dom.cloneNode(isDeep));\r\n    const shallow$1 = original => clone$2(original, false);\r\n    const deep$1 = original => clone$2(original, true);\r\n    const shallowAs = (original, tag) => {\r\n      const nu = SugarElement.fromTag(tag);\r\n      const attributes = clone$4(original);\r\n      setAll$1(nu, attributes);\r\n      return nu;\r\n    };\r\n    const mutate = (original, tag) => {\r\n      const nu = shallowAs(original, tag);\r\n      after$4(original, nu);\r\n      const children = children$1(original);\r\n      append(nu, children);\r\n      remove$5(original);\r\n      return nu;\r\n    };\r\n\r\n    const TextWalker = (startNode, rootNode, isBoundary = never) => {\r\n      const walker = new DomTreeWalker(startNode, rootNode);\r\n      const walk = direction => {\r\n        let next;\r\n        do {\r\n          next = walker[direction]();\r\n        } while (next && !isText$a(next) && !isBoundary(next));\r\n        return Optional.from(next).filter(isText$a);\r\n      };\r\n      return {\r\n        current: () => Optional.from(walker.current()).filter(isText$a),\r\n        next: () => walk('next'),\r\n        prev: () => walk('prev'),\r\n        prev2: () => walk('prev2')\r\n      };\r\n    };\r\n\r\n    const TextSeeker = (dom, isBoundary) => {\r\n      const isBlockBoundary = isBoundary ? isBoundary : node => dom.isBlock(node) || isBr$6(node) || isContentEditableFalse$b(node);\r\n      const walk = (node, offset, walker, process) => {\r\n        if (isText$a(node)) {\r\n          const newOffset = process(node, offset, node.data);\r\n          if (newOffset !== -1) {\r\n            return Optional.some({\r\n              container: node,\r\n              offset: newOffset\r\n            });\r\n          }\r\n        }\r\n        return walker().bind(next => walk(next.container, next.offset, walker, process));\r\n      };\r\n      const backwards = (node, offset, process, root) => {\r\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\r\n        return walk(node, offset, () => walker.prev().map(prev => ({\r\n          container: prev,\r\n          offset: prev.length\r\n        })), process).getOrNull();\r\n      };\r\n      const forwards = (node, offset, process, root) => {\r\n        const walker = TextWalker(node, root !== null && root !== void 0 ? root : dom.getRoot(), isBlockBoundary);\r\n        return walk(node, offset, () => walker.next().map(next => ({\r\n          container: next,\r\n          offset: 0\r\n        })), process).getOrNull();\r\n      };\r\n      return {\r\n        backwards,\r\n        forwards\r\n      };\r\n    };\r\n\r\n    const round$2 = Math.round;\r\n    const clone$1 = rect => {\r\n      if (!rect) {\r\n        return {\r\n          left: 0,\r\n          top: 0,\r\n          bottom: 0,\r\n          right: 0,\r\n          width: 0,\r\n          height: 0\r\n        };\r\n      }\r\n      return {\r\n        left: round$2(rect.left),\r\n        top: round$2(rect.top),\r\n        bottom: round$2(rect.bottom),\r\n        right: round$2(rect.right),\r\n        width: round$2(rect.width),\r\n        height: round$2(rect.height)\r\n      };\r\n    };\r\n    const collapse = (rect, toStart) => {\r\n      rect = clone$1(rect);\r\n      if (toStart) {\r\n        rect.right = rect.left;\r\n      } else {\r\n        rect.left = rect.left + rect.width;\r\n        rect.right = rect.left;\r\n      }\r\n      rect.width = 0;\r\n      return rect;\r\n    };\r\n    const isEqual = (rect1, rect2) => rect1.left === rect2.left && rect1.top === rect2.top && rect1.bottom === rect2.bottom && rect1.right === rect2.right;\r\n    const isValidOverflow = (overflowY, rect1, rect2) => overflowY >= 0 && overflowY <= Math.min(rect1.height, rect2.height) / 2;\r\n    const isAbove$1 = (rect1, rect2) => {\r\n      const halfHeight = Math.min(rect2.height / 2, rect1.height / 2);\r\n      if (rect1.bottom - halfHeight < rect2.top) {\r\n        return true;\r\n      }\r\n      if (rect1.top > rect2.bottom) {\r\n        return false;\r\n      }\r\n      return isValidOverflow(rect2.top - rect1.bottom, rect1, rect2);\r\n    };\r\n    const isBelow$1 = (rect1, rect2) => {\r\n      if (rect1.top > rect2.bottom) {\r\n        return true;\r\n      }\r\n      if (rect1.bottom < rect2.top) {\r\n        return false;\r\n      }\r\n      return isValidOverflow(rect2.bottom - rect1.top, rect1, rect2);\r\n    };\r\n    const containsXY = (rect, clientX, clientY) => clientX >= rect.left && clientX <= rect.right && clientY >= rect.top && clientY <= rect.bottom;\r\n    const boundingClientRectFromRects = rects => {\r\n      return foldl(rects, (acc, rect) => {\r\n        return acc.fold(() => Optional.some(rect), prevRect => {\r\n          const left = Math.min(rect.left, prevRect.left);\r\n          const top = Math.min(rect.top, prevRect.top);\r\n          const right = Math.max(rect.right, prevRect.right);\r\n          const bottom = Math.max(rect.bottom, prevRect.bottom);\r\n          return Optional.some({\r\n            top,\r\n            right,\r\n            bottom,\r\n            left,\r\n            width: right - left,\r\n            height: bottom - top\r\n          });\r\n        });\r\n      }, Optional.none());\r\n    };\r\n    const distanceToRectEdgeFromXY = (rect, x, y) => {\r\n      const cx = Math.max(Math.min(x, rect.left + rect.width), rect.left);\r\n      const cy = Math.max(Math.min(y, rect.top + rect.height), rect.top);\r\n      return Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));\r\n    };\r\n    const overlapY = (r1, r2) => Math.max(0, Math.min(r1.bottom, r2.bottom) - Math.max(r1.top, r2.top));\r\n\r\n    const clamp$2 = (value, min, max) => Math.min(Math.max(value, min), max);\r\n\r\n    const getSelectedNode = range => {\r\n      const startContainer = range.startContainer, startOffset = range.startOffset;\r\n      if (startContainer === range.endContainer && startContainer.hasChildNodes() && range.endOffset === startOffset + 1) {\r\n        return startContainer.childNodes[startOffset];\r\n      }\r\n      return null;\r\n    };\r\n    const getNode$1 = (container, offset) => {\r\n      if (isElement$6(container) && container.hasChildNodes()) {\r\n        const childNodes = container.childNodes;\r\n        const safeOffset = clamp$2(offset, 0, childNodes.length - 1);\r\n        return childNodes[safeOffset];\r\n      } else {\r\n        return container;\r\n      }\r\n    };\r\n    const getNodeUnsafe = (container, offset) => {\r\n      if (offset < 0 && isElement$6(container) && container.hasChildNodes()) {\r\n        return undefined;\r\n      } else {\r\n        return getNode$1(container, offset);\r\n      }\r\n    };\r\n\r\n    const extendingChars = new RegExp('[\\u0300-\\u036f\\u0483-\\u0487\\u0488-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1-\\u05c2\\u05c4-\\u05c5\\u05c7\\u0610-\\u061a' + '\\u064b-\\u065f\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7-\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0' + '\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08e3-\\u0902\\u093a\\u093c' + '\\u0941-\\u0948\\u094d\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2-\\u09e3' + '\\u0a01-\\u0a02\\u0a3c\\u0a41-\\u0a42\\u0a47-\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70-\\u0a71\\u0a75\\u0a81-\\u0a82\\u0abc' + '\\u0ac1-\\u0ac5\\u0ac7-\\u0ac8\\u0acd\\u0ae2-\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57' + '\\u0b62-\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c00\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55-\\u0c56' + '\\u0c62-\\u0c63\\u0c81\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc-\\u0ccd\\u0cd5-\\u0cd6\\u0ce2-\\u0ce3\\u0d01\\u0d3e\\u0d41-\\u0d44' + '\\u0d4d\\u0d57\\u0d62-\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9' + '\\u0ebb-\\u0ebc\\u0ec8-\\u0ecd\\u0f18-\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97' + '\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039-\\u103a\\u103d-\\u103e\\u1058-\\u1059\\u105e-\\u1060\\u1071-\\u1074' + '\\u1082\\u1085-\\u1086\\u108d\\u109d\\u135d-\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17b4-\\u17b5' + '\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193b\\u1a17-\\u1a18' + '\\u1a1b\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1ab0-\\u1abd\\u1ABE\\u1b00-\\u1b03\\u1b34' + '\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80-\\u1b81\\u1ba2-\\u1ba5\\u1ba8-\\u1ba9\\u1bab-\\u1bad\\u1be6\\u1be8-\\u1be9' + '\\u1bed\\u1bef-\\u1bf1\\u1c2c-\\u1c33\\u1c36-\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1cf4\\u1cf8-\\u1cf9' + '\\u1dc0-\\u1df5\\u1dfc-\\u1dff\\u200c-\\u200d\\u20d0-\\u20dc\\u20DD-\\u20E0\\u20e1\\u20E2-\\u20E4\\u20e5-\\u20f0\\u2cef-\\u2cf1' + '\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302d\\u302e-\\u302f\\u3099-\\u309a\\ua66f\\uA670-\\uA672\\ua674-\\ua67d\\ua69e-\\ua69f\\ua6f0-\\ua6f1' + '\\ua802\\ua806\\ua80b\\ua825-\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc' + '\\ua9e5\\uaa29-\\uaa2e\\uaa31-\\uaa32\\uaa35-\\uaa36\\uaa43\\uaa4c\\uaa7c\\uaab0\\uaab2-\\uaab4\\uaab7-\\uaab8\\uaabe-\\uaabf\\uaac1' + '\\uaaec-\\uaaed\\uaaf6\\uabe5\\uabe8\\uabed\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\uff9e-\\uff9f]');\r\n    const isExtendingChar = ch => isString(ch) && ch.charCodeAt(0) >= 768 && extendingChars.test(ch);\r\n\r\n    const or = (...args) => {\r\n      return x => {\r\n        for (let i = 0; i < args.length; i++) {\r\n          if (args[i](x)) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n    };\r\n    const and = (...args) => {\r\n      return x => {\r\n        for (let i = 0; i < args.length; i++) {\r\n          if (!args[i](x)) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      };\r\n    };\r\n\r\n    const isElement$4 = isElement$6;\r\n    const isCaretCandidate$2 = isCaretCandidate$3;\r\n    const isBlock$2 = matchStyleValues('display', 'block table');\r\n    const isFloated = matchStyleValues('float', 'left right');\r\n    const isValidElementCaretCandidate = and(isElement$4, isCaretCandidate$2, not(isFloated));\r\n    const isNotPre = not(matchStyleValues('white-space', 'pre pre-line pre-wrap'));\r\n    const isText$7 = isText$a;\r\n    const isBr$3 = isBr$6;\r\n    const nodeIndex$1 = DOMUtils.nodeIndex;\r\n    const resolveIndex$1 = getNodeUnsafe;\r\n    const createRange$1 = doc => doc ? doc.createRange() : DOMUtils.DOM.createRng();\r\n    const isWhiteSpace$1 = chr => isString(chr) && /[\\r\\n\\t ]/.test(chr);\r\n    const isRange = rng => !!rng.setStart && !!rng.setEnd;\r\n    const isHiddenWhiteSpaceRange = range => {\r\n      const container = range.startContainer;\r\n      const offset = range.startOffset;\r\n      if (isWhiteSpace$1(range.toString()) && isNotPre(container.parentNode) && isText$a(container)) {\r\n        const text = container.data;\r\n        if (isWhiteSpace$1(text[offset - 1]) || isWhiteSpace$1(text[offset + 1])) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    const getBrClientRect = brNode => {\r\n      const doc = brNode.ownerDocument;\r\n      const rng = createRange$1(doc);\r\n      const nbsp$1 = doc.createTextNode(nbsp);\r\n      const parentNode = brNode.parentNode;\r\n      parentNode.insertBefore(nbsp$1, brNode);\r\n      rng.setStart(nbsp$1, 0);\r\n      rng.setEnd(nbsp$1, 1);\r\n      const clientRect = clone$1(rng.getBoundingClientRect());\r\n      parentNode.removeChild(nbsp$1);\r\n      return clientRect;\r\n    };\r\n    const getBoundingClientRectWebKitText = rng => {\r\n      const sc = rng.startContainer;\r\n      const ec = rng.endContainer;\r\n      const so = rng.startOffset;\r\n      const eo = rng.endOffset;\r\n      if (sc === ec && isText$a(ec) && so === 0 && eo === 1) {\r\n        const newRng = rng.cloneRange();\r\n        newRng.setEndAfter(ec);\r\n        return getBoundingClientRect$1(newRng);\r\n      } else {\r\n        return null;\r\n      }\r\n    };\r\n    const isZeroRect = r => r.left === 0 && r.right === 0 && r.top === 0 && r.bottom === 0;\r\n    const getBoundingClientRect$1 = item => {\r\n      var _a;\r\n      let clientRect;\r\n      const clientRects = item.getClientRects();\r\n      if (clientRects.length > 0) {\r\n        clientRect = clone$1(clientRects[0]);\r\n      } else {\r\n        clientRect = clone$1(item.getBoundingClientRect());\r\n      }\r\n      if (!isRange(item) && isBr$3(item) && isZeroRect(clientRect)) {\r\n        return getBrClientRect(item);\r\n      }\r\n      if (isZeroRect(clientRect) && isRange(item)) {\r\n        return (_a = getBoundingClientRectWebKitText(item)) !== null && _a !== void 0 ? _a : clientRect;\r\n      }\r\n      return clientRect;\r\n    };\r\n    const collapseAndInflateWidth = (clientRect, toStart) => {\r\n      const newClientRect = collapse(clientRect, toStart);\r\n      newClientRect.width = 1;\r\n      newClientRect.right = newClientRect.left + 1;\r\n      return newClientRect;\r\n    };\r\n    const getCaretPositionClientRects = caretPosition => {\r\n      const clientRects = [];\r\n      const addUniqueAndValidRect = clientRect => {\r\n        if (clientRect.height === 0) {\r\n          return;\r\n        }\r\n        if (clientRects.length > 0) {\r\n          if (isEqual(clientRect, clientRects[clientRects.length - 1])) {\r\n            return;\r\n          }\r\n        }\r\n        clientRects.push(clientRect);\r\n      };\r\n      const addCharacterOffset = (container, offset) => {\r\n        const range = createRange$1(container.ownerDocument);\r\n        if (offset < container.data.length) {\r\n          if (isExtendingChar(container.data[offset])) {\r\n            return;\r\n          }\r\n          if (isExtendingChar(container.data[offset - 1])) {\r\n            range.setStart(container, offset);\r\n            range.setEnd(container, offset + 1);\r\n            if (!isHiddenWhiteSpaceRange(range)) {\r\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\r\n              return;\r\n            }\r\n          }\r\n        }\r\n        if (offset > 0) {\r\n          range.setStart(container, offset - 1);\r\n          range.setEnd(container, offset);\r\n          if (!isHiddenWhiteSpaceRange(range)) {\r\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), false));\r\n          }\r\n        }\r\n        if (offset < container.data.length) {\r\n          range.setStart(container, offset);\r\n          range.setEnd(container, offset + 1);\r\n          if (!isHiddenWhiteSpaceRange(range)) {\r\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(range), true));\r\n          }\r\n        }\r\n      };\r\n      const container = caretPosition.container();\r\n      const offset = caretPosition.offset();\r\n      if (isText$7(container)) {\r\n        addCharacterOffset(container, offset);\r\n        return clientRects;\r\n      }\r\n      if (isElement$4(container)) {\r\n        if (caretPosition.isAtEnd()) {\r\n          const node = resolveIndex$1(container, offset);\r\n          if (isText$7(node)) {\r\n            addCharacterOffset(node, node.data.length);\r\n          }\r\n          if (isValidElementCaretCandidate(node) && !isBr$3(node)) {\r\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\r\n          }\r\n        } else {\r\n          const node = resolveIndex$1(container, offset);\r\n          if (isText$7(node)) {\r\n            addCharacterOffset(node, 0);\r\n          }\r\n          if (isValidElementCaretCandidate(node) && caretPosition.isAtEnd()) {\r\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), false));\r\n            return clientRects;\r\n          }\r\n          const beforeNode = resolveIndex$1(caretPosition.container(), caretPosition.offset() - 1);\r\n          if (isValidElementCaretCandidate(beforeNode) && !isBr$3(beforeNode)) {\r\n            if (isBlock$2(beforeNode) || isBlock$2(node) || !isValidElementCaretCandidate(node)) {\r\n              addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(beforeNode), false));\r\n            }\r\n          }\r\n          if (isValidElementCaretCandidate(node)) {\r\n            addUniqueAndValidRect(collapseAndInflateWidth(getBoundingClientRect$1(node), true));\r\n          }\r\n        }\r\n      }\r\n      return clientRects;\r\n    };\r\n    const CaretPosition = (container, offset, clientRects) => {\r\n      const isAtStart = () => {\r\n        if (isText$7(container)) {\r\n          return offset === 0;\r\n        }\r\n        return offset === 0;\r\n      };\r\n      const isAtEnd = () => {\r\n        if (isText$7(container)) {\r\n          return offset >= container.data.length;\r\n        }\r\n        return offset >= container.childNodes.length;\r\n      };\r\n      const toRange = () => {\r\n        const range = createRange$1(container.ownerDocument);\r\n        range.setStart(container, offset);\r\n        range.setEnd(container, offset);\r\n        return range;\r\n      };\r\n      const getClientRects = () => {\r\n        if (!clientRects) {\r\n          clientRects = getCaretPositionClientRects(CaretPosition(container, offset));\r\n        }\r\n        return clientRects;\r\n      };\r\n      const isVisible = () => getClientRects().length > 0;\r\n      const isEqual = caretPosition => caretPosition && container === caretPosition.container() && offset === caretPosition.offset();\r\n      const getNode = before => resolveIndex$1(container, before ? offset - 1 : offset);\r\n      return {\r\n        container: constant(container),\r\n        offset: constant(offset),\r\n        toRange,\r\n        getClientRects,\r\n        isVisible,\r\n        isAtStart,\r\n        isAtEnd,\r\n        isEqual,\r\n        getNode\r\n      };\r\n    };\r\n    CaretPosition.fromRangeStart = range => CaretPosition(range.startContainer, range.startOffset);\r\n    CaretPosition.fromRangeEnd = range => CaretPosition(range.endContainer, range.endOffset);\r\n    CaretPosition.after = node => CaretPosition(node.parentNode, nodeIndex$1(node) + 1);\r\n    CaretPosition.before = node => CaretPosition(node.parentNode, nodeIndex$1(node));\r\n    CaretPosition.isAbove = (pos1, pos2) => lift2(head(pos2.getClientRects()), last$3(pos1.getClientRects()), isAbove$1).getOr(false);\r\n    CaretPosition.isBelow = (pos1, pos2) => lift2(last$3(pos2.getClientRects()), head(pos1.getClientRects()), isBelow$1).getOr(false);\r\n    CaretPosition.isAtStart = pos => pos ? pos.isAtStart() : false;\r\n    CaretPosition.isAtEnd = pos => pos ? pos.isAtEnd() : false;\r\n    CaretPosition.isTextPosition = pos => pos ? isText$a(pos.container()) : false;\r\n    CaretPosition.isElementPosition = pos => !CaretPosition.isTextPosition(pos);\r\n\r\n    const trimEmptyTextNode$1 = (dom, node) => {\r\n      if (isText$a(node) && node.data.length === 0) {\r\n        dom.remove(node);\r\n      }\r\n    };\r\n    const insertNode = (dom, rng, node) => {\r\n      rng.insertNode(node);\r\n      trimEmptyTextNode$1(dom, node.previousSibling);\r\n      trimEmptyTextNode$1(dom, node.nextSibling);\r\n    };\r\n    const insertFragment = (dom, rng, frag) => {\r\n      const firstChild = Optional.from(frag.firstChild);\r\n      const lastChild = Optional.from(frag.lastChild);\r\n      rng.insertNode(frag);\r\n      firstChild.each(child => trimEmptyTextNode$1(dom, child.previousSibling));\r\n      lastChild.each(child => trimEmptyTextNode$1(dom, child.nextSibling));\r\n    };\r\n    const rangeInsertNode = (dom, rng, node) => {\r\n      if (isDocumentFragment(node)) {\r\n        insertFragment(dom, rng, node);\r\n      } else {\r\n        insertNode(dom, rng, node);\r\n      }\r\n    };\r\n\r\n    const isText$6 = isText$a;\r\n    const isBogus = isBogus$2;\r\n    const nodeIndex = DOMUtils.nodeIndex;\r\n    const normalizedParent = node => {\r\n      const parentNode = node.parentNode;\r\n      if (isBogus(parentNode)) {\r\n        return normalizedParent(parentNode);\r\n      }\r\n      return parentNode;\r\n    };\r\n    const getChildNodes = node => {\r\n      if (!node) {\r\n        return [];\r\n      }\r\n      return reduce(node.childNodes, (result, node) => {\r\n        if (isBogus(node) && node.nodeName !== 'BR') {\r\n          result = result.concat(getChildNodes(node));\r\n        } else {\r\n          result.push(node);\r\n        }\r\n        return result;\r\n      }, []);\r\n    };\r\n    const normalizedTextOffset = (node, offset) => {\r\n      let tempNode = node;\r\n      while (tempNode = tempNode.previousSibling) {\r\n        if (!isText$6(tempNode)) {\r\n          break;\r\n        }\r\n        offset += tempNode.data.length;\r\n      }\r\n      return offset;\r\n    };\r\n    const equal = a => b => a === b;\r\n    const normalizedNodeIndex = node => {\r\n      let nodes, index;\r\n      nodes = getChildNodes(normalizedParent(node));\r\n      index = findIndex$1(nodes, equal(node), node);\r\n      nodes = nodes.slice(0, index + 1);\r\n      const numTextFragments = reduce(nodes, (result, node, i) => {\r\n        if (isText$6(node) && isText$6(nodes[i - 1])) {\r\n          result++;\r\n        }\r\n        return result;\r\n      }, 0);\r\n      nodes = filter$3(nodes, matchNodeNames([node.nodeName]));\r\n      index = findIndex$1(nodes, equal(node), node);\r\n      return index - numTextFragments;\r\n    };\r\n    const createPathItem = node => {\r\n      const name = isText$6(node) ? 'text()' : node.nodeName.toLowerCase();\r\n      return name + '[' + normalizedNodeIndex(node) + ']';\r\n    };\r\n    const parentsUntil$1 = (root, node, predicate) => {\r\n      const parents = [];\r\n      for (let tempNode = node.parentNode; tempNode && tempNode !== root; tempNode = tempNode.parentNode) {\r\n        if (predicate && predicate(tempNode)) {\r\n          break;\r\n        }\r\n        parents.push(tempNode);\r\n      }\r\n      return parents;\r\n    };\r\n    const create$b = (root, caretPosition) => {\r\n      let path = [];\r\n      let container = caretPosition.container();\r\n      let offset = caretPosition.offset();\r\n      let outputOffset;\r\n      if (isText$6(container)) {\r\n        outputOffset = normalizedTextOffset(container, offset);\r\n      } else {\r\n        const childNodes = container.childNodes;\r\n        if (offset >= childNodes.length) {\r\n          outputOffset = 'after';\r\n          offset = childNodes.length - 1;\r\n        } else {\r\n          outputOffset = 'before';\r\n        }\r\n        container = childNodes[offset];\r\n      }\r\n      path.push(createPathItem(container));\r\n      let parents = parentsUntil$1(root, container);\r\n      parents = filter$3(parents, not(isBogus$2));\r\n      path = path.concat(map$1(parents, node => {\r\n        return createPathItem(node);\r\n      }));\r\n      return path.reverse().join('/') + ',' + outputOffset;\r\n    };\r\n    const resolvePathItem = (node, name, index) => {\r\n      let nodes = getChildNodes(node);\r\n      nodes = filter$3(nodes, (node, index) => {\r\n        return !isText$6(node) || !isText$6(nodes[index - 1]);\r\n      });\r\n      nodes = filter$3(nodes, matchNodeNames([name]));\r\n      return nodes[index];\r\n    };\r\n    const findTextPosition = (container, offset) => {\r\n      let node = container;\r\n      let targetOffset = 0;\r\n      while (isText$6(node)) {\r\n        const dataLen = node.data.length;\r\n        if (offset >= targetOffset && offset <= targetOffset + dataLen) {\r\n          container = node;\r\n          offset = offset - targetOffset;\r\n          break;\r\n        }\r\n        if (!isText$6(node.nextSibling)) {\r\n          container = node;\r\n          offset = dataLen;\r\n          break;\r\n        }\r\n        targetOffset += dataLen;\r\n        node = node.nextSibling;\r\n      }\r\n      if (isText$6(container) && offset > container.data.length) {\r\n        offset = container.data.length;\r\n      }\r\n      return CaretPosition(container, offset);\r\n    };\r\n    const resolve$1 = (root, path) => {\r\n      if (!path) {\r\n        return null;\r\n      }\r\n      const parts = path.split(',');\r\n      const paths = parts[0].split('/');\r\n      const offset = parts.length > 1 ? parts[1] : 'before';\r\n      const container = reduce(paths, (result, value) => {\r\n        const match = /([\\w\\-\\(\\)]+)\\[([0-9]+)\\]/.exec(value);\r\n        if (!match) {\r\n          return null;\r\n        }\r\n        if (match[1] === 'text()') {\r\n          match[1] = '#text';\r\n        }\r\n        return resolvePathItem(result, match[1], parseInt(match[2], 10));\r\n      }, root);\r\n      if (!container) {\r\n        return null;\r\n      }\r\n      if (!isText$6(container) && container.parentNode) {\r\n        let nodeOffset;\r\n        if (offset === 'after') {\r\n          nodeOffset = nodeIndex(container) + 1;\r\n        } else {\r\n          nodeOffset = nodeIndex(container);\r\n        }\r\n        return CaretPosition(container.parentNode, nodeOffset);\r\n      }\r\n      return findTextPosition(container, parseInt(offset, 10));\r\n    };\r\n\r\n    const isContentEditableFalse$9 = isContentEditableFalse$b;\r\n    const getNormalizedTextOffset$1 = (trim, container, offset) => {\r\n      let trimmedOffset = trim(container.data.slice(0, offset)).length;\r\n      for (let node = container.previousSibling; node && isText$a(node); node = node.previousSibling) {\r\n        trimmedOffset += trim(node.data).length;\r\n      }\r\n      return trimmedOffset;\r\n    };\r\n    const getPoint = (dom, trim, normalized, rng, start) => {\r\n      const container = start ? rng.startContainer : rng.endContainer;\r\n      let offset = start ? rng.startOffset : rng.endOffset;\r\n      const point = [];\r\n      const root = dom.getRoot();\r\n      if (isText$a(container)) {\r\n        point.push(normalized ? getNormalizedTextOffset$1(trim, container, offset) : offset);\r\n      } else {\r\n        let after = 0;\r\n        const childNodes = container.childNodes;\r\n        if (offset >= childNodes.length && childNodes.length) {\r\n          after = 1;\r\n          offset = Math.max(0, childNodes.length - 1);\r\n        }\r\n        point.push(dom.nodeIndex(childNodes[offset], normalized) + after);\r\n      }\r\n      for (let node = container; node && node !== root; node = node.parentNode) {\r\n        point.push(dom.nodeIndex(node, normalized));\r\n      }\r\n      return point;\r\n    };\r\n    const getLocation = (trim, selection, normalized, rng) => {\r\n      const dom = selection.dom;\r\n      const start = getPoint(dom, trim, normalized, rng, true);\r\n      const forward = selection.isForward();\r\n      const fakeCaret = isRangeInCaretContainerBlock(rng) ? { isFakeCaret: true } : {};\r\n      if (!selection.isCollapsed()) {\r\n        const end = getPoint(dom, trim, normalized, rng, false);\r\n        return {\r\n          start,\r\n          end,\r\n          forward,\r\n          ...fakeCaret\r\n        };\r\n      } else {\r\n        return {\r\n          start,\r\n          forward,\r\n          ...fakeCaret\r\n        };\r\n      }\r\n    };\r\n    const findIndex = (dom, name, element) => {\r\n      let count = 0;\r\n      Tools.each(dom.select(name), node => {\r\n        if (node.getAttribute('data-mce-bogus') === 'all') {\r\n          return;\r\n        } else if (node === element) {\r\n          return false;\r\n        } else {\r\n          count++;\r\n          return;\r\n        }\r\n      });\r\n      return count;\r\n    };\r\n    const moveEndPoint$1 = (rng, start) => {\r\n      let container = start ? rng.startContainer : rng.endContainer;\r\n      let offset = start ? rng.startOffset : rng.endOffset;\r\n      if (isElement$6(container) && container.nodeName === 'TR') {\r\n        const childNodes = container.childNodes;\r\n        container = childNodes[Math.min(start ? offset : offset - 1, childNodes.length - 1)];\r\n        if (container) {\r\n          offset = start ? 0 : container.childNodes.length;\r\n          if (start) {\r\n            rng.setStart(container, offset);\r\n          } else {\r\n            rng.setEnd(container, offset);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    const normalizeTableCellSelection = rng => {\r\n      moveEndPoint$1(rng, true);\r\n      moveEndPoint$1(rng, false);\r\n      return rng;\r\n    };\r\n    const findSibling = (node, offset) => {\r\n      if (isElement$6(node)) {\r\n        node = getNode$1(node, offset);\r\n        if (isContentEditableFalse$9(node)) {\r\n          return node;\r\n        }\r\n      }\r\n      if (isCaretContainer$2(node)) {\r\n        if (isText$a(node) && isCaretContainerBlock$1(node)) {\r\n          node = node.parentNode;\r\n        }\r\n        let sibling = node.previousSibling;\r\n        if (isContentEditableFalse$9(sibling)) {\r\n          return sibling;\r\n        }\r\n        sibling = node.nextSibling;\r\n        if (isContentEditableFalse$9(sibling)) {\r\n          return sibling;\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n    const findAdjacentContentEditableFalseElm = rng => {\r\n      return findSibling(rng.startContainer, rng.startOffset) || findSibling(rng.endContainer, rng.endOffset);\r\n    };\r\n    const getOffsetBookmark = (trim, normalized, selection) => {\r\n      const element = selection.getNode();\r\n      const rng = selection.getRng();\r\n      if (element.nodeName === 'IMG' || isContentEditableFalse$9(element)) {\r\n        const name = element.nodeName;\r\n        return {\r\n          name,\r\n          index: findIndex(selection.dom, name, element)\r\n        };\r\n      }\r\n      const sibling = findAdjacentContentEditableFalseElm(rng);\r\n      if (sibling) {\r\n        const name = sibling.tagName;\r\n        return {\r\n          name,\r\n          index: findIndex(selection.dom, name, sibling)\r\n        };\r\n      }\r\n      return getLocation(trim, selection, normalized, rng);\r\n    };\r\n    const getCaretBookmark = selection => {\r\n      const rng = selection.getRng();\r\n      return {\r\n        start: create$b(selection.dom.getRoot(), CaretPosition.fromRangeStart(rng)),\r\n        end: create$b(selection.dom.getRoot(), CaretPosition.fromRangeEnd(rng)),\r\n        forward: selection.isForward()\r\n      };\r\n    };\r\n    const getRangeBookmark = selection => {\r\n      return {\r\n        rng: selection.getRng(),\r\n        forward: selection.isForward()\r\n      };\r\n    };\r\n    const createBookmarkSpan = (dom, id, filled) => {\r\n      const args = {\r\n        'data-mce-type': 'bookmark',\r\n        id,\r\n        'style': 'overflow:hidden;line-height:0px'\r\n      };\r\n      return filled ? dom.create('span', args, '&#xFEFF;') : dom.create('span', args);\r\n    };\r\n    const getPersistentBookmark = (selection, filled) => {\r\n      const dom = selection.dom;\r\n      let rng = selection.getRng();\r\n      const id = dom.uniqueId();\r\n      const collapsed = selection.isCollapsed();\r\n      const element = selection.getNode();\r\n      const name = element.nodeName;\r\n      const forward = selection.isForward();\r\n      if (name === 'IMG') {\r\n        return {\r\n          name,\r\n          index: findIndex(dom, name, element)\r\n        };\r\n      }\r\n      const rng2 = normalizeTableCellSelection(rng.cloneRange());\r\n      if (!collapsed) {\r\n        rng2.collapse(false);\r\n        const endBookmarkNode = createBookmarkSpan(dom, id + '_end', filled);\r\n        rangeInsertNode(dom, rng2, endBookmarkNode);\r\n      }\r\n      rng = normalizeTableCellSelection(rng);\r\n      rng.collapse(true);\r\n      const startBookmarkNode = createBookmarkSpan(dom, id + '_start', filled);\r\n      rangeInsertNode(dom, rng, startBookmarkNode);\r\n      selection.moveToBookmark({\r\n        id,\r\n        keep: true,\r\n        forward\r\n      });\r\n      return {\r\n        id,\r\n        forward\r\n      };\r\n    };\r\n    const getBookmark$2 = (selection, type, normalized = false) => {\r\n      if (type === 2) {\r\n        return getOffsetBookmark(trim$2, normalized, selection);\r\n      } else if (type === 3) {\r\n        return getCaretBookmark(selection);\r\n      } else if (type) {\r\n        return getRangeBookmark(selection);\r\n      } else {\r\n        return getPersistentBookmark(selection, false);\r\n      }\r\n    };\r\n    const getUndoBookmark = curry(getOffsetBookmark, identity, true);\r\n\r\n    const value$1 = value => {\r\n      const applyHelper = fn => fn(value);\r\n      const constHelper = constant(value);\r\n      const outputHelper = () => output;\r\n      const output = {\r\n        tag: true,\r\n        inner: value,\r\n        fold: (_onError, onValue) => onValue(value),\r\n        isValue: always,\r\n        isError: never,\r\n        map: mapper => Result.value(mapper(value)),\r\n        mapError: outputHelper,\r\n        bind: applyHelper,\r\n        exists: applyHelper,\r\n        forall: applyHelper,\r\n        getOr: constHelper,\r\n        or: outputHelper,\r\n        getOrThunk: constHelper,\r\n        orThunk: outputHelper,\r\n        getOrDie: constHelper,\r\n        each: fn => {\r\n          fn(value);\r\n        },\r\n        toOptional: () => Optional.some(value)\r\n      };\r\n      return output;\r\n    };\r\n    const error = error => {\r\n      const outputHelper = () => output;\r\n      const output = {\r\n        tag: false,\r\n        inner: error,\r\n        fold: (onError, _onValue) => onError(error),\r\n        isValue: never,\r\n        isError: always,\r\n        map: outputHelper,\r\n        mapError: mapper => Result.error(mapper(error)),\r\n        bind: outputHelper,\r\n        exists: never,\r\n        forall: always,\r\n        getOr: identity,\r\n        or: identity,\r\n        getOrThunk: apply$1,\r\n        orThunk: apply$1,\r\n        getOrDie: die(String(error)),\r\n        each: noop,\r\n        toOptional: Optional.none\r\n      };\r\n      return output;\r\n    };\r\n    const fromOption = (optional, err) => optional.fold(() => error(err), value$1);\r\n    const Result = {\r\n      value: value$1,\r\n      error,\r\n      fromOption\r\n    };\r\n\r\n    const generate = cases => {\r\n      if (!isArray$1(cases)) {\r\n        throw new Error('cases must be an array');\r\n      }\r\n      if (cases.length === 0) {\r\n        throw new Error('there must be at least one case');\r\n      }\r\n      const constructors = [];\r\n      const adt = {};\r\n      each$e(cases, (acase, count) => {\r\n        const keys$1 = keys(acase);\r\n        if (keys$1.length !== 1) {\r\n          throw new Error('one and only one name per case');\r\n        }\r\n        const key = keys$1[0];\r\n        const value = acase[key];\r\n        if (adt[key] !== undefined) {\r\n          throw new Error('duplicate key detected:' + key);\r\n        } else if (key === 'cata') {\r\n          throw new Error('cannot have a case named cata (sorry)');\r\n        } else if (!isArray$1(value)) {\r\n          throw new Error('case arguments must be an array');\r\n        }\r\n        constructors.push(key);\r\n        adt[key] = (...args) => {\r\n          const argLength = args.length;\r\n          if (argLength !== value.length) {\r\n            throw new Error('Wrong number of arguments to case ' + key + '. Expected ' + value.length + ' (' + value + '), got ' + argLength);\r\n          }\r\n          const match = branches => {\r\n            const branchKeys = keys(branches);\r\n            if (constructors.length !== branchKeys.length) {\r\n              throw new Error('Wrong number of arguments to match. Expected: ' + constructors.join(',') + '\\nActual: ' + branchKeys.join(','));\r\n            }\r\n            const allReqd = forall(constructors, reqKey => {\r\n              return contains$2(branchKeys, reqKey);\r\n            });\r\n            if (!allReqd) {\r\n              throw new Error('Not all branches were specified when using match. Specified: ' + branchKeys.join(', ') + '\\nRequired: ' + constructors.join(', '));\r\n            }\r\n            return branches[key].apply(null, args);\r\n          };\r\n          return {\r\n            fold: (...foldArgs) => {\r\n              if (foldArgs.length !== cases.length) {\r\n                throw new Error('Wrong number of arguments to fold. Expected ' + cases.length + ', got ' + foldArgs.length);\r\n              }\r\n              const target = foldArgs[count];\r\n              return target.apply(null, args);\r\n            },\r\n            match,\r\n            log: label => {\r\n              console.log(label, {\r\n                constructors,\r\n                constructor: key,\r\n                params: args\r\n              });\r\n            }\r\n          };\r\n        };\r\n      });\r\n      return adt;\r\n    };\r\n    const Adt = { generate };\r\n\r\n    Adt.generate([\r\n      {\r\n        bothErrors: [\r\n          'error1',\r\n          'error2'\r\n        ]\r\n      },\r\n      {\r\n        firstError: [\r\n          'error1',\r\n          'value2'\r\n        ]\r\n      },\r\n      {\r\n        secondError: [\r\n          'value1',\r\n          'error2'\r\n        ]\r\n      },\r\n      {\r\n        bothValues: [\r\n          'value1',\r\n          'value2'\r\n        ]\r\n      }\r\n    ]);\r\n    const partition$1 = results => {\r\n      const errors = [];\r\n      const values = [];\r\n      each$e(results, result => {\r\n        result.fold(err => {\r\n          errors.push(err);\r\n        }, value => {\r\n          values.push(value);\r\n        });\r\n      });\r\n      return {\r\n        errors,\r\n        values\r\n      };\r\n    };\r\n\r\n    const isInlinePattern = pattern => pattern.type === 'inline-command' || pattern.type === 'inline-format';\r\n    const isBlockPattern = pattern => pattern.type === 'block-command' || pattern.type === 'block-format';\r\n    const normalizePattern = pattern => {\r\n      const err = message => Result.error({\r\n        message,\r\n        pattern\r\n      });\r\n      const formatOrCmd = (name, onFormat, onCommand) => {\r\n        if (pattern.format !== undefined) {\r\n          let formats;\r\n          if (isArray$1(pattern.format)) {\r\n            if (!forall(pattern.format, isString)) {\r\n              return err(name + ' pattern has non-string items in the `format` array');\r\n            }\r\n            formats = pattern.format;\r\n          } else if (isString(pattern.format)) {\r\n            formats = [pattern.format];\r\n          } else {\r\n            return err(name + ' pattern has non-string `format` parameter');\r\n          }\r\n          return Result.value(onFormat(formats));\r\n        } else if (pattern.cmd !== undefined) {\r\n          if (!isString(pattern.cmd)) {\r\n            return err(name + ' pattern has non-string `cmd` parameter');\r\n          }\r\n          return Result.value(onCommand(pattern.cmd, pattern.value));\r\n        } else {\r\n          return err(name + ' pattern is missing both `format` and `cmd` parameters');\r\n        }\r\n      };\r\n      if (!isObject(pattern)) {\r\n        return err('Raw pattern is not an object');\r\n      }\r\n      if (!isString(pattern.start)) {\r\n        return err('Raw pattern is missing `start` parameter');\r\n      }\r\n      if (pattern.end !== undefined) {\r\n        if (!isString(pattern.end)) {\r\n          return err('Inline pattern has non-string `end` parameter');\r\n        }\r\n        if (pattern.start.length === 0 && pattern.end.length === 0) {\r\n          return err('Inline pattern has empty `start` and `end` parameters');\r\n        }\r\n        let start = pattern.start;\r\n        let end = pattern.end;\r\n        if (end.length === 0) {\r\n          end = start;\r\n          start = '';\r\n        }\r\n        return formatOrCmd('Inline', format => ({\r\n          type: 'inline-format',\r\n          start,\r\n          end,\r\n          format\r\n        }), (cmd, value) => ({\r\n          type: 'inline-command',\r\n          start,\r\n          end,\r\n          cmd,\r\n          value\r\n        }));\r\n      } else if (pattern.replacement !== undefined) {\r\n        if (!isString(pattern.replacement)) {\r\n          return err('Replacement pattern has non-string `replacement` parameter');\r\n        }\r\n        if (pattern.start.length === 0) {\r\n          return err('Replacement pattern has empty `start` parameter');\r\n        }\r\n        return Result.value({\r\n          type: 'inline-command',\r\n          start: '',\r\n          end: pattern.start,\r\n          cmd: 'mceInsertContent',\r\n          value: pattern.replacement\r\n        });\r\n      } else {\r\n        if (pattern.start.length === 0) {\r\n          return err('Block pattern has empty `start` parameter');\r\n        }\r\n        return formatOrCmd('Block', formats => ({\r\n          type: 'block-format',\r\n          start: pattern.start,\r\n          format: formats[0]\r\n        }), (command, commandValue) => ({\r\n          type: 'block-command',\r\n          start: pattern.start,\r\n          cmd: command,\r\n          value: commandValue\r\n        }));\r\n      }\r\n    };\r\n    const getBlockPatterns = patterns => filter$5(patterns, isBlockPattern);\r\n    const getInlinePatterns = patterns => filter$5(patterns, isInlinePattern);\r\n    const createPatternSet = (patterns, dynamicPatternsLookup) => ({\r\n      inlinePatterns: getInlinePatterns(patterns),\r\n      blockPatterns: getBlockPatterns(patterns),\r\n      dynamicPatternsLookup\r\n    });\r\n    const fromRawPatterns = patterns => {\r\n      const normalized = partition$1(map$3(patterns, normalizePattern));\r\n      each$e(normalized.errors, err => console.error(err.message, err.pattern));\r\n      return normalized.values;\r\n    };\r\n    const fromRawPatternsLookup = lookupFn => {\r\n      return ctx => {\r\n        const rawPatterns = lookupFn(ctx);\r\n        return fromRawPatterns(rawPatterns);\r\n      };\r\n    };\r\n\r\n    const deviceDetection$1 = detect$2().deviceType;\r\n    const isTouch = deviceDetection$1.isTouch();\r\n    const DOM$a = DOMUtils.DOM;\r\n    const getHash = value => {\r\n      const items = value.indexOf('=') > 0 ? value.split(/[;,](?![^=;,]*(?:[;,]|$))/) : value.split(',');\r\n      return foldl(items, (output, item) => {\r\n        const arr = item.split('=');\r\n        const key = arr[0];\r\n        const val = arr.length > 1 ? arr[1] : key;\r\n        output[trim$4(key)] = trim$4(val);\r\n        return output;\r\n      }, {});\r\n    };\r\n    const isRegExp = x => is$4(x, RegExp);\r\n    const option = name => editor => editor.options.get(name);\r\n    const stringOrObjectProcessor = value => isString(value) || isObject(value);\r\n    const bodyOptionProcessor = (editor, defaultValue = '') => value => {\r\n      const valid = isString(value);\r\n      if (valid) {\r\n        if (value.indexOf('=') !== -1) {\r\n          const bodyObj = getHash(value);\r\n          return {\r\n            value: get$a(bodyObj, editor.id).getOr(defaultValue),\r\n            valid\r\n          };\r\n        } else {\r\n          return {\r\n            value,\r\n            valid\r\n          };\r\n        }\r\n      } else {\r\n        return {\r\n          valid: false,\r\n          message: 'Must be a string.'\r\n        };\r\n      }\r\n    };\r\n    const register$7 = editor => {\r\n      const registerOption = editor.options.register;\r\n      registerOption('id', {\r\n        processor: 'string',\r\n        default: editor.id\r\n      });\r\n      registerOption('selector', { processor: 'string' });\r\n      registerOption('target', { processor: 'object' });\r\n      registerOption('suffix', { processor: 'string' });\r\n      registerOption('cache_suffix', { processor: 'string' });\r\n      registerOption('base_url', { processor: 'string' });\r\n      registerOption('referrer_policy', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('language_load', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('inline', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('iframe_attrs', {\r\n        processor: 'object',\r\n        default: {}\r\n      });\r\n      registerOption('doctype', {\r\n        processor: 'string',\r\n        default: '<!DOCTYPE html>'\r\n      });\r\n      registerOption('document_base_url', {\r\n        processor: 'string',\r\n        default: editor.documentBaseUrl\r\n      });\r\n      registerOption('body_id', {\r\n        processor: bodyOptionProcessor(editor, 'tinymce'),\r\n        default: 'tinymce'\r\n      });\r\n      registerOption('body_class', {\r\n        processor: bodyOptionProcessor(editor),\r\n        default: ''\r\n      });\r\n      registerOption('content_security_policy', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('br_in_pre', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('forced_root_block', {\r\n        processor: value => {\r\n          const valid = isString(value) && isNotEmpty(value);\r\n          if (valid) {\r\n            return {\r\n              value,\r\n              valid\r\n            };\r\n          } else {\r\n            return {\r\n              valid: false,\r\n              message: 'Must be a non-empty string.'\r\n            };\r\n          }\r\n        },\r\n        default: 'p'\r\n      });\r\n      registerOption('forced_root_block_attrs', {\r\n        processor: 'object',\r\n        default: {}\r\n      });\r\n      registerOption('newline_behavior', {\r\n        processor: value => {\r\n          const valid = contains$2([\r\n            'block',\r\n            'linebreak',\r\n            'invert',\r\n            'default'\r\n          ], value);\r\n          return valid ? {\r\n            value,\r\n            valid\r\n          } : {\r\n            valid: false,\r\n            message: 'Must be one of: block, linebreak, invert or default.'\r\n          };\r\n        },\r\n        default: 'default'\r\n      });\r\n      registerOption('br_newline_selector', {\r\n        processor: 'string',\r\n        default: '.mce-toc h2,figcaption,caption'\r\n      });\r\n      registerOption('no_newline_selector', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('keep_styles', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('end_container_on_empty_block', {\r\n        processor: value => {\r\n          if (isBoolean(value)) {\r\n            return {\r\n              valid: true,\r\n              value\r\n            };\r\n          } else if (isString(value)) {\r\n            return {\r\n              valid: true,\r\n              value\r\n            };\r\n          } else {\r\n            return {\r\n              valid: false,\r\n              message: 'Must be boolean or a string'\r\n            };\r\n          }\r\n        },\r\n        default: 'blockquote'\r\n      });\r\n      registerOption('font_size_style_values', {\r\n        processor: 'string',\r\n        default: 'xx-small,x-small,small,medium,large,x-large,xx-large'\r\n      });\r\n      registerOption('font_size_legacy_values', {\r\n        processor: 'string',\r\n        default: 'xx-small,small,medium,large,x-large,xx-large,300%'\r\n      });\r\n      registerOption('font_size_classes', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('automatic_uploads', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('images_reuse_filename', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('images_replace_blob_uris', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('icons', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('icons_url', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('images_upload_url', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('images_upload_base_path', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('images_upload_credentials', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('images_upload_handler', { processor: 'function' });\r\n      registerOption('language', {\r\n        processor: 'string',\r\n        default: 'en'\r\n      });\r\n      registerOption('language_url', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('entity_encoding', {\r\n        processor: 'string',\r\n        default: 'named'\r\n      });\r\n      registerOption('indent', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('indent_before', {\r\n        processor: 'string',\r\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\r\n      });\r\n      registerOption('indent_after', {\r\n        processor: 'string',\r\n        default: 'p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,' + 'tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist'\r\n      });\r\n      registerOption('indent_use_margin', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('indentation', {\r\n        processor: 'string',\r\n        default: '40px'\r\n      });\r\n      registerOption('content_css', {\r\n        processor: value => {\r\n          const valid = value === false || isString(value) || isArrayOf(value, isString);\r\n          if (valid) {\r\n            if (isString(value)) {\r\n              return {\r\n                value: map$3(value.split(','), trim$4),\r\n                valid\r\n              };\r\n            } else if (isArray$1(value)) {\r\n              return {\r\n                value,\r\n                valid\r\n              };\r\n            } else if (value === false) {\r\n              return {\r\n                value: [],\r\n                valid\r\n              };\r\n            } else {\r\n              return {\r\n                value,\r\n                valid\r\n              };\r\n            }\r\n          } else {\r\n            return {\r\n              valid: false,\r\n              message: 'Must be false, a string or an array of strings.'\r\n            };\r\n          }\r\n        },\r\n        default: isInline$1(editor) ? [] : ['default']\r\n      });\r\n      registerOption('content_style', { processor: 'string' });\r\n      registerOption('content_css_cors', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('font_css', {\r\n        processor: value => {\r\n          const valid = isString(value) || isArrayOf(value, isString);\r\n          if (valid) {\r\n            const newValue = isArray$1(value) ? value : map$3(value.split(','), trim$4);\r\n            return {\r\n              value: newValue,\r\n              valid\r\n            };\r\n          } else {\r\n            return {\r\n              valid: false,\r\n              message: 'Must be a string or an array of strings.'\r\n            };\r\n          }\r\n        },\r\n        default: []\r\n      });\r\n      registerOption('inline_boundaries', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('inline_boundaries_selector', {\r\n        processor: 'string',\r\n        default: 'a[href],code,span.mce-annotation'\r\n      });\r\n      registerOption('object_resizing', {\r\n        processor: value => {\r\n          const valid = isBoolean(value) || isString(value);\r\n          if (valid) {\r\n            if (value === false || deviceDetection$1.isiPhone() || deviceDetection$1.isiPad()) {\r\n              return {\r\n                value: '',\r\n                valid\r\n              };\r\n            } else {\r\n              return {\r\n                value: value === true ? 'table,img,figure.image,div,video,iframe' : value,\r\n                valid\r\n              };\r\n            }\r\n          } else {\r\n            return {\r\n              valid: false,\r\n              message: 'Must be boolean or a string'\r\n            };\r\n          }\r\n        },\r\n        default: !isTouch\r\n      });\r\n      registerOption('resize_img_proportional', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('event_root', { processor: 'object' });\r\n      registerOption('service_message', { processor: 'string' });\r\n      registerOption('theme', {\r\n        processor: value => value === false || isString(value) || isFunction(value),\r\n        default: 'silver'\r\n      });\r\n      registerOption('theme_url', { processor: 'string' });\r\n      registerOption('formats', { processor: 'object' });\r\n      registerOption('format_empty_lines', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('format_noneditable_selector', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('preview_styles', {\r\n        processor: value => {\r\n          const valid = value === false || isString(value);\r\n          if (valid) {\r\n            return {\r\n              value: value === false ? '' : value,\r\n              valid\r\n            };\r\n          } else {\r\n            return {\r\n              valid: false,\r\n              message: 'Must be false or a string'\r\n            };\r\n          }\r\n        },\r\n        default: 'font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow'\r\n      });\r\n      registerOption('custom_ui_selector', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('hidden_input', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('submit_patch', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('encoding', { processor: 'string' });\r\n      registerOption('add_form_submit_trigger', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('add_unload_trigger', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('custom_undo_redo_levels', {\r\n        processor: 'number',\r\n        default: 0\r\n      });\r\n      registerOption('disable_nodechange', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('readonly', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('editable_root', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('plugins', {\r\n        processor: 'string[]',\r\n        default: []\r\n      });\r\n      registerOption('external_plugins', { processor: 'object' });\r\n      registerOption('forced_plugins', { processor: 'string[]' });\r\n      registerOption('model', {\r\n        processor: 'string',\r\n        default: editor.hasPlugin('rtc') ? 'plugin' : 'dom'\r\n      });\r\n      registerOption('model_url', { processor: 'string' });\r\n      registerOption('block_unsupported_drop', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('visual', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('visual_table_class', {\r\n        processor: 'string',\r\n        default: 'mce-item-table'\r\n      });\r\n      registerOption('visual_anchor_class', {\r\n        processor: 'string',\r\n        default: 'mce-item-anchor'\r\n      });\r\n      registerOption('iframe_aria_text', {\r\n        processor: 'string',\r\n        default: 'Rich Text Area. Press ALT-0 for help.'\r\n      });\r\n      registerOption('setup', { processor: 'function' });\r\n      registerOption('init_instance_callback', { processor: 'function' });\r\n      registerOption('url_converter', {\r\n        processor: 'function',\r\n        default: editor.convertURL\r\n      });\r\n      registerOption('url_converter_scope', {\r\n        processor: 'object',\r\n        default: editor\r\n      });\r\n      registerOption('urlconverter_callback', { processor: 'function' });\r\n      registerOption('allow_conditional_comments', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('allow_html_data_urls', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('allow_svg_data_urls', { processor: 'boolean' });\r\n      registerOption('allow_html_in_named_anchor', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('allow_script_urls', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('allow_unsafe_link_target', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('convert_fonts_to_spans', {\r\n        processor: 'boolean',\r\n        default: true,\r\n        deprecated: true\r\n      });\r\n      registerOption('fix_list_elements', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('preserve_cdata', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('remove_trailing_brs', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('pad_empty_with_br', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('inline_styles', {\r\n        processor: 'boolean',\r\n        default: true,\r\n        deprecated: true\r\n      });\r\n      registerOption('element_format', {\r\n        processor: 'string',\r\n        default: 'html'\r\n      });\r\n      registerOption('entities', { processor: 'string' });\r\n      registerOption('schema', {\r\n        processor: 'string',\r\n        default: 'html5'\r\n      });\r\n      registerOption('convert_urls', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('relative_urls', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('remove_script_host', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('custom_elements', { processor: 'string' });\r\n      registerOption('extended_valid_elements', { processor: 'string' });\r\n      registerOption('invalid_elements', { processor: 'string' });\r\n      registerOption('invalid_styles', { processor: stringOrObjectProcessor });\r\n      registerOption('valid_children', { processor: 'string' });\r\n      registerOption('valid_classes', { processor: stringOrObjectProcessor });\r\n      registerOption('valid_elements', { processor: 'string' });\r\n      registerOption('valid_styles', { processor: stringOrObjectProcessor });\r\n      registerOption('verify_html', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('auto_focus', { processor: value => isString(value) || value === true });\r\n      registerOption('browser_spellcheck', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('protect', { processor: 'array' });\r\n      registerOption('images_file_types', {\r\n        processor: 'string',\r\n        default: 'jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp'\r\n      });\r\n      registerOption('deprecation_warnings', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('a11y_advanced_options', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('api_key', { processor: 'string' });\r\n      registerOption('paste_block_drop', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('paste_data_images', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('paste_preprocess', { processor: 'function' });\r\n      registerOption('paste_postprocess', { processor: 'function' });\r\n      registerOption('paste_webkit_styles', {\r\n        processor: 'string',\r\n        default: 'none'\r\n      });\r\n      registerOption('paste_remove_styles_if_webkit', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('paste_merge_formats', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('smart_paste', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('paste_as_text', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('paste_tab_spaces', {\r\n        processor: 'number',\r\n        default: 4\r\n      });\r\n      registerOption('text_patterns', {\r\n        processor: value => {\r\n          if (isArrayOf(value, isObject) || value === false) {\r\n            const patterns = value === false ? [] : value;\r\n            return {\r\n              value: fromRawPatterns(patterns),\r\n              valid: true\r\n            };\r\n          } else {\r\n            return {\r\n              valid: false,\r\n              message: 'Must be an array of objects or false.'\r\n            };\r\n          }\r\n        },\r\n        default: [\r\n          {\r\n            start: '*',\r\n            end: '*',\r\n            format: 'italic'\r\n          },\r\n          {\r\n            start: '**',\r\n            end: '**',\r\n            format: 'bold'\r\n          },\r\n          {\r\n            start: '#',\r\n            format: 'h1'\r\n          },\r\n          {\r\n            start: '##',\r\n            format: 'h2'\r\n          },\r\n          {\r\n            start: '###',\r\n            format: 'h3'\r\n          },\r\n          {\r\n            start: '####',\r\n            format: 'h4'\r\n          },\r\n          {\r\n            start: '#####',\r\n            format: 'h5'\r\n          },\r\n          {\r\n            start: '######',\r\n            format: 'h6'\r\n          },\r\n          {\r\n            start: '1. ',\r\n            cmd: 'InsertOrderedList'\r\n          },\r\n          {\r\n            start: '* ',\r\n            cmd: 'InsertUnorderedList'\r\n          },\r\n          {\r\n            start: '- ',\r\n            cmd: 'InsertUnorderedList'\r\n          }\r\n        ]\r\n      });\r\n      registerOption('text_patterns_lookup', {\r\n        processor: value => {\r\n          if (isFunction(value)) {\r\n            return {\r\n              value: fromRawPatternsLookup(value),\r\n              valid: true\r\n            };\r\n          } else {\r\n            return {\r\n              valid: false,\r\n              message: 'Must be a single function'\r\n            };\r\n          }\r\n        },\r\n        default: _ctx => []\r\n      });\r\n      registerOption('noneditable_class', {\r\n        processor: 'string',\r\n        default: 'mceNonEditable'\r\n      });\r\n      registerOption('editable_class', {\r\n        processor: 'string',\r\n        default: 'mceEditable'\r\n      });\r\n      registerOption('noneditable_regexp', {\r\n        processor: value => {\r\n          if (isArrayOf(value, isRegExp)) {\r\n            return {\r\n              value,\r\n              valid: true\r\n            };\r\n          } else if (isRegExp(value)) {\r\n            return {\r\n              value: [value],\r\n              valid: true\r\n            };\r\n          } else {\r\n            return {\r\n              valid: false,\r\n              message: 'Must be a RegExp or an array of RegExp.'\r\n            };\r\n          }\r\n        },\r\n        default: []\r\n      });\r\n      registerOption('table_tab_navigation', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('highlight_on_focus', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('xss_sanitization', {\r\n        processor: 'boolean',\r\n        default: true\r\n      });\r\n      registerOption('details_initial_state', {\r\n        processor: value => {\r\n          const valid = contains$2([\r\n            'inherited',\r\n            'collapsed',\r\n            'expanded'\r\n          ], value);\r\n          return valid ? {\r\n            value,\r\n            valid\r\n          } : {\r\n            valid: false,\r\n            message: 'Must be one of: inherited, collapsed, or expanded.'\r\n          };\r\n        },\r\n        default: 'inherited'\r\n      });\r\n      registerOption('details_serialized_state', {\r\n        processor: value => {\r\n          const valid = contains$2([\r\n            'inherited',\r\n            'collapsed',\r\n            'expanded'\r\n          ], value);\r\n          return valid ? {\r\n            value,\r\n            valid\r\n          } : {\r\n            valid: false,\r\n            message: 'Must be one of: inherited, collapsed, or expanded.'\r\n          };\r\n        },\r\n        default: 'inherited'\r\n      });\r\n      registerOption('init_content_sync', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('newdocument_content', {\r\n        processor: 'string',\r\n        default: ''\r\n      });\r\n      registerOption('force_hex_color', {\r\n        processor: value => {\r\n          const options = [\r\n            'always',\r\n            'rgb_only',\r\n            'off'\r\n          ];\r\n          const valid = contains$2(options, value);\r\n          return valid ? {\r\n            value,\r\n            valid\r\n          } : {\r\n            valid: false,\r\n            message: `Must be one of: ${ options.join(', ') }.`\r\n          };\r\n        },\r\n        default: 'off'\r\n      });\r\n      registerOption('sandbox_iframes', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      registerOption('convert_unsafe_embeds', {\r\n        processor: 'boolean',\r\n        default: false\r\n      });\r\n      editor.on('ScriptsLoaded', () => {\r\n        registerOption('directionality', {\r\n          processor: 'string',\r\n          default: I18n.isRtl() ? 'rtl' : undefined\r\n        });\r\n        registerOption('placeholder', {\r\n          processor: 'string',\r\n          default: DOM$a.getAttrib(editor.getElement(), 'placeholder')\r\n        });\r\n      });\r\n    };\r\n    const getIframeAttrs = option('iframe_attrs');\r\n    const getDocType = option('doctype');\r\n    const getDocumentBaseUrl = option('document_base_url');\r\n    const getBodyId = option('body_id');\r\n    const getBodyClass = option('body_class');\r\n    const getContentSecurityPolicy = option('content_security_policy');\r\n    const shouldPutBrInPre$1 = option('br_in_pre');\r\n    const getForcedRootBlock = option('forced_root_block');\r\n    const getForcedRootBlockAttrs = option('forced_root_block_attrs');\r\n    const getNewlineBehavior = option('newline_behavior');\r\n    const getBrNewLineSelector = option('br_newline_selector');\r\n    const getNoNewLineSelector = option('no_newline_selector');\r\n    const shouldKeepStyles = option('keep_styles');\r\n    const shouldEndContainerOnEmptyBlock = option('end_container_on_empty_block');\r\n    const isAutomaticUploadsEnabled = option('automatic_uploads');\r\n    const shouldReuseFileName = option('images_reuse_filename');\r\n    const shouldReplaceBlobUris = option('images_replace_blob_uris');\r\n    const getIconPackName = option('icons');\r\n    const getIconsUrl = option('icons_url');\r\n    const getImageUploadUrl = option('images_upload_url');\r\n    const getImageUploadBasePath = option('images_upload_base_path');\r\n    const getImagesUploadCredentials = option('images_upload_credentials');\r\n    const getImagesUploadHandler = option('images_upload_handler');\r\n    const shouldUseContentCssCors = option('content_css_cors');\r\n    const getReferrerPolicy = option('referrer_policy');\r\n    const getLanguageCode = option('language');\r\n    const getLanguageUrl = option('language_url');\r\n    const shouldIndentUseMargin = option('indent_use_margin');\r\n    const getIndentation = option('indentation');\r\n    const getContentCss = option('content_css');\r\n    const getContentStyle = option('content_style');\r\n    const getFontCss = option('font_css');\r\n    const getDirectionality = option('directionality');\r\n    const getInlineBoundarySelector = option('inline_boundaries_selector');\r\n    const getObjectResizing = option('object_resizing');\r\n    const getResizeImgProportional = option('resize_img_proportional');\r\n    const getPlaceholder = option('placeholder');\r\n    const getEventRoot = option('event_root');\r\n    const getServiceMessage = option('service_message');\r\n    const getTheme = option('theme');\r\n    const getThemeUrl = option('theme_url');\r\n    const getModel = option('model');\r\n    const getModelUrl = option('model_url');\r\n    const isInlineBoundariesEnabled = option('inline_boundaries');\r\n    const getFormats = option('formats');\r\n    const getPreviewStyles = option('preview_styles');\r\n    const canFormatEmptyLines = option('format_empty_lines');\r\n    const getFormatNoneditableSelector = option('format_noneditable_selector');\r\n    const getCustomUiSelector = option('custom_ui_selector');\r\n    const isInline$1 = option('inline');\r\n    const hasHiddenInput = option('hidden_input');\r\n    const shouldPatchSubmit = option('submit_patch');\r\n    const shouldAddFormSubmitTrigger = option('add_form_submit_trigger');\r\n    const shouldAddUnloadTrigger = option('add_unload_trigger');\r\n    const getCustomUndoRedoLevels = option('custom_undo_redo_levels');\r\n    const shouldDisableNodeChange = option('disable_nodechange');\r\n    const isReadOnly$1 = option('readonly');\r\n    const hasEditableRoot$1 = option('editable_root');\r\n    const hasContentCssCors = option('content_css_cors');\r\n    const getPlugins = option('plugins');\r\n    const getExternalPlugins$1 = option('external_plugins');\r\n    const shouldBlockUnsupportedDrop = option('block_unsupported_drop');\r\n    const isVisualAidsEnabled = option('visual');\r\n    const getVisualAidsTableClass = option('visual_table_class');\r\n    const getVisualAidsAnchorClass = option('visual_anchor_class');\r\n    const getIframeAriaText = option('iframe_aria_text');\r\n    const getSetupCallback = option('setup');\r\n    const getInitInstanceCallback = option('init_instance_callback');\r\n    const getUrlConverterCallback = option('urlconverter_callback');\r\n    const getAutoFocus = option('auto_focus');\r\n    const shouldBrowserSpellcheck = option('browser_spellcheck');\r\n    const getProtect = option('protect');\r\n    const shouldPasteBlockDrop = option('paste_block_drop');\r\n    const shouldPasteDataImages = option('paste_data_images');\r\n    const getPastePreProcess = option('paste_preprocess');\r\n    const getPastePostProcess = option('paste_postprocess');\r\n    const getNewDocumentContent = option('newdocument_content');\r\n    const getPasteWebkitStyles = option('paste_webkit_styles');\r\n    const shouldPasteRemoveWebKitStyles = option('paste_remove_styles_if_webkit');\r\n    const shouldPasteMergeFormats = option('paste_merge_formats');\r\n    const isSmartPasteEnabled = option('smart_paste');\r\n    const isPasteAsTextEnabled = option('paste_as_text');\r\n    const getPasteTabSpaces = option('paste_tab_spaces');\r\n    const shouldAllowHtmlDataUrls = option('allow_html_data_urls');\r\n    const getTextPatterns = option('text_patterns');\r\n    const getTextPatternsLookup = option('text_patterns_lookup');\r\n    const getNonEditableClass = option('noneditable_class');\r\n    const getEditableClass = option('editable_class');\r\n    const getNonEditableRegExps = option('noneditable_regexp');\r\n    const shouldPreserveCData = option('preserve_cdata');\r\n    const shouldHighlightOnFocus = option('highlight_on_focus');\r\n    const shouldSanitizeXss = option('xss_sanitization');\r\n    const shouldUseDocumentWrite = option('init_content_sync');\r\n    const hasTextPatternsLookup = editor => editor.options.isSet('text_patterns_lookup');\r\n    const getFontStyleValues = editor => Tools.explode(editor.options.get('font_size_style_values'));\r\n    const getFontSizeClasses = editor => Tools.explode(editor.options.get('font_size_classes'));\r\n    const isEncodingXml = editor => editor.options.get('encoding') === 'xml';\r\n    const getAllowedImageFileTypes = editor => Tools.explode(editor.options.get('images_file_types'));\r\n    const hasTableTabNavigation = option('table_tab_navigation');\r\n    const getDetailsInitialState = option('details_initial_state');\r\n    const getDetailsSerializedState = option('details_serialized_state');\r\n    const shouldForceHexColor = option('force_hex_color');\r\n    const shouldSandboxIframes = option('sandbox_iframes');\r\n\r\n    const isElement$3 = isElement$6;\r\n    const isText$5 = isText$a;\r\n    const removeNode$1 = node => {\r\n      const parentNode = node.parentNode;\r\n      if (parentNode) {\r\n        parentNode.removeChild(node);\r\n      }\r\n    };\r\n    const trimCount = text => {\r\n      const trimmedText = trim$2(text);\r\n      return {\r\n        count: text.length - trimmedText.length,\r\n        text: trimmedText\r\n      };\r\n    };\r\n    const deleteZwspChars = caretContainer => {\r\n      let idx;\r\n      while ((idx = caretContainer.data.lastIndexOf(ZWSP$1)) !== -1) {\r\n        caretContainer.deleteData(idx, 1);\r\n      }\r\n    };\r\n    const removeUnchanged = (caretContainer, pos) => {\r\n      remove$3(caretContainer);\r\n      return pos;\r\n    };\r\n    const removeTextAndReposition = (caretContainer, pos) => {\r\n      const before = trimCount(caretContainer.data.substr(0, pos.offset()));\r\n      const after = trimCount(caretContainer.data.substr(pos.offset()));\r\n      const text = before.text + after.text;\r\n      if (text.length > 0) {\r\n        deleteZwspChars(caretContainer);\r\n        return CaretPosition(caretContainer, pos.offset() - before.count);\r\n      } else {\r\n        return pos;\r\n      }\r\n    };\r\n    const removeElementAndReposition = (caretContainer, pos) => {\r\n      const parentNode = pos.container();\r\n      const newPosition = indexOf$1(from(parentNode.childNodes), caretContainer).map(index => {\r\n        return index < pos.offset() ? CaretPosition(parentNode, pos.offset() - 1) : pos;\r\n      }).getOr(pos);\r\n      remove$3(caretContainer);\r\n      return newPosition;\r\n    };\r\n    const removeTextCaretContainer = (caretContainer, pos) => isText$5(caretContainer) && pos.container() === caretContainer ? removeTextAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\r\n    const removeElementCaretContainer = (caretContainer, pos) => pos.container() === caretContainer.parentNode ? removeElementAndReposition(caretContainer, pos) : removeUnchanged(caretContainer, pos);\r\n    const removeAndReposition = (container, pos) => CaretPosition.isTextPosition(pos) ? removeTextCaretContainer(container, pos) : removeElementCaretContainer(container, pos);\r\n    const remove$3 = caretContainerNode => {\r\n      if (isElement$3(caretContainerNode) && isCaretContainer$2(caretContainerNode)) {\r\n        if (hasContent(caretContainerNode)) {\r\n          caretContainerNode.removeAttribute('data-mce-caret');\r\n        } else {\r\n          removeNode$1(caretContainerNode);\r\n        }\r\n      }\r\n      if (isText$5(caretContainerNode)) {\r\n        deleteZwspChars(caretContainerNode);\r\n        if (caretContainerNode.data.length === 0) {\r\n          removeNode$1(caretContainerNode);\r\n        }\r\n      }\r\n    };\r\n\r\n    const isContentEditableFalse$8 = isContentEditableFalse$b;\r\n    const isMedia$1 = isMedia$2;\r\n    const isTableCell$1 = isTableCell$3;\r\n    const inlineFakeCaretSelector = '*[contentEditable=false],video,audio,embed,object';\r\n    const getAbsoluteClientRect = (root, element, before) => {\r\n      const clientRect = collapse(element.getBoundingClientRect(), before);\r\n      let scrollX;\r\n      let scrollY;\r\n      if (root.tagName === 'BODY') {\r\n        const docElm = root.ownerDocument.documentElement;\r\n        scrollX = root.scrollLeft || docElm.scrollLeft;\r\n        scrollY = root.scrollTop || docElm.scrollTop;\r\n      } else {\r\n        const rootRect = root.getBoundingClientRect();\r\n        scrollX = root.scrollLeft - rootRect.left;\r\n        scrollY = root.scrollTop - rootRect.top;\r\n      }\r\n      clientRect.left += scrollX;\r\n      clientRect.right += scrollX;\r\n      clientRect.top += scrollY;\r\n      clientRect.bottom += scrollY;\r\n      clientRect.width = 1;\r\n      let margin = element.offsetWidth - element.clientWidth;\r\n      if (margin > 0) {\r\n        if (before) {\r\n          margin *= -1;\r\n        }\r\n        clientRect.left += margin;\r\n        clientRect.right += margin;\r\n      }\r\n      return clientRect;\r\n    };\r\n    const trimInlineCaretContainers = root => {\r\n      var _a, _b;\r\n      const fakeCaretTargetNodes = descendants(SugarElement.fromDom(root), inlineFakeCaretSelector);\r\n      for (let i = 0; i < fakeCaretTargetNodes.length; i++) {\r\n        const node = fakeCaretTargetNodes[i].dom;\r\n        let sibling = node.previousSibling;\r\n        if (endsWithCaretContainer$1(sibling)) {\r\n          const data = sibling.data;\r\n          if (data.length === 1) {\r\n            (_a = sibling.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(sibling);\r\n          } else {\r\n            sibling.deleteData(data.length - 1, 1);\r\n          }\r\n        }\r\n        sibling = node.nextSibling;\r\n        if (startsWithCaretContainer$1(sibling)) {\r\n          const data = sibling.data;\r\n          if (data.length === 1) {\r\n            (_b = sibling.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(sibling);\r\n          } else {\r\n            sibling.deleteData(0, 1);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    const FakeCaret = (editor, root, isBlock, hasFocus) => {\r\n      const lastVisualCaret = value$2();\r\n      let cursorInterval;\r\n      let caretContainerNode;\r\n      const caretBlock = getForcedRootBlock(editor);\r\n      const dom = editor.dom;\r\n      const show = (before, element) => {\r\n        let rng;\r\n        hide();\r\n        if (isTableCell$1(element)) {\r\n          return null;\r\n        }\r\n        if (isBlock(element)) {\r\n          const caretContainer = insertBlock(caretBlock, element, before);\r\n          const clientRect = getAbsoluteClientRect(root, element, before);\r\n          dom.setStyle(caretContainer, 'top', clientRect.top);\r\n          caretContainerNode = caretContainer;\r\n          const caret = dom.create('div', {\r\n            'class': 'mce-visual-caret',\r\n            'data-mce-bogus': 'all'\r\n          });\r\n          dom.setStyles(caret, { ...clientRect });\r\n          dom.add(root, caret);\r\n          lastVisualCaret.set({\r\n            caret,\r\n            element,\r\n            before\r\n          });\r\n          if (before) {\r\n            dom.addClass(caret, 'mce-visual-caret-before');\r\n          }\r\n          startBlink();\r\n          rng = element.ownerDocument.createRange();\r\n          rng.setStart(caretContainer, 0);\r\n          rng.setEnd(caretContainer, 0);\r\n        } else {\r\n          caretContainerNode = insertInline$1(element, before);\r\n          rng = element.ownerDocument.createRange();\r\n          if (isInlineFakeCaretTarget(caretContainerNode.nextSibling)) {\r\n            rng.setStart(caretContainerNode, 0);\r\n            rng.setEnd(caretContainerNode, 0);\r\n          } else {\r\n            rng.setStart(caretContainerNode, 1);\r\n            rng.setEnd(caretContainerNode, 1);\r\n          }\r\n          return rng;\r\n        }\r\n        return rng;\r\n      };\r\n      const hide = () => {\r\n        trimInlineCaretContainers(root);\r\n        if (caretContainerNode) {\r\n          remove$3(caretContainerNode);\r\n          caretContainerNode = null;\r\n        }\r\n        lastVisualCaret.on(caretState => {\r\n          dom.remove(caretState.caret);\r\n          lastVisualCaret.clear();\r\n        });\r\n        if (cursorInterval) {\r\n          clearInterval(cursorInterval);\r\n          cursorInterval = undefined;\r\n        }\r\n      };\r\n      const startBlink = () => {\r\n        cursorInterval = setInterval(() => {\r\n          lastVisualCaret.on(caretState => {\r\n            if (hasFocus()) {\r\n              dom.toggleClass(caretState.caret, 'mce-visual-caret-hidden');\r\n            } else {\r\n              dom.addClass(caretState.caret, 'mce-visual-caret-hidden');\r\n            }\r\n          });\r\n        }, 500);\r\n      };\r\n      const reposition = () => {\r\n        lastVisualCaret.on(caretState => {\r\n          const clientRect = getAbsoluteClientRect(root, caretState.element, caretState.before);\r\n          dom.setStyles(caretState.caret, { ...clientRect });\r\n        });\r\n      };\r\n      const destroy = () => clearInterval(cursorInterval);\r\n      const getCss = () => '.mce-visual-caret {' + 'position: absolute;' + 'background-color: black;' + 'background-color: currentcolor;' + '}' + '.mce-visual-caret-hidden {' + 'display: none;' + '}' + '*[data-mce-caret] {' + 'position: absolute;' + 'left: -1000px;' + 'right: auto;' + 'top: 0;' + 'margin: 0;' + 'padding: 0;' + '}';\r\n      return {\r\n        show,\r\n        hide,\r\n        getCss,\r\n        reposition,\r\n        destroy\r\n      };\r\n    };\r\n    const isFakeCaretTableBrowser = () => Env.browser.isFirefox();\r\n    const isInlineFakeCaretTarget = node => isContentEditableFalse$8(node) || isMedia$1(node);\r\n    const isFakeCaretTarget = node => {\r\n      const isTarget = isInlineFakeCaretTarget(node) || isTable$2(node) && isFakeCaretTableBrowser();\r\n      return isTarget && parentElement(SugarElement.fromDom(node)).exists(isEditable$2);\r\n    };\r\n\r\n    const isContentEditableTrue$1 = isContentEditableTrue$3;\r\n    const isContentEditableFalse$7 = isContentEditableFalse$b;\r\n    const isMedia = isMedia$2;\r\n    const isBlockLike = matchStyleValues('display', 'block table table-cell table-caption list-item');\r\n    const isCaretContainer = isCaretContainer$2;\r\n    const isCaretContainerBlock = isCaretContainerBlock$1;\r\n    const isElement$2 = isElement$6;\r\n    const isText$4 = isText$a;\r\n    const isCaretCandidate$1 = isCaretCandidate$3;\r\n    const isForwards = direction => direction > 0;\r\n    const isBackwards = direction => direction < 0;\r\n    const skipCaretContainers = (walk, shallow) => {\r\n      let node;\r\n      while (node = walk(shallow)) {\r\n        if (!isCaretContainerBlock(node)) {\r\n          return node;\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    const findNode = (node, direction, predicateFn, rootNode, shallow) => {\r\n      const walker = new DomTreeWalker(node, rootNode);\r\n      const isCefOrCaretContainer = isContentEditableFalse$7(node) || isCaretContainerBlock(node);\r\n      let tempNode;\r\n      if (isBackwards(direction)) {\r\n        if (isCefOrCaretContainer) {\r\n          tempNode = skipCaretContainers(walker.prev.bind(walker), true);\r\n          if (predicateFn(tempNode)) {\r\n            return tempNode;\r\n          }\r\n        }\r\n        while (tempNode = skipCaretContainers(walker.prev.bind(walker), shallow)) {\r\n          if (predicateFn(tempNode)) {\r\n            return tempNode;\r\n          }\r\n        }\r\n      }\r\n      if (isForwards(direction)) {\r\n        if (isCefOrCaretContainer) {\r\n          tempNode = skipCaretContainers(walker.next.bind(walker), true);\r\n          if (predicateFn(tempNode)) {\r\n            return tempNode;\r\n          }\r\n        }\r\n        while (tempNode = skipCaretContainers(walker.next.bind(walker), shallow)) {\r\n          if (predicateFn(tempNode)) {\r\n            return tempNode;\r\n          }\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    const getEditingHost = (node, rootNode) => {\r\n      const isCETrue = node => isContentEditableTrue$1(node.dom);\r\n      const isRoot = node => node.dom === rootNode;\r\n      return ancestor$4(SugarElement.fromDom(node), isCETrue, isRoot).map(elm => elm.dom).getOr(rootNode);\r\n    };\r\n    const getParentBlock$3 = (node, rootNode) => {\r\n      while (node && node !== rootNode) {\r\n        if (isBlockLike(node)) {\r\n          return node;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n    const isInSameBlock = (caretPosition1, caretPosition2, rootNode) => getParentBlock$3(caretPosition1.container(), rootNode) === getParentBlock$3(caretPosition2.container(), rootNode);\r\n    const getChildNodeAtRelativeOffset = (relativeOffset, caretPosition) => {\r\n      if (!caretPosition) {\r\n        return Optional.none();\r\n      }\r\n      const container = caretPosition.container();\r\n      const offset = caretPosition.offset();\r\n      if (!isElement$2(container)) {\r\n        return Optional.none();\r\n      }\r\n      return Optional.from(container.childNodes[offset + relativeOffset]);\r\n    };\r\n    const beforeAfter = (before, node) => {\r\n      var _a;\r\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\r\n      const range = doc.createRange();\r\n      if (before) {\r\n        range.setStartBefore(node);\r\n        range.setEndBefore(node);\r\n      } else {\r\n        range.setStartAfter(node);\r\n        range.setEndAfter(node);\r\n      }\r\n      return range;\r\n    };\r\n    const isNodesInSameBlock = (root, node1, node2) => getParentBlock$3(node1, root) === getParentBlock$3(node2, root);\r\n    const lean = (left, root, node) => {\r\n      const siblingName = left ? 'previousSibling' : 'nextSibling';\r\n      let tempNode = node;\r\n      while (tempNode && tempNode !== root) {\r\n        let sibling = tempNode[siblingName];\r\n        if (sibling && isCaretContainer(sibling)) {\r\n          sibling = sibling[siblingName];\r\n        }\r\n        if (isContentEditableFalse$7(sibling) || isMedia(sibling)) {\r\n          if (isNodesInSameBlock(root, sibling, tempNode)) {\r\n            return sibling;\r\n          }\r\n          break;\r\n        }\r\n        if (isCaretCandidate$1(sibling)) {\r\n          break;\r\n        }\r\n        tempNode = tempNode.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n    const before$2 = curry(beforeAfter, true);\r\n    const after$2 = curry(beforeAfter, false);\r\n    const normalizeRange = (direction, root, range) => {\r\n      let node;\r\n      const leanLeft = curry(lean, true, root);\r\n      const leanRight = curry(lean, false, root);\r\n      const container = range.startContainer;\r\n      const offset = range.startOffset;\r\n      if (isCaretContainerBlock$1(container)) {\r\n        const block = isText$4(container) ? container.parentNode : container;\r\n        const location = block.getAttribute('data-mce-caret');\r\n        if (location === 'before') {\r\n          node = block.nextSibling;\r\n          if (isFakeCaretTarget(node)) {\r\n            return before$2(node);\r\n          }\r\n        }\r\n        if (location === 'after') {\r\n          node = block.previousSibling;\r\n          if (isFakeCaretTarget(node)) {\r\n            return after$2(node);\r\n          }\r\n        }\r\n      }\r\n      if (!range.collapsed) {\r\n        return range;\r\n      }\r\n      if (isText$a(container)) {\r\n        if (isCaretContainer(container)) {\r\n          if (direction === 1) {\r\n            node = leanRight(container);\r\n            if (node) {\r\n              return before$2(node);\r\n            }\r\n            node = leanLeft(container);\r\n            if (node) {\r\n              return after$2(node);\r\n            }\r\n          }\r\n          if (direction === -1) {\r\n            node = leanLeft(container);\r\n            if (node) {\r\n              return after$2(node);\r\n            }\r\n            node = leanRight(container);\r\n            if (node) {\r\n              return before$2(node);\r\n            }\r\n          }\r\n          return range;\r\n        }\r\n        if (endsWithCaretContainer$1(container) && offset >= container.data.length - 1) {\r\n          if (direction === 1) {\r\n            node = leanRight(container);\r\n            if (node) {\r\n              return before$2(node);\r\n            }\r\n          }\r\n          return range;\r\n        }\r\n        if (startsWithCaretContainer$1(container) && offset <= 1) {\r\n          if (direction === -1) {\r\n            node = leanLeft(container);\r\n            if (node) {\r\n              return after$2(node);\r\n            }\r\n          }\r\n          return range;\r\n        }\r\n        if (offset === container.data.length) {\r\n          node = leanRight(container);\r\n          if (node) {\r\n            return before$2(node);\r\n          }\r\n          return range;\r\n        }\r\n        if (offset === 0) {\r\n          node = leanLeft(container);\r\n          if (node) {\r\n            return after$2(node);\r\n          }\r\n          return range;\r\n        }\r\n      }\r\n      return range;\r\n    };\r\n    const getRelativeCefElm = (forward, caretPosition) => getChildNodeAtRelativeOffset(forward ? 0 : -1, caretPosition).filter(isContentEditableFalse$7);\r\n    const getNormalizedRangeEndPoint = (direction, root, range) => {\r\n      const normalizedRange = normalizeRange(direction, root, range);\r\n      return direction === -1 ? CaretPosition.fromRangeStart(normalizedRange) : CaretPosition.fromRangeEnd(normalizedRange);\r\n    };\r\n    const getElementFromPosition = pos => Optional.from(pos.getNode()).map(SugarElement.fromDom);\r\n    const getElementFromPrevPosition = pos => Optional.from(pos.getNode(true)).map(SugarElement.fromDom);\r\n    const getVisualCaretPosition = (walkFn, caretPosition) => {\r\n      let pos = caretPosition;\r\n      while (pos = walkFn(pos)) {\r\n        if (pos.isVisible()) {\r\n          return pos;\r\n        }\r\n      }\r\n      return pos;\r\n    };\r\n    const isMoveInsideSameBlock = (from, to) => {\r\n      const inSameBlock = isInSameBlock(from, to);\r\n      if (!inSameBlock && isBr$6(from.getNode())) {\r\n        return true;\r\n      }\r\n      return inSameBlock;\r\n    };\r\n\r\n    var HDirection;\r\n    (function (HDirection) {\r\n      HDirection[HDirection['Backwards'] = -1] = 'Backwards';\r\n      HDirection[HDirection['Forwards'] = 1] = 'Forwards';\r\n    }(HDirection || (HDirection = {})));\r\n    const isContentEditableFalse$6 = isContentEditableFalse$b;\r\n    const isText$3 = isText$a;\r\n    const isElement$1 = isElement$6;\r\n    const isBr$2 = isBr$6;\r\n    const isCaretCandidate = isCaretCandidate$3;\r\n    const isAtomic = isAtomic$1;\r\n    const isEditableCaretCandidate = isEditableCaretCandidate$1;\r\n    const getParents$3 = (node, root) => {\r\n      const parents = [];\r\n      let tempNode = node;\r\n      while (tempNode && tempNode !== root) {\r\n        parents.push(tempNode);\r\n        tempNode = tempNode.parentNode;\r\n      }\r\n      return parents;\r\n    };\r\n    const nodeAtIndex = (container, offset) => {\r\n      if (container.hasChildNodes() && offset < container.childNodes.length) {\r\n        return container.childNodes[offset];\r\n      }\r\n      return null;\r\n    };\r\n    const getCaretCandidatePosition = (direction, node) => {\r\n      if (isForwards(direction)) {\r\n        if (isCaretCandidate(node.previousSibling) && !isText$3(node.previousSibling)) {\r\n          return CaretPosition.before(node);\r\n        }\r\n        if (isText$3(node)) {\r\n          return CaretPosition(node, 0);\r\n        }\r\n      }\r\n      if (isBackwards(direction)) {\r\n        if (isCaretCandidate(node.nextSibling) && !isText$3(node.nextSibling)) {\r\n          return CaretPosition.after(node);\r\n        }\r\n        if (isText$3(node)) {\r\n          return CaretPosition(node, node.data.length);\r\n        }\r\n      }\r\n      if (isBackwards(direction)) {\r\n        if (isBr$2(node)) {\r\n          return CaretPosition.before(node);\r\n        }\r\n        return CaretPosition.after(node);\r\n      }\r\n      return CaretPosition.before(node);\r\n    };\r\n    const moveForwardFromBr = (root, nextNode) => {\r\n      const nextSibling = nextNode.nextSibling;\r\n      if (nextSibling && isCaretCandidate(nextSibling)) {\r\n        if (isText$3(nextSibling)) {\r\n          return CaretPosition(nextSibling, 0);\r\n        } else {\r\n          return CaretPosition.before(nextSibling);\r\n        }\r\n      } else {\r\n        return findCaretPosition$1(HDirection.Forwards, CaretPosition.after(nextNode), root);\r\n      }\r\n    };\r\n    const findCaretPosition$1 = (direction, startPos, root) => {\r\n      let node;\r\n      let nextNode;\r\n      let innerNode;\r\n      let caretPosition;\r\n      if (!isElement$1(root) || !startPos) {\r\n        return null;\r\n      }\r\n      if (startPos.isEqual(CaretPosition.after(root)) && root.lastChild) {\r\n        caretPosition = CaretPosition.after(root.lastChild);\r\n        if (isBackwards(direction) && isCaretCandidate(root.lastChild) && isElement$1(root.lastChild)) {\r\n          return isBr$2(root.lastChild) ? CaretPosition.before(root.lastChild) : caretPosition;\r\n        }\r\n      } else {\r\n        caretPosition = startPos;\r\n      }\r\n      const container = caretPosition.container();\r\n      let offset = caretPosition.offset();\r\n      if (isText$3(container)) {\r\n        if (isBackwards(direction) && offset > 0) {\r\n          return CaretPosition(container, --offset);\r\n        }\r\n        if (isForwards(direction) && offset < container.length) {\r\n          return CaretPosition(container, ++offset);\r\n        }\r\n        node = container;\r\n      } else {\r\n        if (isBackwards(direction) && offset > 0) {\r\n          nextNode = nodeAtIndex(container, offset - 1);\r\n          if (isCaretCandidate(nextNode)) {\r\n            if (!isAtomic(nextNode)) {\r\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\r\n              if (innerNode) {\r\n                if (isText$3(innerNode)) {\r\n                  return CaretPosition(innerNode, innerNode.data.length);\r\n                }\r\n                return CaretPosition.after(innerNode);\r\n              }\r\n            }\r\n            if (isText$3(nextNode)) {\r\n              return CaretPosition(nextNode, nextNode.data.length);\r\n            }\r\n            return CaretPosition.before(nextNode);\r\n          }\r\n        }\r\n        if (isForwards(direction) && offset < container.childNodes.length) {\r\n          nextNode = nodeAtIndex(container, offset);\r\n          if (isCaretCandidate(nextNode)) {\r\n            if (isBr$2(nextNode)) {\r\n              return moveForwardFromBr(root, nextNode);\r\n            }\r\n            if (!isAtomic(nextNode)) {\r\n              innerNode = findNode(nextNode, direction, isEditableCaretCandidate, nextNode);\r\n              if (innerNode) {\r\n                if (isText$3(innerNode)) {\r\n                  return CaretPosition(innerNode, 0);\r\n                }\r\n                return CaretPosition.before(innerNode);\r\n              }\r\n            }\r\n            if (isText$3(nextNode)) {\r\n              return CaretPosition(nextNode, 0);\r\n            }\r\n            return CaretPosition.after(nextNode);\r\n          }\r\n        }\r\n        node = nextNode ? nextNode : caretPosition.getNode();\r\n      }\r\n      if (node && (isForwards(direction) && caretPosition.isAtEnd() || isBackwards(direction) && caretPosition.isAtStart())) {\r\n        node = findNode(node, direction, always, root, true);\r\n        if (isEditableCaretCandidate(node, root)) {\r\n          return getCaretCandidatePosition(direction, node);\r\n        }\r\n      }\r\n      nextNode = node ? findNode(node, direction, isEditableCaretCandidate, root) : node;\r\n      const rootContentEditableFalseElm = last$2(filter$5(getParents$3(container, root), isContentEditableFalse$6));\r\n      if (rootContentEditableFalseElm && (!nextNode || !rootContentEditableFalseElm.contains(nextNode))) {\r\n        if (isForwards(direction)) {\r\n          caretPosition = CaretPosition.after(rootContentEditableFalseElm);\r\n        } else {\r\n          caretPosition = CaretPosition.before(rootContentEditableFalseElm);\r\n        }\r\n        return caretPosition;\r\n      }\r\n      if (nextNode) {\r\n        return getCaretCandidatePosition(direction, nextNode);\r\n      }\r\n      return null;\r\n    };\r\n    const CaretWalker = root => ({\r\n      next: caretPosition => {\r\n        return findCaretPosition$1(HDirection.Forwards, caretPosition, root);\r\n      },\r\n      prev: caretPosition => {\r\n        return findCaretPosition$1(HDirection.Backwards, caretPosition, root);\r\n      }\r\n    });\r\n\r\n    const walkToPositionIn = (forward, root, start) => {\r\n      const position = forward ? CaretPosition.before(start) : CaretPosition.after(start);\r\n      return fromPosition(forward, root, position);\r\n    };\r\n    const afterElement = node => isBr$6(node) ? CaretPosition.before(node) : CaretPosition.after(node);\r\n    const isBeforeOrStart = position => {\r\n      if (CaretPosition.isTextPosition(position)) {\r\n        return position.offset() === 0;\r\n      } else {\r\n        return isCaretCandidate$3(position.getNode());\r\n      }\r\n    };\r\n    const isAfterOrEnd = position => {\r\n      if (CaretPosition.isTextPosition(position)) {\r\n        const container = position.container();\r\n        return position.offset() === container.data.length;\r\n      } else {\r\n        return isCaretCandidate$3(position.getNode(true));\r\n      }\r\n    };\r\n    const isBeforeAfterSameElement = (from, to) => !CaretPosition.isTextPosition(from) && !CaretPosition.isTextPosition(to) && from.getNode() === to.getNode(true);\r\n    const isAtBr = position => !CaretPosition.isTextPosition(position) && isBr$6(position.getNode());\r\n    const shouldSkipPosition = (forward, from, to) => {\r\n      if (forward) {\r\n        return !isBeforeAfterSameElement(from, to) && !isAtBr(from) && isAfterOrEnd(from) && isBeforeOrStart(to);\r\n      } else {\r\n        return !isBeforeAfterSameElement(to, from) && isBeforeOrStart(from) && isAfterOrEnd(to);\r\n      }\r\n    };\r\n    const fromPosition = (forward, root, pos) => {\r\n      const walker = CaretWalker(root);\r\n      return Optional.from(forward ? walker.next(pos) : walker.prev(pos));\r\n    };\r\n    const navigate = (forward, root, from) => fromPosition(forward, root, from).bind(to => {\r\n      if (isInSameBlock(from, to, root) && shouldSkipPosition(forward, from, to)) {\r\n        return fromPosition(forward, root, to);\r\n      } else {\r\n        return Optional.some(to);\r\n      }\r\n    });\r\n    const navigateIgnore = (forward, root, from, ignoreFilter) => navigate(forward, root, from).bind(pos => ignoreFilter(pos) ? navigateIgnore(forward, root, pos, ignoreFilter) : Optional.some(pos));\r\n    const positionIn = (forward, element) => {\r\n      const startNode = forward ? element.firstChild : element.lastChild;\r\n      if (isText$a(startNode)) {\r\n        return Optional.some(CaretPosition(startNode, forward ? 0 : startNode.data.length));\r\n      } else if (startNode) {\r\n        if (isCaretCandidate$3(startNode)) {\r\n          return Optional.some(forward ? CaretPosition.before(startNode) : afterElement(startNode));\r\n        } else {\r\n          return walkToPositionIn(forward, element, startNode);\r\n        }\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const nextPosition = curry(fromPosition, true);\r\n    const prevPosition = curry(fromPosition, false);\r\n    const firstPositionIn = curry(positionIn, true);\r\n    const lastPositionIn = curry(positionIn, false);\r\n\r\n    const CARET_ID = '_mce_caret';\r\n    const isCaretNode = node => isElement$6(node) && node.id === CARET_ID;\r\n    const getParentCaretContainer = (body, node) => {\r\n      let currentNode = node;\r\n      while (currentNode && currentNode !== body) {\r\n        if (isCaretNode(currentNode)) {\r\n          return currentNode;\r\n        }\r\n        currentNode = currentNode.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n\r\n    const isStringPathBookmark = bookmark => isString(bookmark.start);\r\n    const isRangeBookmark = bookmark => has$2(bookmark, 'rng');\r\n    const isIdBookmark = bookmark => has$2(bookmark, 'id');\r\n    const isIndexBookmark = bookmark => has$2(bookmark, 'name');\r\n    const isPathBookmark = bookmark => Tools.isArray(bookmark.start);\r\n\r\n    const isForwardBookmark = bookmark => !isIndexBookmark(bookmark) && isBoolean(bookmark.forward) ? bookmark.forward : true;\r\n    const addBogus = (dom, node) => {\r\n      if (isElement$6(node) && dom.isBlock(node) && !node.innerHTML) {\r\n        node.innerHTML = '<br data-mce-bogus=\"1\" />';\r\n      }\r\n      return node;\r\n    };\r\n    const resolveCaretPositionBookmark = (dom, bookmark) => {\r\n      const startPos = Optional.from(resolve$1(dom.getRoot(), bookmark.start));\r\n      const endPos = Optional.from(resolve$1(dom.getRoot(), bookmark.end));\r\n      return lift2(startPos, endPos, (start, end) => {\r\n        const range = dom.createRng();\r\n        range.setStart(start.container(), start.offset());\r\n        range.setEnd(end.container(), end.offset());\r\n        return {\r\n          range,\r\n          forward: isForwardBookmark(bookmark)\r\n        };\r\n      });\r\n    };\r\n    const insertZwsp = (node, rng) => {\r\n      var _a;\r\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\r\n      const textNode = doc.createTextNode(ZWSP$1);\r\n      node.appendChild(textNode);\r\n      rng.setStart(textNode, 0);\r\n      rng.setEnd(textNode, 0);\r\n    };\r\n    const isEmpty$1 = node => !node.hasChildNodes();\r\n    const tryFindRangePosition = (node, rng) => lastPositionIn(node).fold(never, pos => {\r\n      rng.setStart(pos.container(), pos.offset());\r\n      rng.setEnd(pos.container(), pos.offset());\r\n      return true;\r\n    });\r\n    const padEmptyCaretContainer = (root, node, rng) => {\r\n      if (isEmpty$1(node) && getParentCaretContainer(root, node)) {\r\n        insertZwsp(node, rng);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const setEndPoint = (dom, start, bookmark, rng) => {\r\n      const point = bookmark[start ? 'start' : 'end'];\r\n      const root = dom.getRoot();\r\n      if (point) {\r\n        let node = root;\r\n        let offset = point[0];\r\n        for (let i = point.length - 1; node && i >= 1; i--) {\r\n          const children = node.childNodes;\r\n          if (padEmptyCaretContainer(root, node, rng)) {\r\n            return true;\r\n          }\r\n          if (point[i] > children.length - 1) {\r\n            if (padEmptyCaretContainer(root, node, rng)) {\r\n              return true;\r\n            }\r\n            return tryFindRangePosition(node, rng);\r\n          }\r\n          node = children[point[i]];\r\n        }\r\n        if (isText$a(node)) {\r\n          offset = Math.min(point[0], node.data.length);\r\n        }\r\n        if (isElement$6(node)) {\r\n          offset = Math.min(point[0], node.childNodes.length);\r\n        }\r\n        if (start) {\r\n          rng.setStart(node, offset);\r\n        } else {\r\n          rng.setEnd(node, offset);\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    const isValidTextNode = node => isText$a(node) && node.data.length > 0;\r\n    const restoreEndPoint = (dom, suffix, bookmark) => {\r\n      const marker = dom.get(bookmark.id + '_' + suffix);\r\n      const markerParent = marker === null || marker === void 0 ? void 0 : marker.parentNode;\r\n      const keep = bookmark.keep;\r\n      if (marker && markerParent) {\r\n        let container;\r\n        let offset;\r\n        if (suffix === 'start') {\r\n          if (!keep) {\r\n            container = markerParent;\r\n            offset = dom.nodeIndex(marker);\r\n          } else {\r\n            if (marker.hasChildNodes()) {\r\n              container = marker.firstChild;\r\n              offset = 1;\r\n            } else if (isValidTextNode(marker.nextSibling)) {\r\n              container = marker.nextSibling;\r\n              offset = 0;\r\n            } else if (isValidTextNode(marker.previousSibling)) {\r\n              container = marker.previousSibling;\r\n              offset = marker.previousSibling.data.length;\r\n            } else {\r\n              container = markerParent;\r\n              offset = dom.nodeIndex(marker) + 1;\r\n            }\r\n          }\r\n        } else {\r\n          if (!keep) {\r\n            container = markerParent;\r\n            offset = dom.nodeIndex(marker);\r\n          } else {\r\n            if (marker.hasChildNodes()) {\r\n              container = marker.firstChild;\r\n              offset = 1;\r\n            } else if (isValidTextNode(marker.previousSibling)) {\r\n              container = marker.previousSibling;\r\n              offset = marker.previousSibling.data.length;\r\n            } else {\r\n              container = markerParent;\r\n              offset = dom.nodeIndex(marker);\r\n            }\r\n          }\r\n        }\r\n        if (!keep) {\r\n          const prev = marker.previousSibling;\r\n          const next = marker.nextSibling;\r\n          Tools.each(Tools.grep(marker.childNodes), node => {\r\n            if (isText$a(node)) {\r\n              node.data = node.data.replace(/\\uFEFF/g, '');\r\n            }\r\n          });\r\n          let otherMarker;\r\n          while (otherMarker = dom.get(bookmark.id + '_' + suffix)) {\r\n            dom.remove(otherMarker, true);\r\n          }\r\n          if (isText$a(next) && isText$a(prev) && !Env.browser.isOpera()) {\r\n            const idx = prev.data.length;\r\n            prev.appendData(next.data);\r\n            dom.remove(next);\r\n            container = prev;\r\n            offset = idx;\r\n          }\r\n        }\r\n        return Optional.some(CaretPosition(container, offset));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const resolvePaths = (dom, bookmark) => {\r\n      const range = dom.createRng();\r\n      if (setEndPoint(dom, true, bookmark, range) && setEndPoint(dom, false, bookmark, range)) {\r\n        return Optional.some({\r\n          range,\r\n          forward: isForwardBookmark(bookmark)\r\n        });\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const resolveId = (dom, bookmark) => {\r\n      const startPos = restoreEndPoint(dom, 'start', bookmark);\r\n      const endPos = restoreEndPoint(dom, 'end', bookmark);\r\n      return lift2(startPos, endPos.or(startPos), (spos, epos) => {\r\n        const range = dom.createRng();\r\n        range.setStart(addBogus(dom, spos.container()), spos.offset());\r\n        range.setEnd(addBogus(dom, epos.container()), epos.offset());\r\n        return {\r\n          range,\r\n          forward: isForwardBookmark(bookmark)\r\n        };\r\n      });\r\n    };\r\n    const resolveIndex = (dom, bookmark) => Optional.from(dom.select(bookmark.name)[bookmark.index]).map(elm => {\r\n      const range = dom.createRng();\r\n      range.selectNode(elm);\r\n      return {\r\n        range,\r\n        forward: true\r\n      };\r\n    });\r\n    const resolve = (selection, bookmark) => {\r\n      const dom = selection.dom;\r\n      if (bookmark) {\r\n        if (isPathBookmark(bookmark)) {\r\n          return resolvePaths(dom, bookmark);\r\n        } else if (isStringPathBookmark(bookmark)) {\r\n          return resolveCaretPositionBookmark(dom, bookmark);\r\n        } else if (isIdBookmark(bookmark)) {\r\n          return resolveId(dom, bookmark);\r\n        } else if (isIndexBookmark(bookmark)) {\r\n          return resolveIndex(dom, bookmark);\r\n        } else if (isRangeBookmark(bookmark)) {\r\n          return Optional.some({\r\n            range: bookmark.rng,\r\n            forward: isForwardBookmark(bookmark)\r\n          });\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n\r\n    const getBookmark$1 = (selection, type, normalized) => {\r\n      return getBookmark$2(selection, type, normalized);\r\n    };\r\n    const moveToBookmark = (selection, bookmark) => {\r\n      resolve(selection, bookmark).each(({range, forward}) => {\r\n        selection.setRng(range, forward);\r\n      });\r\n    };\r\n    const isBookmarkNode$1 = node => {\r\n      return isElement$6(node) && node.tagName === 'SPAN' && node.getAttribute('data-mce-type') === 'bookmark';\r\n    };\r\n\r\n    const is = expected => actual => expected === actual;\r\n    const isNbsp = is(nbsp);\r\n    const isWhiteSpace = chr => chr !== '' && ' \\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\r\n    const isContent = chr => !isWhiteSpace(chr) && !isNbsp(chr) && !isZwsp$2(chr);\r\n\r\n    const getRanges$1 = selection => {\r\n      const ranges = [];\r\n      if (selection) {\r\n        for (let i = 0; i < selection.rangeCount; i++) {\r\n          ranges.push(selection.getRangeAt(i));\r\n        }\r\n      }\r\n      return ranges;\r\n    };\r\n    const getSelectedNodes = ranges => {\r\n      return bind$3(ranges, range => {\r\n        const node = getSelectedNode(range);\r\n        return node ? [SugarElement.fromDom(node)] : [];\r\n      });\r\n    };\r\n    const hasMultipleRanges = selection => {\r\n      return getRanges$1(selection).length > 1;\r\n    };\r\n\r\n    const getCellsFromRanges = ranges => filter$5(getSelectedNodes(ranges), isTableCell$2);\r\n    const getCellsFromElement = elm => descendants(elm, 'td[data-mce-selected],th[data-mce-selected]');\r\n    const getCellsFromElementOrRanges = (ranges, element) => {\r\n      const selectedCells = getCellsFromElement(element);\r\n      return selectedCells.length > 0 ? selectedCells : getCellsFromRanges(ranges);\r\n    };\r\n    const getCellsFromEditor = editor => getCellsFromElementOrRanges(getRanges$1(editor.selection.getSel()), SugarElement.fromDom(editor.getBody()));\r\n    const getClosestTable = (cell, isRoot) => ancestor$3(cell, 'table', isRoot);\r\n\r\n    const getStartNode = rng => {\r\n      const sc = rng.startContainer, so = rng.startOffset;\r\n      if (isText$a(sc)) {\r\n        return so === 0 ? Optional.some(SugarElement.fromDom(sc)) : Optional.none();\r\n      } else {\r\n        return Optional.from(sc.childNodes[so]).map(SugarElement.fromDom);\r\n      }\r\n    };\r\n    const getEndNode = rng => {\r\n      const ec = rng.endContainer, eo = rng.endOffset;\r\n      if (isText$a(ec)) {\r\n        return eo === ec.data.length ? Optional.some(SugarElement.fromDom(ec)) : Optional.none();\r\n      } else {\r\n        return Optional.from(ec.childNodes[eo - 1]).map(SugarElement.fromDom);\r\n      }\r\n    };\r\n    const getFirstChildren = node => {\r\n      return firstChild(node).fold(constant([node]), child => {\r\n        return [node].concat(getFirstChildren(child));\r\n      });\r\n    };\r\n    const getLastChildren = node => {\r\n      return lastChild(node).fold(constant([node]), child => {\r\n        if (name(child) === 'br') {\r\n          return prevSibling(child).map(sibling => {\r\n            return [node].concat(getLastChildren(sibling));\r\n          }).getOr([]);\r\n        } else {\r\n          return [node].concat(getLastChildren(child));\r\n        }\r\n      });\r\n    };\r\n    const hasAllContentsSelected = (elm, rng) => {\r\n      return lift2(getStartNode(rng), getEndNode(rng), (startNode, endNode) => {\r\n        const start = find$2(getFirstChildren(elm), curry(eq, startNode));\r\n        const end = find$2(getLastChildren(elm), curry(eq, endNode));\r\n        return start.isSome() && end.isSome();\r\n      }).getOr(false);\r\n    };\r\n    const moveEndPoint = (dom, rng, node, start) => {\r\n      const root = node;\r\n      const walker = new DomTreeWalker(node, root);\r\n      const moveCaretBeforeOnEnterElementsMap = filter$4(dom.schema.getMoveCaretBeforeOnEnterElements(), (_, name) => !contains$2([\r\n        'td',\r\n        'th',\r\n        'table'\r\n      ], name.toLowerCase()));\r\n      let currentNode = node;\r\n      do {\r\n        if (isText$a(currentNode) && Tools.trim(currentNode.data).length !== 0) {\r\n          if (start) {\r\n            rng.setStart(currentNode, 0);\r\n          } else {\r\n            rng.setEnd(currentNode, currentNode.data.length);\r\n          }\r\n          return;\r\n        }\r\n        if (moveCaretBeforeOnEnterElementsMap[currentNode.nodeName]) {\r\n          if (start) {\r\n            rng.setStartBefore(currentNode);\r\n          } else {\r\n            if (currentNode.nodeName === 'BR') {\r\n              rng.setEndBefore(currentNode);\r\n            } else {\r\n              rng.setEndAfter(currentNode);\r\n            }\r\n          }\r\n          return;\r\n        }\r\n      } while (currentNode = start ? walker.next() : walker.prev());\r\n      if (root.nodeName === 'BODY') {\r\n        if (start) {\r\n          rng.setStart(root, 0);\r\n        } else {\r\n          rng.setEnd(root, root.childNodes.length);\r\n        }\r\n      }\r\n    };\r\n    const hasAnyRanges = editor => {\r\n      const sel = editor.selection.getSel();\r\n      return isNonNullable(sel) && sel.rangeCount > 0;\r\n    };\r\n    const runOnRanges = (editor, executor) => {\r\n      const fakeSelectionNodes = getCellsFromEditor(editor);\r\n      if (fakeSelectionNodes.length > 0) {\r\n        each$e(fakeSelectionNodes, elem => {\r\n          const node = elem.dom;\r\n          const fakeNodeRng = editor.dom.createRng();\r\n          fakeNodeRng.setStartBefore(node);\r\n          fakeNodeRng.setEndAfter(node);\r\n          executor(fakeNodeRng, true);\r\n        });\r\n      } else {\r\n        executor(editor.selection.getRng(), false);\r\n      }\r\n    };\r\n    const preserve = (selection, fillBookmark, executor) => {\r\n      const bookmark = getPersistentBookmark(selection, fillBookmark);\r\n      executor(bookmark);\r\n      selection.moveToBookmark(bookmark);\r\n    };\r\n\r\n    const isNode = node => isNumber(node === null || node === void 0 ? void 0 : node.nodeType);\r\n    const isElementNode$1 = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\r\n    const isElementDirectlySelected = (dom, node) => {\r\n      if (isElementNode$1(node) && !/^(TD|TH)$/.test(node.nodeName)) {\r\n        const selectedAttr = dom.getAttrib(node, 'data-mce-selected');\r\n        const value = parseInt(selectedAttr, 10);\r\n        return !isNaN(value) && value > 0;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const preserveSelection = (editor, action, shouldMoveStart) => {\r\n      const {selection, dom} = editor;\r\n      const selectedNodeBeforeAction = selection.getNode();\r\n      const isSelectedBeforeNodeNoneditable = isContentEditableFalse$b(selectedNodeBeforeAction);\r\n      preserve(selection, true, () => {\r\n        action();\r\n      });\r\n      const isBeforeNodeStillNoneditable = isSelectedBeforeNodeNoneditable && isContentEditableFalse$b(selectedNodeBeforeAction);\r\n      if (isBeforeNodeStillNoneditable && dom.isChildOf(selectedNodeBeforeAction, editor.getBody())) {\r\n        editor.selection.select(selectedNodeBeforeAction);\r\n      } else if (shouldMoveStart(selection.getStart())) {\r\n        moveStartToNearestText(dom, selection);\r\n      }\r\n    };\r\n    const moveStartToNearestText = (dom, selection) => {\r\n      var _a, _b;\r\n      const rng = selection.getRng();\r\n      const {startContainer, startOffset} = rng;\r\n      const selectedNode = selection.getNode();\r\n      if (isElementDirectlySelected(dom, selectedNode)) {\r\n        return;\r\n      }\r\n      if (isElement$6(startContainer)) {\r\n        const nodes = startContainer.childNodes;\r\n        const root = dom.getRoot();\r\n        let walker;\r\n        if (startOffset < nodes.length) {\r\n          const startNode = nodes[startOffset];\r\n          walker = new DomTreeWalker(startNode, (_a = dom.getParent(startNode, dom.isBlock)) !== null && _a !== void 0 ? _a : root);\r\n        } else {\r\n          const startNode = nodes[nodes.length - 1];\r\n          walker = new DomTreeWalker(startNode, (_b = dom.getParent(startNode, dom.isBlock)) !== null && _b !== void 0 ? _b : root);\r\n          walker.next(true);\r\n        }\r\n        for (let node = walker.current(); node; node = walker.next()) {\r\n          if (dom.getContentEditable(node) === 'false') {\r\n            return;\r\n          } else if (isText$a(node) && !isWhiteSpaceNode$1(node)) {\r\n            rng.setStart(node, 0);\r\n            selection.setRng(rng);\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    };\r\n    const getNonWhiteSpaceSibling = (node, next, inc) => {\r\n      if (node) {\r\n        const nextName = next ? 'nextSibling' : 'previousSibling';\r\n        for (node = inc ? node : node[nextName]; node; node = node[nextName]) {\r\n          if (isElement$6(node) || !isWhiteSpaceNode$1(node)) {\r\n            return node;\r\n          }\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n    const isTextBlock$1 = (schema, node) => !!schema.getTextBlockElements()[node.nodeName.toLowerCase()] || isTransparentBlock(schema, node);\r\n    const isValid = (ed, parent, child) => {\r\n      return ed.schema.isValidChild(parent, child);\r\n    };\r\n    const isWhiteSpaceNode$1 = (node, allowSpaces = false) => {\r\n      if (isNonNullable(node) && isText$a(node)) {\r\n        const data = allowSpaces ? node.data.replace(/ /g, '\\xA0') : node.data;\r\n        return isWhitespaceText(data);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const isEmptyTextNode$1 = node => {\r\n      return isNonNullable(node) && isText$a(node) && node.length === 0;\r\n    };\r\n    const isWrapNoneditableTarget = (editor, node) => {\r\n      const baseDataSelector = '[data-mce-cef-wrappable]';\r\n      const formatNoneditableSelector = getFormatNoneditableSelector(editor);\r\n      const selector = isEmpty$3(formatNoneditableSelector) ? baseDataSelector : `${ baseDataSelector },${ formatNoneditableSelector }`;\r\n      return is$1(SugarElement.fromDom(node), selector);\r\n    };\r\n    const isWrappableNoneditable = (editor, node) => {\r\n      const dom = editor.dom;\r\n      return isElementNode$1(node) && dom.getContentEditable(node) === 'false' && isWrapNoneditableTarget(editor, node) && dom.select('[contenteditable=\"true\"]', node).length === 0;\r\n    };\r\n    const replaceVars = (value, vars) => {\r\n      if (isFunction(value)) {\r\n        return value(vars);\r\n      } else if (isNonNullable(vars)) {\r\n        value = value.replace(/%(\\w+)/g, (str, name) => {\r\n          return vars[name] || str;\r\n        });\r\n      }\r\n      return value;\r\n    };\r\n    const isEq$5 = (str1, str2) => {\r\n      str1 = str1 || '';\r\n      str2 = str2 || '';\r\n      str1 = '' + (str1.nodeName || str1);\r\n      str2 = '' + (str2.nodeName || str2);\r\n      return str1.toLowerCase() === str2.toLowerCase();\r\n    };\r\n    const normalizeStyleValue = (value, name) => {\r\n      if (isNullable(value)) {\r\n        return null;\r\n      } else {\r\n        let strValue = String(value);\r\n        if (name === 'color' || name === 'backgroundColor') {\r\n          strValue = rgbaToHexString(strValue);\r\n        }\r\n        if (name === 'fontWeight' && value === 700) {\r\n          strValue = 'bold';\r\n        }\r\n        if (name === 'fontFamily') {\r\n          strValue = strValue.replace(/[\\'\\\"]/g, '').replace(/,\\s+/g, ',');\r\n        }\r\n        return strValue;\r\n      }\r\n    };\r\n    const getStyle = (dom, node, name) => {\r\n      const style = dom.getStyle(node, name);\r\n      return normalizeStyleValue(style, name);\r\n    };\r\n    const getTextDecoration = (dom, node) => {\r\n      let decoration;\r\n      dom.getParent(node, n => {\r\n        if (isElement$6(n)) {\r\n          decoration = dom.getStyle(n, 'text-decoration');\r\n          return !!decoration && decoration !== 'none';\r\n        } else {\r\n          return false;\r\n        }\r\n      });\r\n      return decoration;\r\n    };\r\n    const getParents$2 = (dom, node, selector) => {\r\n      return dom.getParents(node, selector, dom.getRoot());\r\n    };\r\n    const isFormatPredicate = (editor, formatName, predicate) => {\r\n      const formats = editor.formatter.get(formatName);\r\n      return isNonNullable(formats) && exists(formats, predicate);\r\n    };\r\n    const isVariableFormatName = (editor, formatName) => {\r\n      const hasVariableValues = format => {\r\n        const isVariableValue = val => isFunction(val) || val.length > 1 && val.charAt(0) === '%';\r\n        return exists([\r\n          'styles',\r\n          'attributes'\r\n        ], key => get$a(format, key).exists(field => {\r\n          const fieldValues = isArray$1(field) ? field : values(field);\r\n          return exists(fieldValues, isVariableValue);\r\n        }));\r\n      };\r\n      return isFormatPredicate(editor, formatName, hasVariableValues);\r\n    };\r\n    const areSimilarFormats = (editor, formatName, otherFormatName) => {\r\n      const validKeys = [\r\n        'inline',\r\n        'block',\r\n        'selector',\r\n        'attributes',\r\n        'styles',\r\n        'classes'\r\n      ];\r\n      const filterObj = format => filter$4(format, (_, key) => exists(validKeys, validKey => validKey === key));\r\n      return isFormatPredicate(editor, formatName, fmt1 => {\r\n        const filteredFmt1 = filterObj(fmt1);\r\n        return isFormatPredicate(editor, otherFormatName, fmt2 => {\r\n          const filteredFmt2 = filterObj(fmt2);\r\n          return equal$1(filteredFmt1, filteredFmt2);\r\n        });\r\n      });\r\n    };\r\n    const isBlockFormat = format => hasNonNullableKey(format, 'block');\r\n    const isWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper === true;\r\n    const isNonWrappingBlockFormat = format => isBlockFormat(format) && format.wrapper !== true;\r\n    const isSelectorFormat = format => hasNonNullableKey(format, 'selector');\r\n    const isInlineFormat = format => hasNonNullableKey(format, 'inline');\r\n    const isMixedFormat = format => isSelectorFormat(format) && isInlineFormat(format) && is$2(get$a(format, 'mixed'), true);\r\n    const shouldExpandToSelector = format => isSelectorFormat(format) && format.expand !== false && !isInlineFormat(format);\r\n    const getEmptyCaretContainers = node => {\r\n      const nodes = [];\r\n      let tempNode = node;\r\n      while (tempNode) {\r\n        if (isText$a(tempNode) && tempNode.data !== ZWSP$1 || tempNode.childNodes.length > 1) {\r\n          return [];\r\n        }\r\n        if (isElement$6(tempNode)) {\r\n          nodes.push(tempNode);\r\n        }\r\n        tempNode = tempNode.firstChild;\r\n      }\r\n      return nodes;\r\n    };\r\n    const isCaretContainerEmpty = node => {\r\n      return getEmptyCaretContainers(node).length > 0;\r\n    };\r\n    const isEmptyCaretFormatElement = element => {\r\n      return isCaretNode(element.dom) && isCaretContainerEmpty(element.dom);\r\n    };\r\n\r\n    const isBookmarkNode = isBookmarkNode$1;\r\n    const getParents$1 = getParents$2;\r\n    const isWhiteSpaceNode = isWhiteSpaceNode$1;\r\n    const isTextBlock = isTextBlock$1;\r\n    const isBogusBr = node => {\r\n      return isBr$6(node) && node.getAttribute('data-mce-bogus') && !node.nextSibling;\r\n    };\r\n    const findParentContentEditable = (dom, node) => {\r\n      let parent = node;\r\n      while (parent) {\r\n        if (isElement$6(parent) && dom.getContentEditable(parent)) {\r\n          return dom.getContentEditable(parent) === 'false' ? parent : node;\r\n        }\r\n        parent = parent.parentNode;\r\n      }\r\n      return node;\r\n    };\r\n    const walkText = (start, node, offset, predicate) => {\r\n      const str = node.data;\r\n      if (start) {\r\n        for (let i = offset; i > 0; i--) {\r\n          if (predicate(str.charAt(i - 1))) {\r\n            return i;\r\n          }\r\n        }\r\n      } else {\r\n        for (let i = offset; i < str.length; i++) {\r\n          if (predicate(str.charAt(i))) {\r\n            return i;\r\n          }\r\n        }\r\n      }\r\n      return -1;\r\n    };\r\n    const findSpace = (start, node, offset) => walkText(start, node, offset, c => isNbsp(c) || isWhiteSpace(c));\r\n    const findContent = (start, node, offset) => walkText(start, node, offset, isContent);\r\n    const findWordEndPoint = (dom, body, container, offset, start, includeTrailingSpaces) => {\r\n      let lastTextNode;\r\n      const rootNode = dom.getParent(container, dom.isBlock) || body;\r\n      const walk = (container, offset, pred) => {\r\n        const textSeeker = TextSeeker(dom);\r\n        const walker = start ? textSeeker.backwards : textSeeker.forwards;\r\n        return Optional.from(walker(container, offset, (text, textOffset) => {\r\n          if (isBookmarkNode(text.parentNode)) {\r\n            return -1;\r\n          } else {\r\n            lastTextNode = text;\r\n            return pred(start, text, textOffset);\r\n          }\r\n        }, rootNode));\r\n      };\r\n      const spaceResult = walk(container, offset, findSpace);\r\n      return spaceResult.bind(result => includeTrailingSpaces ? walk(result.container, result.offset + (start ? -1 : 0), findContent) : Optional.some(result)).orThunk(() => lastTextNode ? Optional.some({\r\n        container: lastTextNode,\r\n        offset: start ? 0 : lastTextNode.length\r\n      }) : Optional.none());\r\n    };\r\n    const findSelectorEndPoint = (dom, formatList, rng, container, siblingName) => {\r\n      const sibling = container[siblingName];\r\n      if (isText$a(container) && isEmpty$3(container.data) && sibling) {\r\n        container = sibling;\r\n      }\r\n      const parents = getParents$1(dom, container);\r\n      for (let i = 0; i < parents.length; i++) {\r\n        for (let y = 0; y < formatList.length; y++) {\r\n          const curFormat = formatList[y];\r\n          if (isNonNullable(curFormat.collapsed) && curFormat.collapsed !== rng.collapsed) {\r\n            continue;\r\n          }\r\n          if (isSelectorFormat(curFormat) && dom.is(parents[i], curFormat.selector)) {\r\n            return parents[i];\r\n          }\r\n        }\r\n      }\r\n      return container;\r\n    };\r\n    const findBlockEndPoint = (dom, formatList, container, siblingName) => {\r\n      var _a;\r\n      let node = container;\r\n      const root = dom.getRoot();\r\n      const format = formatList[0];\r\n      if (isBlockFormat(format)) {\r\n        node = format.wrapper ? null : dom.getParent(container, format.block, root);\r\n      }\r\n      if (!node) {\r\n        const scopeRoot = (_a = dom.getParent(container, 'LI,TD,TH,SUMMARY')) !== null && _a !== void 0 ? _a : root;\r\n        node = dom.getParent(isText$a(container) ? container.parentNode : container, node => node !== root && isTextBlock(dom.schema, node), scopeRoot);\r\n      }\r\n      if (node && isBlockFormat(format) && format.wrapper) {\r\n        node = getParents$1(dom, node, 'ul,ol').reverse()[0] || node;\r\n      }\r\n      if (!node) {\r\n        node = container;\r\n        while (node && node[siblingName] && !dom.isBlock(node[siblingName])) {\r\n          node = node[siblingName];\r\n          if (isEq$5(node, 'br')) {\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      return node || container;\r\n    };\r\n    const isAtBlockBoundary$1 = (dom, root, container, siblingName) => {\r\n      const parent = container.parentNode;\r\n      if (isNonNullable(container[siblingName])) {\r\n        return false;\r\n      } else if (parent === root || isNullable(parent) || dom.isBlock(parent)) {\r\n        return true;\r\n      } else {\r\n        return isAtBlockBoundary$1(dom, root, parent, siblingName);\r\n      }\r\n    };\r\n    const findParentContainer = (dom, formatList, container, offset, start) => {\r\n      let parent = container;\r\n      const siblingName = start ? 'previousSibling' : 'nextSibling';\r\n      const root = dom.getRoot();\r\n      if (isText$a(container) && !isWhiteSpaceNode(container)) {\r\n        if (start ? offset > 0 : offset < container.data.length) {\r\n          return container;\r\n        }\r\n      }\r\n      while (parent) {\r\n        if (!formatList[0].block_expand && dom.isBlock(parent)) {\r\n          return parent;\r\n        }\r\n        for (let sibling = parent[siblingName]; sibling; sibling = sibling[siblingName]) {\r\n          const allowSpaces = isText$a(sibling) && !isAtBlockBoundary$1(dom, root, sibling, siblingName);\r\n          if (!isBookmarkNode(sibling) && !isBogusBr(sibling) && !isWhiteSpaceNode(sibling, allowSpaces)) {\r\n            return parent;\r\n          }\r\n        }\r\n        if (parent === root || parent.parentNode === root) {\r\n          container = parent;\r\n          break;\r\n        }\r\n        parent = parent.parentNode;\r\n      }\r\n      return container;\r\n    };\r\n    const isSelfOrParentBookmark = container => isBookmarkNode(container.parentNode) || isBookmarkNode(container);\r\n    const expandRng = (dom, rng, formatList, includeTrailingSpace = false) => {\r\n      let {startContainer, startOffset, endContainer, endOffset} = rng;\r\n      const format = formatList[0];\r\n      if (isElement$6(startContainer) && startContainer.hasChildNodes()) {\r\n        startContainer = getNode$1(startContainer, startOffset);\r\n        if (isText$a(startContainer)) {\r\n          startOffset = 0;\r\n        }\r\n      }\r\n      if (isElement$6(endContainer) && endContainer.hasChildNodes()) {\r\n        endContainer = getNode$1(endContainer, rng.collapsed ? endOffset : endOffset - 1);\r\n        if (isText$a(endContainer)) {\r\n          endOffset = endContainer.data.length;\r\n        }\r\n      }\r\n      startContainer = findParentContentEditable(dom, startContainer);\r\n      endContainer = findParentContentEditable(dom, endContainer);\r\n      if (isSelfOrParentBookmark(startContainer)) {\r\n        startContainer = isBookmarkNode(startContainer) ? startContainer : startContainer.parentNode;\r\n        if (rng.collapsed) {\r\n          startContainer = startContainer.previousSibling || startContainer;\r\n        } else {\r\n          startContainer = startContainer.nextSibling || startContainer;\r\n        }\r\n        if (isText$a(startContainer)) {\r\n          startOffset = rng.collapsed ? startContainer.length : 0;\r\n        }\r\n      }\r\n      if (isSelfOrParentBookmark(endContainer)) {\r\n        endContainer = isBookmarkNode(endContainer) ? endContainer : endContainer.parentNode;\r\n        if (rng.collapsed) {\r\n          endContainer = endContainer.nextSibling || endContainer;\r\n        } else {\r\n          endContainer = endContainer.previousSibling || endContainer;\r\n        }\r\n        if (isText$a(endContainer)) {\r\n          endOffset = rng.collapsed ? 0 : endContainer.length;\r\n        }\r\n      }\r\n      if (rng.collapsed) {\r\n        const startPoint = findWordEndPoint(dom, dom.getRoot(), startContainer, startOffset, true, includeTrailingSpace);\r\n        startPoint.each(({container, offset}) => {\r\n          startContainer = container;\r\n          startOffset = offset;\r\n        });\r\n        const endPoint = findWordEndPoint(dom, dom.getRoot(), endContainer, endOffset, false, includeTrailingSpace);\r\n        endPoint.each(({container, offset}) => {\r\n          endContainer = container;\r\n          endOffset = offset;\r\n        });\r\n      }\r\n      if (isInlineFormat(format) || format.block_expand) {\r\n        if (!isInlineFormat(format) || (!isText$a(startContainer) || startOffset === 0)) {\r\n          startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\r\n        }\r\n        if (!isInlineFormat(format) || (!isText$a(endContainer) || endOffset === endContainer.data.length)) {\r\n          endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\r\n        }\r\n      }\r\n      if (shouldExpandToSelector(format)) {\r\n        startContainer = findSelectorEndPoint(dom, formatList, rng, startContainer, 'previousSibling');\r\n        endContainer = findSelectorEndPoint(dom, formatList, rng, endContainer, 'nextSibling');\r\n      }\r\n      if (isBlockFormat(format) || isSelectorFormat(format)) {\r\n        startContainer = findBlockEndPoint(dom, formatList, startContainer, 'previousSibling');\r\n        endContainer = findBlockEndPoint(dom, formatList, endContainer, 'nextSibling');\r\n        if (isBlockFormat(format)) {\r\n          if (!dom.isBlock(startContainer)) {\r\n            startContainer = findParentContainer(dom, formatList, startContainer, startOffset, true);\r\n          }\r\n          if (!dom.isBlock(endContainer)) {\r\n            endContainer = findParentContainer(dom, formatList, endContainer, endOffset, false);\r\n          }\r\n        }\r\n      }\r\n      if (isElement$6(startContainer) && startContainer.parentNode) {\r\n        startOffset = dom.nodeIndex(startContainer);\r\n        startContainer = startContainer.parentNode;\r\n      }\r\n      if (isElement$6(endContainer) && endContainer.parentNode) {\r\n        endOffset = dom.nodeIndex(endContainer) + 1;\r\n        endContainer = endContainer.parentNode;\r\n      }\r\n      return {\r\n        startContainer,\r\n        startOffset,\r\n        endContainer,\r\n        endOffset\r\n      };\r\n    };\r\n\r\n    const walk$3 = (dom, rng, callback) => {\r\n      var _a;\r\n      const startOffset = rng.startOffset;\r\n      const startContainer = getNode$1(rng.startContainer, startOffset);\r\n      const endOffset = rng.endOffset;\r\n      const endContainer = getNode$1(rng.endContainer, endOffset - 1);\r\n      const exclude = nodes => {\r\n        const firstNode = nodes[0];\r\n        if (isText$a(firstNode) && firstNode === startContainer && startOffset >= firstNode.data.length) {\r\n          nodes.splice(0, 1);\r\n        }\r\n        const lastNode = nodes[nodes.length - 1];\r\n        if (endOffset === 0 && nodes.length > 0 && lastNode === endContainer && isText$a(lastNode)) {\r\n          nodes.splice(nodes.length - 1, 1);\r\n        }\r\n        return nodes;\r\n      };\r\n      const collectSiblings = (node, name, endNode) => {\r\n        const siblings = [];\r\n        for (; node && node !== endNode; node = node[name]) {\r\n          siblings.push(node);\r\n        }\r\n        return siblings;\r\n      };\r\n      const findEndPoint = (node, root) => dom.getParent(node, node => node.parentNode === root, root);\r\n      const walkBoundary = (startNode, endNode, next) => {\r\n        const siblingName = next ? 'nextSibling' : 'previousSibling';\r\n        for (let node = startNode, parent = node.parentNode; node && node !== endNode; node = parent) {\r\n          parent = node.parentNode;\r\n          const siblings = collectSiblings(node === startNode ? node : node[siblingName], siblingName);\r\n          if (siblings.length) {\r\n            if (!next) {\r\n              siblings.reverse();\r\n            }\r\n            callback(exclude(siblings));\r\n          }\r\n        }\r\n      };\r\n      if (startContainer === endContainer) {\r\n        return callback(exclude([startContainer]));\r\n      }\r\n      const ancestor = (_a = dom.findCommonAncestor(startContainer, endContainer)) !== null && _a !== void 0 ? _a : dom.getRoot();\r\n      if (dom.isChildOf(startContainer, endContainer)) {\r\n        return walkBoundary(startContainer, ancestor, true);\r\n      }\r\n      if (dom.isChildOf(endContainer, startContainer)) {\r\n        return walkBoundary(endContainer, ancestor);\r\n      }\r\n      const startPoint = findEndPoint(startContainer, ancestor) || startContainer;\r\n      const endPoint = findEndPoint(endContainer, ancestor) || endContainer;\r\n      walkBoundary(startContainer, startPoint, true);\r\n      const siblings = collectSiblings(startPoint === startContainer ? startPoint : startPoint.nextSibling, 'nextSibling', endPoint === endContainer ? endPoint.nextSibling : endPoint);\r\n      if (siblings.length) {\r\n        callback(exclude(siblings));\r\n      }\r\n      walkBoundary(endContainer, endPoint);\r\n    };\r\n\r\n    const validBlocks = [\r\n      'pre[class*=language-][contenteditable=\"false\"]',\r\n      'figure.image',\r\n      'div[data-ephox-embed-iri]',\r\n      'div.tiny-pageembed',\r\n      'div.mce-toc',\r\n      'div[data-mce-toc]'\r\n    ];\r\n    const isZeroWidth = elem => isText$b(elem) && get$3(elem) === ZWSP$1;\r\n    const context = (editor, elem, wrapName, nodeName) => parent(elem).fold(() => 'skipping', parent => {\r\n      if (nodeName === 'br' || isZeroWidth(elem)) {\r\n        return 'valid';\r\n      } else if (isAnnotation(elem)) {\r\n        return 'existing';\r\n      } else if (isCaretNode(elem.dom)) {\r\n        return 'caret';\r\n      } else if (exists(validBlocks, selector => is$1(elem, selector))) {\r\n        return 'valid-block';\r\n      } else if (!isValid(editor, wrapName, nodeName) || !isValid(editor, name(parent), wrapName)) {\r\n        return 'invalid-child';\r\n      } else {\r\n        return 'valid';\r\n      }\r\n    });\r\n\r\n    const applyWordGrab = (editor, rng) => {\r\n      const r = expandRng(editor.dom, rng, [{ inline: 'span' }]);\r\n      rng.setStart(r.startContainer, r.startOffset);\r\n      rng.setEnd(r.endContainer, r.endOffset);\r\n      editor.selection.setRng(rng);\r\n    };\r\n    const applyAnnotation = (elem, masterUId, data, annotationName, decorate, directAnnotation) => {\r\n      const {uid = masterUId, ...otherData} = data;\r\n      add$2(elem, annotation());\r\n      set$3(elem, `${ dataAnnotationId() }`, uid);\r\n      set$3(elem, `${ dataAnnotation() }`, annotationName);\r\n      const {attributes = {}, classes = []} = decorate(uid, otherData);\r\n      setAll$1(elem, attributes);\r\n      add(elem, classes);\r\n      if (directAnnotation) {\r\n        if (classes.length > 0) {\r\n          set$3(elem, `${ dataAnnotationClasses() }`, classes.join(','));\r\n        }\r\n        const attributeNames = keys(attributes);\r\n        if (attributeNames.length > 0) {\r\n          set$3(elem, `${ dataAnnotationAttributes() }`, attributeNames.join(','));\r\n        }\r\n      }\r\n    };\r\n    const removeDirectAnnotation = elem => {\r\n      remove$7(elem, annotation());\r\n      remove$a(elem, `${ dataAnnotationId() }`);\r\n      remove$a(elem, `${ dataAnnotation() }`);\r\n      remove$a(elem, `${ dataAnnotationActive() }`);\r\n      const customAttrNames = getOpt(elem, `${ dataAnnotationAttributes() }`).map(names => names.split(',')).getOr([]);\r\n      const customClasses = getOpt(elem, `${ dataAnnotationClasses() }`).map(names => names.split(',')).getOr([]);\r\n      each$e(customAttrNames, name => remove$a(elem, name));\r\n      remove$4(elem, customClasses);\r\n      remove$a(elem, `${ dataAnnotationClasses() }`);\r\n      remove$a(elem, `${ dataAnnotationAttributes() }`);\r\n    };\r\n    const makeAnnotation = (eDoc, uid, data, annotationName, decorate) => {\r\n      const master = SugarElement.fromTag('span', eDoc);\r\n      applyAnnotation(master, uid, data, annotationName, decorate, false);\r\n      return master;\r\n    };\r\n    const annotate = (editor, rng, uid, annotationName, decorate, data) => {\r\n      const newWrappers = [];\r\n      const master = makeAnnotation(editor.getDoc(), uid, data, annotationName, decorate);\r\n      const wrapper = value$2();\r\n      const finishWrapper = () => {\r\n        wrapper.clear();\r\n      };\r\n      const getOrOpenWrapper = () => wrapper.get().getOrThunk(() => {\r\n        const nu = shallow$1(master);\r\n        newWrappers.push(nu);\r\n        wrapper.set(nu);\r\n        return nu;\r\n      });\r\n      const processElements = elems => {\r\n        each$e(elems, processElement);\r\n      };\r\n      const processElement = elem => {\r\n        const ctx = context(editor, elem, 'span', name(elem));\r\n        switch (ctx) {\r\n        case 'invalid-child': {\r\n            finishWrapper();\r\n            const children = children$1(elem);\r\n            processElements(children);\r\n            finishWrapper();\r\n            break;\r\n          }\r\n        case 'valid-block': {\r\n            finishWrapper();\r\n            applyAnnotation(elem, uid, data, annotationName, decorate, true);\r\n            break;\r\n          }\r\n        case 'valid': {\r\n            const w = getOrOpenWrapper();\r\n            wrap$2(elem, w);\r\n            break;\r\n          }\r\n        }\r\n      };\r\n      const processNodes = nodes => {\r\n        const elems = map$3(nodes, SugarElement.fromDom);\r\n        processElements(elems);\r\n      };\r\n      walk$3(editor.dom, rng, nodes => {\r\n        finishWrapper();\r\n        processNodes(nodes);\r\n      });\r\n      return newWrappers;\r\n    };\r\n    const annotateWithBookmark = (editor, name, settings, data) => {\r\n      editor.undoManager.transact(() => {\r\n        const selection = editor.selection;\r\n        const initialRng = selection.getRng();\r\n        const hasFakeSelection = getCellsFromEditor(editor).length > 0;\r\n        const masterUid = generate$1('mce-annotation');\r\n        if (initialRng.collapsed && !hasFakeSelection) {\r\n          applyWordGrab(editor, initialRng);\r\n        }\r\n        if (selection.getRng().collapsed && !hasFakeSelection) {\r\n          const wrapper = makeAnnotation(editor.getDoc(), masterUid, data, name, settings.decorate);\r\n          set$1(wrapper, nbsp);\r\n          selection.getRng().insertNode(wrapper.dom);\r\n          selection.select(wrapper.dom);\r\n        } else {\r\n          preserve(selection, false, () => {\r\n            runOnRanges(editor, selectionRng => {\r\n              annotate(editor, selectionRng, masterUid, name, settings.decorate, data);\r\n            });\r\n          });\r\n        }\r\n      });\r\n    };\r\n\r\n    const Annotator = editor => {\r\n      const registry = create$c();\r\n      setup$x(editor, registry);\r\n      const changes = setup$y(editor, registry);\r\n      const isSpan = isTag('span');\r\n      const removeAnnotations = elements => {\r\n        each$e(elements, element => {\r\n          if (isSpan(element)) {\r\n            unwrap(element);\r\n          } else {\r\n            removeDirectAnnotation(element);\r\n          }\r\n        });\r\n      };\r\n      return {\r\n        register: (name, settings) => {\r\n          registry.register(name, settings);\r\n        },\r\n        annotate: (name, data) => {\r\n          registry.lookup(name).each(settings => {\r\n            annotateWithBookmark(editor, name, settings, data);\r\n          });\r\n        },\r\n        annotationChanged: (name, callback) => {\r\n          changes.addListener(name, callback);\r\n        },\r\n        remove: name => {\r\n          identify(editor, Optional.some(name)).each(({elements}) => {\r\n            const bookmark = editor.selection.getBookmark();\r\n            removeAnnotations(elements);\r\n            editor.selection.moveToBookmark(bookmark);\r\n          });\r\n        },\r\n        removeAll: name => {\r\n          const bookmark = editor.selection.getBookmark();\r\n          each$d(findAll(editor, name), (elements, _) => {\r\n            removeAnnotations(elements);\r\n          });\r\n          editor.selection.moveToBookmark(bookmark);\r\n        },\r\n        getAll: name => {\r\n          const directory = findAll(editor, name);\r\n          return map$2(directory, elems => map$3(elems, elem => elem.dom));\r\n        }\r\n      };\r\n    };\r\n\r\n    const BookmarkManager = selection => {\r\n      return {\r\n        getBookmark: curry(getBookmark$1, selection),\r\n        moveToBookmark: curry(moveToBookmark, selection)\r\n      };\r\n    };\r\n    BookmarkManager.isBookmarkNode = isBookmarkNode$1;\r\n\r\n    const isXYWithinRange = (clientX, clientY, range) => {\r\n      if (range.collapsed) {\r\n        return false;\r\n      } else {\r\n        return exists(range.getClientRects(), rect => containsXY(rect, clientX, clientY));\r\n      }\r\n    };\r\n\r\n    const firePreProcess = (editor, args) => editor.dispatch('PreProcess', args);\r\n    const firePostProcess = (editor, args) => editor.dispatch('PostProcess', args);\r\n    const fireRemove = editor => {\r\n      editor.dispatch('remove');\r\n    };\r\n    const fireDetach = editor => {\r\n      editor.dispatch('detach');\r\n    };\r\n    const fireSwitchMode = (editor, mode) => {\r\n      editor.dispatch('SwitchMode', { mode });\r\n    };\r\n    const fireObjectResizeStart = (editor, target, width, height, origin) => {\r\n      editor.dispatch('ObjectResizeStart', {\r\n        target,\r\n        width,\r\n        height,\r\n        origin\r\n      });\r\n    };\r\n    const fireObjectResized = (editor, target, width, height, origin) => {\r\n      editor.dispatch('ObjectResized', {\r\n        target,\r\n        width,\r\n        height,\r\n        origin\r\n      });\r\n    };\r\n    const firePreInit = editor => {\r\n      editor.dispatch('PreInit');\r\n    };\r\n    const firePostRender = editor => {\r\n      editor.dispatch('PostRender');\r\n    };\r\n    const fireInit = editor => {\r\n      editor.dispatch('Init');\r\n    };\r\n    const firePlaceholderToggle = (editor, state) => {\r\n      editor.dispatch('PlaceholderToggle', { state });\r\n    };\r\n    const fireError = (editor, errorType, error) => {\r\n      editor.dispatch(errorType, error);\r\n    };\r\n    const fireFormatApply = (editor, format, node, vars) => {\r\n      editor.dispatch('FormatApply', {\r\n        format,\r\n        node,\r\n        vars\r\n      });\r\n    };\r\n    const fireFormatRemove = (editor, format, node, vars) => {\r\n      editor.dispatch('FormatRemove', {\r\n        format,\r\n        node,\r\n        vars\r\n      });\r\n    };\r\n    const fireBeforeSetContent = (editor, args) => editor.dispatch('BeforeSetContent', args);\r\n    const fireSetContent = (editor, args) => editor.dispatch('SetContent', args);\r\n    const fireBeforeGetContent = (editor, args) => editor.dispatch('BeforeGetContent', args);\r\n    const fireGetContent = (editor, args) => editor.dispatch('GetContent', args);\r\n    const fireAutocompleterStart = (editor, args) => {\r\n      editor.dispatch('AutocompleterStart', args);\r\n    };\r\n    const fireAutocompleterUpdate = (editor, args) => {\r\n      editor.dispatch('AutocompleterUpdate', args);\r\n    };\r\n    const fireAutocompleterEnd = editor => {\r\n      editor.dispatch('AutocompleterEnd');\r\n    };\r\n    const firePastePreProcess = (editor, html, internal) => editor.dispatch('PastePreProcess', {\r\n      content: html,\r\n      internal\r\n    });\r\n    const firePastePostProcess = (editor, node, internal) => editor.dispatch('PastePostProcess', {\r\n      node,\r\n      internal\r\n    });\r\n    const firePastePlainTextToggle = (editor, state) => editor.dispatch('PastePlainTextToggle', { state });\r\n    const fireEditableRootStateChange = (editor, state) => editor.dispatch('EditableRootStateChange', { state });\r\n\r\n    const VK = {\r\n      BACKSPACE: 8,\r\n      DELETE: 46,\r\n      DOWN: 40,\r\n      ENTER: 13,\r\n      ESC: 27,\r\n      LEFT: 37,\r\n      RIGHT: 39,\r\n      SPACEBAR: 32,\r\n      TAB: 9,\r\n      UP: 38,\r\n      PAGE_UP: 33,\r\n      PAGE_DOWN: 34,\r\n      END: 35,\r\n      HOME: 36,\r\n      modifierPressed: e => {\r\n        return e.shiftKey || e.ctrlKey || e.altKey || VK.metaKeyPressed(e);\r\n      },\r\n      metaKeyPressed: e => {\r\n        return Env.os.isMacOS() || Env.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey;\r\n      }\r\n    };\r\n\r\n    const elementSelectionAttr = 'data-mce-selected';\r\n    const controlElmSelector = 'table,img,figure.image,hr,video,span.mce-preview-object,details';\r\n    const abs = Math.abs;\r\n    const round$1 = Math.round;\r\n    const resizeHandles = {\r\n      nw: [\r\n        0,\r\n        0,\r\n        -1,\r\n        -1\r\n      ],\r\n      ne: [\r\n        1,\r\n        0,\r\n        1,\r\n        -1\r\n      ],\r\n      se: [\r\n        1,\r\n        1,\r\n        1,\r\n        1\r\n      ],\r\n      sw: [\r\n        0,\r\n        1,\r\n        -1,\r\n        1\r\n      ]\r\n    };\r\n    const isTouchEvent = evt => evt.type === 'longpress' || evt.type.indexOf('touch') === 0;\r\n    const ControlSelection = (selection, editor) => {\r\n      const dom = editor.dom;\r\n      const editableDoc = editor.getDoc();\r\n      const rootDocument = document;\r\n      const rootElement = editor.getBody();\r\n      let selectedElm, selectedElmGhost, resizeHelper, selectedHandle, resizeBackdrop;\r\n      let startX, startY, selectedElmX, selectedElmY, startW, startH, ratio, resizeStarted;\r\n      let width;\r\n      let height;\r\n      let startScrollWidth;\r\n      let startScrollHeight;\r\n      const isImage = elm => isNonNullable(elm) && (isImg(elm) || dom.is(elm, 'figure.image'));\r\n      const isMedia = elm => isMedia$2(elm) || dom.hasClass(elm, 'mce-preview-object');\r\n      const isEventOnImageOutsideRange = (evt, range) => {\r\n        if (isTouchEvent(evt)) {\r\n          const touch = evt.touches[0];\r\n          return isImage(evt.target) && !isXYWithinRange(touch.clientX, touch.clientY, range);\r\n        } else {\r\n          return isImage(evt.target) && !isXYWithinRange(evt.clientX, evt.clientY, range);\r\n        }\r\n      };\r\n      const contextMenuSelectImage = evt => {\r\n        const target = evt.target;\r\n        if (isEventOnImageOutsideRange(evt, editor.selection.getRng()) && !evt.isDefaultPrevented()) {\r\n          editor.selection.select(target);\r\n        }\r\n      };\r\n      const getResizeTargets = elm => {\r\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\r\n          return [\r\n            elm,\r\n            elm.firstElementChild\r\n          ];\r\n        } else if (dom.is(elm, 'figure.image')) {\r\n          return [elm.querySelector('img')];\r\n        } else {\r\n          return [elm];\r\n        }\r\n      };\r\n      const isResizable = elm => {\r\n        const selector = getObjectResizing(editor);\r\n        if (!selector) {\r\n          return false;\r\n        }\r\n        if (elm.getAttribute('data-mce-resize') === 'false') {\r\n          return false;\r\n        }\r\n        if (elm === editor.getBody()) {\r\n          return false;\r\n        }\r\n        if (dom.hasClass(elm, 'mce-preview-object') && isNonNullable(elm.firstElementChild)) {\r\n          return is$1(SugarElement.fromDom(elm.firstElementChild), selector);\r\n        } else {\r\n          return is$1(SugarElement.fromDom(elm), selector);\r\n        }\r\n      };\r\n      const createGhostElement = elm => {\r\n        if (isMedia(elm)) {\r\n          return dom.create('img', { src: Env.transparentSrc });\r\n        } else {\r\n          return elm.cloneNode(true);\r\n        }\r\n      };\r\n      const setSizeProp = (element, name, value) => {\r\n        if (isNonNullable(value)) {\r\n          const targets = getResizeTargets(element);\r\n          each$e(targets, target => {\r\n            if (target.style[name] || !editor.schema.isValid(target.nodeName.toLowerCase(), name)) {\r\n              dom.setStyle(target, name, value);\r\n            } else {\r\n              dom.setAttrib(target, name, '' + value);\r\n            }\r\n          });\r\n        }\r\n      };\r\n      const setGhostElmSize = (ghostElm, width, height) => {\r\n        setSizeProp(ghostElm, 'width', width);\r\n        setSizeProp(ghostElm, 'height', height);\r\n      };\r\n      const resizeGhostElement = e => {\r\n        let deltaX, deltaY, proportional;\r\n        let resizeHelperX, resizeHelperY;\r\n        deltaX = e.screenX - startX;\r\n        deltaY = e.screenY - startY;\r\n        width = deltaX * selectedHandle[2] + startW;\r\n        height = deltaY * selectedHandle[3] + startH;\r\n        width = width < 5 ? 5 : width;\r\n        height = height < 5 ? 5 : height;\r\n        if ((isImage(selectedElm) || isMedia(selectedElm)) && getResizeImgProportional(editor) !== false) {\r\n          proportional = !VK.modifierPressed(e);\r\n        } else {\r\n          proportional = VK.modifierPressed(e);\r\n        }\r\n        if (proportional) {\r\n          if (abs(deltaX) > abs(deltaY)) {\r\n            height = round$1(width * ratio);\r\n            width = round$1(height / ratio);\r\n          } else {\r\n            width = round$1(height / ratio);\r\n            height = round$1(width * ratio);\r\n          }\r\n        }\r\n        setGhostElmSize(selectedElmGhost, width, height);\r\n        resizeHelperX = selectedHandle.startPos.x + deltaX;\r\n        resizeHelperY = selectedHandle.startPos.y + deltaY;\r\n        resizeHelperX = resizeHelperX > 0 ? resizeHelperX : 0;\r\n        resizeHelperY = resizeHelperY > 0 ? resizeHelperY : 0;\r\n        dom.setStyles(resizeHelper, {\r\n          left: resizeHelperX,\r\n          top: resizeHelperY,\r\n          display: 'block'\r\n        });\r\n        resizeHelper.innerHTML = width + ' &times; ' + height;\r\n        if (selectedHandle[2] < 0 && selectedElmGhost.clientWidth <= width) {\r\n          dom.setStyle(selectedElmGhost, 'left', selectedElmX + (startW - width));\r\n        }\r\n        if (selectedHandle[3] < 0 && selectedElmGhost.clientHeight <= height) {\r\n          dom.setStyle(selectedElmGhost, 'top', selectedElmY + (startH - height));\r\n        }\r\n        deltaX = rootElement.scrollWidth - startScrollWidth;\r\n        deltaY = rootElement.scrollHeight - startScrollHeight;\r\n        if (deltaX + deltaY !== 0) {\r\n          dom.setStyles(resizeHelper, {\r\n            left: resizeHelperX - deltaX,\r\n            top: resizeHelperY - deltaY\r\n          });\r\n        }\r\n        if (!resizeStarted) {\r\n          fireObjectResizeStart(editor, selectedElm, startW, startH, 'corner-' + selectedHandle.name);\r\n          resizeStarted = true;\r\n        }\r\n      };\r\n      const endGhostResize = () => {\r\n        const wasResizeStarted = resizeStarted;\r\n        resizeStarted = false;\r\n        if (wasResizeStarted) {\r\n          setSizeProp(selectedElm, 'width', width);\r\n          setSizeProp(selectedElm, 'height', height);\r\n        }\r\n        dom.unbind(editableDoc, 'mousemove', resizeGhostElement);\r\n        dom.unbind(editableDoc, 'mouseup', endGhostResize);\r\n        if (rootDocument !== editableDoc) {\r\n          dom.unbind(rootDocument, 'mousemove', resizeGhostElement);\r\n          dom.unbind(rootDocument, 'mouseup', endGhostResize);\r\n        }\r\n        dom.remove(selectedElmGhost);\r\n        dom.remove(resizeHelper);\r\n        dom.remove(resizeBackdrop);\r\n        showResizeRect(selectedElm);\r\n        if (wasResizeStarted) {\r\n          fireObjectResized(editor, selectedElm, width, height, 'corner-' + selectedHandle.name);\r\n          dom.setAttrib(selectedElm, 'style', dom.getAttrib(selectedElm, 'style'));\r\n        }\r\n        editor.nodeChanged();\r\n      };\r\n      const showResizeRect = targetElm => {\r\n        unbindResizeHandleEvents();\r\n        const position = dom.getPos(targetElm, rootElement);\r\n        const selectedElmX = position.x;\r\n        const selectedElmY = position.y;\r\n        const rect = targetElm.getBoundingClientRect();\r\n        const targetWidth = rect.width || rect.right - rect.left;\r\n        const targetHeight = rect.height || rect.bottom - rect.top;\r\n        if (selectedElm !== targetElm) {\r\n          hideResizeRect();\r\n          selectedElm = targetElm;\r\n          width = height = 0;\r\n        }\r\n        const e = editor.dispatch('ObjectSelected', { target: targetElm });\r\n        if (isResizable(targetElm) && !e.isDefaultPrevented()) {\r\n          each$d(resizeHandles, (handle, name) => {\r\n            const startDrag = e => {\r\n              const target = getResizeTargets(selectedElm)[0];\r\n              startX = e.screenX;\r\n              startY = e.screenY;\r\n              startW = target.clientWidth;\r\n              startH = target.clientHeight;\r\n              ratio = startH / startW;\r\n              selectedHandle = handle;\r\n              selectedHandle.name = name;\r\n              selectedHandle.startPos = {\r\n                x: targetWidth * handle[0] + selectedElmX,\r\n                y: targetHeight * handle[1] + selectedElmY\r\n              };\r\n              startScrollWidth = rootElement.scrollWidth;\r\n              startScrollHeight = rootElement.scrollHeight;\r\n              resizeBackdrop = dom.add(rootElement, 'div', {\r\n                'class': 'mce-resize-backdrop',\r\n                'data-mce-bogus': 'all'\r\n              });\r\n              dom.setStyles(resizeBackdrop, {\r\n                position: 'fixed',\r\n                left: '0',\r\n                top: '0',\r\n                width: '100%',\r\n                height: '100%'\r\n              });\r\n              selectedElmGhost = createGhostElement(selectedElm);\r\n              dom.addClass(selectedElmGhost, 'mce-clonedresizable');\r\n              dom.setAttrib(selectedElmGhost, 'data-mce-bogus', 'all');\r\n              selectedElmGhost.contentEditable = 'false';\r\n              dom.setStyles(selectedElmGhost, {\r\n                left: selectedElmX,\r\n                top: selectedElmY,\r\n                margin: 0\r\n              });\r\n              setGhostElmSize(selectedElmGhost, targetWidth, targetHeight);\r\n              selectedElmGhost.removeAttribute(elementSelectionAttr);\r\n              rootElement.appendChild(selectedElmGhost);\r\n              dom.bind(editableDoc, 'mousemove', resizeGhostElement);\r\n              dom.bind(editableDoc, 'mouseup', endGhostResize);\r\n              if (rootDocument !== editableDoc) {\r\n                dom.bind(rootDocument, 'mousemove', resizeGhostElement);\r\n                dom.bind(rootDocument, 'mouseup', endGhostResize);\r\n              }\r\n              resizeHelper = dom.add(rootElement, 'div', {\r\n                'class': 'mce-resize-helper',\r\n                'data-mce-bogus': 'all'\r\n              }, startW + ' &times; ' + startH);\r\n            };\r\n            let handleElm = dom.get('mceResizeHandle' + name);\r\n            if (handleElm) {\r\n              dom.remove(handleElm);\r\n            }\r\n            handleElm = dom.add(rootElement, 'div', {\r\n              'id': 'mceResizeHandle' + name,\r\n              'data-mce-bogus': 'all',\r\n              'class': 'mce-resizehandle',\r\n              'unselectable': true,\r\n              'style': 'cursor:' + name + '-resize; margin:0; padding:0'\r\n            });\r\n            dom.bind(handleElm, 'mousedown', e => {\r\n              e.stopImmediatePropagation();\r\n              e.preventDefault();\r\n              startDrag(e);\r\n            });\r\n            handle.elm = handleElm;\r\n            dom.setStyles(handleElm, {\r\n              left: targetWidth * handle[0] + selectedElmX - handleElm.offsetWidth / 2,\r\n              top: targetHeight * handle[1] + selectedElmY - handleElm.offsetHeight / 2\r\n            });\r\n          });\r\n        } else {\r\n          hideResizeRect(false);\r\n        }\r\n      };\r\n      const throttledShowResizeRect = first$1(showResizeRect, 0);\r\n      const hideResizeRect = (removeSelected = true) => {\r\n        throttledShowResizeRect.cancel();\r\n        unbindResizeHandleEvents();\r\n        if (selectedElm && removeSelected) {\r\n          selectedElm.removeAttribute(elementSelectionAttr);\r\n        }\r\n        each$d(resizeHandles, (value, name) => {\r\n          const handleElm = dom.get('mceResizeHandle' + name);\r\n          if (handleElm) {\r\n            dom.unbind(handleElm);\r\n            dom.remove(handleElm);\r\n          }\r\n        });\r\n      };\r\n      const isChildOrEqual = (node, parent) => dom.isChildOf(node, parent);\r\n      const updateResizeRect = e => {\r\n        if (resizeStarted || editor.removed || editor.composing) {\r\n          return;\r\n        }\r\n        const targetElm = e.type === 'mousedown' ? e.target : selection.getNode();\r\n        const controlElm = closest$3(SugarElement.fromDom(targetElm), controlElmSelector).map(e => e.dom).filter(e => dom.isEditable(e.parentElement) || e.nodeName === 'IMG' && dom.isEditable(e)).getOrUndefined();\r\n        const selectedValue = isNonNullable(controlElm) ? dom.getAttrib(controlElm, elementSelectionAttr, '1') : '1';\r\n        each$e(dom.select(`img[${ elementSelectionAttr }],hr[${ elementSelectionAttr }]`), img => {\r\n          img.removeAttribute(elementSelectionAttr);\r\n        });\r\n        if (isNonNullable(controlElm) && isChildOrEqual(controlElm, rootElement) && editor.hasFocus()) {\r\n          disableGeckoResize();\r\n          const startElm = selection.getStart(true);\r\n          if (isChildOrEqual(startElm, controlElm) && isChildOrEqual(selection.getEnd(true), controlElm)) {\r\n            dom.setAttrib(controlElm, elementSelectionAttr, selectedValue);\r\n            throttledShowResizeRect.throttle(controlElm);\r\n            return;\r\n          }\r\n        }\r\n        hideResizeRect();\r\n      };\r\n      const unbindResizeHandleEvents = () => {\r\n        each$d(resizeHandles, handle => {\r\n          if (handle.elm) {\r\n            dom.unbind(handle.elm);\r\n            delete handle.elm;\r\n          }\r\n        });\r\n      };\r\n      const disableGeckoResize = () => {\r\n        try {\r\n          editor.getDoc().execCommand('enableObjectResizing', false, 'false');\r\n        } catch (ex) {\r\n        }\r\n      };\r\n      editor.on('init', () => {\r\n        disableGeckoResize();\r\n        editor.on('NodeChange ResizeEditor ResizeWindow ResizeContent drop', updateResizeRect);\r\n        editor.on('keyup compositionend', e => {\r\n          if (selectedElm && selectedElm.nodeName === 'TABLE') {\r\n            updateResizeRect(e);\r\n          }\r\n        });\r\n        editor.on('hide blur', hideResizeRect);\r\n        editor.on('contextmenu longpress', contextMenuSelectImage, true);\r\n      });\r\n      editor.on('remove', unbindResizeHandleEvents);\r\n      const destroy = () => {\r\n        throttledShowResizeRect.cancel();\r\n        selectedElm = selectedElmGhost = resizeBackdrop = null;\r\n      };\r\n      return {\r\n        isResizable,\r\n        showResizeRect,\r\n        hideResizeRect,\r\n        updateResizeRect,\r\n        destroy\r\n      };\r\n    };\r\n\r\n    const setStart = (rng, situ) => {\r\n      situ.fold(e => {\r\n        rng.setStartBefore(e.dom);\r\n      }, (e, o) => {\r\n        rng.setStart(e.dom, o);\r\n      }, e => {\r\n        rng.setStartAfter(e.dom);\r\n      });\r\n    };\r\n    const setFinish = (rng, situ) => {\r\n      situ.fold(e => {\r\n        rng.setEndBefore(e.dom);\r\n      }, (e, o) => {\r\n        rng.setEnd(e.dom, o);\r\n      }, e => {\r\n        rng.setEndAfter(e.dom);\r\n      });\r\n    };\r\n    const relativeToNative = (win, startSitu, finishSitu) => {\r\n      const range = win.document.createRange();\r\n      setStart(range, startSitu);\r\n      setFinish(range, finishSitu);\r\n      return range;\r\n    };\r\n    const exactToNative = (win, start, soffset, finish, foffset) => {\r\n      const rng = win.document.createRange();\r\n      rng.setStart(start.dom, soffset);\r\n      rng.setEnd(finish.dom, foffset);\r\n      return rng;\r\n    };\r\n\r\n    const adt$3 = Adt.generate([\r\n      {\r\n        ltr: [\r\n          'start',\r\n          'soffset',\r\n          'finish',\r\n          'foffset'\r\n        ]\r\n      },\r\n      {\r\n        rtl: [\r\n          'start',\r\n          'soffset',\r\n          'finish',\r\n          'foffset'\r\n        ]\r\n      }\r\n    ]);\r\n    const fromRange = (win, type, range) => type(SugarElement.fromDom(range.startContainer), range.startOffset, SugarElement.fromDom(range.endContainer), range.endOffset);\r\n    const getRanges = (win, selection) => selection.match({\r\n      domRange: rng => {\r\n        return {\r\n          ltr: constant(rng),\r\n          rtl: Optional.none\r\n        };\r\n      },\r\n      relative: (startSitu, finishSitu) => {\r\n        return {\r\n          ltr: cached(() => relativeToNative(win, startSitu, finishSitu)),\r\n          rtl: cached(() => Optional.some(relativeToNative(win, finishSitu, startSitu)))\r\n        };\r\n      },\r\n      exact: (start, soffset, finish, foffset) => {\r\n        return {\r\n          ltr: cached(() => exactToNative(win, start, soffset, finish, foffset)),\r\n          rtl: cached(() => Optional.some(exactToNative(win, finish, foffset, start, soffset)))\r\n        };\r\n      }\r\n    });\r\n    const doDiagnose = (win, ranges) => {\r\n      const rng = ranges.ltr();\r\n      if (rng.collapsed) {\r\n        const reversed = ranges.rtl().filter(rev => rev.collapsed === false);\r\n        return reversed.map(rev => adt$3.rtl(SugarElement.fromDom(rev.endContainer), rev.endOffset, SugarElement.fromDom(rev.startContainer), rev.startOffset)).getOrThunk(() => fromRange(win, adt$3.ltr, rng));\r\n      } else {\r\n        return fromRange(win, adt$3.ltr, rng);\r\n      }\r\n    };\r\n    const diagnose = (win, selection) => {\r\n      const ranges = getRanges(win, selection);\r\n      return doDiagnose(win, ranges);\r\n    };\r\n    adt$3.ltr;\r\n    adt$3.rtl;\r\n\r\n    const create$a = (start, soffset, finish, foffset) => ({\r\n      start,\r\n      soffset,\r\n      finish,\r\n      foffset\r\n    });\r\n    const SimRange = { create: create$a };\r\n\r\n    const caretPositionFromPoint = (doc, x, y) => {\r\n      var _a, _b;\r\n      return Optional.from((_b = (_a = doc.dom).caretPositionFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y)).bind(pos => {\r\n        if (pos.offsetNode === null) {\r\n          return Optional.none();\r\n        }\r\n        const r = doc.dom.createRange();\r\n        r.setStart(pos.offsetNode, pos.offset);\r\n        r.collapse();\r\n        return Optional.some(r);\r\n      });\r\n    };\r\n    const caretRangeFromPoint = (doc, x, y) => {\r\n      var _a, _b;\r\n      return Optional.from((_b = (_a = doc.dom).caretRangeFromPoint) === null || _b === void 0 ? void 0 : _b.call(_a, x, y));\r\n    };\r\n    const availableSearch = (() => {\r\n      if (document.caretPositionFromPoint) {\r\n        return caretPositionFromPoint;\r\n      } else if (document.caretRangeFromPoint) {\r\n        return caretRangeFromPoint;\r\n      } else {\r\n        return Optional.none;\r\n      }\r\n    })();\r\n    const fromPoint$1 = (win, x, y) => {\r\n      const doc = SugarElement.fromDom(win.document);\r\n      return availableSearch(doc, x, y).map(rng => SimRange.create(SugarElement.fromDom(rng.startContainer), rng.startOffset, SugarElement.fromDom(rng.endContainer), rng.endOffset));\r\n    };\r\n\r\n    const adt$2 = Adt.generate([\r\n      { before: ['element'] },\r\n      {\r\n        on: [\r\n          'element',\r\n          'offset'\r\n        ]\r\n      },\r\n      { after: ['element'] }\r\n    ]);\r\n    const cata = (subject, onBefore, onOn, onAfter) => subject.fold(onBefore, onOn, onAfter);\r\n    const getStart$2 = situ => situ.fold(identity, identity, identity);\r\n    const before$1 = adt$2.before;\r\n    const on = adt$2.on;\r\n    const after$1 = adt$2.after;\r\n    const Situ = {\r\n      before: before$1,\r\n      on,\r\n      after: after$1,\r\n      cata,\r\n      getStart: getStart$2\r\n    };\r\n\r\n    const adt$1 = Adt.generate([\r\n      { domRange: ['rng'] },\r\n      {\r\n        relative: [\r\n          'startSitu',\r\n          'finishSitu'\r\n        ]\r\n      },\r\n      {\r\n        exact: [\r\n          'start',\r\n          'soffset',\r\n          'finish',\r\n          'foffset'\r\n        ]\r\n      }\r\n    ]);\r\n    const exactFromRange = simRange => adt$1.exact(simRange.start, simRange.soffset, simRange.finish, simRange.foffset);\r\n    const getStart$1 = selection => selection.match({\r\n      domRange: rng => SugarElement.fromDom(rng.startContainer),\r\n      relative: (startSitu, _finishSitu) => Situ.getStart(startSitu),\r\n      exact: (start, _soffset, _finish, _foffset) => start\r\n    });\r\n    const domRange = adt$1.domRange;\r\n    const relative = adt$1.relative;\r\n    const exact = adt$1.exact;\r\n    const getWin = selection => {\r\n      const start = getStart$1(selection);\r\n      return defaultView(start);\r\n    };\r\n    const range = SimRange.create;\r\n    const SimSelection = {\r\n      domRange,\r\n      relative,\r\n      exact,\r\n      exactFromRange,\r\n      getWin,\r\n      range\r\n    };\r\n\r\n    const beforeSpecial = (element, offset) => {\r\n      const name$1 = name(element);\r\n      if ('input' === name$1) {\r\n        return Situ.after(element);\r\n      } else if (!contains$2([\r\n          'br',\r\n          'img'\r\n        ], name$1)) {\r\n        return Situ.on(element, offset);\r\n      } else {\r\n        return offset === 0 ? Situ.before(element) : Situ.after(element);\r\n      }\r\n    };\r\n    const preprocessRelative = (startSitu, finishSitu) => {\r\n      const start = startSitu.fold(Situ.before, beforeSpecial, Situ.after);\r\n      const finish = finishSitu.fold(Situ.before, beforeSpecial, Situ.after);\r\n      return SimSelection.relative(start, finish);\r\n    };\r\n    const preprocessExact = (start, soffset, finish, foffset) => {\r\n      const startSitu = beforeSpecial(start, soffset);\r\n      const finishSitu = beforeSpecial(finish, foffset);\r\n      return SimSelection.relative(startSitu, finishSitu);\r\n    };\r\n    const preprocess = selection => selection.match({\r\n      domRange: rng => {\r\n        const start = SugarElement.fromDom(rng.startContainer);\r\n        const finish = SugarElement.fromDom(rng.endContainer);\r\n        return preprocessExact(start, rng.startOffset, finish, rng.endOffset);\r\n      },\r\n      relative: preprocessRelative,\r\n      exact: preprocessExact\r\n    });\r\n\r\n    const fromElements = (elements, scope) => {\r\n      const doc = scope || document;\r\n      const fragment = doc.createDocumentFragment();\r\n      each$e(elements, element => {\r\n        fragment.appendChild(element.dom);\r\n      });\r\n      return SugarElement.fromDom(fragment);\r\n    };\r\n\r\n    const toNative = selection => {\r\n      const win = SimSelection.getWin(selection).dom;\r\n      const getDomRange = (start, soffset, finish, foffset) => exactToNative(win, start, soffset, finish, foffset);\r\n      const filtered = preprocess(selection);\r\n      return diagnose(win, filtered).match({\r\n        ltr: getDomRange,\r\n        rtl: getDomRange\r\n      });\r\n    };\r\n    const getAtPoint = (win, x, y) => fromPoint$1(win, x, y);\r\n\r\n    const fromPoint = (clientX, clientY, doc) => {\r\n      const win = defaultView(SugarElement.fromDom(doc));\r\n      return getAtPoint(win.dom, clientX, clientY).map(simRange => {\r\n        const rng = doc.createRange();\r\n        rng.setStart(simRange.start.dom, simRange.soffset);\r\n        rng.setEnd(simRange.finish.dom, simRange.foffset);\r\n        return rng;\r\n      }).getOrUndefined();\r\n    };\r\n\r\n    const isEq$4 = (rng1, rng2) => {\r\n      return isNonNullable(rng1) && isNonNullable(rng2) && (rng1.startContainer === rng2.startContainer && rng1.startOffset === rng2.startOffset) && (rng1.endContainer === rng2.endContainer && rng1.endOffset === rng2.endOffset);\r\n    };\r\n\r\n    const findParent = (node, rootNode, predicate) => {\r\n      let currentNode = node;\r\n      while (currentNode && currentNode !== rootNode) {\r\n        if (predicate(currentNode)) {\r\n          return currentNode;\r\n        }\r\n        currentNode = currentNode.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n    const hasParent$1 = (node, rootNode, predicate) => findParent(node, rootNode, predicate) !== null;\r\n    const hasParentWithName = (node, rootNode, name) => hasParent$1(node, rootNode, node => node.nodeName === name);\r\n    const isCeFalseCaretContainer = (node, rootNode) => isCaretContainer$2(node) && !hasParent$1(node, rootNode, isCaretNode);\r\n    const hasBrBeforeAfter = (dom, node, left) => {\r\n      const parentNode = node.parentNode;\r\n      if (parentNode) {\r\n        const walker = new DomTreeWalker(node, dom.getParent(parentNode, dom.isBlock) || dom.getRoot());\r\n        let currentNode;\r\n        while (currentNode = walker[left ? 'prev' : 'next']()) {\r\n          if (isBr$6(currentNode)) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    const isPrevNode = (node, name) => {\r\n      var _a;\r\n      return ((_a = node.previousSibling) === null || _a === void 0 ? void 0 : _a.nodeName) === name;\r\n    };\r\n    const hasContentEditableFalseParent = (root, node) => {\r\n      let currentNode = node;\r\n      while (currentNode && currentNode !== root) {\r\n        if (isContentEditableFalse$b(currentNode)) {\r\n          return true;\r\n        }\r\n        currentNode = currentNode.parentNode;\r\n      }\r\n      return false;\r\n    };\r\n    const findTextNodeRelative = (dom, isAfterNode, collapsed, left, startNode) => {\r\n      const body = dom.getRoot();\r\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\r\n      const parentNode = startNode.parentNode;\r\n      let lastInlineElement;\r\n      let node;\r\n      if (!parentNode) {\r\n        return Optional.none();\r\n      }\r\n      const parentBlockContainer = dom.getParent(parentNode, dom.isBlock) || body;\r\n      if (left && isBr$6(startNode) && isAfterNode && dom.isEmpty(parentBlockContainer)) {\r\n        return Optional.some(CaretPosition(parentNode, dom.nodeIndex(startNode)));\r\n      }\r\n      const walker = new DomTreeWalker(startNode, parentBlockContainer);\r\n      while (node = walker[left ? 'prev' : 'next']()) {\r\n        if (dom.getContentEditableParent(node) === 'false' || isCeFalseCaretContainer(node, body)) {\r\n          return Optional.none();\r\n        }\r\n        if (isText$a(node) && node.data.length > 0) {\r\n          if (!hasParentWithName(node, body, 'A')) {\r\n            return Optional.some(CaretPosition(node, left ? node.data.length : 0));\r\n          }\r\n          return Optional.none();\r\n        }\r\n        if (dom.isBlock(node) || nonEmptyElementsMap[node.nodeName.toLowerCase()]) {\r\n          return Optional.none();\r\n        }\r\n        lastInlineElement = node;\r\n      }\r\n      if (isComment(lastInlineElement)) {\r\n        return Optional.none();\r\n      }\r\n      if (collapsed && lastInlineElement) {\r\n        return Optional.some(CaretPosition(lastInlineElement, 0));\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const normalizeEndPoint = (dom, collapsed, start, rng) => {\r\n      const body = dom.getRoot();\r\n      let node;\r\n      let normalized = false;\r\n      let container = start ? rng.startContainer : rng.endContainer;\r\n      let offset = start ? rng.startOffset : rng.endOffset;\r\n      const isAfterNode = isElement$6(container) && offset === container.childNodes.length;\r\n      const nonEmptyElementsMap = dom.schema.getNonEmptyElements();\r\n      let directionLeft = start;\r\n      if (isCaretContainer$2(container)) {\r\n        return Optional.none();\r\n      }\r\n      if (isElement$6(container) && offset > container.childNodes.length - 1) {\r\n        directionLeft = false;\r\n      }\r\n      if (isDocument$1(container)) {\r\n        container = body;\r\n        offset = 0;\r\n      }\r\n      if (container === body) {\r\n        if (directionLeft) {\r\n          node = container.childNodes[offset > 0 ? offset - 1 : 0];\r\n          if (node) {\r\n            if (isCaretContainer$2(node)) {\r\n              return Optional.none();\r\n            }\r\n            if (nonEmptyElementsMap[node.nodeName] || isTable$2(node)) {\r\n              return Optional.none();\r\n            }\r\n          }\r\n        }\r\n        if (container.hasChildNodes()) {\r\n          offset = Math.min(!directionLeft && offset > 0 ? offset - 1 : offset, container.childNodes.length - 1);\r\n          container = container.childNodes[offset];\r\n          offset = isText$a(container) && isAfterNode ? container.data.length : 0;\r\n          if (!collapsed && container === body.lastChild && isTable$2(container)) {\r\n            return Optional.none();\r\n          }\r\n          if (hasContentEditableFalseParent(body, container) || isCaretContainer$2(container)) {\r\n            return Optional.none();\r\n          }\r\n          if (isDetails(container)) {\r\n            return Optional.none();\r\n          }\r\n          if (container.hasChildNodes() && !isTable$2(container)) {\r\n            node = container;\r\n            const walker = new DomTreeWalker(container, body);\r\n            do {\r\n              if (isContentEditableFalse$b(node) || isCaretContainer$2(node)) {\r\n                normalized = false;\r\n                break;\r\n              }\r\n              if (isText$a(node) && node.data.length > 0) {\r\n                offset = directionLeft ? 0 : node.data.length;\r\n                container = node;\r\n                normalized = true;\r\n                break;\r\n              }\r\n              if (nonEmptyElementsMap[node.nodeName.toLowerCase()] && !isTableCellOrCaption(node)) {\r\n                offset = dom.nodeIndex(node);\r\n                container = node.parentNode;\r\n                if (!directionLeft) {\r\n                  offset++;\r\n                }\r\n                normalized = true;\r\n                break;\r\n              }\r\n            } while (node = directionLeft ? walker.next() : walker.prev());\r\n          }\r\n        }\r\n      }\r\n      if (collapsed) {\r\n        if (isText$a(container) && offset === 0) {\r\n          findTextNodeRelative(dom, isAfterNode, collapsed, true, container).each(pos => {\r\n            container = pos.container();\r\n            offset = pos.offset();\r\n            normalized = true;\r\n          });\r\n        }\r\n        if (isElement$6(container)) {\r\n          node = container.childNodes[offset];\r\n          if (!node) {\r\n            node = container.childNodes[offset - 1];\r\n          }\r\n          if (node && isBr$6(node) && !isPrevNode(node, 'A') && !hasBrBeforeAfter(dom, node, false) && !hasBrBeforeAfter(dom, node, true)) {\r\n            findTextNodeRelative(dom, isAfterNode, collapsed, true, node).each(pos => {\r\n              container = pos.container();\r\n              offset = pos.offset();\r\n              normalized = true;\r\n            });\r\n          }\r\n        }\r\n      }\r\n      if (directionLeft && !collapsed && isText$a(container) && offset === container.data.length) {\r\n        findTextNodeRelative(dom, isAfterNode, collapsed, false, container).each(pos => {\r\n          container = pos.container();\r\n          offset = pos.offset();\r\n          normalized = true;\r\n        });\r\n      }\r\n      return normalized && container ? Optional.some(CaretPosition(container, offset)) : Optional.none();\r\n    };\r\n    const normalize$2 = (dom, rng) => {\r\n      const collapsed = rng.collapsed, normRng = rng.cloneRange();\r\n      const startPos = CaretPosition.fromRangeStart(rng);\r\n      normalizeEndPoint(dom, collapsed, true, normRng).each(pos => {\r\n        if (!collapsed || !CaretPosition.isAbove(startPos, pos)) {\r\n          normRng.setStart(pos.container(), pos.offset());\r\n        }\r\n      });\r\n      if (!collapsed) {\r\n        normalizeEndPoint(dom, collapsed, false, normRng).each(pos => {\r\n          normRng.setEnd(pos.container(), pos.offset());\r\n        });\r\n      }\r\n      if (collapsed) {\r\n        normRng.collapse(true);\r\n      }\r\n      return isEq$4(rng, normRng) ? Optional.none() : Optional.some(normRng);\r\n    };\r\n\r\n    const splitText = (node, offset) => {\r\n      return node.splitText(offset);\r\n    };\r\n    const split = rng => {\r\n      let startContainer = rng.startContainer, startOffset = rng.startOffset, endContainer = rng.endContainer, endOffset = rng.endOffset;\r\n      if (startContainer === endContainer && isText$a(startContainer)) {\r\n        if (startOffset > 0 && startOffset < startContainer.data.length) {\r\n          endContainer = splitText(startContainer, startOffset);\r\n          startContainer = endContainer.previousSibling;\r\n          if (endOffset > startOffset) {\r\n            endOffset = endOffset - startOffset;\r\n            const newContainer = splitText(endContainer, endOffset).previousSibling;\r\n            startContainer = endContainer = newContainer;\r\n            endOffset = newContainer.data.length;\r\n            startOffset = 0;\r\n          } else {\r\n            endOffset = 0;\r\n          }\r\n        }\r\n      } else {\r\n        if (isText$a(startContainer) && startOffset > 0 && startOffset < startContainer.data.length) {\r\n          startContainer = splitText(startContainer, startOffset);\r\n          startOffset = 0;\r\n        }\r\n        if (isText$a(endContainer) && endOffset > 0 && endOffset < endContainer.data.length) {\r\n          const newContainer = splitText(endContainer, endOffset).previousSibling;\r\n          endContainer = newContainer;\r\n          endOffset = newContainer.data.length;\r\n        }\r\n      }\r\n      return {\r\n        startContainer,\r\n        startOffset,\r\n        endContainer,\r\n        endOffset\r\n      };\r\n    };\r\n\r\n    const RangeUtils = dom => {\r\n      const walk = (rng, callback) => {\r\n        return walk$3(dom, rng, callback);\r\n      };\r\n      const split$1 = split;\r\n      const normalize = rng => {\r\n        return normalize$2(dom, rng).fold(never, normalizedRng => {\r\n          rng.setStart(normalizedRng.startContainer, normalizedRng.startOffset);\r\n          rng.setEnd(normalizedRng.endContainer, normalizedRng.endOffset);\r\n          return true;\r\n        });\r\n      };\r\n      const expand = (rng, options = { type: 'word' }) => {\r\n        if (options.type === 'word') {\r\n          const rangeLike = expandRng(dom, rng, [{ inline: 'span' }]);\r\n          const newRange = dom.createRng();\r\n          newRange.setStart(rangeLike.startContainer, rangeLike.startOffset);\r\n          newRange.setEnd(rangeLike.endContainer, rangeLike.endOffset);\r\n          return newRange;\r\n        }\r\n        return rng;\r\n      };\r\n      return {\r\n        walk,\r\n        split: split$1,\r\n        expand,\r\n        normalize\r\n      };\r\n    };\r\n    RangeUtils.compareRanges = isEq$4;\r\n    RangeUtils.getCaretRangeFromPoint = fromPoint;\r\n    RangeUtils.getSelectedNode = getSelectedNode;\r\n    RangeUtils.getNode = getNode$1;\r\n\r\n    const Dimension = (name, getOffset) => {\r\n      const set = (element, h) => {\r\n        if (!isNumber(h) && !h.match(/^[0-9]+$/)) {\r\n          throw new Error(name + '.set accepts only positive integer values. Value was ' + h);\r\n        }\r\n        const dom = element.dom;\r\n        if (isSupported(dom)) {\r\n          dom.style[name] = h + 'px';\r\n        }\r\n      };\r\n      const get = element => {\r\n        const r = getOffset(element);\r\n        if (r <= 0 || r === null) {\r\n          const css = get$7(element, name);\r\n          return parseFloat(css) || 0;\r\n        }\r\n        return r;\r\n      };\r\n      const getOuter = get;\r\n      const aggregate = (element, properties) => foldl(properties, (acc, property) => {\r\n        const val = get$7(element, property);\r\n        const value = val === undefined ? 0 : parseInt(val, 10);\r\n        return isNaN(value) ? acc : acc + value;\r\n      }, 0);\r\n      const max = (element, value, properties) => {\r\n        const cumulativeInclusions = aggregate(element, properties);\r\n        const absoluteMax = value > cumulativeInclusions ? value - cumulativeInclusions : 0;\r\n        return absoluteMax;\r\n      };\r\n      return {\r\n        set,\r\n        get,\r\n        getOuter,\r\n        aggregate,\r\n        max\r\n      };\r\n    };\r\n\r\n    const api = Dimension('height', element => {\r\n      const dom = element.dom;\r\n      return inBody(element) ? dom.getBoundingClientRect().height : dom.offsetHeight;\r\n    });\r\n    const get$2 = element => api.get(element);\r\n\r\n    const getDocument = () => SugarElement.fromDom(document);\r\n\r\n    const walkUp = (navigation, doc) => {\r\n      const frame = navigation.view(doc);\r\n      return frame.fold(constant([]), f => {\r\n        const parent = navigation.owner(f);\r\n        const rest = walkUp(navigation, parent);\r\n        return [f].concat(rest);\r\n      });\r\n    };\r\n    const pathTo = (element, navigation) => {\r\n      const d = navigation.owner(element);\r\n      return walkUp(navigation, d);\r\n    };\r\n\r\n    const view = doc => {\r\n      var _a;\r\n      const element = doc.dom === document ? Optional.none() : Optional.from((_a = doc.dom.defaultView) === null || _a === void 0 ? void 0 : _a.frameElement);\r\n      return element.map(SugarElement.fromDom);\r\n    };\r\n    const owner = element => documentOrOwner(element);\r\n\r\n    var Navigation = /*#__PURE__*/Object.freeze({\r\n        __proto__: null,\r\n        view: view,\r\n        owner: owner\r\n    });\r\n\r\n    const find = element => {\r\n      const doc = getDocument();\r\n      const scroll = get$5(doc);\r\n      const frames = pathTo(element, Navigation);\r\n      const offset = viewport(element);\r\n      const r = foldr(frames, (b, a) => {\r\n        const loc = viewport(a);\r\n        return {\r\n          left: b.left + loc.left,\r\n          top: b.top + loc.top\r\n        };\r\n      }, {\r\n        left: 0,\r\n        top: 0\r\n      });\r\n      return SugarPosition(r.left + offset.left + scroll.left, r.top + offset.top + scroll.top);\r\n    };\r\n\r\n    const excludeFromDescend = element => name(element) === 'textarea';\r\n    const fireScrollIntoViewEvent = (editor, data) => {\r\n      const scrollEvent = editor.dispatch('ScrollIntoView', data);\r\n      return scrollEvent.isDefaultPrevented();\r\n    };\r\n    const fireAfterScrollIntoViewEvent = (editor, data) => {\r\n      editor.dispatch('AfterScrollIntoView', data);\r\n    };\r\n    const descend = (element, offset) => {\r\n      const children = children$1(element);\r\n      if (children.length === 0 || excludeFromDescend(element)) {\r\n        return {\r\n          element,\r\n          offset\r\n        };\r\n      } else if (offset < children.length && !excludeFromDescend(children[offset])) {\r\n        return {\r\n          element: children[offset],\r\n          offset: 0\r\n        };\r\n      } else {\r\n        const last = children[children.length - 1];\r\n        if (excludeFromDescend(last)) {\r\n          return {\r\n            element,\r\n            offset\r\n          };\r\n        } else {\r\n          if (name(last) === 'img') {\r\n            return {\r\n              element: last,\r\n              offset: 1\r\n            };\r\n          } else if (isText$b(last)) {\r\n            return {\r\n              element: last,\r\n              offset: get$3(last).length\r\n            };\r\n          } else {\r\n            return {\r\n              element: last,\r\n              offset: children$1(last).length\r\n            };\r\n          }\r\n        }\r\n      }\r\n    };\r\n    const markerInfo = (element, cleanupFun) => {\r\n      const pos = absolute(element);\r\n      const height = get$2(element);\r\n      return {\r\n        element,\r\n        bottom: pos.top + height,\r\n        height,\r\n        pos,\r\n        cleanup: cleanupFun\r\n      };\r\n    };\r\n    const createMarker$1 = (element, offset) => {\r\n      const startPoint = descend(element, offset);\r\n      const span = SugarElement.fromHtml('<span data-mce-bogus=\"all\" style=\"display: inline-block;\">' + ZWSP$1 + '</span>');\r\n      before$3(startPoint.element, span);\r\n      return markerInfo(span, () => remove$5(span));\r\n    };\r\n    const elementMarker = element => markerInfo(SugarElement.fromDom(element), noop);\r\n    const withMarker = (editor, f, rng, alignToTop) => {\r\n      preserveWith(editor, (_s, _e) => applyWithMarker(editor, f, rng, alignToTop), rng);\r\n    };\r\n    const withScrollEvents = (editor, doc, f, marker, alignToTop) => {\r\n      const data = {\r\n        elm: marker.element.dom,\r\n        alignToTop\r\n      };\r\n      if (fireScrollIntoViewEvent(editor, data)) {\r\n        return;\r\n      }\r\n      const scrollTop = get$5(doc).top;\r\n      f(editor, doc, scrollTop, marker, alignToTop);\r\n      fireAfterScrollIntoViewEvent(editor, data);\r\n    };\r\n    const applyWithMarker = (editor, f, rng, alignToTop) => {\r\n      const body = SugarElement.fromDom(editor.getBody());\r\n      const doc = SugarElement.fromDom(editor.getDoc());\r\n      reflow(body);\r\n      const marker = createMarker$1(SugarElement.fromDom(rng.startContainer), rng.startOffset);\r\n      withScrollEvents(editor, doc, f, marker, alignToTop);\r\n      marker.cleanup();\r\n    };\r\n    const withElement = (editor, element, f, alignToTop) => {\r\n      const doc = SugarElement.fromDom(editor.getDoc());\r\n      withScrollEvents(editor, doc, f, elementMarker(element), alignToTop);\r\n    };\r\n    const preserveWith = (editor, f, rng) => {\r\n      const startElement = rng.startContainer;\r\n      const startOffset = rng.startOffset;\r\n      const endElement = rng.endContainer;\r\n      const endOffset = rng.endOffset;\r\n      f(SugarElement.fromDom(startElement), SugarElement.fromDom(endElement));\r\n      const newRng = editor.dom.createRng();\r\n      newRng.setStart(startElement, startOffset);\r\n      newRng.setEnd(endElement, endOffset);\r\n      editor.selection.setRng(rng);\r\n    };\r\n    const scrollToMarker = (editor, marker, viewHeight, alignToTop, doc) => {\r\n      const pos = marker.pos;\r\n      if (alignToTop) {\r\n        to(pos.left, pos.top, doc);\r\n      } else {\r\n        const y = pos.top - viewHeight + marker.height;\r\n        to(-editor.getBody().getBoundingClientRect().left, y, doc);\r\n      }\r\n    };\r\n    const intoWindowIfNeeded = (editor, doc, scrollTop, viewHeight, marker, alignToTop) => {\r\n      const viewportBottom = viewHeight + scrollTop;\r\n      const markerTop = marker.pos.top;\r\n      const markerBottom = marker.bottom;\r\n      const largerThanViewport = markerBottom - markerTop >= viewHeight;\r\n      if (markerTop < scrollTop) {\r\n        scrollToMarker(editor, marker, viewHeight, alignToTop !== false, doc);\r\n      } else if (markerTop > viewportBottom) {\r\n        const align = largerThanViewport ? alignToTop !== false : alignToTop === true;\r\n        scrollToMarker(editor, marker, viewHeight, align, doc);\r\n      } else if (markerBottom > viewportBottom && !largerThanViewport) {\r\n        scrollToMarker(editor, marker, viewHeight, alignToTop === true, doc);\r\n      }\r\n    };\r\n    const intoWindow = (editor, doc, scrollTop, marker, alignToTop) => {\r\n      const viewHeight = defaultView(doc).dom.innerHeight;\r\n      intoWindowIfNeeded(editor, doc, scrollTop, viewHeight, marker, alignToTop);\r\n    };\r\n    const intoFrame = (editor, doc, scrollTop, marker, alignToTop) => {\r\n      const frameViewHeight = defaultView(doc).dom.innerHeight;\r\n      intoWindowIfNeeded(editor, doc, scrollTop, frameViewHeight, marker, alignToTop);\r\n      const op = find(marker.element);\r\n      const viewportBounds = getBounds(window);\r\n      if (op.top < viewportBounds.y) {\r\n        intoView(marker.element, alignToTop !== false);\r\n      } else if (op.top > viewportBounds.bottom) {\r\n        intoView(marker.element, alignToTop === true);\r\n      }\r\n    };\r\n    const rangeIntoWindow = (editor, rng, alignToTop) => withMarker(editor, intoWindow, rng, alignToTop);\r\n    const elementIntoWindow = (editor, element, alignToTop) => withElement(editor, element, intoWindow, alignToTop);\r\n    const rangeIntoFrame = (editor, rng, alignToTop) => withMarker(editor, intoFrame, rng, alignToTop);\r\n    const elementIntoFrame = (editor, element, alignToTop) => withElement(editor, element, intoFrame, alignToTop);\r\n    const scrollElementIntoView = (editor, element, alignToTop) => {\r\n      const scroller = editor.inline ? elementIntoWindow : elementIntoFrame;\r\n      scroller(editor, element, alignToTop);\r\n    };\r\n    const scrollRangeIntoView = (editor, rng, alignToTop) => {\r\n      const scroller = editor.inline ? rangeIntoWindow : rangeIntoFrame;\r\n      scroller(editor, rng, alignToTop);\r\n    };\r\n\r\n    const focus$1 = (element, preventScroll = false) => element.dom.focus({ preventScroll });\r\n    const hasFocus$1 = element => {\r\n      const root = getRootNode(element).dom;\r\n      return element.dom === root.activeElement;\r\n    };\r\n    const active$1 = (root = getDocument()) => Optional.from(root.dom.activeElement).map(SugarElement.fromDom);\r\n    const search = element => active$1(getRootNode(element)).filter(e => element.dom.contains(e.dom));\r\n\r\n    const clamp$1 = (offset, element) => {\r\n      const max = isText$b(element) ? get$3(element).length : children$1(element).length + 1;\r\n      if (offset > max) {\r\n        return max;\r\n      } else if (offset < 0) {\r\n        return 0;\r\n      }\r\n      return offset;\r\n    };\r\n    const normalizeRng = rng => SimSelection.range(rng.start, clamp$1(rng.soffset, rng.start), rng.finish, clamp$1(rng.foffset, rng.finish));\r\n    const isOrContains = (root, elm) => !isRestrictedNode(elm.dom) && (contains(root, elm) || eq(root, elm));\r\n    const isRngInRoot = root => rng => isOrContains(root, rng.start) && isOrContains(root, rng.finish);\r\n    const shouldStore = editor => editor.inline || Env.browser.isFirefox();\r\n    const nativeRangeToSelectionRange = r => SimSelection.range(SugarElement.fromDom(r.startContainer), r.startOffset, SugarElement.fromDom(r.endContainer), r.endOffset);\r\n    const readRange = win => {\r\n      const selection = win.getSelection();\r\n      const rng = !selection || selection.rangeCount === 0 ? Optional.none() : Optional.from(selection.getRangeAt(0));\r\n      return rng.map(nativeRangeToSelectionRange);\r\n    };\r\n    const getBookmark = root => {\r\n      const win = defaultView(root);\r\n      return readRange(win.dom).filter(isRngInRoot(root));\r\n    };\r\n    const validate = (root, bookmark) => Optional.from(bookmark).filter(isRngInRoot(root)).map(normalizeRng);\r\n    const bookmarkToNativeRng = bookmark => {\r\n      const rng = document.createRange();\r\n      try {\r\n        rng.setStart(bookmark.start.dom, bookmark.soffset);\r\n        rng.setEnd(bookmark.finish.dom, bookmark.foffset);\r\n        return Optional.some(rng);\r\n      } catch (_) {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const store = editor => {\r\n      const newBookmark = shouldStore(editor) ? getBookmark(SugarElement.fromDom(editor.getBody())) : Optional.none();\r\n      editor.bookmark = newBookmark.isSome() ? newBookmark : editor.bookmark;\r\n    };\r\n    const getRng = editor => {\r\n      const bookmark = editor.bookmark ? editor.bookmark : Optional.none();\r\n      return bookmark.bind(x => validate(SugarElement.fromDom(editor.getBody()), x)).bind(bookmarkToNativeRng);\r\n    };\r\n    const restore = editor => {\r\n      getRng(editor).each(rng => editor.selection.setRng(rng));\r\n    };\r\n\r\n    const isEditorUIElement$1 = elm => {\r\n      const className = elm.className.toString();\r\n      return className.indexOf('tox-') !== -1 || className.indexOf('mce-') !== -1;\r\n    };\r\n    const FocusManager = { isEditorUIElement: isEditorUIElement$1 };\r\n\r\n    const wrappedSetTimeout = (callback, time) => {\r\n      if (!isNumber(time)) {\r\n        time = 0;\r\n      }\r\n      return setTimeout(callback, time);\r\n    };\r\n    const wrappedSetInterval = (callback, time) => {\r\n      if (!isNumber(time)) {\r\n        time = 0;\r\n      }\r\n      return setInterval(callback, time);\r\n    };\r\n    const Delay = {\r\n      setEditorTimeout: (editor, callback, time) => {\r\n        return wrappedSetTimeout(() => {\r\n          if (!editor.removed) {\r\n            callback();\r\n          }\r\n        }, time);\r\n      },\r\n      setEditorInterval: (editor, callback, time) => {\r\n        const timer = wrappedSetInterval(() => {\r\n          if (!editor.removed) {\r\n            callback();\r\n          } else {\r\n            clearInterval(timer);\r\n          }\r\n        }, time);\r\n        return timer;\r\n      }\r\n    };\r\n\r\n    const isManualNodeChange = e => {\r\n      return e.type === 'nodechange' && e.selectionChange;\r\n    };\r\n    const registerPageMouseUp = (editor, throttledStore) => {\r\n      const mouseUpPage = () => {\r\n        throttledStore.throttle();\r\n      };\r\n      DOMUtils.DOM.bind(document, 'mouseup', mouseUpPage);\r\n      editor.on('remove', () => {\r\n        DOMUtils.DOM.unbind(document, 'mouseup', mouseUpPage);\r\n      });\r\n    };\r\n    const registerMouseUp = (editor, throttledStore) => {\r\n      editor.on('mouseup touchend', _e => {\r\n        throttledStore.throttle();\r\n      });\r\n    };\r\n    const registerEditorEvents = (editor, throttledStore) => {\r\n      registerMouseUp(editor, throttledStore);\r\n      editor.on('keyup NodeChange AfterSetSelectionRange', e => {\r\n        if (!isManualNodeChange(e)) {\r\n          store(editor);\r\n        }\r\n      });\r\n    };\r\n    const register$6 = editor => {\r\n      const throttledStore = first$1(() => {\r\n        store(editor);\r\n      }, 0);\r\n      editor.on('init', () => {\r\n        if (editor.inline) {\r\n          registerPageMouseUp(editor, throttledStore);\r\n        }\r\n        registerEditorEvents(editor, throttledStore);\r\n      });\r\n      editor.on('remove', () => {\r\n        throttledStore.cancel();\r\n      });\r\n    };\r\n\r\n    let documentFocusInHandler;\r\n    const DOM$9 = DOMUtils.DOM;\r\n    const isEditorUIElement = elm => {\r\n      return isElement$6(elm) && FocusManager.isEditorUIElement(elm);\r\n    };\r\n    const isEditorContentAreaElement = elm => {\r\n      const classList = elm.classList;\r\n      if (classList !== undefined) {\r\n        return classList.contains('tox-edit-area') || classList.contains('tox-edit-area__iframe') || classList.contains('mce-content-body');\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const isUIElement = (editor, elm) => {\r\n      const customSelector = getCustomUiSelector(editor);\r\n      const parent = DOM$9.getParent(elm, elm => {\r\n        return isEditorUIElement(elm) || (customSelector ? editor.dom.is(elm, customSelector) : false);\r\n      });\r\n      return parent !== null;\r\n    };\r\n    const getActiveElement = editor => {\r\n      try {\r\n        const root = getRootNode(SugarElement.fromDom(editor.getElement()));\r\n        return active$1(root).fold(() => document.body, x => x.dom);\r\n      } catch (ex) {\r\n        return document.body;\r\n      }\r\n    };\r\n    const registerEvents$1 = (editorManager, e) => {\r\n      const editor = e.editor;\r\n      register$6(editor);\r\n      const toggleContentAreaOnFocus = (editor, fn) => {\r\n        if (shouldHighlightOnFocus(editor) && editor.inline !== true) {\r\n          const contentArea = SugarElement.fromDom(editor.getContainer());\r\n          fn(contentArea, 'tox-edit-focus');\r\n        }\r\n      };\r\n      editor.on('focusin', () => {\r\n        const focusedEditor = editorManager.focusedEditor;\r\n        if (isEditorContentAreaElement(getActiveElement(editor))) {\r\n          toggleContentAreaOnFocus(editor, add$2);\r\n        }\r\n        if (focusedEditor !== editor) {\r\n          if (focusedEditor) {\r\n            focusedEditor.dispatch('blur', { focusedEditor: editor });\r\n          }\r\n          editorManager.setActive(editor);\r\n          editorManager.focusedEditor = editor;\r\n          editor.dispatch('focus', { blurredEditor: focusedEditor });\r\n          editor.focus(true);\r\n        }\r\n      });\r\n      editor.on('focusout', () => {\r\n        Delay.setEditorTimeout(editor, () => {\r\n          const focusedEditor = editorManager.focusedEditor;\r\n          if (!isEditorContentAreaElement(getActiveElement(editor)) || focusedEditor !== editor) {\r\n            toggleContentAreaOnFocus(editor, remove$7);\r\n          }\r\n          if (!isUIElement(editor, getActiveElement(editor)) && focusedEditor === editor) {\r\n            editor.dispatch('blur', { focusedEditor: null });\r\n            editorManager.focusedEditor = null;\r\n          }\r\n        });\r\n      });\r\n      if (!documentFocusInHandler) {\r\n        documentFocusInHandler = e => {\r\n          const activeEditor = editorManager.activeEditor;\r\n          if (activeEditor) {\r\n            getOriginalEventTarget(e).each(target => {\r\n              const elem = target;\r\n              if (elem.ownerDocument === document) {\r\n                if (elem !== document.body && !isUIElement(activeEditor, elem) && editorManager.focusedEditor === activeEditor) {\r\n                  activeEditor.dispatch('blur', { focusedEditor: null });\r\n                  editorManager.focusedEditor = null;\r\n                }\r\n              }\r\n            });\r\n          }\r\n        };\r\n        DOM$9.bind(document, 'focusin', documentFocusInHandler);\r\n      }\r\n    };\r\n    const unregisterDocumentEvents = (editorManager, e) => {\r\n      if (editorManager.focusedEditor === e.editor) {\r\n        editorManager.focusedEditor = null;\r\n      }\r\n      if (!editorManager.activeEditor && documentFocusInHandler) {\r\n        DOM$9.unbind(document, 'focusin', documentFocusInHandler);\r\n        documentFocusInHandler = null;\r\n      }\r\n    };\r\n    const setup$w = editorManager => {\r\n      editorManager.on('AddEditor', curry(registerEvents$1, editorManager));\r\n      editorManager.on('RemoveEditor', curry(unregisterDocumentEvents, editorManager));\r\n    };\r\n\r\n    const getContentEditableHost = (editor, node) => editor.dom.getParent(node, node => editor.dom.getContentEditable(node) === 'true');\r\n    const getCollapsedNode = rng => rng.collapsed ? Optional.from(getNode$1(rng.startContainer, rng.startOffset)).map(SugarElement.fromDom) : Optional.none();\r\n    const getFocusInElement = (root, rng) => getCollapsedNode(rng).bind(node => {\r\n      if (isTableSection(node)) {\r\n        return Optional.some(node);\r\n      } else if (!contains(root, node)) {\r\n        return Optional.some(root);\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    });\r\n    const normalizeSelection = (editor, rng) => {\r\n      getFocusInElement(SugarElement.fromDom(editor.getBody()), rng).bind(elm => {\r\n        return firstPositionIn(elm.dom);\r\n      }).fold(() => {\r\n        editor.selection.normalize();\r\n      }, caretPos => editor.selection.setRng(caretPos.toRange()));\r\n    };\r\n    const focusBody = body => {\r\n      if (body.setActive) {\r\n        try {\r\n          body.setActive();\r\n        } catch (ex) {\r\n          body.focus();\r\n        }\r\n      } else {\r\n        body.focus();\r\n      }\r\n    };\r\n    const hasElementFocus = elm => hasFocus$1(elm) || search(elm).isSome();\r\n    const hasIframeFocus = editor => isNonNullable(editor.iframeElement) && hasFocus$1(SugarElement.fromDom(editor.iframeElement));\r\n    const hasInlineFocus = editor => {\r\n      const rawBody = editor.getBody();\r\n      return rawBody && hasElementFocus(SugarElement.fromDom(rawBody));\r\n    };\r\n    const hasUiFocus = editor => {\r\n      const dos = getRootNode(SugarElement.fromDom(editor.getElement()));\r\n      return active$1(dos).filter(elem => !isEditorContentAreaElement(elem.dom) && isUIElement(editor, elem.dom)).isSome();\r\n    };\r\n    const hasFocus = editor => editor.inline ? hasInlineFocus(editor) : hasIframeFocus(editor);\r\n    const hasEditorOrUiFocus = editor => hasFocus(editor) || hasUiFocus(editor);\r\n    const focusEditor = editor => {\r\n      const selection = editor.selection;\r\n      const body = editor.getBody();\r\n      let rng = selection.getRng();\r\n      editor.quirks.refreshContentEditable();\r\n      if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\r\n        getRng(editor).each(bookmarkRng => {\r\n          editor.selection.setRng(bookmarkRng);\r\n          rng = bookmarkRng;\r\n        });\r\n      }\r\n      const contentEditableHost = getContentEditableHost(editor, selection.getNode());\r\n      if (contentEditableHost && editor.dom.isChildOf(contentEditableHost, body)) {\r\n        focusBody(contentEditableHost);\r\n        normalizeSelection(editor, rng);\r\n        activateEditor(editor);\r\n        return;\r\n      }\r\n      if (!editor.inline) {\r\n        if (!Env.browser.isOpera()) {\r\n          focusBody(body);\r\n        }\r\n        editor.getWin().focus();\r\n      }\r\n      if (Env.browser.isFirefox() || editor.inline) {\r\n        focusBody(body);\r\n        normalizeSelection(editor, rng);\r\n      }\r\n      activateEditor(editor);\r\n    };\r\n    const activateEditor = editor => editor.editorManager.setActive(editor);\r\n    const focus = (editor, skipFocus) => {\r\n      if (editor.removed) {\r\n        return;\r\n      }\r\n      if (skipFocus) {\r\n        activateEditor(editor);\r\n      } else {\r\n        focusEditor(editor);\r\n      }\r\n    };\r\n\r\n    const isEditableRange = (dom, rng) => {\r\n      if (rng.collapsed) {\r\n        return dom.isEditable(rng.startContainer);\r\n      } else {\r\n        return dom.isEditable(rng.startContainer) && dom.isEditable(rng.endContainer);\r\n      }\r\n    };\r\n\r\n    const getEndpointElement = (root, rng, start, real, resolve) => {\r\n      const container = start ? rng.startContainer : rng.endContainer;\r\n      const offset = start ? rng.startOffset : rng.endOffset;\r\n      return Optional.from(container).map(SugarElement.fromDom).map(elm => !real || !rng.collapsed ? child$1(elm, resolve(elm, offset)).getOr(elm) : elm).bind(elm => isElement$7(elm) ? Optional.some(elm) : parent(elm).filter(isElement$7)).map(elm => elm.dom).getOr(root);\r\n    };\r\n    const getStart = (root, rng, real = false) => getEndpointElement(root, rng, true, real, (elm, offset) => Math.min(childNodesCount(elm), offset));\r\n    const getEnd$1 = (root, rng, real = false) => getEndpointElement(root, rng, false, real, (elm, offset) => offset > 0 ? offset - 1 : offset);\r\n    const skipEmptyTextNodes = (node, forwards) => {\r\n      const orig = node;\r\n      while (node && isText$a(node) && node.length === 0) {\r\n        node = forwards ? node.nextSibling : node.previousSibling;\r\n      }\r\n      return node || orig;\r\n    };\r\n    const getNode = (root, rng) => {\r\n      if (!rng) {\r\n        return root;\r\n      }\r\n      let startContainer = rng.startContainer;\r\n      let endContainer = rng.endContainer;\r\n      const startOffset = rng.startOffset;\r\n      const endOffset = rng.endOffset;\r\n      let node = rng.commonAncestorContainer;\r\n      if (!rng.collapsed) {\r\n        if (startContainer === endContainer) {\r\n          if (endOffset - startOffset < 2) {\r\n            if (startContainer.hasChildNodes()) {\r\n              node = startContainer.childNodes[startOffset];\r\n            }\r\n          }\r\n        }\r\n        if (isText$a(startContainer) && isText$a(endContainer)) {\r\n          if (startContainer.length === startOffset) {\r\n            startContainer = skipEmptyTextNodes(startContainer.nextSibling, true);\r\n          } else {\r\n            startContainer = startContainer.parentNode;\r\n          }\r\n          if (endOffset === 0) {\r\n            endContainer = skipEmptyTextNodes(endContainer.previousSibling, false);\r\n          } else {\r\n            endContainer = endContainer.parentNode;\r\n          }\r\n          if (startContainer && startContainer === endContainer) {\r\n            node = startContainer;\r\n          }\r\n        }\r\n      }\r\n      const elm = isText$a(node) ? node.parentNode : node;\r\n      return isHTMLElement(elm) ? elm : root;\r\n    };\r\n    const getSelectedBlocks = (dom, rng, startElm, endElm) => {\r\n      const selectedBlocks = [];\r\n      const root = dom.getRoot();\r\n      const start = dom.getParent(startElm || getStart(root, rng, rng.collapsed), dom.isBlock);\r\n      const end = dom.getParent(endElm || getEnd$1(root, rng, rng.collapsed), dom.isBlock);\r\n      if (start && start !== root) {\r\n        selectedBlocks.push(start);\r\n      }\r\n      if (start && end && start !== end) {\r\n        let node;\r\n        const walker = new DomTreeWalker(start, root);\r\n        while ((node = walker.next()) && node !== end) {\r\n          if (dom.isBlock(node)) {\r\n            selectedBlocks.push(node);\r\n          }\r\n        }\r\n      }\r\n      if (end && start !== end && end !== root) {\r\n        selectedBlocks.push(end);\r\n      }\r\n      return selectedBlocks;\r\n    };\r\n    const select = (dom, node, content) => Optional.from(node).bind(node => Optional.from(node.parentNode).map(parent => {\r\n      const idx = dom.nodeIndex(node);\r\n      const rng = dom.createRng();\r\n      rng.setStart(parent, idx);\r\n      rng.setEnd(parent, idx + 1);\r\n      if (content) {\r\n        moveEndPoint(dom, rng, node, true);\r\n        moveEndPoint(dom, rng, node, false);\r\n      }\r\n      return rng;\r\n    }));\r\n\r\n    const processRanges = (editor, ranges) => map$3(ranges, range => {\r\n      const evt = editor.dispatch('GetSelectionRange', { range });\r\n      return evt.range !== range ? evt.range : range;\r\n    });\r\n\r\n    const getEnd = element => name(element) === 'img' ? 1 : getOption(element).fold(() => children$1(element).length, v => v.length);\r\n    const isTextNodeWithCursorPosition = el => getOption(el).filter(text => text.trim().length !== 0 || text.indexOf(nbsp) > -1).isSome();\r\n    const isContentEditableFalse$5 = elem => isHTMLElement$1(elem) && get$9(elem, 'contenteditable') === 'false';\r\n    const elementsWithCursorPosition = [\r\n      'img',\r\n      'br'\r\n    ];\r\n    const isCursorPosition = elem => {\r\n      const hasCursorPosition = isTextNodeWithCursorPosition(elem);\r\n      return hasCursorPosition || contains$2(elementsWithCursorPosition, name(elem)) || isContentEditableFalse$5(elem);\r\n    };\r\n\r\n    const first = element => descendant$2(element, isCursorPosition);\r\n    const last = element => descendantRtl(element, isCursorPosition);\r\n    const descendantRtl = (scope, predicate) => {\r\n      const descend = element => {\r\n        const children = children$1(element);\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n          const child = children[i];\r\n          if (predicate(child)) {\r\n            return Optional.some(child);\r\n          }\r\n          const res = descend(child);\r\n          if (res.isSome()) {\r\n            return res;\r\n          }\r\n        }\r\n        return Optional.none();\r\n      };\r\n      return descend(scope);\r\n    };\r\n\r\n    const autocompleteSelector = '[data-mce-autocompleter]';\r\n    const create$9 = (editor, range) => {\r\n      if (findIn(SugarElement.fromDom(editor.getBody())).isNone()) {\r\n        const wrapper = SugarElement.fromHtml('<span data-mce-autocompleter=\"1\" data-mce-bogus=\"1\"></span>', editor.getDoc());\r\n        append$1(wrapper, SugarElement.fromDom(range.extractContents()));\r\n        range.insertNode(wrapper.dom);\r\n        parent(wrapper).each(elm => elm.dom.normalize());\r\n        last(wrapper).map(last => {\r\n          editor.selection.setCursorLocation(last.dom, getEnd(last));\r\n        });\r\n      }\r\n    };\r\n    const detect$1 = elm => closest$3(elm, autocompleteSelector);\r\n    const findIn = elm => descendant$1(elm, autocompleteSelector);\r\n    const remove$2 = (editor, elm) => findIn(elm).each(wrapper => {\r\n      const bookmark = editor.selection.getBookmark();\r\n      unwrap(wrapper);\r\n      editor.selection.moveToBookmark(bookmark);\r\n    });\r\n\r\n    const typeLookup = {\r\n      '#text': 3,\r\n      '#comment': 8,\r\n      '#cdata': 4,\r\n      '#pi': 7,\r\n      '#doctype': 10,\r\n      '#document-fragment': 11\r\n    };\r\n    const walk$2 = (node, root, prev) => {\r\n      const startName = prev ? 'lastChild' : 'firstChild';\r\n      const siblingName = prev ? 'prev' : 'next';\r\n      if (node[startName]) {\r\n        return node[startName];\r\n      }\r\n      if (node !== root) {\r\n        let sibling = node[siblingName];\r\n        if (sibling) {\r\n          return sibling;\r\n        }\r\n        for (let parent = node.parent; parent && parent !== root; parent = parent.parent) {\r\n          sibling = parent[siblingName];\r\n          if (sibling) {\r\n            return sibling;\r\n          }\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n    const isEmptyTextNode = node => {\r\n      var _a;\r\n      const text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\r\n      if (!isWhitespaceText(text)) {\r\n        return false;\r\n      }\r\n      const parentNode = node.parent;\r\n      if (parentNode && (parentNode.name !== 'span' || parentNode.attr('style')) && /^[ ]+$/.test(text)) {\r\n        return false;\r\n      }\r\n      return true;\r\n    };\r\n    const isNonEmptyElement = node => {\r\n      const isNamedAnchor = node.name === 'a' && !node.attr('href') && node.attr('id');\r\n      return node.attr('name') || node.attr('id') && !node.firstChild || node.attr('data-mce-bookmark') || isNamedAnchor;\r\n    };\r\n    class AstNode {\r\n      static create(name, attrs) {\r\n        const node = new AstNode(name, typeLookup[name] || 1);\r\n        if (attrs) {\r\n          each$d(attrs, (value, attrName) => {\r\n            node.attr(attrName, value);\r\n          });\r\n        }\r\n        return node;\r\n      }\r\n      constructor(name, type) {\r\n        this.name = name;\r\n        this.type = type;\r\n        if (type === 1) {\r\n          this.attributes = [];\r\n          this.attributes.map = {};\r\n        }\r\n      }\r\n      replace(node) {\r\n        const self = this;\r\n        if (node.parent) {\r\n          node.remove();\r\n        }\r\n        self.insert(node, self);\r\n        self.remove();\r\n        return self;\r\n      }\r\n      attr(name, value) {\r\n        const self = this;\r\n        if (!isString(name)) {\r\n          if (isNonNullable(name)) {\r\n            each$d(name, (value, key) => {\r\n              self.attr(key, value);\r\n            });\r\n          }\r\n          return self;\r\n        }\r\n        const attrs = self.attributes;\r\n        if (attrs) {\r\n          if (value !== undefined) {\r\n            if (value === null) {\r\n              if (name in attrs.map) {\r\n                delete attrs.map[name];\r\n                let i = attrs.length;\r\n                while (i--) {\r\n                  if (attrs[i].name === name) {\r\n                    attrs.splice(i, 1);\r\n                    return self;\r\n                  }\r\n                }\r\n              }\r\n              return self;\r\n            }\r\n            if (name in attrs.map) {\r\n              let i = attrs.length;\r\n              while (i--) {\r\n                if (attrs[i].name === name) {\r\n                  attrs[i].value = value;\r\n                  break;\r\n                }\r\n              }\r\n            } else {\r\n              attrs.push({\r\n                name,\r\n                value\r\n              });\r\n            }\r\n            attrs.map[name] = value;\r\n            return self;\r\n          }\r\n          return attrs.map[name];\r\n        }\r\n        return undefined;\r\n      }\r\n      clone() {\r\n        const self = this;\r\n        const clone = new AstNode(self.name, self.type);\r\n        const selfAttrs = self.attributes;\r\n        if (selfAttrs) {\r\n          const cloneAttrs = [];\r\n          cloneAttrs.map = {};\r\n          for (let i = 0, l = selfAttrs.length; i < l; i++) {\r\n            const selfAttr = selfAttrs[i];\r\n            if (selfAttr.name !== 'id') {\r\n              cloneAttrs[cloneAttrs.length] = {\r\n                name: selfAttr.name,\r\n                value: selfAttr.value\r\n              };\r\n              cloneAttrs.map[selfAttr.name] = selfAttr.value;\r\n            }\r\n          }\r\n          clone.attributes = cloneAttrs;\r\n        }\r\n        clone.value = self.value;\r\n        return clone;\r\n      }\r\n      wrap(wrapper) {\r\n        const self = this;\r\n        if (self.parent) {\r\n          self.parent.insert(wrapper, self);\r\n          wrapper.append(self);\r\n        }\r\n        return self;\r\n      }\r\n      unwrap() {\r\n        const self = this;\r\n        for (let node = self.firstChild; node;) {\r\n          const next = node.next;\r\n          self.insert(node, self, true);\r\n          node = next;\r\n        }\r\n        self.remove();\r\n      }\r\n      remove() {\r\n        const self = this, parent = self.parent, next = self.next, prev = self.prev;\r\n        if (parent) {\r\n          if (parent.firstChild === self) {\r\n            parent.firstChild = next;\r\n            if (next) {\r\n              next.prev = null;\r\n            }\r\n          } else if (prev) {\r\n            prev.next = next;\r\n          }\r\n          if (parent.lastChild === self) {\r\n            parent.lastChild = prev;\r\n            if (prev) {\r\n              prev.next = null;\r\n            }\r\n          } else if (next) {\r\n            next.prev = prev;\r\n          }\r\n          self.parent = self.next = self.prev = null;\r\n        }\r\n        return self;\r\n      }\r\n      append(node) {\r\n        const self = this;\r\n        if (node.parent) {\r\n          node.remove();\r\n        }\r\n        const last = self.lastChild;\r\n        if (last) {\r\n          last.next = node;\r\n          node.prev = last;\r\n          self.lastChild = node;\r\n        } else {\r\n          self.lastChild = self.firstChild = node;\r\n        }\r\n        node.parent = self;\r\n        return node;\r\n      }\r\n      insert(node, refNode, before) {\r\n        if (node.parent) {\r\n          node.remove();\r\n        }\r\n        const parent = refNode.parent || this;\r\n        if (before) {\r\n          if (refNode === parent.firstChild) {\r\n            parent.firstChild = node;\r\n          } else if (refNode.prev) {\r\n            refNode.prev.next = node;\r\n          }\r\n          node.prev = refNode.prev;\r\n          node.next = refNode;\r\n          refNode.prev = node;\r\n        } else {\r\n          if (refNode === parent.lastChild) {\r\n            parent.lastChild = node;\r\n          } else if (refNode.next) {\r\n            refNode.next.prev = node;\r\n          }\r\n          node.next = refNode.next;\r\n          node.prev = refNode;\r\n          refNode.next = node;\r\n        }\r\n        node.parent = parent;\r\n        return node;\r\n      }\r\n      getAll(name) {\r\n        const self = this;\r\n        const collection = [];\r\n        for (let node = self.firstChild; node; node = walk$2(node, self)) {\r\n          if (node.name === name) {\r\n            collection.push(node);\r\n          }\r\n        }\r\n        return collection;\r\n      }\r\n      children() {\r\n        const self = this;\r\n        const collection = [];\r\n        for (let node = self.firstChild; node; node = node.next) {\r\n          collection.push(node);\r\n        }\r\n        return collection;\r\n      }\r\n      empty() {\r\n        const self = this;\r\n        if (self.firstChild) {\r\n          const nodes = [];\r\n          for (let node = self.firstChild; node; node = walk$2(node, self)) {\r\n            nodes.push(node);\r\n          }\r\n          let i = nodes.length;\r\n          while (i--) {\r\n            const node = nodes[i];\r\n            node.parent = node.firstChild = node.lastChild = node.next = node.prev = null;\r\n          }\r\n        }\r\n        self.firstChild = self.lastChild = null;\r\n        return self;\r\n      }\r\n      isEmpty(elements, whitespace = {}, predicate) {\r\n        var _a;\r\n        const self = this;\r\n        let node = self.firstChild;\r\n        if (isNonEmptyElement(self)) {\r\n          return false;\r\n        }\r\n        if (node) {\r\n          do {\r\n            if (node.type === 1) {\r\n              if (node.attr('data-mce-bogus')) {\r\n                continue;\r\n              }\r\n              if (elements[node.name]) {\r\n                return false;\r\n              }\r\n              if (isNonEmptyElement(node)) {\r\n                return false;\r\n              }\r\n            }\r\n            if (node.type === 8) {\r\n              return false;\r\n            }\r\n            if (node.type === 3 && !isEmptyTextNode(node)) {\r\n              return false;\r\n            }\r\n            if (node.type === 3 && node.parent && whitespace[node.parent.name] && isWhitespaceText((_a = node.value) !== null && _a !== void 0 ? _a : '')) {\r\n              return false;\r\n            }\r\n            if (predicate && predicate(node)) {\r\n              return false;\r\n            }\r\n          } while (node = walk$2(node, self));\r\n        }\r\n        return true;\r\n      }\r\n      walk(prev) {\r\n        return walk$2(this, null, prev);\r\n      }\r\n    }\r\n\r\n    const unescapedTextParents = Tools.makeMap('NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT', ' ');\r\n    const containsZwsp = node => isString(node.nodeValue) && node.nodeValue.includes(ZWSP$1);\r\n    const getTemporaryNodeSelector = tempAttrs => `${ tempAttrs.length === 0 ? '' : `${ map$3(tempAttrs, attr => `[${ attr }]`).join(',') },` }[data-mce-bogus=\"all\"]`;\r\n    const getTemporaryNodes = (tempAttrs, body) => body.querySelectorAll(getTemporaryNodeSelector(tempAttrs));\r\n    const createZwspCommentWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_COMMENT, node => containsZwsp(node) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP);\r\n    const createUnescapedZwspTextWalker = body => document.createTreeWalker(body, NodeFilter.SHOW_TEXT, node => {\r\n      if (containsZwsp(node)) {\r\n        const parent = node.parentNode;\r\n        return parent && has$2(unescapedTextParents, parent.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\r\n      } else {\r\n        return NodeFilter.FILTER_SKIP;\r\n      }\r\n    });\r\n    const hasZwspComment = body => createZwspCommentWalker(body).nextNode() !== null;\r\n    const hasUnescapedZwspText = body => createUnescapedZwspTextWalker(body).nextNode() !== null;\r\n    const hasTemporaryNode = (tempAttrs, body) => body.querySelector(getTemporaryNodeSelector(tempAttrs)) !== null;\r\n    const trimTemporaryNodes = (tempAttrs, body) => {\r\n      each$e(getTemporaryNodes(tempAttrs, body), elm => {\r\n        const element = SugarElement.fromDom(elm);\r\n        if (get$9(element, 'data-mce-bogus') === 'all') {\r\n          remove$5(element);\r\n        } else {\r\n          each$e(tempAttrs, attr => {\r\n            if (has$1(element, attr)) {\r\n              remove$a(element, attr);\r\n            }\r\n          });\r\n        }\r\n      });\r\n    };\r\n    const emptyAllNodeValuesInWalker = walker => {\r\n      let curr = walker.nextNode();\r\n      while (curr !== null) {\r\n        curr.nodeValue = null;\r\n        curr = walker.nextNode();\r\n      }\r\n    };\r\n    const emptyZwspComments = compose(emptyAllNodeValuesInWalker, createZwspCommentWalker);\r\n    const emptyUnescapedZwspTexts = compose(emptyAllNodeValuesInWalker, createUnescapedZwspTextWalker);\r\n    const trim$1 = (body, tempAttrs) => {\r\n      const conditionalTrims = [\r\n        {\r\n          condition: curry(hasTemporaryNode, tempAttrs),\r\n          action: curry(trimTemporaryNodes, tempAttrs)\r\n        },\r\n        {\r\n          condition: hasZwspComment,\r\n          action: emptyZwspComments\r\n        },\r\n        {\r\n          condition: hasUnescapedZwspText,\r\n          action: emptyUnescapedZwspTexts\r\n        }\r\n      ];\r\n      let trimmed = body;\r\n      let cloned = false;\r\n      each$e(conditionalTrims, ({condition, action}) => {\r\n        if (condition(trimmed)) {\r\n          if (!cloned) {\r\n            trimmed = body.cloneNode(true);\r\n            cloned = true;\r\n          }\r\n          action(trimmed);\r\n        }\r\n      });\r\n      return trimmed;\r\n    };\r\n\r\n    const cleanupBogusElements = parent => {\r\n      const bogusElements = descendants(parent, '[data-mce-bogus]');\r\n      each$e(bogusElements, elem => {\r\n        const bogusValue = get$9(elem, 'data-mce-bogus');\r\n        if (bogusValue === 'all') {\r\n          remove$5(elem);\r\n        } else if (isBr$5(elem)) {\r\n          before$3(elem, SugarElement.fromText(zeroWidth));\r\n          remove$5(elem);\r\n        } else {\r\n          unwrap(elem);\r\n        }\r\n      });\r\n    };\r\n    const cleanupInputNames = parent => {\r\n      const inputs = descendants(parent, 'input');\r\n      each$e(inputs, input => {\r\n        remove$a(input, 'name');\r\n      });\r\n    };\r\n\r\n    const trimEmptyContents = (editor, html) => {\r\n      const blockName = getForcedRootBlock(editor);\r\n      const emptyRegExp = new RegExp(`^(<${ blockName }[^>]*>(&nbsp;|&#160;|\\\\s|\\u00a0|<br \\\\/>|)<\\\\/${ blockName }>[\\r\\n]*|<br \\\\/>[\\r\\n]*)$`);\r\n      return html.replace(emptyRegExp, '');\r\n    };\r\n    const getPlainTextContent = (editor, body) => {\r\n      const doc = editor.getDoc();\r\n      const dos = getRootNode(SugarElement.fromDom(editor.getBody()));\r\n      const offscreenDiv = SugarElement.fromTag('div', doc);\r\n      set$3(offscreenDiv, 'data-mce-bogus', 'all');\r\n      setAll(offscreenDiv, {\r\n        position: 'fixed',\r\n        left: '-9999999px',\r\n        top: '0'\r\n      });\r\n      set$1(offscreenDiv, body.innerHTML);\r\n      cleanupBogusElements(offscreenDiv);\r\n      cleanupInputNames(offscreenDiv);\r\n      const root = getContentContainer(dos);\r\n      append$1(root, offscreenDiv);\r\n      const content = trim$2(offscreenDiv.dom.innerText);\r\n      remove$5(offscreenDiv);\r\n      return content;\r\n    };\r\n    const getContentFromBody = (editor, args, body) => {\r\n      let content;\r\n      if (args.format === 'raw') {\r\n        content = Tools.trim(trim$2(trim$1(body, editor.serializer.getTempAttrs()).innerHTML));\r\n      } else if (args.format === 'text') {\r\n        content = getPlainTextContent(editor, body);\r\n      } else if (args.format === 'tree') {\r\n        content = editor.serializer.serialize(body, args);\r\n      } else {\r\n        content = trimEmptyContents(editor, editor.serializer.serialize(body, args));\r\n      }\r\n      const shouldTrim = args.format !== 'text' && !isWsPreserveElement(SugarElement.fromDom(body));\r\n      return shouldTrim && isString(content) ? Tools.trim(content) : content;\r\n    };\r\n    const getContentInternal = (editor, args) => Optional.from(editor.getBody()).fold(constant(args.format === 'tree' ? new AstNode('body', 11) : ''), body => getContentFromBody(editor, args, body));\r\n\r\n    const makeMap$1 = Tools.makeMap;\r\n    const Writer = settings => {\r\n      const html = [];\r\n      settings = settings || {};\r\n      const indent = settings.indent;\r\n      const indentBefore = makeMap$1(settings.indent_before || '');\r\n      const indentAfter = makeMap$1(settings.indent_after || '');\r\n      const encode = Entities.getEncodeFunc(settings.entity_encoding || 'raw', settings.entities);\r\n      const htmlOutput = settings.element_format !== 'xhtml';\r\n      return {\r\n        start: (name, attrs, empty) => {\r\n          if (indent && indentBefore[name] && html.length > 0) {\r\n            const value = html[html.length - 1];\r\n            if (value.length > 0 && value !== '\\n') {\r\n              html.push('\\n');\r\n            }\r\n          }\r\n          html.push('<', name);\r\n          if (attrs) {\r\n            for (let i = 0, l = attrs.length; i < l; i++) {\r\n              const attr = attrs[i];\r\n              html.push(' ', attr.name, '=\"', encode(attr.value, true), '\"');\r\n            }\r\n          }\r\n          if (!empty || htmlOutput) {\r\n            html[html.length] = '>';\r\n          } else {\r\n            html[html.length] = ' />';\r\n          }\r\n          if (empty && indent && indentAfter[name] && html.length > 0) {\r\n            const value = html[html.length - 1];\r\n            if (value.length > 0 && value !== '\\n') {\r\n              html.push('\\n');\r\n            }\r\n          }\r\n        },\r\n        end: name => {\r\n          let value;\r\n          html.push('</', name, '>');\r\n          if (indent && indentAfter[name] && html.length > 0) {\r\n            value = html[html.length - 1];\r\n            if (value.length > 0 && value !== '\\n') {\r\n              html.push('\\n');\r\n            }\r\n          }\r\n        },\r\n        text: (text, raw) => {\r\n          if (text.length > 0) {\r\n            html[html.length] = raw ? text : encode(text);\r\n          }\r\n        },\r\n        cdata: text => {\r\n          html.push('<![CDATA[', text, ']]>');\r\n        },\r\n        comment: text => {\r\n          html.push('<!--', text, '-->');\r\n        },\r\n        pi: (name, text) => {\r\n          if (text) {\r\n            html.push('<?', name, ' ', encode(text), '?>');\r\n          } else {\r\n            html.push('<?', name, '?>');\r\n          }\r\n          if (indent) {\r\n            html.push('\\n');\r\n          }\r\n        },\r\n        doctype: text => {\r\n          html.push('<!DOCTYPE', text, '>', indent ? '\\n' : '');\r\n        },\r\n        reset: () => {\r\n          html.length = 0;\r\n        },\r\n        getContent: () => {\r\n          return html.join('').replace(/\\n$/, '');\r\n        }\r\n      };\r\n    };\r\n\r\n    const HtmlSerializer = (settings = {}, schema = Schema()) => {\r\n      const writer = Writer(settings);\r\n      settings.validate = 'validate' in settings ? settings.validate : true;\r\n      const serialize = node => {\r\n        const validate = settings.validate;\r\n        const handlers = {\r\n          3: node => {\r\n            var _a;\r\n            writer.text((_a = node.value) !== null && _a !== void 0 ? _a : '', node.raw);\r\n          },\r\n          8: node => {\r\n            var _a;\r\n            writer.comment((_a = node.value) !== null && _a !== void 0 ? _a : '');\r\n          },\r\n          7: node => {\r\n            writer.pi(node.name, node.value);\r\n          },\r\n          10: node => {\r\n            var _a;\r\n            writer.doctype((_a = node.value) !== null && _a !== void 0 ? _a : '');\r\n          },\r\n          4: node => {\r\n            var _a;\r\n            writer.cdata((_a = node.value) !== null && _a !== void 0 ? _a : '');\r\n          },\r\n          11: node => {\r\n            let tempNode = node;\r\n            if (tempNode = tempNode.firstChild) {\r\n              do {\r\n                walk(tempNode);\r\n              } while (tempNode = tempNode.next);\r\n            }\r\n          }\r\n        };\r\n        writer.reset();\r\n        const walk = node => {\r\n          var _a;\r\n          const handler = handlers[node.type];\r\n          if (!handler) {\r\n            const name = node.name;\r\n            const isEmpty = name in schema.getVoidElements();\r\n            let attrs = node.attributes;\r\n            if (validate && attrs && attrs.length > 1) {\r\n              const sortedAttrs = [];\r\n              sortedAttrs.map = {};\r\n              const elementRule = schema.getElementRule(node.name);\r\n              if (elementRule) {\r\n                for (let i = 0, l = elementRule.attributesOrder.length; i < l; i++) {\r\n                  const attrName = elementRule.attributesOrder[i];\r\n                  if (attrName in attrs.map) {\r\n                    const attrValue = attrs.map[attrName];\r\n                    sortedAttrs.map[attrName] = attrValue;\r\n                    sortedAttrs.push({\r\n                      name: attrName,\r\n                      value: attrValue\r\n                    });\r\n                  }\r\n                }\r\n                for (let i = 0, l = attrs.length; i < l; i++) {\r\n                  const attrName = attrs[i].name;\r\n                  if (!(attrName in sortedAttrs.map)) {\r\n                    const attrValue = attrs.map[attrName];\r\n                    sortedAttrs.map[attrName] = attrValue;\r\n                    sortedAttrs.push({\r\n                      name: attrName,\r\n                      value: attrValue\r\n                    });\r\n                  }\r\n                }\r\n                attrs = sortedAttrs;\r\n              }\r\n            }\r\n            writer.start(name, attrs, isEmpty);\r\n            if (isNonHtmlElementRootName(name)) {\r\n              if (isString(node.value)) {\r\n                writer.text(node.value, true);\r\n              }\r\n              writer.end(name);\r\n            } else {\r\n              if (!isEmpty) {\r\n                let child = node.firstChild;\r\n                if (child) {\r\n                  if ((name === 'pre' || name === 'textarea') && child.type === 3 && ((_a = child.value) === null || _a === void 0 ? void 0 : _a[0]) === '\\n') {\r\n                    writer.text('\\n', true);\r\n                  }\r\n                  do {\r\n                    walk(child);\r\n                  } while (child = child.next);\r\n                }\r\n                writer.end(name);\r\n              }\r\n            }\r\n          } else {\r\n            handler(node);\r\n          }\r\n        };\r\n        if (node.type === 1 && !settings.inner) {\r\n          walk(node);\r\n        } else if (node.type === 3) {\r\n          handlers[3](node);\r\n        } else {\r\n          handlers[11](node);\r\n        }\r\n        return writer.getContent();\r\n      };\r\n      return { serialize };\r\n    };\r\n\r\n    const nonInheritableStyles = new Set();\r\n    (() => {\r\n      const nonInheritableStylesArr = [\r\n        'margin',\r\n        'margin-left',\r\n        'margin-right',\r\n        'margin-top',\r\n        'margin-bottom',\r\n        'padding',\r\n        'padding-left',\r\n        'padding-right',\r\n        'padding-top',\r\n        'padding-bottom',\r\n        'border',\r\n        'border-width',\r\n        'border-style',\r\n        'border-color',\r\n        'background',\r\n        'background-attachment',\r\n        'background-clip',\r\n        'background-color',\r\n        'background-image',\r\n        'background-origin',\r\n        'background-position',\r\n        'background-repeat',\r\n        'background-size',\r\n        'float',\r\n        'position',\r\n        'left',\r\n        'right',\r\n        'top',\r\n        'bottom',\r\n        'z-index',\r\n        'display',\r\n        'transform',\r\n        'width',\r\n        'max-width',\r\n        'min-width',\r\n        'height',\r\n        'max-height',\r\n        'min-height',\r\n        'overflow',\r\n        'overflow-x',\r\n        'overflow-y',\r\n        'text-overflow',\r\n        'vertical-align',\r\n        'transition',\r\n        'transition-delay',\r\n        'transition-duration',\r\n        'transition-property',\r\n        'transition-timing-function'\r\n      ];\r\n      each$e(nonInheritableStylesArr, style => {\r\n        nonInheritableStyles.add(style);\r\n      });\r\n    })();\r\n    const shorthandStyleProps = [\r\n      'font',\r\n      'text-decoration',\r\n      'text-emphasis'\r\n    ];\r\n    const getStyleProps = (dom, node) => keys(dom.parseStyle(dom.getAttrib(node, 'style')));\r\n    const isNonInheritableStyle = style => nonInheritableStyles.has(style);\r\n    const hasInheritableStyles = (dom, node) => forall(getStyleProps(dom, node), style => !isNonInheritableStyle(style));\r\n    const getLonghandStyleProps = styles => filter$5(styles, style => exists(shorthandStyleProps, prop => startsWith(style, prop)));\r\n    const hasStyleConflict = (dom, node, parentNode) => {\r\n      const nodeStyleProps = getStyleProps(dom, node);\r\n      const parentNodeStyleProps = getStyleProps(dom, parentNode);\r\n      const valueMismatch = prop => {\r\n        var _a, _b;\r\n        const nodeValue = (_a = dom.getStyle(node, prop)) !== null && _a !== void 0 ? _a : '';\r\n        const parentValue = (_b = dom.getStyle(parentNode, prop)) !== null && _b !== void 0 ? _b : '';\r\n        return isNotEmpty(nodeValue) && isNotEmpty(parentValue) && nodeValue !== parentValue;\r\n      };\r\n      return exists(nodeStyleProps, nodeStyleProp => {\r\n        const propExists = props => exists(props, prop => prop === nodeStyleProp);\r\n        if (!propExists(parentNodeStyleProps) && propExists(shorthandStyleProps)) {\r\n          const longhandProps = getLonghandStyleProps(parentNodeStyleProps);\r\n          return exists(longhandProps, valueMismatch);\r\n        } else {\r\n          return valueMismatch(nodeStyleProp);\r\n        }\r\n      });\r\n    };\r\n\r\n    const isChar = (forward, predicate, pos) => Optional.from(pos.container()).filter(isText$a).exists(text => {\r\n      const delta = forward ? 0 : -1;\r\n      return predicate(text.data.charAt(pos.offset() + delta));\r\n    });\r\n    const isBeforeSpace = curry(isChar, true, isWhiteSpace);\r\n    const isAfterSpace = curry(isChar, false, isWhiteSpace);\r\n    const isEmptyText = pos => {\r\n      const container = pos.container();\r\n      return isText$a(container) && (container.data.length === 0 || isZwsp$1(container.data) && BookmarkManager.isBookmarkNode(container.parentNode));\r\n    };\r\n    const matchesElementPosition = (before, predicate) => pos => getChildNodeAtRelativeOffset(before ? 0 : -1, pos).filter(predicate).isSome();\r\n    const isImageBlock = node => isImg(node) && get$7(SugarElement.fromDom(node), 'display') === 'block';\r\n    const isCefNode = node => isContentEditableFalse$b(node) && !isBogusAll$1(node);\r\n    const isBeforeImageBlock = matchesElementPosition(true, isImageBlock);\r\n    const isAfterImageBlock = matchesElementPosition(false, isImageBlock);\r\n    const isBeforeMedia = matchesElementPosition(true, isMedia$2);\r\n    const isAfterMedia = matchesElementPosition(false, isMedia$2);\r\n    const isBeforeTable = matchesElementPosition(true, isTable$2);\r\n    const isAfterTable = matchesElementPosition(false, isTable$2);\r\n    const isBeforeContentEditableFalse = matchesElementPosition(true, isCefNode);\r\n    const isAfterContentEditableFalse = matchesElementPosition(false, isCefNode);\r\n\r\n    const dropLast = xs => xs.slice(0, -1);\r\n    const parentsUntil = (start, root, predicate) => {\r\n      if (contains(root, start)) {\r\n        return dropLast(parents$1(start, elm => {\r\n          return predicate(elm) || eq(elm, root);\r\n        }));\r\n      } else {\r\n        return [];\r\n      }\r\n    };\r\n    const parents = (start, root) => parentsUntil(start, root, never);\r\n    const parentsAndSelf = (start, root) => [start].concat(parents(start, root));\r\n\r\n    const navigateIgnoreEmptyTextNodes = (forward, root, from) => navigateIgnore(forward, root, from, isEmptyText);\r\n    const isBlock$1 = schema => el => schema.isBlock(name(el));\r\n    const getClosestBlock$1 = (root, pos, schema) => find$2(parentsAndSelf(SugarElement.fromDom(pos.container()), root), isBlock$1(schema));\r\n    const isAtBeforeAfterBlockBoundary = (forward, root, pos, schema) => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => getClosestBlock$1(root, pos, schema).fold(() => !isInSameBlock(newPos, pos, root.dom), fromBlock => !isInSameBlock(newPos, pos, root.dom) && contains(fromBlock, SugarElement.fromDom(newPos.container()))));\r\n    const isAtBlockBoundary = (forward, root, pos, schema) => getClosestBlock$1(root, pos, schema).fold(() => navigateIgnoreEmptyTextNodes(forward, root.dom, pos).forall(newPos => !isInSameBlock(newPos, pos, root.dom)), parent => navigateIgnoreEmptyTextNodes(forward, parent.dom, pos).isNone());\r\n    const isAtStartOfBlock = curry(isAtBlockBoundary, false);\r\n    const isAtEndOfBlock = curry(isAtBlockBoundary, true);\r\n    const isBeforeBlock = curry(isAtBeforeAfterBlockBoundary, false);\r\n    const isAfterBlock = curry(isAtBeforeAfterBlockBoundary, true);\r\n\r\n    const isBr$1 = pos => getElementFromPosition(pos).exists(isBr$5);\r\n    const findBr = (forward, root, pos, schema) => {\r\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\r\n      const scope = head(parentBlocks).getOr(root);\r\n      return fromPosition(forward, scope.dom, pos).filter(isBr$1);\r\n    };\r\n    const isBeforeBr$1 = (root, pos, schema) => getElementFromPosition(pos).exists(isBr$5) || findBr(true, root, pos, schema).isSome();\r\n    const isAfterBr = (root, pos, schema) => getElementFromPrevPosition(pos).exists(isBr$5) || findBr(false, root, pos, schema).isSome();\r\n    const findPreviousBr = curry(findBr, false);\r\n    const findNextBr = curry(findBr, true);\r\n\r\n    const isInMiddleOfText = pos => CaretPosition.isTextPosition(pos) && !pos.isAtStart() && !pos.isAtEnd();\r\n    const getClosestBlock = (root, pos, schema) => {\r\n      const parentBlocks = filter$5(parentsAndSelf(SugarElement.fromDom(pos.container()), root), el => schema.isBlock(name(el)));\r\n      return head(parentBlocks).getOr(root);\r\n    };\r\n    const hasSpaceBefore = (root, pos, schema) => {\r\n      if (isInMiddleOfText(pos)) {\r\n        return isAfterSpace(pos);\r\n      } else {\r\n        return isAfterSpace(pos) || prevPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isAfterSpace);\r\n      }\r\n    };\r\n    const hasSpaceAfter = (root, pos, schema) => {\r\n      if (isInMiddleOfText(pos)) {\r\n        return isBeforeSpace(pos);\r\n      } else {\r\n        return isBeforeSpace(pos) || nextPosition(getClosestBlock(root, pos, schema).dom, pos).exists(isBeforeSpace);\r\n      }\r\n    };\r\n    const isPreValue = value => contains$2([\r\n      'pre',\r\n      'pre-wrap'\r\n    ], value);\r\n    const isInPre = pos => getElementFromPosition(pos).bind(elm => closest$4(elm, isElement$7)).exists(elm => isPreValue(get$7(elm, 'white-space')));\r\n    const isAtBeginningOfBody = (root, pos) => prevPosition(root.dom, pos).isNone();\r\n    const isAtEndOfBody = (root, pos) => nextPosition(root.dom, pos).isNone();\r\n    const isAtLineBoundary = (root, pos, schema) => isAtBeginningOfBody(root, pos) || isAtEndOfBody(root, pos) || isAtStartOfBlock(root, pos, schema) || isAtEndOfBlock(root, pos, schema) || isAfterBr(root, pos, schema) || isBeforeBr$1(root, pos, schema);\r\n    const isCefBlock = node => isNonNullable(node) && isContentEditableFalse$b(node) && isBlockLike(node);\r\n    const isSiblingCefBlock = (root, direction) => container => {\r\n      return isCefBlock(new DomTreeWalker(container, root)[direction]());\r\n    };\r\n    const isBeforeCefBlock = (root, pos) => {\r\n      const nextPos = nextPosition(root.dom, pos).getOr(pos);\r\n      const isNextCefBlock = isSiblingCefBlock(root.dom, 'next');\r\n      return pos.isAtEnd() && (isNextCefBlock(pos.container()) || isNextCefBlock(nextPos.container()));\r\n    };\r\n    const isAfterCefBlock = (root, pos) => {\r\n      const prevPos = prevPosition(root.dom, pos).getOr(pos);\r\n      const isPrevCefBlock = isSiblingCefBlock(root.dom, 'prev');\r\n      return pos.isAtStart() && (isPrevCefBlock(pos.container()) || isPrevCefBlock(prevPos.container()));\r\n    };\r\n    const needsToHaveNbsp = (root, pos, schema) => {\r\n      if (isInPre(pos)) {\r\n        return false;\r\n      } else {\r\n        return isAtLineBoundary(root, pos, schema) || hasSpaceBefore(root, pos, schema) || hasSpaceAfter(root, pos, schema);\r\n      }\r\n    };\r\n    const needsToBeNbspLeft = (root, pos, schema) => {\r\n      if (isInPre(pos)) {\r\n        return false;\r\n      } else {\r\n        return isAtStartOfBlock(root, pos, schema) || isBeforeBlock(root, pos, schema) || isAfterBr(root, pos, schema) || hasSpaceBefore(root, pos, schema) || isAfterCefBlock(root, pos);\r\n      }\r\n    };\r\n    const leanRight = pos => {\r\n      const container = pos.container();\r\n      const offset = pos.offset();\r\n      if (isText$a(container) && offset < container.data.length) {\r\n        return CaretPosition(container, offset + 1);\r\n      } else {\r\n        return pos;\r\n      }\r\n    };\r\n    const needsToBeNbspRight = (root, pos, schema) => {\r\n      if (isInPre(pos)) {\r\n        return false;\r\n      } else {\r\n        return isAtEndOfBlock(root, pos, schema) || isAfterBlock(root, pos, schema) || isBeforeBr$1(root, pos, schema) || hasSpaceAfter(root, pos, schema) || isBeforeCefBlock(root, pos);\r\n      }\r\n    };\r\n    const needsToBeNbsp = (root, pos, schema) => needsToBeNbspLeft(root, pos, schema) || needsToBeNbspRight(root, leanRight(pos), schema);\r\n    const isNbspAt = (text, offset) => isNbsp(text.charAt(offset));\r\n    const isWhiteSpaceAt = (text, offset) => isWhiteSpace(text.charAt(offset));\r\n    const hasNbsp = pos => {\r\n      const container = pos.container();\r\n      return isText$a(container) && contains$1(container.data, nbsp);\r\n    };\r\n    const normalizeNbspMiddle = text => {\r\n      const chars = text.split('');\r\n      return map$3(chars, (chr, i) => {\r\n        if (isNbsp(chr) && i > 0 && i < chars.length - 1 && isContent(chars[i - 1]) && isContent(chars[i + 1])) {\r\n          return ' ';\r\n        } else {\r\n          return chr;\r\n        }\r\n      }).join('');\r\n    };\r\n    const normalizeNbspAtStart = (root, node, makeNbsp, schema) => {\r\n      const text = node.data;\r\n      const firstPos = CaretPosition(node, 0);\r\n      if (!makeNbsp && isNbspAt(text, 0) && !needsToBeNbsp(root, firstPos, schema)) {\r\n        node.data = ' ' + text.slice(1);\r\n        return true;\r\n      } else if (makeNbsp && isWhiteSpaceAt(text, 0) && needsToBeNbspLeft(root, firstPos, schema)) {\r\n        node.data = nbsp + text.slice(1);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const normalizeNbspInMiddleOfTextNode = node => {\r\n      const text = node.data;\r\n      const newText = normalizeNbspMiddle(text);\r\n      if (newText !== text) {\r\n        node.data = newText;\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const normalizeNbspAtEnd = (root, node, makeNbsp, schema) => {\r\n      const text = node.data;\r\n      const lastPos = CaretPosition(node, text.length - 1);\r\n      if (!makeNbsp && isNbspAt(text, text.length - 1) && !needsToBeNbsp(root, lastPos, schema)) {\r\n        node.data = text.slice(0, -1) + ' ';\r\n        return true;\r\n      } else if (makeNbsp && isWhiteSpaceAt(text, text.length - 1) && needsToBeNbspRight(root, lastPos, schema)) {\r\n        node.data = text.slice(0, -1) + nbsp;\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const normalizeNbsps = (root, pos, schema) => {\r\n      const container = pos.container();\r\n      if (!isText$a(container)) {\r\n        return Optional.none();\r\n      }\r\n      if (hasNbsp(pos)) {\r\n        const normalized = normalizeNbspAtStart(root, container, false, schema) || normalizeNbspInMiddleOfTextNode(container) || normalizeNbspAtEnd(root, container, false, schema);\r\n        return someIf(normalized, pos);\r\n      } else if (needsToBeNbsp(root, pos, schema)) {\r\n        const normalized = normalizeNbspAtStart(root, container, true, schema) || normalizeNbspAtEnd(root, container, true, schema);\r\n        return someIf(normalized, pos);\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const normalizeNbspsInEditor = editor => {\r\n      const root = SugarElement.fromDom(editor.getBody());\r\n      if (editor.selection.isCollapsed()) {\r\n        normalizeNbsps(root, CaretPosition.fromRangeStart(editor.selection.getRng()), editor.schema).each(pos => {\r\n          editor.selection.setRng(pos.toRange());\r\n        });\r\n      }\r\n    };\r\n\r\n    const normalize$1 = (node, offset, count, schema) => {\r\n      if (count === 0) {\r\n        return;\r\n      }\r\n      const elm = SugarElement.fromDom(node);\r\n      const root = ancestor$4(elm, el => schema.isBlock(name(el))).getOr(elm);\r\n      const whitespace = node.data.slice(offset, offset + count);\r\n      const isEndOfContent = offset + count >= node.data.length && needsToBeNbspRight(root, CaretPosition(node, node.data.length), schema);\r\n      const isStartOfContent = offset === 0 && needsToBeNbspLeft(root, CaretPosition(node, 0), schema);\r\n      node.replaceData(offset, count, normalize$4(whitespace, 4, isStartOfContent, isEndOfContent));\r\n    };\r\n    const normalizeWhitespaceAfter = (node, offset, schema) => {\r\n      const content = node.data.slice(offset);\r\n      const whitespaceCount = content.length - lTrim(content).length;\r\n      normalize$1(node, offset, whitespaceCount, schema);\r\n    };\r\n    const normalizeWhitespaceBefore = (node, offset, schema) => {\r\n      const content = node.data.slice(0, offset);\r\n      const whitespaceCount = content.length - rTrim(content).length;\r\n      normalize$1(node, offset - whitespaceCount, whitespaceCount, schema);\r\n    };\r\n    const mergeTextNodes = (prevNode, nextNode, schema, normalizeWhitespace, mergeToPrev = true) => {\r\n      const whitespaceOffset = rTrim(prevNode.data).length;\r\n      const newNode = mergeToPrev ? prevNode : nextNode;\r\n      const removeNode = mergeToPrev ? nextNode : prevNode;\r\n      if (mergeToPrev) {\r\n        newNode.appendData(removeNode.data);\r\n      } else {\r\n        newNode.insertData(0, removeNode.data);\r\n      }\r\n      remove$5(SugarElement.fromDom(removeNode));\r\n      if (normalizeWhitespace) {\r\n        normalizeWhitespaceAfter(newNode, whitespaceOffset, schema);\r\n      }\r\n      return newNode;\r\n    };\r\n\r\n    const needsReposition = (pos, elm) => {\r\n      const container = pos.container();\r\n      const offset = pos.offset();\r\n      return !CaretPosition.isTextPosition(pos) && container === elm.parentNode && offset > CaretPosition.before(elm).offset();\r\n    };\r\n    const reposition = (elm, pos) => needsReposition(pos, elm) ? CaretPosition(pos.container(), pos.offset() - 1) : pos;\r\n    const beforeOrStartOf = node => isText$a(node) ? CaretPosition(node, 0) : CaretPosition.before(node);\r\n    const afterOrEndOf = node => isText$a(node) ? CaretPosition(node, node.data.length) : CaretPosition.after(node);\r\n    const getPreviousSiblingCaretPosition = elm => {\r\n      if (isCaretCandidate$3(elm.previousSibling)) {\r\n        return Optional.some(afterOrEndOf(elm.previousSibling));\r\n      } else {\r\n        return elm.previousSibling ? lastPositionIn(elm.previousSibling) : Optional.none();\r\n      }\r\n    };\r\n    const getNextSiblingCaretPosition = elm => {\r\n      if (isCaretCandidate$3(elm.nextSibling)) {\r\n        return Optional.some(beforeOrStartOf(elm.nextSibling));\r\n      } else {\r\n        return elm.nextSibling ? firstPositionIn(elm.nextSibling) : Optional.none();\r\n      }\r\n    };\r\n    const findCaretPositionBackwardsFromElm = (rootElement, elm) => {\r\n      return Optional.from(elm.previousSibling ? elm.previousSibling : elm.parentNode).bind(node => prevPosition(rootElement, CaretPosition.before(node))).orThunk(() => nextPosition(rootElement, CaretPosition.after(elm)));\r\n    };\r\n    const findCaretPositionForwardsFromElm = (rootElement, elm) => nextPosition(rootElement, CaretPosition.after(elm)).orThunk(() => prevPosition(rootElement, CaretPosition.before(elm)));\r\n    const findCaretPositionBackwards = (rootElement, elm) => getPreviousSiblingCaretPosition(elm).orThunk(() => getNextSiblingCaretPosition(elm)).orThunk(() => findCaretPositionBackwardsFromElm(rootElement, elm));\r\n    const findCaretPositionForward = (rootElement, elm) => getNextSiblingCaretPosition(elm).orThunk(() => getPreviousSiblingCaretPosition(elm)).orThunk(() => findCaretPositionForwardsFromElm(rootElement, elm));\r\n    const findCaretPosition = (forward, rootElement, elm) => forward ? findCaretPositionForward(rootElement, elm) : findCaretPositionBackwards(rootElement, elm);\r\n    const findCaretPosOutsideElmAfterDelete = (forward, rootElement, elm) => findCaretPosition(forward, rootElement, elm).map(curry(reposition, elm));\r\n    const setSelection$1 = (editor, forward, pos) => {\r\n      pos.fold(() => {\r\n        editor.focus();\r\n      }, pos => {\r\n        editor.selection.setRng(pos.toRange(), forward);\r\n      });\r\n    };\r\n    const eqRawNode = rawNode => elm => elm.dom === rawNode;\r\n    const isBlock = (editor, elm) => elm && has$2(editor.schema.getBlockElements(), name(elm));\r\n    const paddEmptyBlock = (elm, preserveEmptyCaret) => {\r\n      if (isEmpty$2(elm)) {\r\n        const br = SugarElement.fromHtml('<br data-mce-bogus=\"1\">');\r\n        if (preserveEmptyCaret) {\r\n          each$e(children$1(elm), node => {\r\n            if (!isEmptyCaretFormatElement(node)) {\r\n              remove$5(node);\r\n            }\r\n          });\r\n        } else {\r\n          empty(elm);\r\n        }\r\n        append$1(elm, br);\r\n        return Optional.some(CaretPosition.before(br.dom));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const deleteNormalized = (elm, afterDeletePosOpt, schema, normalizeWhitespace) => {\r\n      const prevTextOpt = prevSibling(elm).filter(isText$b);\r\n      const nextTextOpt = nextSibling(elm).filter(isText$b);\r\n      remove$5(elm);\r\n      return lift3(prevTextOpt, nextTextOpt, afterDeletePosOpt, (prev, next, pos) => {\r\n        const prevNode = prev.dom, nextNode = next.dom;\r\n        const offset = prevNode.data.length;\r\n        mergeTextNodes(prevNode, nextNode, schema, normalizeWhitespace);\r\n        return pos.container() === nextNode ? CaretPosition(prevNode, offset) : pos;\r\n      }).orThunk(() => {\r\n        if (normalizeWhitespace) {\r\n          prevTextOpt.each(elm => normalizeWhitespaceBefore(elm.dom, elm.dom.length, schema));\r\n          nextTextOpt.each(elm => normalizeWhitespaceAfter(elm.dom, 0, schema));\r\n        }\r\n        return afterDeletePosOpt;\r\n      });\r\n    };\r\n    const isInlineElement = (editor, element) => has$2(editor.schema.getTextInlineElements(), name(element));\r\n    const deleteElement$2 = (editor, forward, elm, moveCaret = true, preserveEmptyCaret = false) => {\r\n      const afterDeletePos = findCaretPosOutsideElmAfterDelete(forward, editor.getBody(), elm.dom);\r\n      const parentBlock = ancestor$4(elm, curry(isBlock, editor), eqRawNode(editor.getBody()));\r\n      const normalizedAfterDeletePos = deleteNormalized(elm, afterDeletePos, editor.schema, isInlineElement(editor, elm));\r\n      if (editor.dom.isEmpty(editor.getBody())) {\r\n        editor.setContent('');\r\n        editor.selection.setCursorLocation();\r\n      } else {\r\n        parentBlock.bind(elm => paddEmptyBlock(elm, preserveEmptyCaret)).fold(() => {\r\n          if (moveCaret) {\r\n            setSelection$1(editor, forward, normalizedAfterDeletePos);\r\n          }\r\n        }, paddPos => {\r\n          if (moveCaret) {\r\n            setSelection$1(editor, forward, Optional.some(paddPos));\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    const strongRtl = /[\\u0591-\\u07FF\\uFB1D-\\uFDFF\\uFE70-\\uFEFC]/;\r\n    const hasStrongRtl = text => strongRtl.test(text);\r\n\r\n    const isInlineTarget = (editor, elm) => is$1(SugarElement.fromDom(elm), getInlineBoundarySelector(editor)) && !isTransparentBlock(editor.schema, elm) && editor.dom.isEditable(elm);\r\n    const isRtl = element => {\r\n      var _a;\r\n      return DOMUtils.DOM.getStyle(element, 'direction', true) === 'rtl' || hasStrongRtl((_a = element.textContent) !== null && _a !== void 0 ? _a : '');\r\n    };\r\n    const findInlineParents = (isInlineTarget, rootNode, pos) => filter$5(DOMUtils.DOM.getParents(pos.container(), '*', rootNode), isInlineTarget);\r\n    const findRootInline = (isInlineTarget, rootNode, pos) => {\r\n      const parents = findInlineParents(isInlineTarget, rootNode, pos);\r\n      return Optional.from(parents[parents.length - 1]);\r\n    };\r\n    const hasSameParentBlock = (rootNode, node1, node2) => {\r\n      const block1 = getParentBlock$3(node1, rootNode);\r\n      const block2 = getParentBlock$3(node2, rootNode);\r\n      return isNonNullable(block1) && block1 === block2;\r\n    };\r\n    const isAtZwsp = pos => isBeforeInline(pos) || isAfterInline(pos);\r\n    const normalizePosition = (forward, pos) => {\r\n      const container = pos.container(), offset = pos.offset();\r\n      if (forward) {\r\n        if (isCaretContainerInline(container)) {\r\n          if (isText$a(container.nextSibling)) {\r\n            return CaretPosition(container.nextSibling, 0);\r\n          } else {\r\n            return CaretPosition.after(container);\r\n          }\r\n        } else {\r\n          return isBeforeInline(pos) ? CaretPosition(container, offset + 1) : pos;\r\n        }\r\n      } else {\r\n        if (isCaretContainerInline(container)) {\r\n          if (isText$a(container.previousSibling)) {\r\n            return CaretPosition(container.previousSibling, container.previousSibling.data.length);\r\n          } else {\r\n            return CaretPosition.before(container);\r\n          }\r\n        } else {\r\n          return isAfterInline(pos) ? CaretPosition(container, offset - 1) : pos;\r\n        }\r\n      }\r\n    };\r\n    const normalizeForwards = curry(normalizePosition, true);\r\n    const normalizeBackwards = curry(normalizePosition, false);\r\n\r\n    const execCommandIgnoreInputEvents = (editor, command) => {\r\n      const inputBlocker = e => e.stopImmediatePropagation();\r\n      editor.on('beforeinput input', inputBlocker, true);\r\n      editor.getDoc().execCommand(command);\r\n      editor.off('beforeinput input', inputBlocker);\r\n    };\r\n    const execEditorDeleteCommand = editor => {\r\n      editor.execCommand('delete');\r\n    };\r\n    const execNativeDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'Delete');\r\n    const execNativeForwardDeleteCommand = editor => execCommandIgnoreInputEvents(editor, 'ForwardDelete');\r\n    const isBeforeRoot = rootNode => elm => is$2(parent(elm), rootNode, eq);\r\n    const isTextBlockOrListItem = element => isTextBlock$2(element) || isListItem$1(element);\r\n    const getParentBlock$2 = (rootNode, elm) => {\r\n      if (contains(rootNode, elm)) {\r\n        return closest$4(elm, isTextBlockOrListItem, isBeforeRoot(rootNode));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const paddEmptyBody = (editor, moveSelection = true) => {\r\n      if (editor.dom.isEmpty(editor.getBody())) {\r\n        editor.setContent('', { no_selection: !moveSelection });\r\n      }\r\n    };\r\n    const willDeleteLastPositionInElement = (forward, fromPos, elm) => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\r\n      const normalizedFirstPos = normalizePosition(true, firstPos);\r\n      const normalizedLastPos = normalizePosition(false, lastPos);\r\n      const normalizedFromPos = normalizePosition(false, fromPos);\r\n      if (forward) {\r\n        return nextPosition(elm, normalizedFromPos).exists(nextPos => nextPos.isEqual(normalizedLastPos) && fromPos.isEqual(normalizedFirstPos));\r\n      } else {\r\n        return prevPosition(elm, normalizedFromPos).exists(prevPos => prevPos.isEqual(normalizedFirstPos) && fromPos.isEqual(normalizedLastPos));\r\n      }\r\n    }).getOr(true);\r\n    const freefallRtl = root => {\r\n      const child = isComment$1(root) ? prevSibling(root) : lastChild(root);\r\n      return child.bind(freefallRtl).orThunk(() => Optional.some(root));\r\n    };\r\n    const deleteRangeContents = (editor, rng, root, moveSelection = true) => {\r\n      var _a;\r\n      rng.deleteContents();\r\n      const lastNode = freefallRtl(root).getOr(root);\r\n      const lastBlock = SugarElement.fromDom((_a = editor.dom.getParent(lastNode.dom, editor.dom.isBlock)) !== null && _a !== void 0 ? _a : root.dom);\r\n      if (lastBlock.dom === editor.getBody()) {\r\n        paddEmptyBody(editor, moveSelection);\r\n      } else if (isEmpty$2(lastBlock)) {\r\n        fillWithPaddingBr(lastBlock);\r\n        if (moveSelection) {\r\n          editor.selection.setCursorLocation(lastBlock.dom, 0);\r\n        }\r\n      }\r\n      if (!eq(root, lastBlock)) {\r\n        const additionalCleanupNodes = is$2(parent(lastBlock), root) ? [] : siblings(lastBlock);\r\n        each$e(additionalCleanupNodes.concat(children$1(root)), node => {\r\n          if (!eq(node, lastBlock) && !contains(node, lastBlock) && isEmpty$2(node)) {\r\n            remove$5(node);\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    const ancestor$1 = (scope, predicate, isRoot) => ancestor$4(scope, predicate, isRoot).isSome();\r\n    const sibling = (scope, predicate) => sibling$1(scope, predicate).isSome();\r\n    const descendant = (scope, predicate) => descendant$2(scope, predicate).isSome();\r\n\r\n    const isRootFromElement = root => cur => eq(root, cur);\r\n    const getTableCells = table => descendants(table, 'td,th');\r\n    const getTable$1 = (node, isRoot) => getClosestTable(SugarElement.fromDom(node), isRoot);\r\n    const selectionInTableWithNestedTable = details => {\r\n      return lift2(details.startTable, details.endTable, (startTable, endTable) => {\r\n        const isStartTableParentOfEndTable = descendant(startTable, t => eq(t, endTable));\r\n        const isEndTableParentOfStartTable = descendant(endTable, t => eq(t, startTable));\r\n        return !isStartTableParentOfEndTable && !isEndTableParentOfStartTable ? details : {\r\n          ...details,\r\n          startTable: isStartTableParentOfEndTable ? Optional.none() : details.startTable,\r\n          endTable: isEndTableParentOfStartTable ? Optional.none() : details.endTable,\r\n          isSameTable: false,\r\n          isMultiTable: false\r\n        };\r\n      }).getOr(details);\r\n    };\r\n    const adjustQuirksInDetails = details => {\r\n      return selectionInTableWithNestedTable(details);\r\n    };\r\n    const getTableDetailsFromRange = (rng, isRoot) => {\r\n      const startTable = getTable$1(rng.startContainer, isRoot);\r\n      const endTable = getTable$1(rng.endContainer, isRoot);\r\n      const isStartInTable = startTable.isSome();\r\n      const isEndInTable = endTable.isSome();\r\n      const isSameTable = lift2(startTable, endTable, eq).getOr(false);\r\n      const isMultiTable = !isSameTable && isStartInTable && isEndInTable;\r\n      return adjustQuirksInDetails({\r\n        startTable,\r\n        endTable,\r\n        isStartInTable,\r\n        isEndInTable,\r\n        isSameTable,\r\n        isMultiTable\r\n      });\r\n    };\r\n\r\n    const tableCellRng = (start, end) => ({\r\n      start,\r\n      end\r\n    });\r\n    const tableSelection = (rng, table, cells) => ({\r\n      rng,\r\n      table,\r\n      cells\r\n    });\r\n    const deleteAction = Adt.generate([\r\n      {\r\n        singleCellTable: [\r\n          'rng',\r\n          'cell'\r\n        ]\r\n      },\r\n      { fullTable: ['table'] },\r\n      {\r\n        partialTable: [\r\n          'cells',\r\n          'outsideDetails'\r\n        ]\r\n      },\r\n      {\r\n        multiTable: [\r\n          'startTableCells',\r\n          'endTableCells',\r\n          'betweenRng'\r\n        ]\r\n      }\r\n    ]);\r\n    const getClosestCell$1 = (container, isRoot) => closest$3(SugarElement.fromDom(container), 'td,th', isRoot);\r\n    const isExpandedCellRng = cellRng => !eq(cellRng.start, cellRng.end);\r\n    const getTableFromCellRng = (cellRng, isRoot) => getClosestTable(cellRng.start, isRoot).bind(startParentTable => getClosestTable(cellRng.end, isRoot).bind(endParentTable => someIf(eq(startParentTable, endParentTable), startParentTable)));\r\n    const isSingleCellTable = (cellRng, isRoot) => !isExpandedCellRng(cellRng) && getTableFromCellRng(cellRng, isRoot).exists(table => {\r\n      const rows = table.dom.rows;\r\n      return rows.length === 1 && rows[0].cells.length === 1;\r\n    });\r\n    const getCellRng = (rng, isRoot) => {\r\n      const startCell = getClosestCell$1(rng.startContainer, isRoot);\r\n      const endCell = getClosestCell$1(rng.endContainer, isRoot);\r\n      return lift2(startCell, endCell, tableCellRng);\r\n    };\r\n    const getCellRangeFromStartTable = isRoot => startCell => getClosestTable(startCell, isRoot).bind(table => last$3(getTableCells(table)).map(endCell => tableCellRng(startCell, endCell)));\r\n    const getCellRangeFromEndTable = isRoot => endCell => getClosestTable(endCell, isRoot).bind(table => head(getTableCells(table)).map(startCell => tableCellRng(startCell, endCell)));\r\n    const getTableSelectionFromCellRng = isRoot => cellRng => getTableFromCellRng(cellRng, isRoot).map(table => tableSelection(cellRng, table, getTableCells(table)));\r\n    const getTableSelections = (cellRng, selectionDetails, rng, isRoot) => {\r\n      if (rng.collapsed || !cellRng.forall(isExpandedCellRng)) {\r\n        return Optional.none();\r\n      } else if (selectionDetails.isSameTable) {\r\n        const sameTableSelection = cellRng.bind(getTableSelectionFromCellRng(isRoot));\r\n        return Optional.some({\r\n          start: sameTableSelection,\r\n          end: sameTableSelection\r\n        });\r\n      } else {\r\n        const startCell = getClosestCell$1(rng.startContainer, isRoot);\r\n        const endCell = getClosestCell$1(rng.endContainer, isRoot);\r\n        const startTableSelection = startCell.bind(getCellRangeFromStartTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\r\n        const endTableSelection = endCell.bind(getCellRangeFromEndTable(isRoot)).bind(getTableSelectionFromCellRng(isRoot));\r\n        return Optional.some({\r\n          start: startTableSelection,\r\n          end: endTableSelection\r\n        });\r\n      }\r\n    };\r\n    const getCellIndex = (cells, cell) => findIndex$2(cells, x => eq(x, cell));\r\n    const getSelectedCells = tableSelection => lift2(getCellIndex(tableSelection.cells, tableSelection.rng.start), getCellIndex(tableSelection.cells, tableSelection.rng.end), (startIndex, endIndex) => tableSelection.cells.slice(startIndex, endIndex + 1));\r\n    const isSingleCellTableContentSelected = (optCellRng, rng, isRoot) => optCellRng.exists(cellRng => isSingleCellTable(cellRng, isRoot) && hasAllContentsSelected(cellRng.start, rng));\r\n    const unselectCells = (rng, selectionDetails) => {\r\n      const {startTable, endTable} = selectionDetails;\r\n      const otherContentRng = rng.cloneRange();\r\n      startTable.each(table => otherContentRng.setStartAfter(table.dom));\r\n      endTable.each(table => otherContentRng.setEndBefore(table.dom));\r\n      return otherContentRng;\r\n    };\r\n    const handleSingleTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => start.or(end)).bind(tableSelection => {\r\n      const {isSameTable} = selectionDetails;\r\n      const selectedCells = getSelectedCells(tableSelection).getOr([]);\r\n      if (isSameTable && tableSelection.cells.length === selectedCells.length) {\r\n        return Optional.some(deleteAction.fullTable(tableSelection.table));\r\n      } else if (selectedCells.length > 0) {\r\n        if (isSameTable) {\r\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.none()));\r\n        } else {\r\n          const otherContentRng = unselectCells(rng, selectionDetails);\r\n          return Optional.some(deleteAction.partialTable(selectedCells, Optional.some({\r\n            ...selectionDetails,\r\n            rng: otherContentRng\r\n          })));\r\n        }\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    });\r\n    const handleMultiTable = (cellRng, selectionDetails, rng, isRoot) => getTableSelections(cellRng, selectionDetails, rng, isRoot).bind(({start, end}) => {\r\n      const startTableSelectedCells = start.bind(getSelectedCells).getOr([]);\r\n      const endTableSelectedCells = end.bind(getSelectedCells).getOr([]);\r\n      if (startTableSelectedCells.length > 0 && endTableSelectedCells.length > 0) {\r\n        const otherContentRng = unselectCells(rng, selectionDetails);\r\n        return Optional.some(deleteAction.multiTable(startTableSelectedCells, endTableSelectedCells, otherContentRng));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    });\r\n    const getActionFromRange = (root, rng) => {\r\n      const isRoot = isRootFromElement(root);\r\n      const optCellRng = getCellRng(rng, isRoot);\r\n      const selectionDetails = getTableDetailsFromRange(rng, isRoot);\r\n      if (isSingleCellTableContentSelected(optCellRng, rng, isRoot)) {\r\n        return optCellRng.map(cellRng => deleteAction.singleCellTable(rng, cellRng.start));\r\n      } else if (selectionDetails.isMultiTable) {\r\n        return handleMultiTable(optCellRng, selectionDetails, rng, isRoot);\r\n      } else {\r\n        return handleSingleTable(optCellRng, selectionDetails, rng, isRoot);\r\n      }\r\n    };\r\n\r\n    const cleanCells = cells => each$e(cells, cell => {\r\n      remove$a(cell, 'contenteditable');\r\n      fillWithPaddingBr(cell);\r\n    });\r\n    const getOutsideBlock = (editor, container) => Optional.from(editor.dom.getParent(container, editor.dom.isBlock)).map(SugarElement.fromDom);\r\n    const handleEmptyBlock = (editor, startInTable, emptyBlock) => {\r\n      emptyBlock.each(block => {\r\n        if (startInTable) {\r\n          remove$5(block);\r\n        } else {\r\n          fillWithPaddingBr(block);\r\n          editor.selection.setCursorLocation(block.dom, 0);\r\n        }\r\n      });\r\n    };\r\n    const deleteContentInsideCell = (editor, cell, rng, isFirstCellInSelection) => {\r\n      const insideTableRng = rng.cloneRange();\r\n      if (isFirstCellInSelection) {\r\n        insideTableRng.setStart(rng.startContainer, rng.startOffset);\r\n        insideTableRng.setEndAfter(cell.dom.lastChild);\r\n      } else {\r\n        insideTableRng.setStartBefore(cell.dom.firstChild);\r\n        insideTableRng.setEnd(rng.endContainer, rng.endOffset);\r\n      }\r\n      deleteCellContents(editor, insideTableRng, cell, false).each(action => action());\r\n    };\r\n    const collapseAndRestoreCellSelection = editor => {\r\n      const selectedCells = getCellsFromEditor(editor);\r\n      const selectedNode = SugarElement.fromDom(editor.selection.getNode());\r\n      if (isTableCell$3(selectedNode.dom) && isEmpty$2(selectedNode)) {\r\n        editor.selection.setCursorLocation(selectedNode.dom, 0);\r\n      } else {\r\n        editor.selection.collapse(true);\r\n      }\r\n      if (selectedCells.length > 1 && exists(selectedCells, cell => eq(cell, selectedNode))) {\r\n        set$3(selectedNode, 'data-mce-selected', '1');\r\n      }\r\n    };\r\n    const emptySingleTableCells = (editor, cells, outsideDetails) => Optional.some(() => {\r\n      const editorRng = editor.selection.getRng();\r\n      const cellsToClean = outsideDetails.bind(({rng, isStartInTable}) => {\r\n        const outsideBlock = getOutsideBlock(editor, isStartInTable ? rng.endContainer : rng.startContainer);\r\n        rng.deleteContents();\r\n        handleEmptyBlock(editor, isStartInTable, outsideBlock.filter(isEmpty$2));\r\n        const endPointCell = isStartInTable ? cells[0] : cells[cells.length - 1];\r\n        deleteContentInsideCell(editor, endPointCell, editorRng, isStartInTable);\r\n        if (!isEmpty$2(endPointCell)) {\r\n          return Optional.some(isStartInTable ? cells.slice(1) : cells.slice(0, -1));\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      }).getOr(cells);\r\n      cleanCells(cellsToClean);\r\n      collapseAndRestoreCellSelection(editor);\r\n    });\r\n    const emptyMultiTableCells = (editor, startTableCells, endTableCells, betweenRng) => Optional.some(() => {\r\n      const rng = editor.selection.getRng();\r\n      const startCell = startTableCells[0];\r\n      const endCell = endTableCells[endTableCells.length - 1];\r\n      deleteContentInsideCell(editor, startCell, rng, true);\r\n      deleteContentInsideCell(editor, endCell, rng, false);\r\n      const startTableCellsToClean = isEmpty$2(startCell) ? startTableCells : startTableCells.slice(1);\r\n      const endTableCellsToClean = isEmpty$2(endCell) ? endTableCells : endTableCells.slice(0, -1);\r\n      cleanCells(startTableCellsToClean.concat(endTableCellsToClean));\r\n      betweenRng.deleteContents();\r\n      collapseAndRestoreCellSelection(editor);\r\n    });\r\n    const deleteCellContents = (editor, rng, cell, moveSelection = true) => Optional.some(() => {\r\n      deleteRangeContents(editor, rng, cell, moveSelection);\r\n    });\r\n    const deleteTableElement = (editor, table) => Optional.some(() => deleteElement$2(editor, false, table));\r\n    const deleteCellRange = (editor, rootElm, rng) => getActionFromRange(rootElm, rng).bind(action => action.fold(curry(deleteCellContents, editor), curry(deleteTableElement, editor), curry(emptySingleTableCells, editor), curry(emptyMultiTableCells, editor)));\r\n    const deleteCaptionRange = (editor, caption) => emptyElement(editor, caption);\r\n    const deleteTableRange = (editor, rootElm, rng, startElm) => getParentCaption(rootElm, startElm).fold(() => deleteCellRange(editor, rootElm, rng), caption => deleteCaptionRange(editor, caption));\r\n    const deleteRange$3 = (editor, startElm, selectedCells) => {\r\n      const rootNode = SugarElement.fromDom(editor.getBody());\r\n      const rng = editor.selection.getRng();\r\n      return selectedCells.length !== 0 ? emptySingleTableCells(editor, selectedCells, Optional.none()) : deleteTableRange(editor, rootNode, rng, startElm);\r\n    };\r\n    const getParentCell = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTableCell$2);\r\n    const getParentCaption = (rootElm, elm) => find$2(parentsAndSelf(elm, rootElm), isTag('caption'));\r\n    const deleteBetweenCells = (editor, rootElm, forward, fromCell, from) => navigate(forward, editor.getBody(), from).bind(to => getParentCell(rootElm, SugarElement.fromDom(to.getNode())).bind(toCell => eq(toCell, fromCell) ? Optional.none() : Optional.some(noop)));\r\n    const emptyElement = (editor, elm) => Optional.some(() => {\r\n      fillWithPaddingBr(elm);\r\n      editor.selection.setCursorLocation(elm.dom, 0);\r\n    });\r\n    const isDeleteOfLastCharPos = (fromCaption, forward, from, to) => firstPositionIn(fromCaption.dom).bind(first => lastPositionIn(fromCaption.dom).map(last => forward ? from.isEqual(first) && to.isEqual(last) : from.isEqual(last) && to.isEqual(first))).getOr(true);\r\n    const emptyCaretCaption = (editor, elm) => emptyElement(editor, elm);\r\n    const validateCaretCaption = (rootElm, fromCaption, to) => getParentCaption(rootElm, SugarElement.fromDom(to.getNode())).fold(() => Optional.some(noop), toCaption => someIf(!eq(toCaption, fromCaption), noop));\r\n    const deleteCaretInsideCaption = (editor, rootElm, forward, fromCaption, from) => navigate(forward, editor.getBody(), from).fold(() => Optional.some(noop), to => isDeleteOfLastCharPos(fromCaption, forward, from, to) ? emptyCaretCaption(editor, fromCaption) : validateCaretCaption(rootElm, fromCaption, to));\r\n    const deleteCaretCells = (editor, forward, rootElm, startElm) => {\r\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return getParentCell(rootElm, startElm).bind(fromCell => isEmpty$2(fromCell) ? emptyElement(editor, fromCell) : deleteBetweenCells(editor, rootElm, forward, fromCell, from));\r\n    };\r\n    const deleteCaretCaption = (editor, forward, rootElm, fromCaption) => {\r\n      const from = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return isEmpty$2(fromCaption) ? emptyElement(editor, fromCaption) : deleteCaretInsideCaption(editor, rootElm, forward, fromCaption, from);\r\n    };\r\n    const isNearTable = (forward, pos) => forward ? isBeforeTable(pos) : isAfterTable(pos);\r\n    const isBeforeOrAfterTable = (editor, forward) => {\r\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return isNearTable(forward, fromPos) || fromPosition(forward, editor.getBody(), fromPos).exists(pos => isNearTable(forward, pos));\r\n    };\r\n    const deleteCaret$3 = (editor, forward, startElm) => {\r\n      const rootElm = SugarElement.fromDom(editor.getBody());\r\n      return getParentCaption(rootElm, startElm).fold(() => deleteCaretCells(editor, forward, rootElm, startElm).orThunk(() => someIf(isBeforeOrAfterTable(editor, forward), noop)), fromCaption => deleteCaretCaption(editor, forward, rootElm, fromCaption));\r\n    };\r\n    const backspaceDelete$a = (editor, forward) => {\r\n      const startElm = SugarElement.fromDom(editor.selection.getStart(true));\r\n      const cells = getCellsFromEditor(editor);\r\n      return editor.selection.isCollapsed() && cells.length === 0 ? deleteCaret$3(editor, forward, startElm) : deleteRange$3(editor, startElm, cells);\r\n    };\r\n\r\n    const getContentEditableRoot$1 = (root, node) => {\r\n      let tempNode = node;\r\n      while (tempNode && tempNode !== root) {\r\n        if (isContentEditableTrue$3(tempNode) || isContentEditableFalse$b(tempNode)) {\r\n          return tempNode;\r\n        }\r\n        tempNode = tempNode.parentNode;\r\n      }\r\n      return null;\r\n    };\r\n\r\n    const internalAttributesPrefixes = [\r\n      'data-ephox-',\r\n      'data-mce-',\r\n      'data-alloy-',\r\n      'data-snooker-',\r\n      '_'\r\n    ];\r\n    const each$9 = Tools.each;\r\n    const ElementUtils = editor => {\r\n      const dom = editor.dom;\r\n      const internalAttributes = new Set(editor.serializer.getTempAttrs());\r\n      const compare = (node1, node2) => {\r\n        if (node1.nodeName !== node2.nodeName || node1.nodeType !== node2.nodeType) {\r\n          return false;\r\n        }\r\n        const getAttribs = node => {\r\n          const attribs = {};\r\n          each$9(dom.getAttribs(node), attr => {\r\n            const name = attr.nodeName.toLowerCase();\r\n            if (name !== 'style' && !isAttributeInternal(name)) {\r\n              attribs[name] = dom.getAttrib(node, name);\r\n            }\r\n          });\r\n          return attribs;\r\n        };\r\n        const compareObjects = (obj1, obj2) => {\r\n          for (const name in obj1) {\r\n            if (has$2(obj1, name)) {\r\n              const value = obj2[name];\r\n              if (isUndefined(value)) {\r\n                return false;\r\n              }\r\n              if (obj1[name] !== value) {\r\n                return false;\r\n              }\r\n              delete obj2[name];\r\n            }\r\n          }\r\n          for (const name in obj2) {\r\n            if (has$2(obj2, name)) {\r\n              return false;\r\n            }\r\n          }\r\n          return true;\r\n        };\r\n        if (isElement$6(node1) && isElement$6(node2)) {\r\n          if (!compareObjects(getAttribs(node1), getAttribs(node2))) {\r\n            return false;\r\n          }\r\n          if (!compareObjects(dom.parseStyle(dom.getAttrib(node1, 'style')), dom.parseStyle(dom.getAttrib(node2, 'style')))) {\r\n            return false;\r\n          }\r\n        }\r\n        return !isBookmarkNode$1(node1) && !isBookmarkNode$1(node2);\r\n      };\r\n      const isAttributeInternal = attributeName => exists(internalAttributesPrefixes, value => startsWith(attributeName, value)) || internalAttributes.has(attributeName);\r\n      return {\r\n        compare,\r\n        isAttributeInternal\r\n      };\r\n    };\r\n\r\n    const isHeading = node => [\r\n      'h1',\r\n      'h2',\r\n      'h3',\r\n      'h4',\r\n      'h5',\r\n      'h6'\r\n    ].includes(node.name);\r\n    const isSummary = node => node.name === 'summary';\r\n\r\n    const traverse = (root, fn) => {\r\n      let node = root;\r\n      while (node = node.walk()) {\r\n        fn(node);\r\n      }\r\n    };\r\n    const matchNode$1 = (nodeFilters, attributeFilters, node, matches) => {\r\n      const name = node.name;\r\n      for (let ni = 0, nl = nodeFilters.length; ni < nl; ni++) {\r\n        const filter = nodeFilters[ni];\r\n        if (filter.name === name) {\r\n          const match = matches.nodes[name];\r\n          if (match) {\r\n            match.nodes.push(node);\r\n          } else {\r\n            matches.nodes[name] = {\r\n              filter,\r\n              nodes: [node]\r\n            };\r\n          }\r\n        }\r\n      }\r\n      if (node.attributes) {\r\n        for (let ai = 0, al = attributeFilters.length; ai < al; ai++) {\r\n          const filter = attributeFilters[ai];\r\n          const attrName = filter.name;\r\n          if (attrName in node.attributes.map) {\r\n            const match = matches.attributes[attrName];\r\n            if (match) {\r\n              match.nodes.push(node);\r\n            } else {\r\n              matches.attributes[attrName] = {\r\n                filter,\r\n                nodes: [node]\r\n              };\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n    const findMatchingNodes = (nodeFilters, attributeFilters, node) => {\r\n      const matches = {\r\n        nodes: {},\r\n        attributes: {}\r\n      };\r\n      if (node.firstChild) {\r\n        traverse(node, childNode => {\r\n          matchNode$1(nodeFilters, attributeFilters, childNode, matches);\r\n        });\r\n      }\r\n      return matches;\r\n    };\r\n    const runFilters = (matches, args) => {\r\n      const run = (matchRecord, filteringAttributes) => {\r\n        each$d(matchRecord, match => {\r\n          const nodes = from(match.nodes);\r\n          each$e(match.filter.callbacks, callback => {\r\n            for (let i = nodes.length - 1; i >= 0; i--) {\r\n              const node = nodes[i];\r\n              const valueMatches = filteringAttributes ? node.attr(match.filter.name) !== undefined : node.name === match.filter.name;\r\n              if (!valueMatches || isNullable(node.parent)) {\r\n                nodes.splice(i, 1);\r\n              }\r\n            }\r\n            if (nodes.length > 0) {\r\n              callback(nodes, match.filter.name, args);\r\n            }\r\n          });\r\n        });\r\n      };\r\n      run(matches.nodes, false);\r\n      run(matches.attributes, true);\r\n    };\r\n    const filter$2 = (nodeFilters, attributeFilters, node, args = {}) => {\r\n      const matches = findMatchingNodes(nodeFilters, attributeFilters, node);\r\n      runFilters(matches, args);\r\n    };\r\n\r\n    const paddEmptyNode = (settings, args, isBlock, node) => {\r\n      const brPreferred = settings.pad_empty_with_br || args.insert;\r\n      if (brPreferred && isBlock(node)) {\r\n        const astNode = new AstNode('br', 1);\r\n        if (args.insert) {\r\n          astNode.attr('data-mce-bogus', '1');\r\n        }\r\n        node.empty().append(astNode);\r\n      } else {\r\n        node.empty().append(new AstNode('#text', 3)).value = nbsp;\r\n      }\r\n    };\r\n    const isPaddedWithNbsp = node => {\r\n      var _a;\r\n      return hasOnlyChild(node, '#text') && ((_a = node === null || node === void 0 ? void 0 : node.firstChild) === null || _a === void 0 ? void 0 : _a.value) === nbsp;\r\n    };\r\n    const hasOnlyChild = (node, name) => {\r\n      const firstChild = node === null || node === void 0 ? void 0 : node.firstChild;\r\n      return isNonNullable(firstChild) && firstChild === node.lastChild && firstChild.name === name;\r\n    };\r\n    const isPadded = (schema, node) => {\r\n      const rule = schema.getElementRule(node.name);\r\n      return (rule === null || rule === void 0 ? void 0 : rule.paddEmpty) === true;\r\n    };\r\n    const isEmpty = (schema, nonEmptyElements, whitespaceElements, node) => node.isEmpty(nonEmptyElements, whitespaceElements, node => isPadded(schema, node));\r\n    const isLineBreakNode = (node, isBlock) => isNonNullable(node) && (isBlock(node) || node.name === 'br');\r\n    const findClosestEditingHost = scope => {\r\n      let editableNode;\r\n      for (let node = scope; node; node = node.parent) {\r\n        const contentEditable = node.attr('contenteditable');\r\n        if (contentEditable === 'false') {\r\n          break;\r\n        } else if (contentEditable === 'true') {\r\n          editableNode = node;\r\n        }\r\n      }\r\n      return Optional.from(editableNode);\r\n    };\r\n\r\n    const removeOrUnwrapInvalidNode = (node, schema, originalNodeParent = node.parent) => {\r\n      if (schema.getSpecialElements()[node.name]) {\r\n        node.empty().remove();\r\n      } else {\r\n        const children = node.children();\r\n        for (const childNode of children) {\r\n          if (originalNodeParent && !schema.isValidChild(originalNodeParent.name, childNode.name)) {\r\n            removeOrUnwrapInvalidNode(childNode, schema, originalNodeParent);\r\n          }\r\n        }\r\n        node.unwrap();\r\n      }\r\n    };\r\n    const cleanInvalidNodes = (nodes, schema, rootNode, onCreate = noop) => {\r\n      const textBlockElements = schema.getTextBlockElements();\r\n      const nonEmptyElements = schema.getNonEmptyElements();\r\n      const whitespaceElements = schema.getWhitespaceElements();\r\n      const nonSplittableElements = Tools.makeMap('tr,td,th,tbody,thead,tfoot,table,summary');\r\n      const fixed = new Set();\r\n      const isSplittableElement = node => node !== rootNode && !nonSplittableElements[node.name];\r\n      for (let ni = 0; ni < nodes.length; ni++) {\r\n        const node = nodes[ni];\r\n        let parent;\r\n        let newParent;\r\n        let tempNode;\r\n        if (!node.parent || fixed.has(node)) {\r\n          continue;\r\n        }\r\n        if (textBlockElements[node.name] && node.parent.name === 'li') {\r\n          let sibling = node.next;\r\n          while (sibling) {\r\n            if (textBlockElements[sibling.name]) {\r\n              sibling.name = 'li';\r\n              fixed.add(sibling);\r\n              node.parent.insert(sibling, node.parent);\r\n            } else {\r\n              break;\r\n            }\r\n            sibling = sibling.next;\r\n          }\r\n          node.unwrap();\r\n          continue;\r\n        }\r\n        const parents = [node];\r\n        for (parent = node.parent; parent && !schema.isValidChild(parent.name, node.name) && isSplittableElement(parent); parent = parent.parent) {\r\n          parents.push(parent);\r\n        }\r\n        if (parent && parents.length > 1) {\r\n          if (!isInvalid(schema, node, parent)) {\r\n            parents.reverse();\r\n            newParent = parents[0].clone();\r\n            onCreate(newParent);\r\n            let currentNode = newParent;\r\n            for (let i = 0; i < parents.length - 1; i++) {\r\n              if (schema.isValidChild(currentNode.name, parents[i].name) && i > 0) {\r\n                tempNode = parents[i].clone();\r\n                onCreate(tempNode);\r\n                currentNode.append(tempNode);\r\n              } else {\r\n                tempNode = currentNode;\r\n              }\r\n              for (let childNode = parents[i].firstChild; childNode && childNode !== parents[i + 1];) {\r\n                const nextNode = childNode.next;\r\n                tempNode.append(childNode);\r\n                childNode = nextNode;\r\n              }\r\n              currentNode = tempNode;\r\n            }\r\n            if (!isEmpty(schema, nonEmptyElements, whitespaceElements, newParent)) {\r\n              parent.insert(newParent, parents[0], true);\r\n              parent.insert(node, newParent);\r\n            } else {\r\n              parent.insert(node, parents[0], true);\r\n            }\r\n            parent = parents[0];\r\n            if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent) || hasOnlyChild(parent, 'br')) {\r\n              parent.empty().remove();\r\n            }\r\n          } else {\r\n            removeOrUnwrapInvalidNode(node, schema);\r\n          }\r\n        } else if (node.parent) {\r\n          if (node.name === 'li') {\r\n            let sibling = node.prev;\r\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol')) {\r\n              sibling.append(node);\r\n              continue;\r\n            }\r\n            sibling = node.next;\r\n            if (sibling && (sibling.name === 'ul' || sibling.name === 'ol') && sibling.firstChild) {\r\n              sibling.insert(node, sibling.firstChild, true);\r\n              continue;\r\n            }\r\n            const wrapper = new AstNode('ul', 1);\r\n            onCreate(wrapper);\r\n            node.wrap(wrapper);\r\n            continue;\r\n          }\r\n          if (schema.isValidChild(node.parent.name, 'div') && schema.isValidChild('div', node.name)) {\r\n            const wrapper = new AstNode('div', 1);\r\n            onCreate(wrapper);\r\n            node.wrap(wrapper);\r\n          } else {\r\n            removeOrUnwrapInvalidNode(node, schema);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    const hasClosest = (node, parentName) => {\r\n      let tempNode = node;\r\n      while (tempNode) {\r\n        if (tempNode.name === parentName) {\r\n          return true;\r\n        }\r\n        tempNode = tempNode.parent;\r\n      }\r\n      return false;\r\n    };\r\n    const isInvalid = (schema, node, parent = node.parent) => {\r\n      if (!parent) {\r\n        return false;\r\n      }\r\n      if (schema.children[node.name] && !schema.isValidChild(parent.name, node.name)) {\r\n        return true;\r\n      }\r\n      if (node.name === 'a' && hasClosest(parent, 'a')) {\r\n        return true;\r\n      }\r\n      if (isSummary(parent) && isHeading(node)) {\r\n        return !((parent === null || parent === void 0 ? void 0 : parent.firstChild) === node && (parent === null || parent === void 0 ? void 0 : parent.lastChild) === node);\r\n      }\r\n      return false;\r\n    };\r\n\r\n    const createRange = (sc, so, ec, eo) => {\r\n      const rng = document.createRange();\r\n      rng.setStart(sc, so);\r\n      rng.setEnd(ec, eo);\r\n      return rng;\r\n    };\r\n    const normalizeBlockSelectionRange = rng => {\r\n      const startPos = CaretPosition.fromRangeStart(rng);\r\n      const endPos = CaretPosition.fromRangeEnd(rng);\r\n      const rootNode = rng.commonAncestorContainer;\r\n      return fromPosition(false, rootNode, endPos).map(newEndPos => {\r\n        if (!isInSameBlock(startPos, endPos, rootNode) && isInSameBlock(startPos, newEndPos, rootNode)) {\r\n          return createRange(startPos.container(), startPos.offset(), newEndPos.container(), newEndPos.offset());\r\n        } else {\r\n          return rng;\r\n        }\r\n      }).getOr(rng);\r\n    };\r\n    const normalize = rng => rng.collapsed ? rng : normalizeBlockSelectionRange(rng);\r\n\r\n    const hasOnlyOneChild$1 = node => {\r\n      return isNonNullable(node.firstChild) && node.firstChild === node.lastChild;\r\n    };\r\n    const isPaddingNode = node => {\r\n      return node.name === 'br' || node.value === nbsp;\r\n    };\r\n    const isPaddedEmptyBlock = (schema, node) => {\r\n      const blockElements = schema.getBlockElements();\r\n      return blockElements[node.name] && hasOnlyOneChild$1(node) && isPaddingNode(node.firstChild);\r\n    };\r\n    const isEmptyFragmentElement = (schema, node) => {\r\n      const nonEmptyElements = schema.getNonEmptyElements();\r\n      return isNonNullable(node) && (node.isEmpty(nonEmptyElements) || isPaddedEmptyBlock(schema, node));\r\n    };\r\n    const isListFragment = (schema, fragment) => {\r\n      let firstChild = fragment.firstChild;\r\n      let lastChild = fragment.lastChild;\r\n      if (firstChild && firstChild.name === 'meta') {\r\n        firstChild = firstChild.next;\r\n      }\r\n      if (lastChild && lastChild.attr('id') === 'mce_marker') {\r\n        lastChild = lastChild.prev;\r\n      }\r\n      if (isEmptyFragmentElement(schema, lastChild)) {\r\n        lastChild = lastChild === null || lastChild === void 0 ? void 0 : lastChild.prev;\r\n      }\r\n      if (!firstChild || firstChild !== lastChild) {\r\n        return false;\r\n      }\r\n      return firstChild.name === 'ul' || firstChild.name === 'ol';\r\n    };\r\n    const cleanupDomFragment = domFragment => {\r\n      var _a, _b;\r\n      const firstChild = domFragment.firstChild;\r\n      const lastChild = domFragment.lastChild;\r\n      if (firstChild && firstChild.nodeName === 'META') {\r\n        (_a = firstChild.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(firstChild);\r\n      }\r\n      if (lastChild && lastChild.id === 'mce_marker') {\r\n        (_b = lastChild.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(lastChild);\r\n      }\r\n      return domFragment;\r\n    };\r\n    const toDomFragment = (dom, serializer, fragment) => {\r\n      const html = serializer.serialize(fragment);\r\n      const domFragment = dom.createFragment(html);\r\n      return cleanupDomFragment(domFragment);\r\n    };\r\n    const listItems = elm => {\r\n      var _a;\r\n      return filter$5((_a = elm === null || elm === void 0 ? void 0 : elm.childNodes) !== null && _a !== void 0 ? _a : [], child => {\r\n        return child.nodeName === 'LI';\r\n      });\r\n    };\r\n    const isPadding = node => {\r\n      return node.data === nbsp || isBr$6(node);\r\n    };\r\n    const isListItemPadded = node => {\r\n      return isNonNullable(node === null || node === void 0 ? void 0 : node.firstChild) && node.firstChild === node.lastChild && isPadding(node.firstChild);\r\n    };\r\n    const isEmptyOrPadded = elm => {\r\n      return !elm.firstChild || isListItemPadded(elm);\r\n    };\r\n    const trimListItems = elms => {\r\n      return elms.length > 0 && isEmptyOrPadded(elms[elms.length - 1]) ? elms.slice(0, -1) : elms;\r\n    };\r\n    const getParentLi = (dom, node) => {\r\n      const parentBlock = dom.getParent(node, dom.isBlock);\r\n      return parentBlock && parentBlock.nodeName === 'LI' ? parentBlock : null;\r\n    };\r\n    const isParentBlockLi = (dom, node) => {\r\n      return !!getParentLi(dom, node);\r\n    };\r\n    const getSplit = (parentNode, rng) => {\r\n      const beforeRng = rng.cloneRange();\r\n      const afterRng = rng.cloneRange();\r\n      beforeRng.setStartBefore(parentNode);\r\n      afterRng.setEndAfter(parentNode);\r\n      return [\r\n        beforeRng.cloneContents(),\r\n        afterRng.cloneContents()\r\n      ];\r\n    };\r\n    const findFirstIn = (node, rootNode) => {\r\n      const caretPos = CaretPosition.before(node);\r\n      const caretWalker = CaretWalker(rootNode);\r\n      const newCaretPos = caretWalker.next(caretPos);\r\n      return newCaretPos ? newCaretPos.toRange() : null;\r\n    };\r\n    const findLastOf = (node, rootNode) => {\r\n      const caretPos = CaretPosition.after(node);\r\n      const caretWalker = CaretWalker(rootNode);\r\n      const newCaretPos = caretWalker.prev(caretPos);\r\n      return newCaretPos ? newCaretPos.toRange() : null;\r\n    };\r\n    const insertMiddle = (target, elms, rootNode, rng) => {\r\n      const parts = getSplit(target, rng);\r\n      const parentElm = target.parentNode;\r\n      if (parentElm) {\r\n        parentElm.insertBefore(parts[0], target);\r\n        Tools.each(elms, li => {\r\n          parentElm.insertBefore(li, target);\r\n        });\r\n        parentElm.insertBefore(parts[1], target);\r\n        parentElm.removeChild(target);\r\n      }\r\n      return findLastOf(elms[elms.length - 1], rootNode);\r\n    };\r\n    const insertBefore$2 = (target, elms, rootNode) => {\r\n      const parentElm = target.parentNode;\r\n      if (parentElm) {\r\n        Tools.each(elms, elm => {\r\n          parentElm.insertBefore(elm, target);\r\n        });\r\n      }\r\n      return findFirstIn(target, rootNode);\r\n    };\r\n    const insertAfter$2 = (target, elms, rootNode, dom) => {\r\n      dom.insertAfter(elms.reverse(), target);\r\n      return findLastOf(elms[0], rootNode);\r\n    };\r\n    const insertAtCaret$1 = (serializer, dom, rng, fragment) => {\r\n      const domFragment = toDomFragment(dom, serializer, fragment);\r\n      const liTarget = getParentLi(dom, rng.startContainer);\r\n      const liElms = trimListItems(listItems(domFragment.firstChild));\r\n      const BEGINNING = 1, END = 2;\r\n      const rootNode = dom.getRoot();\r\n      const isAt = location => {\r\n        const caretPos = CaretPosition.fromRangeStart(rng);\r\n        const caretWalker = CaretWalker(dom.getRoot());\r\n        const newPos = location === BEGINNING ? caretWalker.prev(caretPos) : caretWalker.next(caretPos);\r\n        const newPosNode = newPos === null || newPos === void 0 ? void 0 : newPos.getNode();\r\n        return newPosNode ? getParentLi(dom, newPosNode) !== liTarget : true;\r\n      };\r\n      if (!liTarget) {\r\n        return null;\r\n      } else if (isAt(BEGINNING)) {\r\n        return insertBefore$2(liTarget, liElms, rootNode);\r\n      } else if (isAt(END)) {\r\n        return insertAfter$2(liTarget, liElms, rootNode, dom);\r\n      } else {\r\n        return insertMiddle(liTarget, liElms, rootNode, rng);\r\n      }\r\n    };\r\n\r\n    const mergeableWrappedElements = ['pre'];\r\n    const shouldPasteContentOnly = (dom, fragment, parentNode, root) => {\r\n      var _a;\r\n      const firstNode = fragment.firstChild;\r\n      const lastNode = fragment.lastChild;\r\n      const last = lastNode.attr('data-mce-type') === 'bookmark' ? lastNode.prev : lastNode;\r\n      const isPastingSingleElement = firstNode === last;\r\n      const isWrappedElement = contains$2(mergeableWrappedElements, firstNode.name);\r\n      if (isPastingSingleElement && isWrappedElement) {\r\n        const isContentEditable = firstNode.attr('contenteditable') !== 'false';\r\n        const isPastingInTheSameBlockTag = ((_a = dom.getParent(parentNode, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase()) === firstNode.name;\r\n        const isPastingInContentEditable = Optional.from(getContentEditableRoot$1(root, parentNode)).forall(isContentEditableTrue$3);\r\n        return isContentEditable && isPastingInTheSameBlockTag && isPastingInContentEditable;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const isTableCell = isTableCell$3;\r\n    const isTableCellContentSelected = (dom, rng, cell) => {\r\n      if (isNonNullable(cell)) {\r\n        const endCell = dom.getParent(rng.endContainer, isTableCell);\r\n        return cell === endCell && hasAllContentsSelected(SugarElement.fromDom(cell), rng);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const validInsertion = (editor, value, parentNode) => {\r\n      var _a;\r\n      if (parentNode.getAttribute('data-mce-bogus') === 'all') {\r\n        (_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(editor.dom.createFragment(value), parentNode);\r\n      } else {\r\n        const node = parentNode.firstChild;\r\n        const node2 = parentNode.lastChild;\r\n        if (!node || node === node2 && node.nodeName === 'BR') {\r\n          editor.dom.setHTML(parentNode, value);\r\n        } else {\r\n          editor.selection.setContent(value, { no_events: true });\r\n        }\r\n      }\r\n    };\r\n    const trimBrsFromTableCell = (dom, elm, schema) => {\r\n      Optional.from(dom.getParent(elm, 'td,th')).map(SugarElement.fromDom).each(el => trimBlockTrailingBr(el, schema));\r\n    };\r\n    const reduceInlineTextElements = (editor, merge) => {\r\n      const textInlineElements = editor.schema.getTextInlineElements();\r\n      const dom = editor.dom;\r\n      if (merge) {\r\n        const root = editor.getBody();\r\n        const elementUtils = ElementUtils(editor);\r\n        Tools.each(dom.select('*[data-mce-fragment]'), node => {\r\n          const isInline = isNonNullable(textInlineElements[node.nodeName.toLowerCase()]);\r\n          if (isInline && hasInheritableStyles(dom, node)) {\r\n            for (let parentNode = node.parentElement; isNonNullable(parentNode) && parentNode !== root; parentNode = parentNode.parentElement) {\r\n              const styleConflict = hasStyleConflict(dom, node, parentNode);\r\n              if (styleConflict) {\r\n                break;\r\n              }\r\n              if (elementUtils.compare(parentNode, node)) {\r\n                dom.remove(node, true);\r\n                break;\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n    };\r\n    const markFragmentElements = fragment => {\r\n      let node = fragment;\r\n      while (node = node.walk()) {\r\n        if (node.type === 1) {\r\n          node.attr('data-mce-fragment', '1');\r\n        }\r\n      }\r\n    };\r\n    const unmarkFragmentElements = elm => {\r\n      Tools.each(elm.getElementsByTagName('*'), elm => {\r\n        elm.removeAttribute('data-mce-fragment');\r\n      });\r\n    };\r\n    const isPartOfFragment = node => {\r\n      return !!node.getAttribute('data-mce-fragment');\r\n    };\r\n    const canHaveChildren = (editor, node) => {\r\n      return isNonNullable(node) && !editor.schema.getVoidElements()[node.nodeName];\r\n    };\r\n    const moveSelectionToMarker = (editor, marker) => {\r\n      var _a, _b, _c;\r\n      let nextRng;\r\n      const dom = editor.dom;\r\n      const selection = editor.selection;\r\n      if (!marker) {\r\n        return;\r\n      }\r\n      selection.scrollIntoView(marker);\r\n      const parentEditableElm = getContentEditableRoot$1(editor.getBody(), marker);\r\n      if (parentEditableElm && dom.getContentEditable(parentEditableElm) === 'false') {\r\n        dom.remove(marker);\r\n        selection.select(parentEditableElm);\r\n        return;\r\n      }\r\n      let rng = dom.createRng();\r\n      const node = marker.previousSibling;\r\n      if (isText$a(node)) {\r\n        rng.setStart(node, (_b = (_a = node.nodeValue) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);\r\n        const node2 = marker.nextSibling;\r\n        if (isText$a(node2)) {\r\n          node.appendData(node2.data);\r\n          (_c = node2.parentNode) === null || _c === void 0 ? void 0 : _c.removeChild(node2);\r\n        }\r\n      } else {\r\n        rng.setStartBefore(marker);\r\n        rng.setEndBefore(marker);\r\n      }\r\n      const findNextCaretRng = rng => {\r\n        let caretPos = CaretPosition.fromRangeStart(rng);\r\n        const caretWalker = CaretWalker(editor.getBody());\r\n        caretPos = caretWalker.next(caretPos);\r\n        return caretPos === null || caretPos === void 0 ? void 0 : caretPos.toRange();\r\n      };\r\n      const parentBlock = dom.getParent(marker, dom.isBlock);\r\n      dom.remove(marker);\r\n      if (parentBlock && dom.isEmpty(parentBlock)) {\r\n        const isCell = isTableCell(parentBlock);\r\n        empty(SugarElement.fromDom(parentBlock));\r\n        rng.setStart(parentBlock, 0);\r\n        rng.setEnd(parentBlock, 0);\r\n        if (!isCell && !isPartOfFragment(parentBlock) && (nextRng = findNextCaretRng(rng))) {\r\n          rng = nextRng;\r\n          dom.remove(parentBlock);\r\n        } else {\r\n          dom.add(parentBlock, dom.create('br', isCell ? {} : { 'data-mce-bogus': '1' }));\r\n        }\r\n      }\r\n      selection.setRng(rng);\r\n    };\r\n    const deleteSelectedContent = editor => {\r\n      const dom = editor.dom;\r\n      const rng = normalize(editor.selection.getRng());\r\n      editor.selection.setRng(rng);\r\n      const startCell = dom.getParent(rng.startContainer, isTableCell);\r\n      if (isTableCellContentSelected(dom, rng, startCell)) {\r\n        deleteCellContents(editor, rng, SugarElement.fromDom(startCell));\r\n      } else if (rng.startContainer === rng.endContainer && rng.endOffset - rng.startOffset === 1 && isText$a(rng.startContainer.childNodes[rng.startOffset])) {\r\n        rng.deleteContents();\r\n      } else {\r\n        editor.getDoc().execCommand('Delete', false);\r\n      }\r\n    };\r\n    const findMarkerNode = scope => {\r\n      for (let markerNode = scope; markerNode; markerNode = markerNode.walk()) {\r\n        if (markerNode.attr('id') === 'mce_marker') {\r\n          return Optional.some(markerNode);\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const notHeadingsInSummary = (dom, node, fragment) => {\r\n      var _a;\r\n      return exists(fragment.children(), isHeading) && ((_a = dom.getParent(node, dom.isBlock)) === null || _a === void 0 ? void 0 : _a.nodeName) === 'SUMMARY';\r\n    };\r\n    const insertHtmlAtCaret = (editor, value, details) => {\r\n      var _a, _b;\r\n      const selection = editor.selection;\r\n      const dom = editor.dom;\r\n      const parser = editor.parser;\r\n      const merge = details.merge;\r\n      const serializer = HtmlSerializer({ validate: true }, editor.schema);\r\n      const bookmarkHtml = '<span id=\"mce_marker\" data-mce-type=\"bookmark\">&#xFEFF;</span>';\r\n      if (!details.preserve_zwsp) {\r\n        value = trim$2(value);\r\n      }\r\n      if (value.indexOf('{$caret}') === -1) {\r\n        value += '{$caret}';\r\n      }\r\n      value = value.replace(/\\{\\$caret\\}/, bookmarkHtml);\r\n      let rng = selection.getRng();\r\n      const caretElement = rng.startContainer;\r\n      const body = editor.getBody();\r\n      if (caretElement === body && selection.isCollapsed()) {\r\n        if (dom.isBlock(body.firstChild) && canHaveChildren(editor, body.firstChild) && dom.isEmpty(body.firstChild)) {\r\n          rng = dom.createRng();\r\n          rng.setStart(body.firstChild, 0);\r\n          rng.setEnd(body.firstChild, 0);\r\n          selection.setRng(rng);\r\n        }\r\n      }\r\n      if (!selection.isCollapsed()) {\r\n        deleteSelectedContent(editor);\r\n      }\r\n      const parentNode = selection.getNode();\r\n      const parserArgs = {\r\n        context: parentNode.nodeName.toLowerCase(),\r\n        data: details.data,\r\n        insert: true\r\n      };\r\n      const fragment = parser.parse(value, parserArgs);\r\n      if (details.paste === true && isListFragment(editor.schema, fragment) && isParentBlockLi(dom, parentNode)) {\r\n        rng = insertAtCaret$1(serializer, dom, selection.getRng(), fragment);\r\n        if (rng) {\r\n          selection.setRng(rng);\r\n        }\r\n        return value;\r\n      }\r\n      if (details.paste === true && shouldPasteContentOnly(dom, fragment, parentNode, editor.getBody())) {\r\n        (_a = fragment.firstChild) === null || _a === void 0 ? void 0 : _a.unwrap();\r\n      }\r\n      markFragmentElements(fragment);\r\n      let node = fragment.lastChild;\r\n      if (node && node.attr('id') === 'mce_marker') {\r\n        const marker = node;\r\n        for (node = node.prev; node; node = node.walk(true)) {\r\n          if (node.type === 3 || !dom.isBlock(node.name)) {\r\n            if (node.parent && editor.schema.isValidChild(node.parent.name, 'span')) {\r\n              node.parent.insert(marker, node, node.name === 'br');\r\n            }\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      editor._selectionOverrides.showBlockCaretContainer(parentNode);\r\n      if (!parserArgs.invalid && !notHeadingsInSummary(dom, parentNode, fragment)) {\r\n        value = serializer.serialize(fragment);\r\n        validInsertion(editor, value, parentNode);\r\n      } else {\r\n        editor.selection.setContent(bookmarkHtml);\r\n        let parentNode = selection.getNode();\r\n        let tempNode;\r\n        const rootNode = editor.getBody();\r\n        if (isDocument$1(parentNode)) {\r\n          parentNode = tempNode = rootNode;\r\n        } else {\r\n          tempNode = parentNode;\r\n        }\r\n        while (tempNode && tempNode !== rootNode) {\r\n          parentNode = tempNode;\r\n          tempNode = tempNode.parentNode;\r\n        }\r\n        value = parentNode === rootNode ? rootNode.innerHTML : dom.getOuterHTML(parentNode);\r\n        const root = parser.parse(value);\r\n        const markerNode = findMarkerNode(root);\r\n        const editingHost = markerNode.bind(findClosestEditingHost).getOr(root);\r\n        markerNode.each(marker => marker.replace(fragment));\r\n        const toExtract = fragment.children();\r\n        const parent = (_b = fragment.parent) !== null && _b !== void 0 ? _b : root;\r\n        fragment.unwrap();\r\n        const invalidChildren = filter$5(toExtract, node => isInvalid(editor.schema, node, parent));\r\n        cleanInvalidNodes(invalidChildren, editor.schema, editingHost);\r\n        filter$2(parser.getNodeFilters(), parser.getAttributeFilters(), root);\r\n        value = serializer.serialize(root);\r\n        if (parentNode === rootNode) {\r\n          dom.setHTML(rootNode, value);\r\n        } else {\r\n          dom.setOuterHTML(parentNode, value);\r\n        }\r\n      }\r\n      reduceInlineTextElements(editor, merge);\r\n      moveSelectionToMarker(editor, dom.get('mce_marker'));\r\n      unmarkFragmentElements(editor.getBody());\r\n      trimBrsFromTableCell(dom, selection.getStart(), editor.schema);\r\n      updateCaret(editor.schema, editor.getBody(), selection.getStart());\r\n      return value;\r\n    };\r\n\r\n    const isTreeNode = content => content instanceof AstNode;\r\n\r\n    const moveSelection = editor => {\r\n      if (hasFocus(editor)) {\r\n        firstPositionIn(editor.getBody()).each(pos => {\r\n          const node = pos.getNode();\r\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\r\n          editor.selection.setRng(caretPos.toRange());\r\n        });\r\n      }\r\n    };\r\n    const setEditorHtml = (editor, html, noSelection) => {\r\n      editor.dom.setHTML(editor.getBody(), html);\r\n      if (noSelection !== true) {\r\n        moveSelection(editor);\r\n      }\r\n    };\r\n    const setContentString = (editor, body, content, args) => {\r\n      content = trim$2(content);\r\n      if (content.length === 0 || /^\\s+$/.test(content)) {\r\n        const padd = '<br data-mce-bogus=\"1\">';\r\n        if (body.nodeName === 'TABLE') {\r\n          content = '<tr><td>' + padd + '</td></tr>';\r\n        } else if (/^(UL|OL)$/.test(body.nodeName)) {\r\n          content = '<li>' + padd + '</li>';\r\n        }\r\n        const forcedRootBlockName = getForcedRootBlock(editor);\r\n        if (editor.schema.isValidChild(body.nodeName.toLowerCase(), forcedRootBlockName.toLowerCase())) {\r\n          content = padd;\r\n          content = editor.dom.createHTML(forcedRootBlockName, getForcedRootBlockAttrs(editor), content);\r\n        } else if (!content) {\r\n          content = padd;\r\n        }\r\n        setEditorHtml(editor, content, args.no_selection);\r\n        return {\r\n          content,\r\n          html: content\r\n        };\r\n      } else {\r\n        if (args.format !== 'raw') {\r\n          content = HtmlSerializer({ validate: false }, editor.schema).serialize(editor.parser.parse(content, {\r\n            isRootContent: true,\r\n            insert: true\r\n          }));\r\n        }\r\n        const trimmedHtml = isWsPreserveElement(SugarElement.fromDom(body)) ? content : Tools.trim(content);\r\n        setEditorHtml(editor, trimmedHtml, args.no_selection);\r\n        return {\r\n          content: trimmedHtml,\r\n          html: trimmedHtml\r\n        };\r\n      }\r\n    };\r\n    const setContentTree = (editor, body, content, args) => {\r\n      filter$2(editor.parser.getNodeFilters(), editor.parser.getAttributeFilters(), content);\r\n      const html = HtmlSerializer({ validate: false }, editor.schema).serialize(content);\r\n      const trimmedHtml = trim$2(isWsPreserveElement(SugarElement.fromDom(body)) ? html : Tools.trim(html));\r\n      setEditorHtml(editor, trimmedHtml, args.no_selection);\r\n      return {\r\n        content,\r\n        html: trimmedHtml\r\n      };\r\n    };\r\n    const setContentInternal = (editor, content, args) => {\r\n      return Optional.from(editor.getBody()).map(body => {\r\n        if (isTreeNode(content)) {\r\n          return setContentTree(editor, body, content, args);\r\n        } else {\r\n          return setContentString(editor, body, content, args);\r\n        }\r\n      }).getOr({\r\n        content,\r\n        html: isTreeNode(args.content) ? '' : args.content\r\n      });\r\n    };\r\n\r\n    const ensureIsRoot = isRoot => isFunction(isRoot) ? isRoot : never;\r\n    const ancestor = (scope, transform, isRoot) => {\r\n      let element = scope.dom;\r\n      const stop = ensureIsRoot(isRoot);\r\n      while (element.parentNode) {\r\n        element = element.parentNode;\r\n        const el = SugarElement.fromDom(element);\r\n        const transformed = transform(el);\r\n        if (transformed.isSome()) {\r\n          return transformed;\r\n        } else if (stop(el)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const closest$1 = (scope, transform, isRoot) => {\r\n      const current = transform(scope);\r\n      const stop = ensureIsRoot(isRoot);\r\n      return current.orThunk(() => stop(scope) ? Optional.none() : ancestor(scope, transform, stop));\r\n    };\r\n\r\n    const isEq$3 = isEq$5;\r\n    const matchesUnInheritedFormatSelector = (ed, node, name) => {\r\n      const formatList = ed.formatter.get(name);\r\n      if (formatList) {\r\n        for (let i = 0; i < formatList.length; i++) {\r\n          const format = formatList[i];\r\n          if (isSelectorFormat(format) && format.inherit === false && ed.dom.is(node, format.selector)) {\r\n            return true;\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    const matchParents = (editor, node, name, vars, similar) => {\r\n      const root = editor.dom.getRoot();\r\n      if (node === root) {\r\n        return false;\r\n      }\r\n      const matchedNode = editor.dom.getParent(node, elm => {\r\n        if (matchesUnInheritedFormatSelector(editor, elm, name)) {\r\n          return true;\r\n        }\r\n        return elm.parentNode === root || !!matchNode(editor, elm, name, vars, true);\r\n      });\r\n      return !!matchNode(editor, matchedNode, name, vars, similar);\r\n    };\r\n    const matchName = (dom, node, format) => {\r\n      if (isInlineFormat(format) && isEq$3(node, format.inline)) {\r\n        return true;\r\n      }\r\n      if (isBlockFormat(format) && isEq$3(node, format.block)) {\r\n        return true;\r\n      }\r\n      if (isSelectorFormat(format)) {\r\n        return isElement$6(node) && dom.is(node, format.selector);\r\n      }\r\n      return false;\r\n    };\r\n    const matchItems = (dom, node, format, itemName, similar, vars) => {\r\n      const items = format[itemName];\r\n      const matchAttributes = itemName === 'attributes';\r\n      if (isFunction(format.onmatch)) {\r\n        return format.onmatch(node, format, itemName);\r\n      }\r\n      if (items) {\r\n        if (!isArrayLike(items)) {\r\n          for (const key in items) {\r\n            if (has$2(items, key)) {\r\n              const value = matchAttributes ? dom.getAttrib(node, key) : getStyle(dom, node, key);\r\n              const expectedValue = replaceVars(items[key], vars);\r\n              const isEmptyValue = isNullable(value) || isEmpty$3(value);\r\n              if (isEmptyValue && isNullable(expectedValue)) {\r\n                continue;\r\n              }\r\n              if (similar && isEmptyValue && !format.exact) {\r\n                return false;\r\n              }\r\n              if ((!similar || format.exact) && !isEq$3(value, normalizeStyleValue(expectedValue, key))) {\r\n                return false;\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          for (let i = 0; i < items.length; i++) {\r\n            if (matchAttributes ? dom.getAttrib(node, items[i]) : getStyle(dom, node, items[i])) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return true;\r\n    };\r\n    const matchNode = (ed, node, name, vars, similar) => {\r\n      const formatList = ed.formatter.get(name);\r\n      const dom = ed.dom;\r\n      if (formatList && isElement$6(node)) {\r\n        for (let i = 0; i < formatList.length; i++) {\r\n          const format = formatList[i];\r\n          if (matchName(ed.dom, node, format) && matchItems(dom, node, format, 'attributes', similar, vars) && matchItems(dom, node, format, 'styles', similar, vars)) {\r\n            const classes = format.classes;\r\n            if (classes) {\r\n              for (let x = 0; x < classes.length; x++) {\r\n                if (!ed.dom.hasClass(node, replaceVars(classes[x], vars))) {\r\n                  return;\r\n                }\r\n              }\r\n            }\r\n            return format;\r\n          }\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n    const match$2 = (editor, name, vars, node, similar) => {\r\n      if (node) {\r\n        return matchParents(editor, node, name, vars, similar);\r\n      }\r\n      node = editor.selection.getNode();\r\n      if (matchParents(editor, node, name, vars, similar)) {\r\n        return true;\r\n      }\r\n      const startNode = editor.selection.getStart();\r\n      if (startNode !== node) {\r\n        if (matchParents(editor, startNode, name, vars, similar)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    const matchAll = (editor, names, vars) => {\r\n      const matchedFormatNames = [];\r\n      const checkedMap = {};\r\n      const startElement = editor.selection.getStart();\r\n      editor.dom.getParent(startElement, node => {\r\n        for (let i = 0; i < names.length; i++) {\r\n          const name = names[i];\r\n          if (!checkedMap[name] && matchNode(editor, node, name, vars)) {\r\n            checkedMap[name] = true;\r\n            matchedFormatNames.push(name);\r\n          }\r\n        }\r\n      }, editor.dom.getRoot());\r\n      return matchedFormatNames;\r\n    };\r\n    const closest = (editor, names) => {\r\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\r\n      const match = (elm, name) => matchNode(editor, elm.dom, name) ? Optional.some(name) : Optional.none();\r\n      return Optional.from(editor.selection.getStart(true)).bind(rawElm => closest$1(SugarElement.fromDom(rawElm), elm => findMap(names, name => match(elm, name)), isRoot)).getOrNull();\r\n    };\r\n    const canApply = (editor, name) => {\r\n      const formatList = editor.formatter.get(name);\r\n      const dom = editor.dom;\r\n      if (formatList && editor.selection.isEditable()) {\r\n        const startNode = editor.selection.getStart();\r\n        const parents = getParents$2(dom, startNode);\r\n        for (let x = formatList.length - 1; x >= 0; x--) {\r\n          const format = formatList[x];\r\n          if (!isSelectorFormat(format)) {\r\n            return true;\r\n          }\r\n          for (let i = parents.length - 1; i >= 0; i--) {\r\n            if (dom.is(parents[i], format.selector)) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    const matchAllOnNode = (editor, node, formatNames) => foldl(formatNames, (acc, name) => {\r\n      const matchSimilar = isVariableFormatName(editor, name);\r\n      if (editor.formatter.matchNode(node, name, {}, matchSimilar)) {\r\n        return acc.concat([name]);\r\n      } else {\r\n        return acc;\r\n      }\r\n    }, []);\r\n\r\n    const ZWSP = ZWSP$1;\r\n    const importNode = (ownerDocument, node) => {\r\n      return ownerDocument.importNode(node, true);\r\n    };\r\n    const findFirstTextNode = node => {\r\n      if (node) {\r\n        const walker = new DomTreeWalker(node, node);\r\n        for (let tempNode = walker.current(); tempNode; tempNode = walker.next()) {\r\n          if (isText$a(tempNode)) {\r\n            return tempNode;\r\n          }\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    const createCaretContainer = fill => {\r\n      const caretContainer = SugarElement.fromTag('span');\r\n      setAll$1(caretContainer, {\r\n        'id': CARET_ID,\r\n        'data-mce-bogus': '1',\r\n        'data-mce-type': 'format-caret'\r\n      });\r\n      if (fill) {\r\n        append$1(caretContainer, SugarElement.fromText(ZWSP));\r\n      }\r\n      return caretContainer;\r\n    };\r\n    const trimZwspFromCaretContainer = caretContainerNode => {\r\n      const textNode = findFirstTextNode(caretContainerNode);\r\n      if (textNode && textNode.data.charAt(0) === ZWSP) {\r\n        textNode.deleteData(0, 1);\r\n      }\r\n      return textNode;\r\n    };\r\n    const removeCaretContainerNode = (editor, node, moveCaret) => {\r\n      const dom = editor.dom, selection = editor.selection;\r\n      if (isCaretContainerEmpty(node)) {\r\n        deleteElement$2(editor, false, SugarElement.fromDom(node), moveCaret, true);\r\n      } else {\r\n        const rng = selection.getRng();\r\n        const block = dom.getParent(node, dom.isBlock);\r\n        const startContainer = rng.startContainer;\r\n        const startOffset = rng.startOffset;\r\n        const endContainer = rng.endContainer;\r\n        const endOffset = rng.endOffset;\r\n        const textNode = trimZwspFromCaretContainer(node);\r\n        dom.remove(node, true);\r\n        if (startContainer === textNode && startOffset > 0) {\r\n          rng.setStart(textNode, startOffset - 1);\r\n        }\r\n        if (endContainer === textNode && endOffset > 0) {\r\n          rng.setEnd(textNode, endOffset - 1);\r\n        }\r\n        if (block && dom.isEmpty(block)) {\r\n          fillWithPaddingBr(SugarElement.fromDom(block));\r\n        }\r\n        selection.setRng(rng);\r\n      }\r\n    };\r\n    const removeCaretContainer = (editor, node, moveCaret) => {\r\n      const dom = editor.dom, selection = editor.selection;\r\n      if (!node) {\r\n        node = getParentCaretContainer(editor.getBody(), selection.getStart());\r\n        if (!node) {\r\n          while (node = dom.get(CARET_ID)) {\r\n            removeCaretContainerNode(editor, node, moveCaret);\r\n          }\r\n        }\r\n      } else {\r\n        removeCaretContainerNode(editor, node, moveCaret);\r\n      }\r\n    };\r\n    const insertCaretContainerNode = (editor, caretContainer, formatNode) => {\r\n      var _a, _b;\r\n      const dom = editor.dom;\r\n      const block = dom.getParent(formatNode, curry(isTextBlock$1, editor.schema));\r\n      if (block && dom.isEmpty(block)) {\r\n        (_a = formatNode.parentNode) === null || _a === void 0 ? void 0 : _a.replaceChild(caretContainer, formatNode);\r\n      } else {\r\n        removeTrailingBr(SugarElement.fromDom(formatNode));\r\n        if (dom.isEmpty(formatNode)) {\r\n          (_b = formatNode.parentNode) === null || _b === void 0 ? void 0 : _b.replaceChild(caretContainer, formatNode);\r\n        } else {\r\n          dom.insertAfter(caretContainer, formatNode);\r\n        }\r\n      }\r\n    };\r\n    const appendNode = (parentNode, node) => {\r\n      parentNode.appendChild(node);\r\n      return node;\r\n    };\r\n    const insertFormatNodesIntoCaretContainer = (formatNodes, caretContainer) => {\r\n      var _a;\r\n      const innerMostFormatNode = foldr(formatNodes, (parentNode, formatNode) => {\r\n        return appendNode(parentNode, formatNode.cloneNode(false));\r\n      }, caretContainer);\r\n      const doc = (_a = innerMostFormatNode.ownerDocument) !== null && _a !== void 0 ? _a : document;\r\n      return appendNode(innerMostFormatNode, doc.createTextNode(ZWSP));\r\n    };\r\n    const cleanFormatNode = (editor, caretContainer, formatNode, name, vars, similar) => {\r\n      const formatter = editor.formatter;\r\n      const dom = editor.dom;\r\n      const validFormats = filter$5(keys(formatter.get()), formatName => formatName !== name && !contains$1(formatName, 'removeformat'));\r\n      const matchedFormats = matchAllOnNode(editor, formatNode, validFormats);\r\n      const uniqueFormats = filter$5(matchedFormats, fmtName => !areSimilarFormats(editor, fmtName, name));\r\n      if (uniqueFormats.length > 0) {\r\n        const clonedFormatNode = formatNode.cloneNode(false);\r\n        dom.add(caretContainer, clonedFormatNode);\r\n        formatter.remove(name, vars, clonedFormatNode, similar);\r\n        dom.remove(clonedFormatNode);\r\n        return Optional.some(clonedFormatNode);\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const applyCaretFormat = (editor, name, vars) => {\r\n      let caretContainer;\r\n      const selection = editor.selection;\r\n      const formatList = editor.formatter.get(name);\r\n      if (!formatList) {\r\n        return;\r\n      }\r\n      const selectionRng = selection.getRng();\r\n      let offset = selectionRng.startOffset;\r\n      const container = selectionRng.startContainer;\r\n      const text = container.nodeValue;\r\n      caretContainer = getParentCaretContainer(editor.getBody(), selection.getStart());\r\n      const wordcharRegex = /[^\\s\\u00a0\\u00ad\\u200b\\ufeff]/;\r\n      if (text && offset > 0 && offset < text.length && wordcharRegex.test(text.charAt(offset)) && wordcharRegex.test(text.charAt(offset - 1))) {\r\n        const bookmark = selection.getBookmark();\r\n        selectionRng.collapse(true);\r\n        let rng = expandRng(editor.dom, selectionRng, formatList);\r\n        rng = split(rng);\r\n        editor.formatter.apply(name, vars, rng);\r\n        selection.moveToBookmark(bookmark);\r\n      } else {\r\n        let textNode = caretContainer ? findFirstTextNode(caretContainer) : null;\r\n        if (!caretContainer || (textNode === null || textNode === void 0 ? void 0 : textNode.data) !== ZWSP) {\r\n          caretContainer = importNode(editor.getDoc(), createCaretContainer(true).dom);\r\n          textNode = caretContainer.firstChild;\r\n          selectionRng.insertNode(caretContainer);\r\n          offset = 1;\r\n          editor.formatter.apply(name, vars, caretContainer);\r\n        } else {\r\n          editor.formatter.apply(name, vars, caretContainer);\r\n        }\r\n        selection.setCursorLocation(textNode, offset);\r\n      }\r\n    };\r\n    const removeCaretFormat = (editor, name, vars, similar) => {\r\n      const dom = editor.dom;\r\n      const selection = editor.selection;\r\n      let hasContentAfter = false;\r\n      const formatList = editor.formatter.get(name);\r\n      if (!formatList) {\r\n        return;\r\n      }\r\n      const rng = selection.getRng();\r\n      const container = rng.startContainer;\r\n      const offset = rng.startOffset;\r\n      let node = container;\r\n      if (isText$a(container)) {\r\n        if (offset !== container.data.length) {\r\n          hasContentAfter = true;\r\n        }\r\n        node = node.parentNode;\r\n      }\r\n      const parents = [];\r\n      let formatNode;\r\n      while (node) {\r\n        if (matchNode(editor, node, name, vars, similar)) {\r\n          formatNode = node;\r\n          break;\r\n        }\r\n        if (node.nextSibling) {\r\n          hasContentAfter = true;\r\n        }\r\n        parents.push(node);\r\n        node = node.parentNode;\r\n      }\r\n      if (!formatNode) {\r\n        return;\r\n      }\r\n      if (hasContentAfter) {\r\n        const bookmark = selection.getBookmark();\r\n        rng.collapse(true);\r\n        let expandedRng = expandRng(dom, rng, formatList, true);\r\n        expandedRng = split(expandedRng);\r\n        editor.formatter.remove(name, vars, expandedRng, similar);\r\n        selection.moveToBookmark(bookmark);\r\n      } else {\r\n        const caretContainer = getParentCaretContainer(editor.getBody(), formatNode);\r\n        const parentsAfter = isNonNullable(caretContainer) ? dom.getParents(formatNode.parentNode, always, caretContainer) : [];\r\n        const newCaretContainer = createCaretContainer(false).dom;\r\n        insertCaretContainerNode(editor, newCaretContainer, caretContainer !== null && caretContainer !== void 0 ? caretContainer : formatNode);\r\n        const cleanedFormatNode = cleanFormatNode(editor, newCaretContainer, formatNode, name, vars, similar);\r\n        const caretTextNode = insertFormatNodesIntoCaretContainer([\r\n          ...parents,\r\n          ...cleanedFormatNode.toArray(),\r\n          ...parentsAfter\r\n        ], newCaretContainer);\r\n        if (caretContainer) {\r\n          removeCaretContainerNode(editor, caretContainer, isNonNullable(caretContainer));\r\n        }\r\n        selection.setCursorLocation(caretTextNode, 1);\r\n        if (dom.isEmpty(formatNode)) {\r\n          dom.remove(formatNode);\r\n        }\r\n      }\r\n    };\r\n    const disableCaretContainer = (editor, keyCode, moveCaret) => {\r\n      const selection = editor.selection, body = editor.getBody();\r\n      removeCaretContainer(editor, null, moveCaret);\r\n      if ((keyCode === 8 || keyCode === 46) && selection.isCollapsed() && selection.getStart().innerHTML === ZWSP) {\r\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\r\n      }\r\n      if (keyCode === 37 || keyCode === 39) {\r\n        removeCaretContainer(editor, getParentCaretContainer(body, selection.getStart()), true);\r\n      }\r\n    };\r\n    const endsWithNbsp = element => isText$a(element) && endsWith(element.data, nbsp);\r\n    const setup$v = editor => {\r\n      editor.on('mouseup keydown', e => {\r\n        disableCaretContainer(editor, e.keyCode, endsWithNbsp(editor.selection.getRng().endContainer));\r\n      });\r\n    };\r\n    const createCaretFormat = formatNodes => {\r\n      const caretContainer = createCaretContainer(false);\r\n      const innerMost = insertFormatNodesIntoCaretContainer(formatNodes, caretContainer.dom);\r\n      return {\r\n        caretContainer,\r\n        caretPosition: CaretPosition(innerMost, 0)\r\n      };\r\n    };\r\n    const replaceWithCaretFormat = (targetNode, formatNodes) => {\r\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\r\n      before$3(SugarElement.fromDom(targetNode), caretContainer);\r\n      remove$5(SugarElement.fromDom(targetNode));\r\n      return caretPosition;\r\n    };\r\n    const createCaretFormatAtStart$1 = (rng, formatNodes) => {\r\n      const {caretContainer, caretPosition} = createCaretFormat(formatNodes);\r\n      rng.insertNode(caretContainer.dom);\r\n      return caretPosition;\r\n    };\r\n    const isFormatElement = (editor, element) => {\r\n      if (isCaretNode(element.dom)) {\r\n        return false;\r\n      }\r\n      const inlineElements = editor.schema.getTextInlineElements();\r\n      return has$2(inlineElements, name(element)) && !isCaretNode(element.dom) && !isBogus$2(element.dom);\r\n    };\r\n\r\n    const postProcessHooks = {};\r\n    const isPre = matchNodeNames(['pre']);\r\n    const addPostProcessHook = (name, hook) => {\r\n      const hooks = postProcessHooks[name];\r\n      if (!hooks) {\r\n        postProcessHooks[name] = [];\r\n      }\r\n      postProcessHooks[name].push(hook);\r\n    };\r\n    const postProcess$1 = (name, editor) => {\r\n      if (has$2(postProcessHooks, name)) {\r\n        each$e(postProcessHooks[name], hook => {\r\n          hook(editor);\r\n        });\r\n      }\r\n    };\r\n    addPostProcessHook('pre', editor => {\r\n      const rng = editor.selection.getRng();\r\n      const hasPreSibling = blocks => pre => {\r\n        const prev = pre.previousSibling;\r\n        return isPre(prev) && contains$2(blocks, prev);\r\n      };\r\n      const joinPre = (pre1, pre2) => {\r\n        const sPre2 = SugarElement.fromDom(pre2);\r\n        const doc = documentOrOwner(sPre2).dom;\r\n        remove$5(sPre2);\r\n        append(SugarElement.fromDom(pre1), [\r\n          SugarElement.fromTag('br', doc),\r\n          SugarElement.fromTag('br', doc),\r\n          ...children$1(sPre2)\r\n        ]);\r\n      };\r\n      if (!rng.collapsed) {\r\n        const blocks = editor.selection.getSelectedBlocks();\r\n        const preBlocks = filter$5(filter$5(blocks, isPre), hasPreSibling(blocks));\r\n        each$e(preBlocks, pre => {\r\n          joinPre(pre.previousSibling, pre);\r\n        });\r\n      }\r\n    });\r\n\r\n    const listItemStyles = [\r\n      'fontWeight',\r\n      'fontStyle',\r\n      'color',\r\n      'fontSize',\r\n      'fontFamily'\r\n    ];\r\n    const hasListStyles = fmt => isObject(fmt.styles) && exists(keys(fmt.styles), name => contains$2(listItemStyles, name));\r\n    const findExpandedListItemFormat = formats => find$2(formats, fmt => isInlineFormat(fmt) && fmt.inline === 'span' && hasListStyles(fmt));\r\n    const getExpandedListItemFormat = (formatter, format) => {\r\n      const formatList = formatter.get(format);\r\n      return isArray$1(formatList) ? findExpandedListItemFormat(formatList) : Optional.none();\r\n    };\r\n    const isRngStartAtStartOfElement = (rng, elm) => prevPosition(elm, CaretPosition.fromRangeStart(rng)).isNone();\r\n    const isRngEndAtEndOfElement = (rng, elm) => {\r\n      return nextPosition(elm, CaretPosition.fromRangeEnd(rng)).exists(pos => !isBr$6(pos.getNode()) || nextPosition(elm, pos).isSome()) === false;\r\n    };\r\n    const isEditableListItem = dom => elm => isListItem$2(elm) && dom.isEditable(elm);\r\n    const getFullySelectedBlocks = selection => {\r\n      const blocks = selection.getSelectedBlocks();\r\n      const rng = selection.getRng();\r\n      if (selection.isCollapsed()) {\r\n        return [];\r\n      }\r\n      if (blocks.length === 1) {\r\n        return isRngStartAtStartOfElement(rng, blocks[0]) && isRngEndAtEndOfElement(rng, blocks[0]) ? blocks : [];\r\n      } else {\r\n        const first = head(blocks).filter(elm => isRngStartAtStartOfElement(rng, elm)).toArray();\r\n        const last = last$3(blocks).filter(elm => isRngEndAtEndOfElement(rng, elm)).toArray();\r\n        const middle = blocks.slice(1, -1);\r\n        return first.concat(middle).concat(last);\r\n      }\r\n    };\r\n    const getFullySelectedListItems = selection => filter$5(getFullySelectedBlocks(selection), isEditableListItem(selection.dom));\r\n    const getPartiallySelectedListItems = selection => filter$5(selection.getSelectedBlocks(), isEditableListItem(selection.dom));\r\n\r\n    const each$8 = Tools.each;\r\n    const isElementNode = node => isElement$6(node) && !isBookmarkNode$1(node) && !isCaretNode(node) && !isBogus$2(node);\r\n    const findElementSibling = (node, siblingName) => {\r\n      for (let sibling = node; sibling; sibling = sibling[siblingName]) {\r\n        if (isText$a(sibling) && isNotEmpty(sibling.data)) {\r\n          return node;\r\n        }\r\n        if (isElement$6(sibling) && !isBookmarkNode$1(sibling)) {\r\n          return sibling;\r\n        }\r\n      }\r\n      return node;\r\n    };\r\n    const mergeSiblingsNodes = (editor, prev, next) => {\r\n      const elementUtils = ElementUtils(editor);\r\n      const isPrevEditable = isHTMLElement(prev) && editor.dom.isEditable(prev);\r\n      const isNextEditable = isHTMLElement(next) && editor.dom.isEditable(next);\r\n      if (isPrevEditable && isNextEditable) {\r\n        const prevSibling = findElementSibling(prev, 'previousSibling');\r\n        const nextSibling = findElementSibling(next, 'nextSibling');\r\n        if (elementUtils.compare(prevSibling, nextSibling)) {\r\n          for (let sibling = prevSibling.nextSibling; sibling && sibling !== nextSibling;) {\r\n            const tmpSibling = sibling;\r\n            sibling = sibling.nextSibling;\r\n            prevSibling.appendChild(tmpSibling);\r\n          }\r\n          editor.dom.remove(nextSibling);\r\n          Tools.each(Tools.grep(nextSibling.childNodes), node => {\r\n            prevSibling.appendChild(node);\r\n          });\r\n          return prevSibling;\r\n        }\r\n      }\r\n      return next;\r\n    };\r\n    const mergeSiblings = (editor, format, vars, node) => {\r\n      var _a;\r\n      if (node && format.merge_siblings !== false) {\r\n        const newNode = (_a = mergeSiblingsNodes(editor, getNonWhiteSpaceSibling(node), node)) !== null && _a !== void 0 ? _a : node;\r\n        mergeSiblingsNodes(editor, newNode, getNonWhiteSpaceSibling(newNode, true));\r\n      }\r\n    };\r\n    const clearChildStyles = (dom, format, node) => {\r\n      if (format.clear_child_styles) {\r\n        const selector = format.links ? '*:not(a)' : '*';\r\n        each$8(dom.select(selector, node), childNode => {\r\n          if (isElementNode(childNode) && dom.isEditable(childNode)) {\r\n            each$8(format.styles, (_value, name) => {\r\n              dom.setStyle(childNode, name, '');\r\n            });\r\n          }\r\n        });\r\n      }\r\n    };\r\n    const processChildElements = (node, filter, process) => {\r\n      each$8(node.childNodes, node => {\r\n        if (isElementNode(node)) {\r\n          if (filter(node)) {\r\n            process(node);\r\n          }\r\n          if (node.hasChildNodes()) {\r\n            processChildElements(node, filter, process);\r\n          }\r\n        }\r\n      });\r\n    };\r\n    const unwrapEmptySpan = (dom, node) => {\r\n      if (node.nodeName === 'SPAN' && dom.getAttribs(node).length === 0) {\r\n        dom.remove(node, true);\r\n      }\r\n    };\r\n    const hasStyle = (dom, name) => node => !!(node && getStyle(dom, node, name));\r\n    const applyStyle = (dom, name, value) => node => {\r\n      dom.setStyle(node, name, value);\r\n      if (node.getAttribute('style') === '') {\r\n        node.removeAttribute('style');\r\n      }\r\n      unwrapEmptySpan(dom, node);\r\n    };\r\n\r\n    const removeResult = Adt.generate([\r\n      { keep: [] },\r\n      { rename: ['name'] },\r\n      { removed: [] }\r\n    ]);\r\n    const MCE_ATTR_RE = /^(src|href|style)$/;\r\n    const each$7 = Tools.each;\r\n    const isEq$2 = isEq$5;\r\n    const isTableCellOrRow = node => /^(TR|TH|TD)$/.test(node.nodeName);\r\n    const isChildOfInlineParent = (dom, node, parent) => dom.isChildOf(node, parent) && node !== parent && !dom.isBlock(parent);\r\n    const getContainer = (ed, rng, start) => {\r\n      let container = rng[start ? 'startContainer' : 'endContainer'];\r\n      let offset = rng[start ? 'startOffset' : 'endOffset'];\r\n      if (isElement$6(container)) {\r\n        const lastIdx = container.childNodes.length - 1;\r\n        if (!start && offset) {\r\n          offset--;\r\n        }\r\n        container = container.childNodes[offset > lastIdx ? lastIdx : offset];\r\n      }\r\n      if (isText$a(container) && start && offset >= container.data.length) {\r\n        container = new DomTreeWalker(container, ed.getBody()).next() || container;\r\n      }\r\n      if (isText$a(container) && !start && offset === 0) {\r\n        container = new DomTreeWalker(container, ed.getBody()).prev() || container;\r\n      }\r\n      return container;\r\n    };\r\n    const normalizeTableSelection = (node, start) => {\r\n      const prop = start ? 'firstChild' : 'lastChild';\r\n      const childNode = node[prop];\r\n      if (isTableCellOrRow(node) && childNode) {\r\n        if (node.nodeName === 'TR') {\r\n          return childNode[prop] || childNode;\r\n        } else {\r\n          return childNode;\r\n        }\r\n      }\r\n      return node;\r\n    };\r\n    const wrap$1 = (dom, node, name, attrs) => {\r\n      var _a;\r\n      const wrapper = dom.create(name, attrs);\r\n      (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(wrapper, node);\r\n      wrapper.appendChild(node);\r\n      return wrapper;\r\n    };\r\n    const wrapWithSiblings = (dom, node, next, name, attrs) => {\r\n      const start = SugarElement.fromDom(node);\r\n      const wrapper = SugarElement.fromDom(dom.create(name, attrs));\r\n      const siblings = next ? nextSiblings(start) : prevSiblings(start);\r\n      append(wrapper, siblings);\r\n      if (next) {\r\n        before$3(start, wrapper);\r\n        prepend(wrapper, start);\r\n      } else {\r\n        after$4(start, wrapper);\r\n        append$1(wrapper, start);\r\n      }\r\n      return wrapper.dom;\r\n    };\r\n    const isColorFormatAndAnchor = (node, format) => format.links && node.nodeName === 'A';\r\n    const removeNode = (ed, node, format) => {\r\n      const parentNode = node.parentNode;\r\n      let rootBlockElm;\r\n      const dom = ed.dom;\r\n      const forcedRootBlock = getForcedRootBlock(ed);\r\n      if (isBlockFormat(format)) {\r\n        if (parentNode === dom.getRoot()) {\r\n          if (!format.list_block || !isEq$2(node, format.list_block)) {\r\n            each$e(from(node.childNodes), node => {\r\n              if (isValid(ed, forcedRootBlock, node.nodeName.toLowerCase())) {\r\n                if (!rootBlockElm) {\r\n                  rootBlockElm = wrap$1(dom, node, forcedRootBlock);\r\n                  dom.setAttribs(rootBlockElm, getForcedRootBlockAttrs(ed));\r\n                } else {\r\n                  rootBlockElm.appendChild(node);\r\n                }\r\n              } else {\r\n                rootBlockElm = null;\r\n              }\r\n            });\r\n          }\r\n        }\r\n      }\r\n      if (isMixedFormat(format) && !isEq$2(format.inline, node)) {\r\n        return;\r\n      }\r\n      dom.remove(node, true);\r\n    };\r\n    const processFormatAttrOrStyle = (name, value, vars) => {\r\n      if (isNumber(name)) {\r\n        return {\r\n          name: value,\r\n          value: null\r\n        };\r\n      } else {\r\n        return {\r\n          name,\r\n          value: replaceVars(value, vars)\r\n        };\r\n      }\r\n    };\r\n    const removeEmptyStyleAttributeIfNeeded = (dom, elm) => {\r\n      if (dom.getAttrib(elm, 'style') === '') {\r\n        elm.removeAttribute('style');\r\n        elm.removeAttribute('data-mce-style');\r\n      }\r\n    };\r\n    const removeStyles = (dom, elm, format, vars, compareNode) => {\r\n      let stylesModified = false;\r\n      each$7(format.styles, (value, name) => {\r\n        const {\r\n          name: styleName,\r\n          value: styleValue\r\n        } = processFormatAttrOrStyle(name, value, vars);\r\n        const normalizedStyleValue = normalizeStyleValue(styleValue, styleName);\r\n        if (format.remove_similar || isNull(styleValue) || !isElement$6(compareNode) || isEq$2(getStyle(dom, compareNode, styleName), normalizedStyleValue)) {\r\n          dom.setStyle(elm, styleName, '');\r\n        }\r\n        stylesModified = true;\r\n      });\r\n      if (stylesModified) {\r\n        removeEmptyStyleAttributeIfNeeded(dom, elm);\r\n      }\r\n    };\r\n    const removeListStyleFormats = (editor, name, vars) => {\r\n      if (name === 'removeformat') {\r\n        each$e(getPartiallySelectedListItems(editor.selection), li => {\r\n          each$e(listItemStyles, name => editor.dom.setStyle(li, name, ''));\r\n          removeEmptyStyleAttributeIfNeeded(editor.dom, li);\r\n        });\r\n      } else {\r\n        getExpandedListItemFormat(editor.formatter, name).each(liFmt => {\r\n          each$e(getPartiallySelectedListItems(editor.selection), li => removeStyles(editor.dom, li, liFmt, vars, null));\r\n        });\r\n      }\r\n    };\r\n    const removeNodeFormatInternal = (ed, format, vars, node, compareNode) => {\r\n      const dom = ed.dom;\r\n      const elementUtils = ElementUtils(ed);\r\n      const schema = ed.schema;\r\n      if (isInlineFormat(format) && isTransparentElementName(schema, format.inline) && isTransparentBlock(schema, node) && node.parentElement === ed.getBody()) {\r\n        removeNode(ed, node, format);\r\n        return removeResult.removed();\r\n      }\r\n      if (!format.ceFalseOverride && node && dom.getContentEditableParent(node) === 'false') {\r\n        return removeResult.keep();\r\n      }\r\n      if (node && !matchName(dom, node, format) && !isColorFormatAndAnchor(node, format)) {\r\n        return removeResult.keep();\r\n      }\r\n      const elm = node;\r\n      const preserveAttributes = format.preserve_attributes;\r\n      if (isInlineFormat(format) && format.remove === 'all' && isArray$1(preserveAttributes)) {\r\n        const attrsToPreserve = filter$5(dom.getAttribs(elm), attr => contains$2(preserveAttributes, attr.name.toLowerCase()));\r\n        dom.removeAllAttribs(elm);\r\n        each$e(attrsToPreserve, attr => dom.setAttrib(elm, attr.name, attr.value));\r\n        if (attrsToPreserve.length > 0) {\r\n          return removeResult.rename('span');\r\n        }\r\n      }\r\n      if (format.remove !== 'all') {\r\n        removeStyles(dom, elm, format, vars, compareNode);\r\n        each$7(format.attributes, (value, name) => {\r\n          const {\r\n            name: attrName,\r\n            value: attrValue\r\n          } = processFormatAttrOrStyle(name, value, vars);\r\n          if (format.remove_similar || isNull(attrValue) || !isElement$6(compareNode) || isEq$2(dom.getAttrib(compareNode, attrName), attrValue)) {\r\n            if (attrName === 'class') {\r\n              const currentValue = dom.getAttrib(elm, attrName);\r\n              if (currentValue) {\r\n                let valueOut = '';\r\n                each$e(currentValue.split(/\\s+/), cls => {\r\n                  if (/mce\\-\\w+/.test(cls)) {\r\n                    valueOut += (valueOut ? ' ' : '') + cls;\r\n                  }\r\n                });\r\n                if (valueOut) {\r\n                  dom.setAttrib(elm, attrName, valueOut);\r\n                  return;\r\n                }\r\n              }\r\n            }\r\n            if (MCE_ATTR_RE.test(attrName)) {\r\n              elm.removeAttribute('data-mce-' + attrName);\r\n            }\r\n            if (attrName === 'style' && matchNodeNames(['li'])(elm) && dom.getStyle(elm, 'list-style-type') === 'none') {\r\n              elm.removeAttribute(attrName);\r\n              dom.setStyle(elm, 'list-style-type', 'none');\r\n              return;\r\n            }\r\n            if (attrName === 'class') {\r\n              elm.removeAttribute('className');\r\n            }\r\n            elm.removeAttribute(attrName);\r\n          }\r\n        });\r\n        each$7(format.classes, value => {\r\n          value = replaceVars(value, vars);\r\n          if (!isElement$6(compareNode) || dom.hasClass(compareNode, value)) {\r\n            dom.removeClass(elm, value);\r\n          }\r\n        });\r\n        const attrs = dom.getAttribs(elm);\r\n        for (let i = 0; i < attrs.length; i++) {\r\n          const attrName = attrs[i].nodeName;\r\n          if (!elementUtils.isAttributeInternal(attrName)) {\r\n            return removeResult.keep();\r\n          }\r\n        }\r\n      }\r\n      if (format.remove !== 'none') {\r\n        removeNode(ed, elm, format);\r\n        return removeResult.removed();\r\n      }\r\n      return removeResult.keep();\r\n    };\r\n    const findFormatRoot = (editor, container, name, vars, similar) => {\r\n      let formatRoot;\r\n      if (container.parentNode) {\r\n        each$e(getParents$2(editor.dom, container.parentNode).reverse(), parent => {\r\n          if (!formatRoot && isElement$6(parent) && parent.id !== '_start' && parent.id !== '_end') {\r\n            const format = matchNode(editor, parent, name, vars, similar);\r\n            if (format && format.split !== false) {\r\n              formatRoot = parent;\r\n            }\r\n          }\r\n        });\r\n      }\r\n      return formatRoot;\r\n    };\r\n    const removeNodeFormatFromClone = (editor, format, vars, clone) => removeNodeFormatInternal(editor, format, vars, clone, clone).fold(constant(clone), newName => {\r\n      const fragment = editor.dom.createFragment();\r\n      fragment.appendChild(clone);\r\n      return editor.dom.rename(clone, newName);\r\n    }, constant(null));\r\n    const wrapAndSplit = (editor, formatList, formatRoot, container, target, split, format, vars) => {\r\n      var _a, _b;\r\n      let lastClone;\r\n      let firstClone;\r\n      const dom = editor.dom;\r\n      if (formatRoot) {\r\n        const formatRootParent = formatRoot.parentNode;\r\n        for (let parent = container.parentNode; parent && parent !== formatRootParent; parent = parent.parentNode) {\r\n          let clone = dom.clone(parent, false);\r\n          for (let i = 0; i < formatList.length; i++) {\r\n            clone = removeNodeFormatFromClone(editor, formatList[i], vars, clone);\r\n            if (clone === null) {\r\n              break;\r\n            }\r\n          }\r\n          if (clone) {\r\n            if (lastClone) {\r\n              clone.appendChild(lastClone);\r\n            }\r\n            if (!firstClone) {\r\n              firstClone = clone;\r\n            }\r\n            lastClone = clone;\r\n          }\r\n        }\r\n        if (split && (!format.mixed || !dom.isBlock(formatRoot))) {\r\n          container = (_a = dom.split(formatRoot, container)) !== null && _a !== void 0 ? _a : container;\r\n        }\r\n        if (lastClone && firstClone) {\r\n          (_b = target.parentNode) === null || _b === void 0 ? void 0 : _b.insertBefore(lastClone, target);\r\n          firstClone.appendChild(target);\r\n          if (isInlineFormat(format)) {\r\n            mergeSiblings(editor, format, vars, lastClone);\r\n          }\r\n        }\r\n      }\r\n      return container;\r\n    };\r\n    const removeFormatInternal = (ed, name, vars, node, similar) => {\r\n      const formatList = ed.formatter.get(name);\r\n      const format = formatList[0];\r\n      const dom = ed.dom;\r\n      const selection = ed.selection;\r\n      const splitToFormatRoot = container => {\r\n        const formatRoot = findFormatRoot(ed, container, name, vars, similar);\r\n        return wrapAndSplit(ed, formatList, formatRoot, container, container, true, format, vars);\r\n      };\r\n      const isRemoveBookmarkNode = node => isBookmarkNode$1(node) && isElement$6(node) && (node.id === '_start' || node.id === '_end');\r\n      const removeFormatOnNode = node => exists(formatList, fmt => removeNodeFormat(ed, fmt, vars, node, node));\r\n      const process = node => {\r\n        const children = from(node.childNodes);\r\n        const removed = removeFormatOnNode(node);\r\n        const currentNodeMatches = removed || exists(formatList, f => matchName(dom, node, f));\r\n        const parentNode = node.parentNode;\r\n        if (!currentNodeMatches && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\r\n          removeFormatOnNode(parentNode);\r\n        }\r\n        if (format.deep) {\r\n          if (children.length) {\r\n            for (let i = 0; i < children.length; i++) {\r\n              process(children[i]);\r\n            }\r\n          }\r\n        }\r\n        const textDecorations = [\r\n          'underline',\r\n          'line-through',\r\n          'overline'\r\n        ];\r\n        each$e(textDecorations, decoration => {\r\n          if (isElement$6(node) && ed.dom.getStyle(node, 'text-decoration') === decoration && node.parentNode && getTextDecoration(dom, node.parentNode) === decoration) {\r\n            removeNodeFormat(ed, {\r\n              deep: false,\r\n              exact: true,\r\n              inline: 'span',\r\n              styles: { textDecoration: decoration }\r\n            }, undefined, node);\r\n          }\r\n        });\r\n      };\r\n      const unwrap = start => {\r\n        const node = dom.get(start ? '_start' : '_end');\r\n        if (node) {\r\n          let out = node[start ? 'firstChild' : 'lastChild'];\r\n          if (isRemoveBookmarkNode(out)) {\r\n            out = out[start ? 'firstChild' : 'lastChild'];\r\n          }\r\n          if (isText$a(out) && out.data.length === 0) {\r\n            out = start ? node.previousSibling || node.nextSibling : node.nextSibling || node.previousSibling;\r\n          }\r\n          dom.remove(node, true);\r\n          return out;\r\n        } else {\r\n          return null;\r\n        }\r\n      };\r\n      const removeRngStyle = rng => {\r\n        let startContainer;\r\n        let endContainer;\r\n        let expandedRng = expandRng(dom, rng, formatList, rng.collapsed);\r\n        if (format.split) {\r\n          expandedRng = split(expandedRng);\r\n          startContainer = getContainer(ed, expandedRng, true);\r\n          endContainer = getContainer(ed, expandedRng);\r\n          if (startContainer !== endContainer) {\r\n            startContainer = normalizeTableSelection(startContainer, true);\r\n            endContainer = normalizeTableSelection(endContainer, false);\r\n            if (isChildOfInlineParent(dom, startContainer, endContainer)) {\r\n              const marker = Optional.from(startContainer.firstChild).getOr(startContainer);\r\n              splitToFormatRoot(wrapWithSiblings(dom, marker, true, 'span', {\r\n                'id': '_start',\r\n                'data-mce-type': 'bookmark'\r\n              }));\r\n              unwrap(true);\r\n              return;\r\n            }\r\n            if (isChildOfInlineParent(dom, endContainer, startContainer)) {\r\n              const marker = Optional.from(endContainer.lastChild).getOr(endContainer);\r\n              splitToFormatRoot(wrapWithSiblings(dom, marker, false, 'span', {\r\n                'id': '_end',\r\n                'data-mce-type': 'bookmark'\r\n              }));\r\n              unwrap(false);\r\n              return;\r\n            }\r\n            startContainer = wrap$1(dom, startContainer, 'span', {\r\n              'id': '_start',\r\n              'data-mce-type': 'bookmark'\r\n            });\r\n            endContainer = wrap$1(dom, endContainer, 'span', {\r\n              'id': '_end',\r\n              'data-mce-type': 'bookmark'\r\n            });\r\n            const newRng = dom.createRng();\r\n            newRng.setStartAfter(startContainer);\r\n            newRng.setEndBefore(endContainer);\r\n            walk$3(dom, newRng, nodes => {\r\n              each$e(nodes, n => {\r\n                if (!isBookmarkNode$1(n) && !isBookmarkNode$1(n.parentNode)) {\r\n                  splitToFormatRoot(n);\r\n                }\r\n              });\r\n            });\r\n            splitToFormatRoot(startContainer);\r\n            splitToFormatRoot(endContainer);\r\n            startContainer = unwrap(true);\r\n            endContainer = unwrap();\r\n          } else {\r\n            startContainer = endContainer = splitToFormatRoot(startContainer);\r\n          }\r\n          expandedRng.startContainer = startContainer.parentNode ? startContainer.parentNode : startContainer;\r\n          expandedRng.startOffset = dom.nodeIndex(startContainer);\r\n          expandedRng.endContainer = endContainer.parentNode ? endContainer.parentNode : endContainer;\r\n          expandedRng.endOffset = dom.nodeIndex(endContainer) + 1;\r\n        }\r\n        walk$3(dom, expandedRng, nodes => {\r\n          each$e(nodes, process);\r\n        });\r\n      };\r\n      if (node) {\r\n        if (isNode(node)) {\r\n          const rng = dom.createRng();\r\n          rng.setStartBefore(node);\r\n          rng.setEndAfter(node);\r\n          removeRngStyle(rng);\r\n        } else {\r\n          removeRngStyle(node);\r\n        }\r\n        fireFormatRemove(ed, name, node, vars);\r\n        return;\r\n      }\r\n      if (!selection.isCollapsed() || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\r\n        preserveSelection(ed, () => runOnRanges(ed, removeRngStyle), startNode => isInlineFormat(format) && match$2(ed, name, vars, startNode));\r\n        ed.nodeChanged();\r\n      } else {\r\n        removeCaretFormat(ed, name, vars, similar);\r\n      }\r\n      removeListStyleFormats(ed, name, vars);\r\n      fireFormatRemove(ed, name, node, vars);\r\n    };\r\n    const removeFormat$1 = (ed, name, vars, node, similar) => {\r\n      if (node || ed.selection.isEditable()) {\r\n        removeFormatInternal(ed, name, vars, node, similar);\r\n      }\r\n    };\r\n    const removeNodeFormat = (editor, format, vars, node, compareNode) => {\r\n      return removeNodeFormatInternal(editor, format, vars, node, compareNode).fold(never, newName => {\r\n        editor.dom.rename(node, newName);\r\n        return true;\r\n      }, always);\r\n    };\r\n\r\n    const each$6 = Tools.each;\r\n    const mergeTextDecorationsAndColor = (dom, format, vars, node) => {\r\n      const processTextDecorationsAndColor = n => {\r\n        if (isHTMLElement(n) && isElement$6(n.parentNode) && dom.isEditable(n)) {\r\n          const parentTextDecoration = getTextDecoration(dom, n.parentNode);\r\n          if (dom.getStyle(n, 'color') && parentTextDecoration) {\r\n            dom.setStyle(n, 'text-decoration', parentTextDecoration);\r\n          } else if (dom.getStyle(n, 'text-decoration') === parentTextDecoration) {\r\n            dom.setStyle(n, 'text-decoration', null);\r\n          }\r\n        }\r\n      };\r\n      if (format.styles && (format.styles.color || format.styles.textDecoration)) {\r\n        Tools.walk(node, processTextDecorationsAndColor, 'childNodes');\r\n        processTextDecorationsAndColor(node);\r\n      }\r\n    };\r\n    const mergeBackgroundColorAndFontSize = (dom, format, vars, node) => {\r\n      if (format.styles && format.styles.backgroundColor) {\r\n        const hasFontSize = hasStyle(dom, 'fontSize');\r\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'backgroundColor', replaceVars(format.styles.backgroundColor, vars)));\r\n      }\r\n    };\r\n    const mergeSubSup = (dom, format, vars, node) => {\r\n      if (isInlineFormat(format) && (format.inline === 'sub' || format.inline === 'sup')) {\r\n        const hasFontSize = hasStyle(dom, 'fontSize');\r\n        processChildElements(node, elm => hasFontSize(elm) && dom.isEditable(elm), applyStyle(dom, 'fontSize', ''));\r\n        const inverseTagDescendants = filter$5(dom.select(format.inline === 'sup' ? 'sub' : 'sup', node), dom.isEditable);\r\n        dom.remove(inverseTagDescendants, true);\r\n      }\r\n    };\r\n    const mergeWithChildren = (editor, formatList, vars, node) => {\r\n      each$6(formatList, format => {\r\n        if (isInlineFormat(format)) {\r\n          each$6(editor.dom.select(format.inline, node), child => {\r\n            if (isElementNode(child)) {\r\n              removeNodeFormat(editor, format, vars, child, format.exact ? child : null);\r\n            }\r\n          });\r\n        }\r\n        clearChildStyles(editor.dom, format, node);\r\n      });\r\n    };\r\n    const mergeWithParents = (editor, format, name, vars, node) => {\r\n      const parentNode = node.parentNode;\r\n      if (matchNode(editor, parentNode, name, vars)) {\r\n        if (removeNodeFormat(editor, format, vars, node)) {\r\n          return;\r\n        }\r\n      }\r\n      if (format.merge_with_parents && parentNode) {\r\n        editor.dom.getParent(parentNode, parent => {\r\n          if (matchNode(editor, parent, name, vars)) {\r\n            removeNodeFormat(editor, format, vars, node);\r\n            return true;\r\n          } else {\r\n            return false;\r\n          }\r\n        });\r\n      }\r\n    };\r\n\r\n    const each$5 = Tools.each;\r\n    const canFormatBR = (editor, format, node, parentName) => {\r\n      if (canFormatEmptyLines(editor) && isInlineFormat(format) && node.parentNode) {\r\n        const validBRParentElements = getTextRootBlockElements(editor.schema);\r\n        const hasCaretNodeSibling = sibling(SugarElement.fromDom(node), sibling => isCaretNode(sibling.dom));\r\n        return hasNonNullableKey(validBRParentElements, parentName) && isEmpty$2(SugarElement.fromDom(node.parentNode), false) && !hasCaretNodeSibling;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const applyStyles = (dom, elm, format, vars) => {\r\n      each$5(format.styles, (value, name) => {\r\n        dom.setStyle(elm, name, replaceVars(value, vars));\r\n      });\r\n      if (format.styles) {\r\n        const styleVal = dom.getAttrib(elm, 'style');\r\n        if (styleVal) {\r\n          dom.setAttrib(elm, 'data-mce-style', styleVal);\r\n        }\r\n      }\r\n    };\r\n    const applyFormatAction = (ed, name, vars, node) => {\r\n      const formatList = ed.formatter.get(name);\r\n      const format = formatList[0];\r\n      const isCollapsed = !node && ed.selection.isCollapsed();\r\n      const dom = ed.dom;\r\n      const selection = ed.selection;\r\n      const setElementFormat = (elm, fmt = format) => {\r\n        if (isFunction(fmt.onformat)) {\r\n          fmt.onformat(elm, fmt, vars, node);\r\n        }\r\n        applyStyles(dom, elm, fmt, vars);\r\n        each$5(fmt.attributes, (value, name) => {\r\n          dom.setAttrib(elm, name, replaceVars(value, vars));\r\n        });\r\n        each$5(fmt.classes, value => {\r\n          const newValue = replaceVars(value, vars);\r\n          if (!dom.hasClass(elm, newValue)) {\r\n            dom.addClass(elm, newValue);\r\n          }\r\n        });\r\n      };\r\n      const applyNodeStyle = (formatList, node) => {\r\n        let found = false;\r\n        each$5(formatList, format => {\r\n          if (!isSelectorFormat(format)) {\r\n            return false;\r\n          }\r\n          if (dom.getContentEditable(node) === 'false' && !format.ceFalseOverride) {\r\n            return true;\r\n          }\r\n          if (isNonNullable(format.collapsed) && format.collapsed !== isCollapsed) {\r\n            return true;\r\n          }\r\n          if (dom.is(node, format.selector) && !isCaretNode(node)) {\r\n            setElementFormat(node, format);\r\n            found = true;\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n        return found;\r\n      };\r\n      const createWrapElement = wrapName => {\r\n        if (isString(wrapName)) {\r\n          const wrapElm = dom.create(wrapName);\r\n          setElementFormat(wrapElm);\r\n          return wrapElm;\r\n        } else {\r\n          return null;\r\n        }\r\n      };\r\n      const applyRngStyle = (dom, rng, nodeSpecific) => {\r\n        const newWrappers = [];\r\n        let contentEditable = true;\r\n        const wrapName = format.inline || format.block;\r\n        const wrapElm = createWrapElement(wrapName);\r\n        const isMatchingWrappingBlock = node => isWrappingBlockFormat(format) && matchNode(ed, node, name, vars);\r\n        const canRenameBlock = (node, parentName, isEditableDescendant) => {\r\n          const isValidBlockFormatForNode = isNonWrappingBlockFormat(format) && isTextBlock$1(ed.schema, node) && isValid(ed, parentName, wrapName);\r\n          return isEditableDescendant && isValidBlockFormatForNode;\r\n        };\r\n        const canWrapNode = (node, parentName, isEditableDescendant, isWrappableNoneditableElm) => {\r\n          const nodeName = node.nodeName.toLowerCase();\r\n          const isValidWrapNode = isValid(ed, wrapName, nodeName) && isValid(ed, parentName, wrapName);\r\n          const isZwsp = !nodeSpecific && isText$a(node) && isZwsp$1(node.data);\r\n          const isCaret = isCaretNode(node);\r\n          const isCorrectFormatForNode = !isInlineFormat(format) || !dom.isBlock(node);\r\n          return (isEditableDescendant || isWrappableNoneditableElm) && isValidWrapNode && !isZwsp && !isCaret && isCorrectFormatForNode;\r\n        };\r\n        walk$3(dom, rng, nodes => {\r\n          let currentWrapElm;\r\n          const process = node => {\r\n            let hasContentEditableState = false;\r\n            let lastContentEditable = contentEditable;\r\n            let isWrappableNoneditableElm = false;\r\n            const parentNode = node.parentNode;\r\n            const parentName = parentNode.nodeName.toLowerCase();\r\n            const contentEditableValue = dom.getContentEditable(node);\r\n            if (isNonNullable(contentEditableValue)) {\r\n              lastContentEditable = contentEditable;\r\n              contentEditable = contentEditableValue === 'true';\r\n              hasContentEditableState = true;\r\n              isWrappableNoneditableElm = isWrappableNoneditable(ed, node);\r\n            }\r\n            const isEditableDescendant = contentEditable && !hasContentEditableState;\r\n            if (isBr$6(node) && !canFormatBR(ed, format, node, parentName)) {\r\n              currentWrapElm = null;\r\n              if (isBlockFormat(format)) {\r\n                dom.remove(node);\r\n              }\r\n              return;\r\n            }\r\n            if (isMatchingWrappingBlock(node)) {\r\n              currentWrapElm = null;\r\n              return;\r\n            }\r\n            if (canRenameBlock(node, parentName, isEditableDescendant)) {\r\n              const elm = dom.rename(node, wrapName);\r\n              setElementFormat(elm);\r\n              newWrappers.push(elm);\r\n              currentWrapElm = null;\r\n              return;\r\n            }\r\n            if (isSelectorFormat(format)) {\r\n              let found = applyNodeStyle(formatList, node);\r\n              if (!found && isNonNullable(parentNode) && shouldExpandToSelector(format)) {\r\n                found = applyNodeStyle(formatList, parentNode);\r\n              }\r\n              if (!isInlineFormat(format) || found) {\r\n                currentWrapElm = null;\r\n                return;\r\n              }\r\n            }\r\n            if (isNonNullable(wrapElm) && canWrapNode(node, parentName, isEditableDescendant, isWrappableNoneditableElm)) {\r\n              if (!currentWrapElm) {\r\n                currentWrapElm = dom.clone(wrapElm, false);\r\n                parentNode.insertBefore(currentWrapElm, node);\r\n                newWrappers.push(currentWrapElm);\r\n              }\r\n              if (isWrappableNoneditableElm && hasContentEditableState) {\r\n                contentEditable = lastContentEditable;\r\n              }\r\n              currentWrapElm.appendChild(node);\r\n            } else {\r\n              currentWrapElm = null;\r\n              each$e(from(node.childNodes), process);\r\n              if (hasContentEditableState) {\r\n                contentEditable = lastContentEditable;\r\n              }\r\n              currentWrapElm = null;\r\n            }\r\n          };\r\n          each$e(nodes, process);\r\n        });\r\n        if (format.links === true) {\r\n          each$e(newWrappers, node => {\r\n            const process = node => {\r\n              if (node.nodeName === 'A') {\r\n                setElementFormat(node, format);\r\n              }\r\n              each$e(from(node.childNodes), process);\r\n            };\r\n            process(node);\r\n          });\r\n        }\r\n        each$e(newWrappers, node => {\r\n          const getChildCount = node => {\r\n            let count = 0;\r\n            each$e(node.childNodes, node => {\r\n              if (!isEmptyTextNode$1(node) && !isBookmarkNode$1(node)) {\r\n                count++;\r\n              }\r\n            });\r\n            return count;\r\n          };\r\n          const mergeStyles = node => {\r\n            const childElement = find$2(node.childNodes, isElementNode$1).filter(child => dom.getContentEditable(child) !== 'false' && matchName(dom, child, format));\r\n            return childElement.map(child => {\r\n              const clone = dom.clone(child, false);\r\n              setElementFormat(clone);\r\n              dom.replace(clone, node, true);\r\n              dom.remove(child, true);\r\n              return clone;\r\n            }).getOr(node);\r\n          };\r\n          const childCount = getChildCount(node);\r\n          if ((newWrappers.length > 1 || !dom.isBlock(node)) && childCount === 0) {\r\n            dom.remove(node, true);\r\n            return;\r\n          }\r\n          if (isInlineFormat(format) || isBlockFormat(format) && format.wrapper) {\r\n            if (!format.exact && childCount === 1) {\r\n              node = mergeStyles(node);\r\n            }\r\n            mergeWithChildren(ed, formatList, vars, node);\r\n            mergeWithParents(ed, format, name, vars, node);\r\n            mergeBackgroundColorAndFontSize(dom, format, vars, node);\r\n            mergeTextDecorationsAndColor(dom, format, vars, node);\r\n            mergeSubSup(dom, format, vars, node);\r\n            mergeSiblings(ed, format, vars, node);\r\n          }\r\n        });\r\n      };\r\n      const targetNode = isNode(node) ? node : selection.getNode();\r\n      if (dom.getContentEditable(targetNode) === 'false' && !isWrappableNoneditable(ed, targetNode)) {\r\n        node = targetNode;\r\n        applyNodeStyle(formatList, node);\r\n        fireFormatApply(ed, name, node, vars);\r\n        return;\r\n      }\r\n      if (format) {\r\n        if (node) {\r\n          if (isNode(node)) {\r\n            if (!applyNodeStyle(formatList, node)) {\r\n              const rng = dom.createRng();\r\n              rng.setStartBefore(node);\r\n              rng.setEndAfter(node);\r\n              applyRngStyle(dom, expandRng(dom, rng, formatList), true);\r\n            }\r\n          } else {\r\n            applyRngStyle(dom, node, true);\r\n          }\r\n        } else {\r\n          if (!isCollapsed || !isInlineFormat(format) || getCellsFromEditor(ed).length) {\r\n            selection.setRng(normalize(selection.getRng()));\r\n            preserveSelection(ed, () => {\r\n              runOnRanges(ed, (selectionRng, fake) => {\r\n                const expandedRng = fake ? selectionRng : expandRng(dom, selectionRng, formatList);\r\n                applyRngStyle(dom, expandedRng, false);\r\n              });\r\n            }, always);\r\n            ed.nodeChanged();\r\n          } else {\r\n            applyCaretFormat(ed, name, vars);\r\n          }\r\n          getExpandedListItemFormat(ed.formatter, name).each(liFmt => {\r\n            each$e(getFullySelectedListItems(ed.selection), li => applyStyles(dom, li, liFmt, vars));\r\n          });\r\n        }\r\n        postProcess$1(name, ed);\r\n      }\r\n      fireFormatApply(ed, name, node, vars);\r\n    };\r\n    const applyFormat$1 = (editor, name, vars, node) => {\r\n      if (node || editor.selection.isEditable()) {\r\n        applyFormatAction(editor, name, vars, node);\r\n      }\r\n    };\r\n\r\n    const hasVars = value => has$2(value, 'vars');\r\n    const setup$u = (registeredFormatListeners, editor) => {\r\n      registeredFormatListeners.set({});\r\n      editor.on('NodeChange', e => {\r\n        updateAndFireChangeCallbacks(editor, e.element, registeredFormatListeners.get());\r\n      });\r\n      editor.on('FormatApply FormatRemove', e => {\r\n        const element = Optional.from(e.node).map(nodeOrRange => isNode(nodeOrRange) ? nodeOrRange : nodeOrRange.startContainer).bind(node => isElement$6(node) ? Optional.some(node) : Optional.from(node.parentElement)).getOrThunk(() => fallbackElement(editor));\r\n        updateAndFireChangeCallbacks(editor, element, registeredFormatListeners.get());\r\n      });\r\n    };\r\n    const fallbackElement = editor => editor.selection.getStart();\r\n    const matchingNode = (editor, parents, format, similar, vars) => {\r\n      const isMatchingNode = node => {\r\n        const matchingFormat = editor.formatter.matchNode(node, format, vars !== null && vars !== void 0 ? vars : {}, similar);\r\n        return !isUndefined(matchingFormat);\r\n      };\r\n      const isUnableToMatch = node => {\r\n        if (matchesUnInheritedFormatSelector(editor, node, format)) {\r\n          return true;\r\n        } else {\r\n          if (!similar) {\r\n            return isNonNullable(editor.formatter.matchNode(node, format, vars, true));\r\n          } else {\r\n            return false;\r\n          }\r\n        }\r\n      };\r\n      return findUntil$1(parents, isMatchingNode, isUnableToMatch);\r\n    };\r\n    const getParents = (editor, elm) => {\r\n      const element = elm !== null && elm !== void 0 ? elm : fallbackElement(editor);\r\n      return filter$5(getParents$2(editor.dom, element), node => isElement$6(node) && !isBogus$2(node));\r\n    };\r\n    const updateAndFireChangeCallbacks = (editor, elm, registeredCallbacks) => {\r\n      const parents = getParents(editor, elm);\r\n      each$d(registeredCallbacks, (data, format) => {\r\n        const runIfChanged = spec => {\r\n          const match = matchingNode(editor, parents, format, spec.similar, hasVars(spec) ? spec.vars : undefined);\r\n          const isSet = match.isSome();\r\n          if (spec.state.get() !== isSet) {\r\n            spec.state.set(isSet);\r\n            const node = match.getOr(elm);\r\n            if (hasVars(spec)) {\r\n              spec.callback(isSet, {\r\n                node,\r\n                format,\r\n                parents\r\n              });\r\n            } else {\r\n              each$e(spec.callbacks, callback => callback(isSet, {\r\n                node,\r\n                format,\r\n                parents\r\n              }));\r\n            }\r\n          }\r\n        };\r\n        each$e([\r\n          data.withSimilar,\r\n          data.withoutSimilar\r\n        ], runIfChanged);\r\n        each$e(data.withVars, runIfChanged);\r\n      });\r\n    };\r\n    const addListeners = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\r\n      const formatChangeItems = registeredFormatListeners.get();\r\n      each$e(formats.split(','), format => {\r\n        const group = get$a(formatChangeItems, format).getOrThunk(() => {\r\n          const base = {\r\n            withSimilar: {\r\n              state: Cell(false),\r\n              similar: true,\r\n              callbacks: []\r\n            },\r\n            withoutSimilar: {\r\n              state: Cell(false),\r\n              similar: false,\r\n              callbacks: []\r\n            },\r\n            withVars: []\r\n          };\r\n          formatChangeItems[format] = base;\r\n          return base;\r\n        });\r\n        const getCurrent = () => {\r\n          const parents = getParents(editor);\r\n          return matchingNode(editor, parents, format, similar, vars).isSome();\r\n        };\r\n        if (isUndefined(vars)) {\r\n          const toAppendTo = similar ? group.withSimilar : group.withoutSimilar;\r\n          toAppendTo.callbacks.push(callback);\r\n          if (toAppendTo.callbacks.length === 1) {\r\n            toAppendTo.state.set(getCurrent());\r\n          }\r\n        } else {\r\n          group.withVars.push({\r\n            state: Cell(getCurrent()),\r\n            similar,\r\n            vars,\r\n            callback\r\n          });\r\n        }\r\n      });\r\n      registeredFormatListeners.set(formatChangeItems);\r\n    };\r\n    const removeListeners = (registeredFormatListeners, formats, callback) => {\r\n      const formatChangeItems = registeredFormatListeners.get();\r\n      each$e(formats.split(','), format => get$a(formatChangeItems, format).each(group => {\r\n        formatChangeItems[format] = {\r\n          withSimilar: {\r\n            ...group.withSimilar,\r\n            callbacks: filter$5(group.withSimilar.callbacks, cb => cb !== callback)\r\n          },\r\n          withoutSimilar: {\r\n            ...group.withoutSimilar,\r\n            callbacks: filter$5(group.withoutSimilar.callbacks, cb => cb !== callback)\r\n          },\r\n          withVars: filter$5(group.withVars, item => item.callback !== callback)\r\n        };\r\n      }));\r\n      registeredFormatListeners.set(formatChangeItems);\r\n    };\r\n    const formatChangedInternal = (editor, registeredFormatListeners, formats, callback, similar, vars) => {\r\n      addListeners(editor, registeredFormatListeners, formats, callback, similar, vars);\r\n      return { unbind: () => removeListeners(registeredFormatListeners, formats, callback) };\r\n    };\r\n\r\n    const toggle = (editor, name, vars, node) => {\r\n      const fmt = editor.formatter.get(name);\r\n      if (fmt) {\r\n        if (match$2(editor, name, vars, node) && (!('toggle' in fmt[0]) || fmt[0].toggle)) {\r\n          removeFormat$1(editor, name, vars, node);\r\n        } else {\r\n          applyFormat$1(editor, name, vars, node);\r\n        }\r\n      }\r\n    };\r\n\r\n    const explode$1 = Tools.explode;\r\n    const create$8 = () => {\r\n      const filters = {};\r\n      const addFilter = (name, callback) => {\r\n        each$e(explode$1(name), name => {\r\n          if (!has$2(filters, name)) {\r\n            filters[name] = {\r\n              name,\r\n              callbacks: []\r\n            };\r\n          }\r\n          filters[name].callbacks.push(callback);\r\n        });\r\n      };\r\n      const getFilters = () => values(filters);\r\n      const removeFilter = (name, callback) => {\r\n        each$e(explode$1(name), name => {\r\n          if (has$2(filters, name)) {\r\n            if (isNonNullable(callback)) {\r\n              const filter = filters[name];\r\n              const newCallbacks = filter$5(filter.callbacks, c => c !== callback);\r\n              if (newCallbacks.length > 0) {\r\n                filter.callbacks = newCallbacks;\r\n              } else {\r\n                delete filters[name];\r\n              }\r\n            } else {\r\n              delete filters[name];\r\n            }\r\n          }\r\n        });\r\n      };\r\n      return {\r\n        addFilter,\r\n        getFilters,\r\n        removeFilter\r\n      };\r\n    };\r\n\r\n    const removeAttrs = (node, names) => {\r\n      each$e(names, name => {\r\n        node.attr(name, null);\r\n      });\r\n    };\r\n    const addFontToSpansFilter = (domParser, styles, fontSizes) => {\r\n      domParser.addNodeFilter('font', nodes => {\r\n        each$e(nodes, node => {\r\n          const props = styles.parse(node.attr('style'));\r\n          const color = node.attr('color');\r\n          const face = node.attr('face');\r\n          const size = node.attr('size');\r\n          if (color) {\r\n            props.color = color;\r\n          }\r\n          if (face) {\r\n            props['font-family'] = face;\r\n          }\r\n          if (size) {\r\n            toInt(size).each(num => {\r\n              props['font-size'] = fontSizes[num - 1];\r\n            });\r\n          }\r\n          node.name = 'span';\r\n          node.attr('style', styles.serialize(props));\r\n          removeAttrs(node, [\r\n            'color',\r\n            'face',\r\n            'size'\r\n          ]);\r\n        });\r\n      });\r\n    };\r\n    const addStrikeFilter = (domParser, schema, styles) => {\r\n      domParser.addNodeFilter('strike', nodes => {\r\n        const convertToSTag = schema.type !== 'html4';\r\n        each$e(nodes, node => {\r\n          if (convertToSTag) {\r\n            node.name = 's';\r\n          } else {\r\n            const props = styles.parse(node.attr('style'));\r\n            props['text-decoration'] = 'line-through';\r\n            node.name = 'span';\r\n            node.attr('style', styles.serialize(props));\r\n          }\r\n        });\r\n      });\r\n    };\r\n    const addFilters = (domParser, settings, schema) => {\r\n      var _a;\r\n      const styles = Styles();\r\n      if (settings.convert_fonts_to_spans) {\r\n        addFontToSpansFilter(domParser, styles, Tools.explode((_a = settings.font_size_legacy_values) !== null && _a !== void 0 ? _a : ''));\r\n      }\r\n      addStrikeFilter(domParser, schema, styles);\r\n    };\r\n    const register$5 = (domParser, settings, schema) => {\r\n      if (settings.inline_styles) {\r\n        addFilters(domParser, settings, schema);\r\n      }\r\n    };\r\n\r\n    const addNodeFilter = (settings, htmlParser, schema) => {\r\n      htmlParser.addNodeFilter('br', (nodes, _, args) => {\r\n        const blockElements = Tools.extend({}, schema.getBlockElements());\r\n        const nonEmptyElements = schema.getNonEmptyElements();\r\n        const whitespaceElements = schema.getWhitespaceElements();\r\n        blockElements.body = 1;\r\n        const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node);\r\n        for (let i = 0, l = nodes.length; i < l; i++) {\r\n          let node = nodes[i];\r\n          let parent = node.parent;\r\n          if (parent && isBlock(parent) && node === parent.lastChild) {\r\n            let prev = node.prev;\r\n            while (prev) {\r\n              const prevName = prev.name;\r\n              if (prevName !== 'span' || prev.attr('data-mce-type') !== 'bookmark') {\r\n                if (prevName === 'br') {\r\n                  node = null;\r\n                }\r\n                break;\r\n              }\r\n              prev = prev.prev;\r\n            }\r\n            if (node) {\r\n              node.remove();\r\n              if (isEmpty(schema, nonEmptyElements, whitespaceElements, parent)) {\r\n                const elementRule = schema.getElementRule(parent.name);\r\n                if (elementRule) {\r\n                  if (elementRule.removeEmpty) {\r\n                    parent.remove();\r\n                  } else if (elementRule.paddEmpty) {\r\n                    paddEmptyNode(settings, args, isBlock, parent);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          } else {\r\n            let lastParent = node;\r\n            while (parent && parent.firstChild === lastParent && parent.lastChild === lastParent) {\r\n              lastParent = parent;\r\n              if (blockElements[parent.name]) {\r\n                break;\r\n              }\r\n              parent = parent.parent;\r\n            }\r\n            if (lastParent === parent) {\r\n              const textNode = new AstNode('#text', 3);\r\n              textNode.value = nbsp;\r\n              node.replace(textNode);\r\n            }\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    const blobUriToBlob = url => fetch(url).then(res => res.ok ? res.blob() : Promise.reject()).catch(() => Promise.reject({\r\n      message: `Cannot convert ${ url } to Blob. Resource might not exist or is inaccessible.`,\r\n      uriType: 'blob'\r\n    }));\r\n    const extractBase64Data = data => {\r\n      const matches = /([a-z0-9+\\/=\\s]+)/i.exec(data);\r\n      return matches ? matches[1] : '';\r\n    };\r\n    const parseDataUri = uri => {\r\n      const [type, ...rest] = uri.split(',');\r\n      const data = rest.join(',');\r\n      const matches = /data:([^/]+\\/[^;]+)(;.+)?/.exec(type);\r\n      if (matches) {\r\n        const base64Encoded = matches[2] === ';base64';\r\n        const extractedData = base64Encoded ? extractBase64Data(data) : decodeURIComponent(data);\r\n        return Optional.some({\r\n          type: matches[1],\r\n          data: extractedData,\r\n          base64Encoded\r\n        });\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const buildBlob = (type, data, base64Encoded = true) => {\r\n      let str = data;\r\n      if (base64Encoded) {\r\n        try {\r\n          str = atob(data);\r\n        } catch (e) {\r\n          return Optional.none();\r\n        }\r\n      }\r\n      const arr = new Uint8Array(str.length);\r\n      for (let i = 0; i < arr.length; i++) {\r\n        arr[i] = str.charCodeAt(i);\r\n      }\r\n      return Optional.some(new Blob([arr], { type }));\r\n    };\r\n    const dataUriToBlob = uri => {\r\n      return new Promise((resolve, reject) => {\r\n        parseDataUri(uri).bind(({type, data, base64Encoded}) => buildBlob(type, data, base64Encoded)).fold(() => reject('Invalid data URI'), resolve);\r\n      });\r\n    };\r\n    const uriToBlob = url => {\r\n      if (startsWith(url, 'blob:')) {\r\n        return blobUriToBlob(url);\r\n      } else if (startsWith(url, 'data:')) {\r\n        return dataUriToBlob(url);\r\n      } else {\r\n        return Promise.reject('Unknown URI format');\r\n      }\r\n    };\r\n    const blobToDataUri = blob => {\r\n      return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onloadend = () => {\r\n          resolve(reader.result);\r\n        };\r\n        reader.onerror = () => {\r\n          var _a;\r\n          reject((_a = reader.error) === null || _a === void 0 ? void 0 : _a.message);\r\n        };\r\n        reader.readAsDataURL(blob);\r\n      });\r\n    };\r\n\r\n    let count$1 = 0;\r\n    const uniqueId$1 = prefix => {\r\n      return (prefix || 'blobid') + count$1++;\r\n    };\r\n    const processDataUri = (dataUri, base64Only, generateBlobInfo) => {\r\n      return parseDataUri(dataUri).bind(({data, type, base64Encoded}) => {\r\n        if (base64Only && !base64Encoded) {\r\n          return Optional.none();\r\n        } else {\r\n          const base64 = base64Encoded ? data : btoa(data);\r\n          return generateBlobInfo(base64, type);\r\n        }\r\n      });\r\n    };\r\n    const createBlobInfo$1 = (blobCache, blob, base64) => {\r\n      const blobInfo = blobCache.create(uniqueId$1(), blob, base64);\r\n      blobCache.add(blobInfo);\r\n      return blobInfo;\r\n    };\r\n    const dataUriToBlobInfo = (blobCache, dataUri, base64Only = false) => {\r\n      return processDataUri(dataUri, base64Only, (base64, type) => Optional.from(blobCache.getByData(base64, type)).orThunk(() => buildBlob(type, base64).map(blob => createBlobInfo$1(blobCache, blob, base64))));\r\n    };\r\n    const imageToBlobInfo = (blobCache, imageSrc) => {\r\n      const invalidDataUri = () => Promise.reject('Invalid data URI');\r\n      if (startsWith(imageSrc, 'blob:')) {\r\n        const blobInfo = blobCache.getByUri(imageSrc);\r\n        if (isNonNullable(blobInfo)) {\r\n          return Promise.resolve(blobInfo);\r\n        } else {\r\n          return uriToBlob(imageSrc).then(blob => {\r\n            return blobToDataUri(blob).then(dataUri => {\r\n              return processDataUri(dataUri, false, base64 => {\r\n                return Optional.some(createBlobInfo$1(blobCache, blob, base64));\r\n              }).getOrThunk(invalidDataUri);\r\n            });\r\n          });\r\n        }\r\n      } else if (startsWith(imageSrc, 'data:')) {\r\n        return dataUriToBlobInfo(blobCache, imageSrc).fold(invalidDataUri, blobInfo => Promise.resolve(blobInfo));\r\n      } else {\r\n        return Promise.reject('Unknown image data format');\r\n      }\r\n    };\r\n\r\n    const isBogusImage = img => isNonNullable(img.attr('data-mce-bogus'));\r\n    const isInternalImageSource = img => img.attr('src') === Env.transparentSrc || isNonNullable(img.attr('data-mce-placeholder'));\r\n    const registerBase64ImageFilter = (parser, settings) => {\r\n      const {blob_cache: blobCache} = settings;\r\n      if (blobCache) {\r\n        const processImage = img => {\r\n          const inputSrc = img.attr('src');\r\n          if (isInternalImageSource(img) || isBogusImage(img) || isNullable(inputSrc)) {\r\n            return;\r\n          }\r\n          dataUriToBlobInfo(blobCache, inputSrc, true).each(blobInfo => {\r\n            img.attr('src', blobInfo.blobUri());\r\n          });\r\n        };\r\n        parser.addAttributeFilter('src', nodes => each$e(nodes, processImage));\r\n      }\r\n    };\r\n    const isMimeType = (mime, type) => startsWith(mime, `${ type }/`);\r\n    const createSafeEmbed = (mime, src, width, height, sandboxIframes) => {\r\n      let name;\r\n      if (isUndefined(mime)) {\r\n        name = 'iframe';\r\n      } else if (isMimeType(mime, 'image')) {\r\n        name = 'img';\r\n      } else if (isMimeType(mime, 'video')) {\r\n        name = 'video';\r\n      } else if (isMimeType(mime, 'audio')) {\r\n        name = 'audio';\r\n      } else {\r\n        name = 'iframe';\r\n      }\r\n      const embed = new AstNode(name, 1);\r\n      embed.attr(name === 'audio' ? { src } : {\r\n        src,\r\n        width,\r\n        height\r\n      });\r\n      if (name === 'audio' || name === 'video') {\r\n        embed.attr('controls', '');\r\n      }\r\n      if (name === 'iframe' && sandboxIframes) {\r\n        embed.attr('sandbox', '');\r\n      }\r\n      return embed;\r\n    };\r\n    const register$4 = (parser, settings) => {\r\n      const schema = parser.schema;\r\n      if (settings.remove_trailing_brs) {\r\n        addNodeFilter(settings, parser, schema);\r\n      }\r\n      parser.addAttributeFilter('href', nodes => {\r\n        let i = nodes.length;\r\n        const appendRel = rel => {\r\n          const parts = rel.split(' ').filter(p => p.length > 0);\r\n          return parts.concat(['noopener']).sort().join(' ');\r\n        };\r\n        const addNoOpener = rel => {\r\n          const newRel = rel ? Tools.trim(rel) : '';\r\n          if (!/\\b(noopener)\\b/g.test(newRel)) {\r\n            return appendRel(newRel);\r\n          } else {\r\n            return newRel;\r\n          }\r\n        };\r\n        if (!settings.allow_unsafe_link_target) {\r\n          while (i--) {\r\n            const node = nodes[i];\r\n            if (node.name === 'a' && node.attr('target') === '_blank') {\r\n              node.attr('rel', addNoOpener(node.attr('rel')));\r\n            }\r\n          }\r\n        }\r\n      });\r\n      if (!settings.allow_html_in_named_anchor) {\r\n        parser.addAttributeFilter('id,name', nodes => {\r\n          let i = nodes.length, sibling, prevSibling, parent, node;\r\n          while (i--) {\r\n            node = nodes[i];\r\n            if (node.name === 'a' && node.firstChild && !node.attr('href')) {\r\n              parent = node.parent;\r\n              sibling = node.lastChild;\r\n              while (sibling && parent) {\r\n                prevSibling = sibling.prev;\r\n                parent.insert(sibling, node);\r\n                sibling = prevSibling;\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n      if (settings.fix_list_elements) {\r\n        parser.addNodeFilter('ul,ol', nodes => {\r\n          let i = nodes.length, node, parentNode;\r\n          while (i--) {\r\n            node = nodes[i];\r\n            parentNode = node.parent;\r\n            if (parentNode && (parentNode.name === 'ul' || parentNode.name === 'ol')) {\r\n              if (node.prev && node.prev.name === 'li') {\r\n                node.prev.append(node);\r\n              } else {\r\n                const li = new AstNode('li', 1);\r\n                li.attr('style', 'list-style-type: none');\r\n                node.wrap(li);\r\n              }\r\n            }\r\n          }\r\n        });\r\n      }\r\n      const validClasses = schema.getValidClasses();\r\n      if (settings.validate && validClasses) {\r\n        parser.addAttributeFilter('class', nodes => {\r\n          var _a;\r\n          let i = nodes.length;\r\n          while (i--) {\r\n            const node = nodes[i];\r\n            const clazz = (_a = node.attr('class')) !== null && _a !== void 0 ? _a : '';\r\n            const classList = Tools.explode(clazz, ' ');\r\n            let classValue = '';\r\n            for (let ci = 0; ci < classList.length; ci++) {\r\n              const className = classList[ci];\r\n              let valid = false;\r\n              let validClassesMap = validClasses['*'];\r\n              if (validClassesMap && validClassesMap[className]) {\r\n                valid = true;\r\n              }\r\n              validClassesMap = validClasses[node.name];\r\n              if (!valid && validClassesMap && validClassesMap[className]) {\r\n                valid = true;\r\n              }\r\n              if (valid) {\r\n                if (classValue) {\r\n                  classValue += ' ';\r\n                }\r\n                classValue += className;\r\n              }\r\n            }\r\n            if (!classValue.length) {\r\n              classValue = null;\r\n            }\r\n            node.attr('class', classValue);\r\n          }\r\n        });\r\n      }\r\n      registerBase64ImageFilter(parser, settings);\r\n      if (settings.convert_unsafe_embeds) {\r\n        parser.addNodeFilter('object,embed', nodes => each$e(nodes, node => {\r\n          node.replace(createSafeEmbed(node.attr('type'), node.name === 'object' ? node.attr('data') : node.attr('src'), node.attr('width'), node.attr('height'), settings.sandbox_iframes));\r\n        }));\r\n      }\r\n      if (settings.sandbox_iframes) {\r\n        parser.addNodeFilter('iframe', nodes => each$e(nodes, node => node.attr('sandbox', '')));\r\n      }\r\n    };\r\n\r\n    const {entries, setPrototypeOf, isFrozen, getPrototypeOf, getOwnPropertyDescriptor} = Object;\r\n    let {freeze, seal, create: create$7} = Object;\r\n    let {apply, construct} = typeof Reflect !== 'undefined' && Reflect;\r\n    if (!apply) {\r\n      apply = function apply(fun, thisValue, args) {\r\n        return fun.apply(thisValue, args);\r\n      };\r\n    }\r\n    if (!freeze) {\r\n      freeze = function freeze(x) {\r\n        return x;\r\n      };\r\n    }\r\n    if (!seal) {\r\n      seal = function seal(x) {\r\n        return x;\r\n      };\r\n    }\r\n    if (!construct) {\r\n      construct = function construct(Func, args) {\r\n        return new Func(...args);\r\n      };\r\n    }\r\n    const arrayForEach = unapply(Array.prototype.forEach);\r\n    const arrayPop = unapply(Array.prototype.pop);\r\n    const arrayPush = unapply(Array.prototype.push);\r\n    const stringToLowerCase = unapply(String.prototype.toLowerCase);\r\n    const stringToString = unapply(String.prototype.toString);\r\n    const stringMatch = unapply(String.prototype.match);\r\n    const stringReplace = unapply(String.prototype.replace);\r\n    const stringIndexOf = unapply(String.prototype.indexOf);\r\n    const stringTrim = unapply(String.prototype.trim);\r\n    const regExpTest = unapply(RegExp.prototype.test);\r\n    const typeErrorCreate = unconstruct(TypeError);\r\n    function unapply(func) {\r\n      return function (thisArg) {\r\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\r\n          args[_key - 1] = arguments[_key];\r\n        }\r\n        return apply(func, thisArg, args);\r\n      };\r\n    }\r\n    function unconstruct(func) {\r\n      return function () {\r\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\r\n          args[_key2] = arguments[_key2];\r\n        }\r\n        return construct(func, args);\r\n      };\r\n    }\r\n    function addToSet(set, array, transformCaseFunc) {\r\n      var _transformCaseFunc;\r\n      transformCaseFunc = (_transformCaseFunc = transformCaseFunc) !== null && _transformCaseFunc !== void 0 ? _transformCaseFunc : stringToLowerCase;\r\n      if (setPrototypeOf) {\r\n        setPrototypeOf(set, null);\r\n      }\r\n      let l = array.length;\r\n      while (l--) {\r\n        let element = array[l];\r\n        if (typeof element === 'string') {\r\n          const lcElement = transformCaseFunc(element);\r\n          if (lcElement !== element) {\r\n            if (!isFrozen(array)) {\r\n              array[l] = lcElement;\r\n            }\r\n            element = lcElement;\r\n          }\r\n        }\r\n        set[element] = true;\r\n      }\r\n      return set;\r\n    }\r\n    function clone(object) {\r\n      const newObject = create$7(null);\r\n      for (const [property, value] of entries(object)) {\r\n        newObject[property] = value;\r\n      }\r\n      return newObject;\r\n    }\r\n    function lookupGetter(object, prop) {\r\n      while (object !== null) {\r\n        const desc = getOwnPropertyDescriptor(object, prop);\r\n        if (desc) {\r\n          if (desc.get) {\r\n            return unapply(desc.get);\r\n          }\r\n          if (typeof desc.value === 'function') {\r\n            return unapply(desc.value);\r\n          }\r\n        }\r\n        object = getPrototypeOf(object);\r\n      }\r\n      function fallbackValue(element) {\r\n        console.warn('fallback value for', element);\r\n        return null;\r\n      }\r\n      return fallbackValue;\r\n    }\r\n    const html$1 = freeze([\r\n      'a',\r\n      'abbr',\r\n      'acronym',\r\n      'address',\r\n      'area',\r\n      'article',\r\n      'aside',\r\n      'audio',\r\n      'b',\r\n      'bdi',\r\n      'bdo',\r\n      'big',\r\n      'blink',\r\n      'blockquote',\r\n      'body',\r\n      'br',\r\n      'button',\r\n      'canvas',\r\n      'caption',\r\n      'center',\r\n      'cite',\r\n      'code',\r\n      'col',\r\n      'colgroup',\r\n      'content',\r\n      'data',\r\n      'datalist',\r\n      'dd',\r\n      'decorator',\r\n      'del',\r\n      'details',\r\n      'dfn',\r\n      'dialog',\r\n      'dir',\r\n      'div',\r\n      'dl',\r\n      'dt',\r\n      'element',\r\n      'em',\r\n      'fieldset',\r\n      'figcaption',\r\n      'figure',\r\n      'font',\r\n      'footer',\r\n      'form',\r\n      'h1',\r\n      'h2',\r\n      'h3',\r\n      'h4',\r\n      'h5',\r\n      'h6',\r\n      'head',\r\n      'header',\r\n      'hgroup',\r\n      'hr',\r\n      'html',\r\n      'i',\r\n      'img',\r\n      'input',\r\n      'ins',\r\n      'kbd',\r\n      'label',\r\n      'legend',\r\n      'li',\r\n      'main',\r\n      'map',\r\n      'mark',\r\n      'marquee',\r\n      'menu',\r\n      'menuitem',\r\n      'meter',\r\n      'nav',\r\n      'nobr',\r\n      'ol',\r\n      'optgroup',\r\n      'option',\r\n      'output',\r\n      'p',\r\n      'picture',\r\n      'pre',\r\n      'progress',\r\n      'q',\r\n      'rp',\r\n      'rt',\r\n      'ruby',\r\n      's',\r\n      'samp',\r\n      'section',\r\n      'select',\r\n      'shadow',\r\n      'small',\r\n      'source',\r\n      'spacer',\r\n      'span',\r\n      'strike',\r\n      'strong',\r\n      'style',\r\n      'sub',\r\n      'summary',\r\n      'sup',\r\n      'table',\r\n      'tbody',\r\n      'td',\r\n      'template',\r\n      'textarea',\r\n      'tfoot',\r\n      'th',\r\n      'thead',\r\n      'time',\r\n      'tr',\r\n      'track',\r\n      'tt',\r\n      'u',\r\n      'ul',\r\n      'var',\r\n      'video',\r\n      'wbr'\r\n    ]);\r\n    const svg$1 = freeze([\r\n      'svg',\r\n      'a',\r\n      'altglyph',\r\n      'altglyphdef',\r\n      'altglyphitem',\r\n      'animatecolor',\r\n      'animatemotion',\r\n      'animatetransform',\r\n      'circle',\r\n      'clippath',\r\n      'defs',\r\n      'desc',\r\n      'ellipse',\r\n      'filter',\r\n      'font',\r\n      'g',\r\n      'glyph',\r\n      'glyphref',\r\n      'hkern',\r\n      'image',\r\n      'line',\r\n      'lineargradient',\r\n      'marker',\r\n      'mask',\r\n      'metadata',\r\n      'mpath',\r\n      'path',\r\n      'pattern',\r\n      'polygon',\r\n      'polyline',\r\n      'radialgradient',\r\n      'rect',\r\n      'stop',\r\n      'style',\r\n      'switch',\r\n      'symbol',\r\n      'text',\r\n      'textpath',\r\n      'title',\r\n      'tref',\r\n      'tspan',\r\n      'view',\r\n      'vkern'\r\n    ]);\r\n    const svgFilters = freeze([\r\n      'feBlend',\r\n      'feColorMatrix',\r\n      'feComponentTransfer',\r\n      'feComposite',\r\n      'feConvolveMatrix',\r\n      'feDiffuseLighting',\r\n      'feDisplacementMap',\r\n      'feDistantLight',\r\n      'feDropShadow',\r\n      'feFlood',\r\n      'feFuncA',\r\n      'feFuncB',\r\n      'feFuncG',\r\n      'feFuncR',\r\n      'feGaussianBlur',\r\n      'feImage',\r\n      'feMerge',\r\n      'feMergeNode',\r\n      'feMorphology',\r\n      'feOffset',\r\n      'fePointLight',\r\n      'feSpecularLighting',\r\n      'feSpotLight',\r\n      'feTile',\r\n      'feTurbulence'\r\n    ]);\r\n    const svgDisallowed = freeze([\r\n      'animate',\r\n      'color-profile',\r\n      'cursor',\r\n      'discard',\r\n      'font-face',\r\n      'font-face-format',\r\n      'font-face-name',\r\n      'font-face-src',\r\n      'font-face-uri',\r\n      'foreignobject',\r\n      'hatch',\r\n      'hatchpath',\r\n      'mesh',\r\n      'meshgradient',\r\n      'meshpatch',\r\n      'meshrow',\r\n      'missing-glyph',\r\n      'script',\r\n      'set',\r\n      'solidcolor',\r\n      'unknown',\r\n      'use'\r\n    ]);\r\n    const mathMl$1 = freeze([\r\n      'math',\r\n      'menclose',\r\n      'merror',\r\n      'mfenced',\r\n      'mfrac',\r\n      'mglyph',\r\n      'mi',\r\n      'mlabeledtr',\r\n      'mmultiscripts',\r\n      'mn',\r\n      'mo',\r\n      'mover',\r\n      'mpadded',\r\n      'mphantom',\r\n      'mroot',\r\n      'mrow',\r\n      'ms',\r\n      'mspace',\r\n      'msqrt',\r\n      'mstyle',\r\n      'msub',\r\n      'msup',\r\n      'msubsup',\r\n      'mtable',\r\n      'mtd',\r\n      'mtext',\r\n      'mtr',\r\n      'munder',\r\n      'munderover',\r\n      'mprescripts'\r\n    ]);\r\n    const mathMlDisallowed = freeze([\r\n      'maction',\r\n      'maligngroup',\r\n      'malignmark',\r\n      'mlongdiv',\r\n      'mscarries',\r\n      'mscarry',\r\n      'msgroup',\r\n      'mstack',\r\n      'msline',\r\n      'msrow',\r\n      'semantics',\r\n      'annotation',\r\n      'annotation-xml',\r\n      'mprescripts',\r\n      'none'\r\n    ]);\r\n    const text = freeze(['#text']);\r\n    const html = freeze([\r\n      'accept',\r\n      'action',\r\n      'align',\r\n      'alt',\r\n      'autocapitalize',\r\n      'autocomplete',\r\n      'autopictureinpicture',\r\n      'autoplay',\r\n      'background',\r\n      'bgcolor',\r\n      'border',\r\n      'capture',\r\n      'cellpadding',\r\n      'cellspacing',\r\n      'checked',\r\n      'cite',\r\n      'class',\r\n      'clear',\r\n      'color',\r\n      'cols',\r\n      'colspan',\r\n      'controls',\r\n      'controlslist',\r\n      'coords',\r\n      'crossorigin',\r\n      'datetime',\r\n      'decoding',\r\n      'default',\r\n      'dir',\r\n      'disabled',\r\n      'disablepictureinpicture',\r\n      'disableremoteplayback',\r\n      'download',\r\n      'draggable',\r\n      'enctype',\r\n      'enterkeyhint',\r\n      'face',\r\n      'for',\r\n      'headers',\r\n      'height',\r\n      'hidden',\r\n      'high',\r\n      'href',\r\n      'hreflang',\r\n      'id',\r\n      'inputmode',\r\n      'integrity',\r\n      'ismap',\r\n      'kind',\r\n      'label',\r\n      'lang',\r\n      'list',\r\n      'loading',\r\n      'loop',\r\n      'low',\r\n      'max',\r\n      'maxlength',\r\n      'media',\r\n      'method',\r\n      'min',\r\n      'minlength',\r\n      'multiple',\r\n      'muted',\r\n      'name',\r\n      'nonce',\r\n      'noshade',\r\n      'novalidate',\r\n      'nowrap',\r\n      'open',\r\n      'optimum',\r\n      'pattern',\r\n      'placeholder',\r\n      'playsinline',\r\n      'poster',\r\n      'preload',\r\n      'pubdate',\r\n      'radiogroup',\r\n      'readonly',\r\n      'rel',\r\n      'required',\r\n      'rev',\r\n      'reversed',\r\n      'role',\r\n      'rows',\r\n      'rowspan',\r\n      'spellcheck',\r\n      'scope',\r\n      'selected',\r\n      'shape',\r\n      'size',\r\n      'sizes',\r\n      'span',\r\n      'srclang',\r\n      'start',\r\n      'src',\r\n      'srcset',\r\n      'step',\r\n      'style',\r\n      'summary',\r\n      'tabindex',\r\n      'title',\r\n      'translate',\r\n      'type',\r\n      'usemap',\r\n      'valign',\r\n      'value',\r\n      'width',\r\n      'xmlns',\r\n      'slot'\r\n    ]);\r\n    const svg = freeze([\r\n      'accent-height',\r\n      'accumulate',\r\n      'additive',\r\n      'alignment-baseline',\r\n      'ascent',\r\n      'attributename',\r\n      'attributetype',\r\n      'azimuth',\r\n      'basefrequency',\r\n      'baseline-shift',\r\n      'begin',\r\n      'bias',\r\n      'by',\r\n      'class',\r\n      'clip',\r\n      'clippathunits',\r\n      'clip-path',\r\n      'clip-rule',\r\n      'color',\r\n      'color-interpolation',\r\n      'color-interpolation-filters',\r\n      'color-profile',\r\n      'color-rendering',\r\n      'cx',\r\n      'cy',\r\n      'd',\r\n      'dx',\r\n      'dy',\r\n      'diffuseconstant',\r\n      'direction',\r\n      'display',\r\n      'divisor',\r\n      'dur',\r\n      'edgemode',\r\n      'elevation',\r\n      'end',\r\n      'fill',\r\n      'fill-opacity',\r\n      'fill-rule',\r\n      'filter',\r\n      'filterunits',\r\n      'flood-color',\r\n      'flood-opacity',\r\n      'font-family',\r\n      'font-size',\r\n      'font-size-adjust',\r\n      'font-stretch',\r\n      'font-style',\r\n      'font-variant',\r\n      'font-weight',\r\n      'fx',\r\n      'fy',\r\n      'g1',\r\n      'g2',\r\n      'glyph-name',\r\n      'glyphref',\r\n      'gradientunits',\r\n      'gradienttransform',\r\n      'height',\r\n      'href',\r\n      'id',\r\n      'image-rendering',\r\n      'in',\r\n      'in2',\r\n      'k',\r\n      'k1',\r\n      'k2',\r\n      'k3',\r\n      'k4',\r\n      'kerning',\r\n      'keypoints',\r\n      'keysplines',\r\n      'keytimes',\r\n      'lang',\r\n      'lengthadjust',\r\n      'letter-spacing',\r\n      'kernelmatrix',\r\n      'kernelunitlength',\r\n      'lighting-color',\r\n      'local',\r\n      'marker-end',\r\n      'marker-mid',\r\n      'marker-start',\r\n      'markerheight',\r\n      'markerunits',\r\n      'markerwidth',\r\n      'maskcontentunits',\r\n      'maskunits',\r\n      'max',\r\n      'mask',\r\n      'media',\r\n      'method',\r\n      'mode',\r\n      'min',\r\n      'name',\r\n      'numoctaves',\r\n      'offset',\r\n      'operator',\r\n      'opacity',\r\n      'order',\r\n      'orient',\r\n      'orientation',\r\n      'origin',\r\n      'overflow',\r\n      'paint-order',\r\n      'path',\r\n      'pathlength',\r\n      'patterncontentunits',\r\n      'patterntransform',\r\n      'patternunits',\r\n      'points',\r\n      'preservealpha',\r\n      'preserveaspectratio',\r\n      'primitiveunits',\r\n      'r',\r\n      'rx',\r\n      'ry',\r\n      'radius',\r\n      'refx',\r\n      'refy',\r\n      'repeatcount',\r\n      'repeatdur',\r\n      'restart',\r\n      'result',\r\n      'rotate',\r\n      'scale',\r\n      'seed',\r\n      'shape-rendering',\r\n      'specularconstant',\r\n      'specularexponent',\r\n      'spreadmethod',\r\n      'startoffset',\r\n      'stddeviation',\r\n      'stitchtiles',\r\n      'stop-color',\r\n      'stop-opacity',\r\n      'stroke-dasharray',\r\n      'stroke-dashoffset',\r\n      'stroke-linecap',\r\n      'stroke-linejoin',\r\n      'stroke-miterlimit',\r\n      'stroke-opacity',\r\n      'stroke',\r\n      'stroke-width',\r\n      'style',\r\n      'surfacescale',\r\n      'systemlanguage',\r\n      'tabindex',\r\n      'targetx',\r\n      'targety',\r\n      'transform',\r\n      'transform-origin',\r\n      'text-anchor',\r\n      'text-decoration',\r\n      'text-rendering',\r\n      'textlength',\r\n      'type',\r\n      'u1',\r\n      'u2',\r\n      'unicode',\r\n      'values',\r\n      'viewbox',\r\n      'visibility',\r\n      'version',\r\n      'vert-adv-y',\r\n      'vert-origin-x',\r\n      'vert-origin-y',\r\n      'width',\r\n      'word-spacing',\r\n      'wrap',\r\n      'writing-mode',\r\n      'xchannelselector',\r\n      'ychannelselector',\r\n      'x',\r\n      'x1',\r\n      'x2',\r\n      'xmlns',\r\n      'y',\r\n      'y1',\r\n      'y2',\r\n      'z',\r\n      'zoomandpan'\r\n    ]);\r\n    const mathMl = freeze([\r\n      'accent',\r\n      'accentunder',\r\n      'align',\r\n      'bevelled',\r\n      'close',\r\n      'columnsalign',\r\n      'columnlines',\r\n      'columnspan',\r\n      'denomalign',\r\n      'depth',\r\n      'dir',\r\n      'display',\r\n      'displaystyle',\r\n      'encoding',\r\n      'fence',\r\n      'frame',\r\n      'height',\r\n      'href',\r\n      'id',\r\n      'largeop',\r\n      'length',\r\n      'linethickness',\r\n      'lspace',\r\n      'lquote',\r\n      'mathbackground',\r\n      'mathcolor',\r\n      'mathsize',\r\n      'mathvariant',\r\n      'maxsize',\r\n      'minsize',\r\n      'movablelimits',\r\n      'notation',\r\n      'numalign',\r\n      'open',\r\n      'rowalign',\r\n      'rowlines',\r\n      'rowspacing',\r\n      'rowspan',\r\n      'rspace',\r\n      'rquote',\r\n      'scriptlevel',\r\n      'scriptminsize',\r\n      'scriptsizemultiplier',\r\n      'selection',\r\n      'separator',\r\n      'separators',\r\n      'stretchy',\r\n      'subscriptshift',\r\n      'supscriptshift',\r\n      'symmetric',\r\n      'voffset',\r\n      'width',\r\n      'xmlns'\r\n    ]);\r\n    const xml = freeze([\r\n      'xlink:href',\r\n      'xml:id',\r\n      'xlink:title',\r\n      'xml:space',\r\n      'xmlns:xlink'\r\n    ]);\r\n    const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm);\r\n    const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\r\n    const TMPLIT_EXPR = seal(/\\${[\\w\\W]*}/gm);\r\n    const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]/);\r\n    const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/);\r\n    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i);\r\n    const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\r\n    const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g);\r\n    const DOCTYPE_NAME = seal(/^html$/i);\r\n    var EXPRESSIONS = Object.freeze({\r\n      __proto__: null,\r\n      MUSTACHE_EXPR: MUSTACHE_EXPR,\r\n      ERB_EXPR: ERB_EXPR,\r\n      TMPLIT_EXPR: TMPLIT_EXPR,\r\n      DATA_ATTR: DATA_ATTR,\r\n      ARIA_ATTR: ARIA_ATTR,\r\n      IS_ALLOWED_URI: IS_ALLOWED_URI,\r\n      IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\r\n      ATTR_WHITESPACE: ATTR_WHITESPACE,\r\n      DOCTYPE_NAME: DOCTYPE_NAME\r\n    });\r\n    const getGlobal = () => typeof window === 'undefined' ? null : window;\r\n    const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\r\n      if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\r\n        return null;\r\n      }\r\n      let suffix = null;\r\n      const ATTR_NAME = 'data-tt-policy-suffix';\r\n      if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\r\n        suffix = purifyHostElement.getAttribute(ATTR_NAME);\r\n      }\r\n      const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\r\n      try {\r\n        return trustedTypes.createPolicy(policyName, {\r\n          createHTML(html) {\r\n            return html;\r\n          },\r\n          createScriptURL(scriptUrl) {\r\n            return scriptUrl;\r\n          }\r\n        });\r\n      } catch (_) {\r\n        console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\r\n        return null;\r\n      }\r\n    };\r\n    function createDOMPurify() {\r\n      let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\r\n      const DOMPurify = root => createDOMPurify(root);\r\n      DOMPurify.version = '3.0.5';\r\n      DOMPurify.removed = [];\r\n      if (!window || !window.document || window.document.nodeType !== 9) {\r\n        DOMPurify.isSupported = false;\r\n        return DOMPurify;\r\n      }\r\n      const originalDocument = window.document;\r\n      const currentScript = originalDocument.currentScript;\r\n      let {document} = window;\r\n      const {DocumentFragment, HTMLTemplateElement, Node, Element, NodeFilter, NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap, HTMLFormElement, DOMParser, trustedTypes} = window;\r\n      const ElementPrototype = Element.prototype;\r\n      const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\r\n      const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\r\n      const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\r\n      const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\r\n      if (typeof HTMLTemplateElement === 'function') {\r\n        const template = document.createElement('template');\r\n        if (template.content && template.content.ownerDocument) {\r\n          document = template.content.ownerDocument;\r\n        }\r\n      }\r\n      let trustedTypesPolicy;\r\n      let emptyHTML = '';\r\n      const {implementation, createNodeIterator, createDocumentFragment, getElementsByTagName} = document;\r\n      const {importNode} = originalDocument;\r\n      let hooks = {};\r\n      DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\r\n      const {MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR, DATA_ATTR, ARIA_ATTR, IS_SCRIPT_OR_DATA, ATTR_WHITESPACE} = EXPRESSIONS;\r\n      let {IS_ALLOWED_URI: IS_ALLOWED_URI$1} = EXPRESSIONS;\r\n      let ALLOWED_TAGS = null;\r\n      const DEFAULT_ALLOWED_TAGS = addToSet({}, [\r\n        ...html$1,\r\n        ...svg$1,\r\n        ...svgFilters,\r\n        ...mathMl$1,\r\n        ...text\r\n      ]);\r\n      let ALLOWED_ATTR = null;\r\n      const DEFAULT_ALLOWED_ATTR = addToSet({}, [\r\n        ...html,\r\n        ...svg,\r\n        ...mathMl,\r\n        ...xml\r\n      ]);\r\n      let CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {\r\n        tagNameCheck: {\r\n          writable: true,\r\n          configurable: false,\r\n          enumerable: true,\r\n          value: null\r\n        },\r\n        attributeNameCheck: {\r\n          writable: true,\r\n          configurable: false,\r\n          enumerable: true,\r\n          value: null\r\n        },\r\n        allowCustomizedBuiltInElements: {\r\n          writable: true,\r\n          configurable: false,\r\n          enumerable: true,\r\n          value: false\r\n        }\r\n      }));\r\n      let FORBID_TAGS = null;\r\n      let FORBID_ATTR = null;\r\n      let ALLOW_ARIA_ATTR = true;\r\n      let ALLOW_DATA_ATTR = true;\r\n      let ALLOW_UNKNOWN_PROTOCOLS = false;\r\n      let ALLOW_SELF_CLOSE_IN_ATTR = true;\r\n      let SAFE_FOR_TEMPLATES = false;\r\n      let WHOLE_DOCUMENT = false;\r\n      let SET_CONFIG = false;\r\n      let FORCE_BODY = false;\r\n      let RETURN_DOM = false;\r\n      let RETURN_DOM_FRAGMENT = false;\r\n      let RETURN_TRUSTED_TYPE = false;\r\n      let SANITIZE_DOM = true;\r\n      let SANITIZE_NAMED_PROPS = false;\r\n      const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\r\n      let KEEP_CONTENT = true;\r\n      let IN_PLACE = false;\r\n      let USE_PROFILES = {};\r\n      let FORBID_CONTENTS = null;\r\n      const DEFAULT_FORBID_CONTENTS = addToSet({}, [\r\n        'annotation-xml',\r\n        'audio',\r\n        'colgroup',\r\n        'desc',\r\n        'foreignobject',\r\n        'head',\r\n        'iframe',\r\n        'math',\r\n        'mi',\r\n        'mn',\r\n        'mo',\r\n        'ms',\r\n        'mtext',\r\n        'noembed',\r\n        'noframes',\r\n        'noscript',\r\n        'plaintext',\r\n        'script',\r\n        'style',\r\n        'svg',\r\n        'template',\r\n        'thead',\r\n        'title',\r\n        'video',\r\n        'xmp'\r\n      ]);\r\n      let DATA_URI_TAGS = null;\r\n      const DEFAULT_DATA_URI_TAGS = addToSet({}, [\r\n        'audio',\r\n        'video',\r\n        'img',\r\n        'source',\r\n        'image',\r\n        'track'\r\n      ]);\r\n      let URI_SAFE_ATTRIBUTES = null;\r\n      const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\r\n        'alt',\r\n        'class',\r\n        'for',\r\n        'id',\r\n        'label',\r\n        'name',\r\n        'pattern',\r\n        'placeholder',\r\n        'role',\r\n        'summary',\r\n        'title',\r\n        'value',\r\n        'style',\r\n        'xmlns'\r\n      ]);\r\n      const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\r\n      const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\r\n      const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\r\n      let NAMESPACE = HTML_NAMESPACE;\r\n      let IS_EMPTY_INPUT = false;\r\n      let ALLOWED_NAMESPACES = null;\r\n      const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\r\n        MATHML_NAMESPACE,\r\n        SVG_NAMESPACE,\r\n        HTML_NAMESPACE\r\n      ], stringToString);\r\n      let PARSER_MEDIA_TYPE;\r\n      const SUPPORTED_PARSER_MEDIA_TYPES = [\r\n        'application/xhtml+xml',\r\n        'text/html'\r\n      ];\r\n      const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\r\n      let transformCaseFunc;\r\n      let CONFIG = null;\r\n      const formElement = document.createElement('form');\r\n      const isRegexOrFunction = function isRegexOrFunction(testValue) {\r\n        return testValue instanceof RegExp || testValue instanceof Function;\r\n      };\r\n      const _parseConfig = function _parseConfig(cfg) {\r\n        if (CONFIG && CONFIG === cfg) {\r\n          return;\r\n        }\r\n        if (!cfg || typeof cfg !== 'object') {\r\n          cfg = {};\r\n        }\r\n        cfg = clone(cfg);\r\n        PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;\r\n        transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\r\n        ALLOWED_TAGS = 'ALLOWED_TAGS' in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\r\n        ALLOWED_ATTR = 'ALLOWED_ATTR' in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\r\n        ALLOWED_NAMESPACES = 'ALLOWED_NAMESPACES' in cfg ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\r\n        URI_SAFE_ATTRIBUTES = 'ADD_URI_SAFE_ATTR' in cfg ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\r\n        DATA_URI_TAGS = 'ADD_DATA_URI_TAGS' in cfg ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\r\n        FORBID_CONTENTS = 'FORBID_CONTENTS' in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\r\n        FORBID_TAGS = 'FORBID_TAGS' in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};\r\n        FORBID_ATTR = 'FORBID_ATTR' in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};\r\n        USE_PROFILES = 'USE_PROFILES' in cfg ? cfg.USE_PROFILES : false;\r\n        ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;\r\n        ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;\r\n        ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;\r\n        ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false;\r\n        SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;\r\n        WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;\r\n        RETURN_DOM = cfg.RETURN_DOM || false;\r\n        RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;\r\n        RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;\r\n        FORCE_BODY = cfg.FORCE_BODY || false;\r\n        SANITIZE_DOM = cfg.SANITIZE_DOM !== false;\r\n        SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;\r\n        KEEP_CONTENT = cfg.KEEP_CONTENT !== false;\r\n        IN_PLACE = cfg.IN_PLACE || false;\r\n        IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\r\n        NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\r\n        CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\r\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\r\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\r\n        }\r\n        if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\r\n          CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\r\n        }\r\n        if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\r\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\r\n        }\r\n        if (SAFE_FOR_TEMPLATES) {\r\n          ALLOW_DATA_ATTR = false;\r\n        }\r\n        if (RETURN_DOM_FRAGMENT) {\r\n          RETURN_DOM = true;\r\n        }\r\n        if (USE_PROFILES) {\r\n          ALLOWED_TAGS = addToSet({}, [...text]);\r\n          ALLOWED_ATTR = [];\r\n          if (USE_PROFILES.html === true) {\r\n            addToSet(ALLOWED_TAGS, html$1);\r\n            addToSet(ALLOWED_ATTR, html);\r\n          }\r\n          if (USE_PROFILES.svg === true) {\r\n            addToSet(ALLOWED_TAGS, svg$1);\r\n            addToSet(ALLOWED_ATTR, svg);\r\n            addToSet(ALLOWED_ATTR, xml);\r\n          }\r\n          if (USE_PROFILES.svgFilters === true) {\r\n            addToSet(ALLOWED_TAGS, svgFilters);\r\n            addToSet(ALLOWED_ATTR, svg);\r\n            addToSet(ALLOWED_ATTR, xml);\r\n          }\r\n          if (USE_PROFILES.mathMl === true) {\r\n            addToSet(ALLOWED_TAGS, mathMl$1);\r\n            addToSet(ALLOWED_ATTR, mathMl);\r\n            addToSet(ALLOWED_ATTR, xml);\r\n          }\r\n        }\r\n        if (cfg.ADD_TAGS) {\r\n          if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\r\n            ALLOWED_TAGS = clone(ALLOWED_TAGS);\r\n          }\r\n          addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\r\n        }\r\n        if (cfg.ADD_ATTR) {\r\n          if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\r\n            ALLOWED_ATTR = clone(ALLOWED_ATTR);\r\n          }\r\n          addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\r\n        }\r\n        if (cfg.ADD_URI_SAFE_ATTR) {\r\n          addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\r\n        }\r\n        if (cfg.FORBID_CONTENTS) {\r\n          if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\r\n            FORBID_CONTENTS = clone(FORBID_CONTENTS);\r\n          }\r\n          addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\r\n        }\r\n        if (KEEP_CONTENT) {\r\n          ALLOWED_TAGS['#text'] = true;\r\n        }\r\n        if (WHOLE_DOCUMENT) {\r\n          addToSet(ALLOWED_TAGS, [\r\n            'html',\r\n            'head',\r\n            'body'\r\n          ]);\r\n        }\r\n        if (ALLOWED_TAGS.table) {\r\n          addToSet(ALLOWED_TAGS, ['tbody']);\r\n          delete FORBID_TAGS.tbody;\r\n        }\r\n        if (cfg.TRUSTED_TYPES_POLICY) {\r\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\r\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\r\n          }\r\n          if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\r\n            throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\r\n          }\r\n          trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\r\n          emptyHTML = trustedTypesPolicy.createHTML('');\r\n        } else {\r\n          if (trustedTypesPolicy === undefined) {\r\n            trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\r\n          }\r\n          if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\r\n            emptyHTML = trustedTypesPolicy.createHTML('');\r\n          }\r\n        }\r\n        if (freeze) {\r\n          freeze(cfg);\r\n        }\r\n        CONFIG = cfg;\r\n      };\r\n      const MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\r\n        'mi',\r\n        'mo',\r\n        'mn',\r\n        'ms',\r\n        'mtext'\r\n      ]);\r\n      const HTML_INTEGRATION_POINTS = addToSet({}, [\r\n        'foreignobject',\r\n        'desc',\r\n        'title',\r\n        'annotation-xml'\r\n      ]);\r\n      const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\r\n        'title',\r\n        'style',\r\n        'font',\r\n        'a',\r\n        'script'\r\n      ]);\r\n      const ALL_SVG_TAGS = addToSet({}, svg$1);\r\n      addToSet(ALL_SVG_TAGS, svgFilters);\r\n      addToSet(ALL_SVG_TAGS, svgDisallowed);\r\n      const ALL_MATHML_TAGS = addToSet({}, mathMl$1);\r\n      addToSet(ALL_MATHML_TAGS, mathMlDisallowed);\r\n      const _checkValidNamespace = function _checkValidNamespace(element) {\r\n        let parent = getParentNode(element);\r\n        if (!parent || !parent.tagName) {\r\n          parent = {\r\n            namespaceURI: NAMESPACE,\r\n            tagName: 'template'\r\n          };\r\n        }\r\n        const tagName = stringToLowerCase(element.tagName);\r\n        const parentTagName = stringToLowerCase(parent.tagName);\r\n        if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\r\n          return false;\r\n        }\r\n        if (element.namespaceURI === SVG_NAMESPACE) {\r\n          if (parent.namespaceURI === HTML_NAMESPACE) {\r\n            return tagName === 'svg';\r\n          }\r\n          if (parent.namespaceURI === MATHML_NAMESPACE) {\r\n            return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\r\n          }\r\n          return Boolean(ALL_SVG_TAGS[tagName]);\r\n        }\r\n        if (element.namespaceURI === MATHML_NAMESPACE) {\r\n          if (parent.namespaceURI === HTML_NAMESPACE) {\r\n            return tagName === 'math';\r\n          }\r\n          if (parent.namespaceURI === SVG_NAMESPACE) {\r\n            return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\r\n          }\r\n          return Boolean(ALL_MATHML_TAGS[tagName]);\r\n        }\r\n        if (element.namespaceURI === HTML_NAMESPACE) {\r\n          if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\r\n            return false;\r\n          }\r\n          if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\r\n            return false;\r\n          }\r\n          return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\r\n        }\r\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\r\n          return true;\r\n        }\r\n        return false;\r\n      };\r\n      const _forceRemove = function _forceRemove(node) {\r\n        arrayPush(DOMPurify.removed, { element: node });\r\n        try {\r\n          node.parentNode.removeChild(node);\r\n        } catch (_) {\r\n          node.remove();\r\n        }\r\n      };\r\n      const _removeAttribute = function _removeAttribute(name, node) {\r\n        try {\r\n          arrayPush(DOMPurify.removed, {\r\n            attribute: node.getAttributeNode(name),\r\n            from: node\r\n          });\r\n        } catch (_) {\r\n          arrayPush(DOMPurify.removed, {\r\n            attribute: null,\r\n            from: node\r\n          });\r\n        }\r\n        node.removeAttribute(name);\r\n        if (name === 'is' && !ALLOWED_ATTR[name]) {\r\n          if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\r\n            try {\r\n              _forceRemove(node);\r\n            } catch (_) {\r\n            }\r\n          } else {\r\n            try {\r\n              node.setAttribute(name, '');\r\n            } catch (_) {\r\n            }\r\n          }\r\n        }\r\n      };\r\n      const _initDocument = function _initDocument(dirty) {\r\n        let doc;\r\n        let leadingWhitespace;\r\n        if (FORCE_BODY) {\r\n          dirty = '<remove></remove>' + dirty;\r\n        } else {\r\n          const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\r\n          leadingWhitespace = matches && matches[0];\r\n        }\r\n        if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\r\n          dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\r\n        }\r\n        const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\r\n        if (NAMESPACE === HTML_NAMESPACE) {\r\n          try {\r\n            doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\r\n          } catch (_) {\r\n          }\r\n        }\r\n        if (!doc || !doc.documentElement) {\r\n          doc = implementation.createDocument(NAMESPACE, 'template', null);\r\n          try {\r\n            doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\r\n          } catch (_) {\r\n          }\r\n        }\r\n        const body = doc.body || doc.documentElement;\r\n        if (dirty && leadingWhitespace) {\r\n          body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\r\n        }\r\n        if (NAMESPACE === HTML_NAMESPACE) {\r\n          return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\r\n        }\r\n        return WHOLE_DOCUMENT ? doc.documentElement : body;\r\n      };\r\n      const _createIterator = function _createIterator(root) {\r\n        return createNodeIterator.call(root.ownerDocument || root, root, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT, null, false);\r\n      };\r\n      const _isClobbered = function _isClobbered(elm) {\r\n        return elm instanceof HTMLFormElement && (typeof elm.nodeName !== 'string' || typeof elm.textContent !== 'string' || typeof elm.removeChild !== 'function' || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== 'function' || typeof elm.setAttribute !== 'function' || typeof elm.namespaceURI !== 'string' || typeof elm.insertBefore !== 'function' || typeof elm.hasChildNodes !== 'function');\r\n      };\r\n      const _isNode = function _isNode(object) {\r\n        return typeof Node === 'object' ? object instanceof Node : object && typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string';\r\n      };\r\n      const _executeHook = function _executeHook(entryPoint, currentNode, data) {\r\n        if (!hooks[entryPoint]) {\r\n          return;\r\n        }\r\n        arrayForEach(hooks[entryPoint], hook => {\r\n          hook.call(DOMPurify, currentNode, data, CONFIG);\r\n        });\r\n      };\r\n      const _sanitizeElements = function _sanitizeElements(currentNode) {\r\n        let content;\r\n        _executeHook('beforeSanitizeElements', currentNode, null);\r\n        if (_isClobbered(currentNode)) {\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        const tagName = transformCaseFunc(currentNode.nodeName);\r\n        _executeHook('uponSanitizeElement', currentNode, {\r\n          tagName,\r\n          allowedTags: ALLOWED_TAGS\r\n        });\r\n        if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\\w]/g, currentNode.innerHTML) && regExpTest(/<[/\\w]/g, currentNode.textContent)) {\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\r\n          if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {\r\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))\r\n              return false;\r\n            if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))\r\n              return false;\r\n          }\r\n          if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\r\n            const parentNode = getParentNode(currentNode) || currentNode.parentNode;\r\n            const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\r\n            if (childNodes && parentNode) {\r\n              const childCount = childNodes.length;\r\n              for (let i = childCount - 1; i >= 0; --i) {\r\n                parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));\r\n              }\r\n            }\r\n          }\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\r\n          _forceRemove(currentNode);\r\n          return true;\r\n        }\r\n        if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {\r\n          content = currentNode.textContent;\r\n          content = stringReplace(content, MUSTACHE_EXPR, ' ');\r\n          content = stringReplace(content, ERB_EXPR, ' ');\r\n          content = stringReplace(content, TMPLIT_EXPR, ' ');\r\n          if (currentNode.textContent !== content) {\r\n            arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\r\n            currentNode.textContent = content;\r\n          }\r\n        }\r\n        _executeHook('afterSanitizeElements', currentNode, null);\r\n        return false;\r\n      };\r\n      const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\r\n        if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\r\n          return false;\r\n        }\r\n        if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName));\r\n        else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName));\r\n        else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\r\n          if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)));\r\n          else {\r\n            return false;\r\n          }\r\n        } else if (URI_SAFE_ATTRIBUTES[lcName]);\r\n        else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, '')));\r\n        else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]);\r\n        else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, '')));\r\n        else if (value) {\r\n          return false;\r\n        } else ;\r\n        return true;\r\n      };\r\n      const _basicCustomElementTest = function _basicCustomElementTest(tagName) {\r\n        return tagName.indexOf('-') > 0;\r\n      };\r\n      const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\r\n        let attr;\r\n        let value;\r\n        let lcName;\r\n        let l;\r\n        _executeHook('beforeSanitizeAttributes', currentNode, null);\r\n        const {attributes} = currentNode;\r\n        if (!attributes) {\r\n          return;\r\n        }\r\n        const hookEvent = {\r\n          attrName: '',\r\n          attrValue: '',\r\n          keepAttr: true,\r\n          allowedAttributes: ALLOWED_ATTR\r\n        };\r\n        l = attributes.length;\r\n        while (l--) {\r\n          attr = attributes[l];\r\n          const {name, namespaceURI} = attr;\r\n          value = name === 'value' ? attr.value : stringTrim(attr.value);\r\n          const initValue = value;\r\n          lcName = transformCaseFunc(name);\r\n          hookEvent.attrName = lcName;\r\n          hookEvent.attrValue = value;\r\n          hookEvent.keepAttr = true;\r\n          hookEvent.forceKeepAttr = undefined;\r\n          _executeHook('uponSanitizeAttribute', currentNode, hookEvent);\r\n          value = hookEvent.attrValue;\r\n          if (hookEvent.forceKeepAttr) {\r\n            continue;\r\n          }\r\n          if (!hookEvent.keepAttr) {\r\n            _removeAttribute(name, currentNode);\r\n            continue;\r\n          }\r\n          if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\r\n            _removeAttribute(name, currentNode);\r\n            continue;\r\n          }\r\n          if (SAFE_FOR_TEMPLATES) {\r\n            value = stringReplace(value, MUSTACHE_EXPR, ' ');\r\n            value = stringReplace(value, ERB_EXPR, ' ');\r\n            value = stringReplace(value, TMPLIT_EXPR, ' ');\r\n          }\r\n          const lcTag = transformCaseFunc(currentNode.nodeName);\r\n          if (!_isValidAttribute(lcTag, lcName, value)) {\r\n            _removeAttribute(name, currentNode);\r\n            continue;\r\n          }\r\n          if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\r\n            _removeAttribute(name, currentNode);\r\n            value = SANITIZE_NAMED_PROPS_PREFIX + value;\r\n          }\r\n          if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\r\n            if (namespaceURI);\r\n            else {\r\n              switch (trustedTypes.getAttributeType(lcTag, lcName)) {\r\n              case 'TrustedHTML': {\r\n                  value = trustedTypesPolicy.createHTML(value);\r\n                  break;\r\n                }\r\n              case 'TrustedScriptURL': {\r\n                  value = trustedTypesPolicy.createScriptURL(value);\r\n                  break;\r\n                }\r\n              }\r\n            }\r\n          }\r\n          if (value !== initValue) {\r\n            try {\r\n              if (namespaceURI) {\r\n                currentNode.setAttributeNS(namespaceURI, name, value);\r\n              } else {\r\n                currentNode.setAttribute(name, value);\r\n              }\r\n            } catch (_) {\r\n              _removeAttribute(name, currentNode);\r\n            }\r\n          }\r\n        }\r\n        _executeHook('afterSanitizeAttributes', currentNode, null);\r\n      };\r\n      const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\r\n        let shadowNode;\r\n        const shadowIterator = _createIterator(fragment);\r\n        _executeHook('beforeSanitizeShadowDOM', fragment, null);\r\n        while (shadowNode = shadowIterator.nextNode()) {\r\n          _executeHook('uponSanitizeShadowNode', shadowNode, null);\r\n          if (_sanitizeElements(shadowNode)) {\r\n            continue;\r\n          }\r\n          if (shadowNode.content instanceof DocumentFragment) {\r\n            _sanitizeShadowDOM(shadowNode.content);\r\n          }\r\n          _sanitizeAttributes(shadowNode);\r\n        }\r\n        _executeHook('afterSanitizeShadowDOM', fragment, null);\r\n      };\r\n      DOMPurify.sanitize = function (dirty) {\r\n        let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\r\n        let body;\r\n        let importedNode;\r\n        let currentNode;\r\n        let returnNode;\r\n        IS_EMPTY_INPUT = !dirty;\r\n        if (IS_EMPTY_INPUT) {\r\n          dirty = '<!-->';\r\n        }\r\n        if (typeof dirty !== 'string' && !_isNode(dirty)) {\r\n          if (typeof dirty.toString === 'function') {\r\n            dirty = dirty.toString();\r\n            if (typeof dirty !== 'string') {\r\n              throw typeErrorCreate('dirty is not a string, aborting');\r\n            }\r\n          } else {\r\n            throw typeErrorCreate('toString is not a function');\r\n          }\r\n        }\r\n        if (!DOMPurify.isSupported) {\r\n          return dirty;\r\n        }\r\n        if (!SET_CONFIG) {\r\n          _parseConfig(cfg);\r\n        }\r\n        DOMPurify.removed = [];\r\n        if (typeof dirty === 'string') {\r\n          IN_PLACE = false;\r\n        }\r\n        if (IN_PLACE) {\r\n          if (dirty.nodeName) {\r\n            const tagName = transformCaseFunc(dirty.nodeName);\r\n            if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\r\n              throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\r\n            }\r\n          }\r\n        } else if (dirty instanceof Node) {\r\n          body = _initDocument('<!---->');\r\n          importedNode = body.ownerDocument.importNode(dirty, true);\r\n          if (importedNode.nodeType === 1 && importedNode.nodeName === 'BODY') {\r\n            body = importedNode;\r\n          } else if (importedNode.nodeName === 'HTML') {\r\n            body = importedNode;\r\n          } else {\r\n            body.appendChild(importedNode);\r\n          }\r\n        } else {\r\n          if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf('<') === -1) {\r\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\r\n          }\r\n          body = _initDocument(dirty);\r\n          if (!body) {\r\n            return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\r\n          }\r\n        }\r\n        if (body && FORCE_BODY) {\r\n          _forceRemove(body.firstChild);\r\n        }\r\n        const nodeIterator = _createIterator(IN_PLACE ? dirty : body);\r\n        while (currentNode = nodeIterator.nextNode()) {\r\n          if (_sanitizeElements(currentNode)) {\r\n            continue;\r\n          }\r\n          if (currentNode.content instanceof DocumentFragment) {\r\n            _sanitizeShadowDOM(currentNode.content);\r\n          }\r\n          _sanitizeAttributes(currentNode);\r\n        }\r\n        if (IN_PLACE) {\r\n          return dirty;\r\n        }\r\n        if (RETURN_DOM) {\r\n          if (RETURN_DOM_FRAGMENT) {\r\n            returnNode = createDocumentFragment.call(body.ownerDocument);\r\n            while (body.firstChild) {\r\n              returnNode.appendChild(body.firstChild);\r\n            }\r\n          } else {\r\n            returnNode = body;\r\n          }\r\n          if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\r\n            returnNode = importNode.call(originalDocument, returnNode, true);\r\n          }\r\n          return returnNode;\r\n        }\r\n        let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\r\n        if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\r\n          serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\r\n        }\r\n        if (SAFE_FOR_TEMPLATES) {\r\n          serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR, ' ');\r\n          serializedHTML = stringReplace(serializedHTML, ERB_EXPR, ' ');\r\n          serializedHTML = stringReplace(serializedHTML, TMPLIT_EXPR, ' ');\r\n        }\r\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\r\n      };\r\n      DOMPurify.setConfig = function (cfg) {\r\n        _parseConfig(cfg);\r\n        SET_CONFIG = true;\r\n      };\r\n      DOMPurify.clearConfig = function () {\r\n        CONFIG = null;\r\n        SET_CONFIG = false;\r\n      };\r\n      DOMPurify.isValidAttribute = function (tag, attr, value) {\r\n        if (!CONFIG) {\r\n          _parseConfig({});\r\n        }\r\n        const lcTag = transformCaseFunc(tag);\r\n        const lcName = transformCaseFunc(attr);\r\n        return _isValidAttribute(lcTag, lcName, value);\r\n      };\r\n      DOMPurify.addHook = function (entryPoint, hookFunction) {\r\n        if (typeof hookFunction !== 'function') {\r\n          return;\r\n        }\r\n        hooks[entryPoint] = hooks[entryPoint] || [];\r\n        arrayPush(hooks[entryPoint], hookFunction);\r\n      };\r\n      DOMPurify.removeHook = function (entryPoint) {\r\n        if (hooks[entryPoint]) {\r\n          return arrayPop(hooks[entryPoint]);\r\n        }\r\n      };\r\n      DOMPurify.removeHooks = function (entryPoint) {\r\n        if (hooks[entryPoint]) {\r\n          hooks[entryPoint] = [];\r\n        }\r\n      };\r\n      DOMPurify.removeAllHooks = function () {\r\n        hooks = {};\r\n      };\r\n      return DOMPurify;\r\n    }\r\n    var purify = createDOMPurify();\r\n\r\n    const each$4 = Tools.each, trim = Tools.trim;\r\n    const queryParts = [\r\n      'source',\r\n      'protocol',\r\n      'authority',\r\n      'userInfo',\r\n      'user',\r\n      'password',\r\n      'host',\r\n      'port',\r\n      'relative',\r\n      'path',\r\n      'directory',\r\n      'file',\r\n      'query',\r\n      'anchor'\r\n    ];\r\n    const DEFAULT_PORTS = {\r\n      ftp: 21,\r\n      http: 80,\r\n      https: 443,\r\n      mailto: 25\r\n    };\r\n    const safeSvgDataUrlElements = [\r\n      'img',\r\n      'video'\r\n    ];\r\n    const blockSvgDataUris = (allowSvgDataUrls, tagName) => {\r\n      if (isNonNullable(allowSvgDataUrls)) {\r\n        return !allowSvgDataUrls;\r\n      } else {\r\n        return isNonNullable(tagName) ? !contains$2(safeSvgDataUrlElements, tagName) : true;\r\n      }\r\n    };\r\n    const decodeUri = encodedUri => {\r\n      try {\r\n        return decodeURIComponent(encodedUri);\r\n      } catch (ex) {\r\n        return unescape(encodedUri);\r\n      }\r\n    };\r\n    const isInvalidUri = (settings, uri, tagName) => {\r\n      const decodedUri = decodeUri(uri).replace(/\\s/g, '');\r\n      if (settings.allow_script_urls) {\r\n        return false;\r\n      } else if (/((java|vb)script|mhtml):/i.test(decodedUri)) {\r\n        return true;\r\n      } else if (settings.allow_html_data_urls) {\r\n        return false;\r\n      } else if (/^data:image\\//i.test(decodedUri)) {\r\n        return blockSvgDataUris(settings.allow_svg_data_urls, tagName) && /^data:image\\/svg\\+xml/i.test(decodedUri);\r\n      } else {\r\n        return /^data:/i.test(decodedUri);\r\n      }\r\n    };\r\n    class URI {\r\n      static parseDataUri(uri) {\r\n        let type;\r\n        const uriComponents = decodeURIComponent(uri).split(',');\r\n        const matches = /data:([^;]+)/.exec(uriComponents[0]);\r\n        if (matches) {\r\n          type = matches[1];\r\n        }\r\n        return {\r\n          type,\r\n          data: uriComponents[1]\r\n        };\r\n      }\r\n      static isDomSafe(uri, context, options = {}) {\r\n        if (options.allow_script_urls) {\r\n          return true;\r\n        } else {\r\n          const decodedUri = Entities.decode(uri).replace(/[\\s\\u0000-\\u001F]+/g, '');\r\n          return !isInvalidUri(options, decodedUri, context);\r\n        }\r\n      }\r\n      static getDocumentBaseUrl(loc) {\r\n        var _a;\r\n        let baseUrl;\r\n        if (loc.protocol.indexOf('http') !== 0 && loc.protocol !== 'file:') {\r\n          baseUrl = (_a = loc.href) !== null && _a !== void 0 ? _a : '';\r\n        } else {\r\n          baseUrl = loc.protocol + '//' + loc.host + loc.pathname;\r\n        }\r\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(baseUrl)) {\r\n          baseUrl = baseUrl.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\r\n          if (!/[\\/\\\\]$/.test(baseUrl)) {\r\n            baseUrl += '/';\r\n          }\r\n        }\r\n        return baseUrl;\r\n      }\r\n      constructor(url, settings = {}) {\r\n        this.path = '';\r\n        this.directory = '';\r\n        url = trim(url);\r\n        this.settings = settings;\r\n        const baseUri = settings.base_uri;\r\n        const self = this;\r\n        if (/^([\\w\\-]+):([^\\/]{2})/i.test(url) || /^\\s*#/.test(url)) {\r\n          self.source = url;\r\n          return;\r\n        }\r\n        const isProtocolRelative = url.indexOf('//') === 0;\r\n        if (url.indexOf('/') === 0 && !isProtocolRelative) {\r\n          url = (baseUri ? baseUri.protocol || 'http' : 'http') + '://mce_host' + url;\r\n        }\r\n        if (!/^[\\w\\-]*:?\\/\\//.test(url)) {\r\n          const baseUrl = baseUri ? baseUri.path : new URI(document.location.href).directory;\r\n          if ((baseUri === null || baseUri === void 0 ? void 0 : baseUri.protocol) === '') {\r\n            url = '//mce_host' + self.toAbsPath(baseUrl, url);\r\n          } else {\r\n            const match = /([^#?]*)([#?]?.*)/.exec(url);\r\n            if (match) {\r\n              url = (baseUri && baseUri.protocol || 'http') + '://mce_host' + self.toAbsPath(baseUrl, match[1]) + match[2];\r\n            }\r\n          }\r\n        }\r\n        url = url.replace(/@@/g, '(mce_at)');\r\n        const urlMatch = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@\\/]*):?([^:@\\/]*))?@)?(\\[[a-zA-Z0-9:.%]+\\]|[^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/.exec(url);\r\n        if (urlMatch) {\r\n          each$4(queryParts, (v, i) => {\r\n            let part = urlMatch[i];\r\n            if (part) {\r\n              part = part.replace(/\\(mce_at\\)/g, '@@');\r\n            }\r\n            self[v] = part;\r\n          });\r\n        }\r\n        if (baseUri) {\r\n          if (!self.protocol) {\r\n            self.protocol = baseUri.protocol;\r\n          }\r\n          if (!self.userInfo) {\r\n            self.userInfo = baseUri.userInfo;\r\n          }\r\n          if (!self.port && self.host === 'mce_host') {\r\n            self.port = baseUri.port;\r\n          }\r\n          if (!self.host || self.host === 'mce_host') {\r\n            self.host = baseUri.host;\r\n          }\r\n          self.source = '';\r\n        }\r\n        if (isProtocolRelative) {\r\n          self.protocol = '';\r\n        }\r\n      }\r\n      setPath(path) {\r\n        const pathMatch = /^(.*?)\\/?(\\w+)?$/.exec(path);\r\n        if (pathMatch) {\r\n          this.path = pathMatch[0];\r\n          this.directory = pathMatch[1];\r\n          this.file = pathMatch[2];\r\n        }\r\n        this.source = '';\r\n        this.getURI();\r\n      }\r\n      toRelative(uri) {\r\n        if (uri === './') {\r\n          return uri;\r\n        }\r\n        const relativeUri = new URI(uri, { base_uri: this });\r\n        if (relativeUri.host !== 'mce_host' && this.host !== relativeUri.host && relativeUri.host || this.port !== relativeUri.port || this.protocol !== relativeUri.protocol && relativeUri.protocol !== '') {\r\n          return relativeUri.getURI();\r\n        }\r\n        const tu = this.getURI(), uu = relativeUri.getURI();\r\n        if (tu === uu || tu.charAt(tu.length - 1) === '/' && tu.substr(0, tu.length - 1) === uu) {\r\n          return tu;\r\n        }\r\n        let output = this.toRelPath(this.path, relativeUri.path);\r\n        if (relativeUri.query) {\r\n          output += '?' + relativeUri.query;\r\n        }\r\n        if (relativeUri.anchor) {\r\n          output += '#' + relativeUri.anchor;\r\n        }\r\n        return output;\r\n      }\r\n      toAbsolute(uri, noHost) {\r\n        const absoluteUri = new URI(uri, { base_uri: this });\r\n        return absoluteUri.getURI(noHost && this.isSameOrigin(absoluteUri));\r\n      }\r\n      isSameOrigin(uri) {\r\n        if (this.host == uri.host && this.protocol == uri.protocol) {\r\n          if (this.port == uri.port) {\r\n            return true;\r\n          }\r\n          const defaultPort = this.protocol ? DEFAULT_PORTS[this.protocol] : null;\r\n          if (defaultPort && (this.port || defaultPort) == (uri.port || defaultPort)) {\r\n            return true;\r\n          }\r\n        }\r\n        return false;\r\n      }\r\n      toRelPath(base, path) {\r\n        let breakPoint = 0, out = '', i, l;\r\n        const normalizedBase = base.substring(0, base.lastIndexOf('/')).split('/');\r\n        const items = path.split('/');\r\n        if (normalizedBase.length >= items.length) {\r\n          for (i = 0, l = normalizedBase.length; i < l; i++) {\r\n            if (i >= items.length || normalizedBase[i] !== items[i]) {\r\n              breakPoint = i + 1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (normalizedBase.length < items.length) {\r\n          for (i = 0, l = items.length; i < l; i++) {\r\n            if (i >= normalizedBase.length || normalizedBase[i] !== items[i]) {\r\n              breakPoint = i + 1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        if (breakPoint === 1) {\r\n          return path;\r\n        }\r\n        for (i = 0, l = normalizedBase.length - (breakPoint - 1); i < l; i++) {\r\n          out += '../';\r\n        }\r\n        for (i = breakPoint - 1, l = items.length; i < l; i++) {\r\n          if (i !== breakPoint - 1) {\r\n            out += '/' + items[i];\r\n          } else {\r\n            out += items[i];\r\n          }\r\n        }\r\n        return out;\r\n      }\r\n      toAbsPath(base, path) {\r\n        let nb = 0;\r\n        const tr = /\\/$/.test(path) ? '/' : '';\r\n        const normalizedBase = base.split('/');\r\n        const normalizedPath = path.split('/');\r\n        const baseParts = [];\r\n        each$4(normalizedBase, k => {\r\n          if (k) {\r\n            baseParts.push(k);\r\n          }\r\n        });\r\n        const pathParts = [];\r\n        for (let i = normalizedPath.length - 1; i >= 0; i--) {\r\n          if (normalizedPath[i].length === 0 || normalizedPath[i] === '.') {\r\n            continue;\r\n          }\r\n          if (normalizedPath[i] === '..') {\r\n            nb++;\r\n            continue;\r\n          }\r\n          if (nb > 0) {\r\n            nb--;\r\n            continue;\r\n          }\r\n          pathParts.push(normalizedPath[i]);\r\n        }\r\n        const i = baseParts.length - nb;\r\n        let outPath;\r\n        if (i <= 0) {\r\n          outPath = reverse(pathParts).join('/');\r\n        } else {\r\n          outPath = baseParts.slice(0, i).join('/') + '/' + reverse(pathParts).join('/');\r\n        }\r\n        if (outPath.indexOf('/') !== 0) {\r\n          outPath = '/' + outPath;\r\n        }\r\n        if (tr && outPath.lastIndexOf('/') !== outPath.length - 1) {\r\n          outPath += tr;\r\n        }\r\n        return outPath;\r\n      }\r\n      getURI(noProtoHost = false) {\r\n        let s;\r\n        if (!this.source || noProtoHost) {\r\n          s = '';\r\n          if (!noProtoHost) {\r\n            if (this.protocol) {\r\n              s += this.protocol + '://';\r\n            } else {\r\n              s += '//';\r\n            }\r\n            if (this.userInfo) {\r\n              s += this.userInfo + '@';\r\n            }\r\n            if (this.host) {\r\n              s += this.host;\r\n            }\r\n            if (this.port) {\r\n              s += ':' + this.port;\r\n            }\r\n          }\r\n          if (this.path) {\r\n            s += this.path;\r\n          }\r\n          if (this.query) {\r\n            s += '?' + this.query;\r\n          }\r\n          if (this.anchor) {\r\n            s += '#' + this.anchor;\r\n          }\r\n          this.source = s;\r\n        }\r\n        return this.source;\r\n      }\r\n    }\r\n\r\n    const filteredUrlAttrs = Tools.makeMap('src,href,data,background,action,formaction,poster,xlink:href');\r\n    const internalElementAttr = 'data-mce-type';\r\n    let uid = 0;\r\n    const processNode = (node, settings, schema, scope, evt) => {\r\n      var _a, _b, _c, _d;\r\n      const validate = settings.validate;\r\n      const specialElements = schema.getSpecialElements();\r\n      if (node.nodeType === COMMENT && !settings.allow_conditional_comments && /^\\[if/i.test((_a = node.nodeValue) !== null && _a !== void 0 ? _a : '')) {\r\n        node.nodeValue = ' ' + node.nodeValue;\r\n      }\r\n      const lcTagName = (_b = evt === null || evt === void 0 ? void 0 : evt.tagName) !== null && _b !== void 0 ? _b : node.nodeName.toLowerCase();\r\n      if (scope !== 'html' && schema.isValid(scope)) {\r\n        if (isNonNullable(evt)) {\r\n          evt.allowedTags[lcTagName] = true;\r\n        }\r\n        return;\r\n      }\r\n      if (node.nodeType !== ELEMENT || lcTagName === 'body') {\r\n        return;\r\n      }\r\n      const element = SugarElement.fromDom(node);\r\n      const isInternalElement = has$1(element, internalElementAttr);\r\n      const bogus = get$9(element, 'data-mce-bogus');\r\n      if (!isInternalElement && isString(bogus)) {\r\n        if (bogus === 'all') {\r\n          remove$5(element);\r\n        } else {\r\n          unwrap(element);\r\n        }\r\n        return;\r\n      }\r\n      const rule = schema.getElementRule(lcTagName);\r\n      if (validate && !rule) {\r\n        if (has$2(specialElements, lcTagName)) {\r\n          remove$5(element);\r\n        } else {\r\n          unwrap(element);\r\n        }\r\n        return;\r\n      } else {\r\n        if (isNonNullable(evt)) {\r\n          evt.allowedTags[lcTagName] = true;\r\n        }\r\n      }\r\n      if (validate && rule && !isInternalElement) {\r\n        each$e((_c = rule.attributesForced) !== null && _c !== void 0 ? _c : [], attr => {\r\n          set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\r\n        });\r\n        each$e((_d = rule.attributesDefault) !== null && _d !== void 0 ? _d : [], attr => {\r\n          if (!has$1(element, attr.name)) {\r\n            set$3(element, attr.name, attr.value === '{$uid}' ? `mce_${ uid++ }` : attr.value);\r\n          }\r\n        });\r\n        if (rule.attributesRequired && !exists(rule.attributesRequired, attr => has$1(element, attr))) {\r\n          unwrap(element);\r\n          return;\r\n        }\r\n        if (rule.removeEmptyAttrs && hasNone(element)) {\r\n          unwrap(element);\r\n          return;\r\n        }\r\n        if (rule.outputName && rule.outputName !== lcTagName) {\r\n          mutate(element, rule.outputName);\r\n        }\r\n      }\r\n    };\r\n    const processAttr = (ele, settings, schema, scope, evt) => {\r\n      const tagName = ele.tagName.toLowerCase();\r\n      const {attrName, attrValue} = evt;\r\n      evt.keepAttr = shouldKeepAttribute(settings, schema, scope, tagName, attrName, attrValue);\r\n      if (evt.keepAttr) {\r\n        evt.allowedAttributes[attrName] = true;\r\n        if (isBooleanAttribute(attrName, schema)) {\r\n          evt.attrValue = attrName;\r\n        }\r\n        if (settings.allow_svg_data_urls && startsWith(attrValue, 'data:image/svg+xml')) {\r\n          evt.forceKeepAttr = true;\r\n        }\r\n      } else if (isRequiredAttributeOfInternalElement(ele, attrName)) {\r\n        evt.forceKeepAttr = true;\r\n      }\r\n    };\r\n    const shouldKeepAttribute = (settings, schema, scope, tagName, attrName, attrValue) => {\r\n      if (scope !== 'html' && !isNonHtmlElementRootName(tagName)) {\r\n        return true;\r\n      }\r\n      return !(attrName in filteredUrlAttrs && isInvalidUri(settings, attrValue, tagName)) && (!settings.validate || schema.isValid(tagName, attrName) || startsWith(attrName, 'data-') || startsWith(attrName, 'aria-'));\r\n    };\r\n    const isRequiredAttributeOfInternalElement = (ele, attrName) => ele.hasAttribute(internalElementAttr) && (attrName === 'id' || attrName === 'class' || attrName === 'style');\r\n    const isBooleanAttribute = (attrName, schema) => attrName in schema.getBoolAttrs();\r\n    const filterAttributes = (ele, settings, schema, scope) => {\r\n      const {attributes} = ele;\r\n      for (let i = attributes.length - 1; i >= 0; i--) {\r\n        const attr = attributes[i];\r\n        const attrName = attr.name;\r\n        const attrValue = attr.value;\r\n        if (!shouldKeepAttribute(settings, schema, scope, ele.tagName.toLowerCase(), attrName, attrValue) && !isRequiredAttributeOfInternalElement(ele, attrName)) {\r\n          ele.removeAttribute(attrName);\r\n        } else if (isBooleanAttribute(attrName, schema)) {\r\n          ele.setAttribute(attrName, attrName);\r\n        }\r\n      }\r\n    };\r\n    const setupPurify = (settings, schema, namespaceTracker) => {\r\n      const purify$1 = purify();\r\n      purify$1.addHook('uponSanitizeElement', (ele, evt) => {\r\n        processNode(ele, settings, schema, namespaceTracker.track(ele), evt);\r\n      });\r\n      purify$1.addHook('uponSanitizeAttribute', (ele, evt) => {\r\n        processAttr(ele, settings, schema, namespaceTracker.current(), evt);\r\n      });\r\n      return purify$1;\r\n    };\r\n    const getPurifyConfig = (settings, mimeType) => {\r\n      const basePurifyConfig = {\r\n        IN_PLACE: true,\r\n        ALLOW_UNKNOWN_PROTOCOLS: true,\r\n        ALLOWED_TAGS: [\r\n          '#comment',\r\n          '#cdata-section',\r\n          'body'\r\n        ],\r\n        ALLOWED_ATTR: []\r\n      };\r\n      const config = { ...basePurifyConfig };\r\n      config.PARSER_MEDIA_TYPE = mimeType;\r\n      if (settings.allow_script_urls) {\r\n        config.ALLOWED_URI_REGEXP = /.*/;\r\n      } else if (settings.allow_html_data_urls) {\r\n        config.ALLOWED_URI_REGEXP = /^(?!(\\w+script|mhtml):)/i;\r\n      }\r\n      return config;\r\n    };\r\n    const sanitizeNamespaceElement = ele => {\r\n      const xlinkAttrs = [\r\n        'type',\r\n        'href',\r\n        'role',\r\n        'arcrole',\r\n        'title',\r\n        'show',\r\n        'actuate',\r\n        'label',\r\n        'from',\r\n        'to'\r\n      ].map(name => `xlink:${ name }`);\r\n      const config = {\r\n        IN_PLACE: true,\r\n        USE_PROFILES: {\r\n          html: true,\r\n          svg: true,\r\n          svgFilters: true\r\n        },\r\n        ALLOWED_ATTR: xlinkAttrs\r\n      };\r\n      purify().sanitize(ele, config);\r\n      return ele.innerHTML;\r\n    };\r\n    const getSanitizer = (settings, schema) => {\r\n      const namespaceTracker = createNamespaceTracker();\r\n      if (settings.sanitize) {\r\n        const purify = setupPurify(settings, schema, namespaceTracker);\r\n        const sanitizeHtmlElement = (body, mimeType) => {\r\n          purify.sanitize(body, getPurifyConfig(settings, mimeType));\r\n          purify.removed = [];\r\n          namespaceTracker.reset();\r\n        };\r\n        return {\r\n          sanitizeHtmlElement,\r\n          sanitizeNamespaceElement\r\n        };\r\n      } else {\r\n        const sanitizeHtmlElement = (body, _mimeType) => {\r\n          const nodeIterator = document.createNodeIterator(body, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);\r\n          let node;\r\n          while (node = nodeIterator.nextNode()) {\r\n            const currentScope = namespaceTracker.track(node);\r\n            processNode(node, settings, schema, currentScope);\r\n            if (isElement$6(node)) {\r\n              filterAttributes(node, settings, schema, currentScope);\r\n            }\r\n          }\r\n          namespaceTracker.reset();\r\n        };\r\n        const sanitizeNamespaceElement = noop;\r\n        return {\r\n          sanitizeHtmlElement,\r\n          sanitizeNamespaceElement\r\n        };\r\n      }\r\n    };\r\n\r\n    const makeMap = Tools.makeMap, extend$1 = Tools.extend;\r\n    const transferChildren = (parent, nativeParent, specialElements, nsSanitizer) => {\r\n      const parentName = parent.name;\r\n      const isSpecial = parentName in specialElements && parentName !== 'title' && parentName !== 'textarea';\r\n      const childNodes = nativeParent.childNodes;\r\n      for (let ni = 0, nl = childNodes.length; ni < nl; ni++) {\r\n        const nativeChild = childNodes[ni];\r\n        const child = new AstNode(nativeChild.nodeName.toLowerCase(), nativeChild.nodeType);\r\n        if (isElement$6(nativeChild)) {\r\n          const attributes = nativeChild.attributes;\r\n          for (let ai = 0, al = attributes.length; ai < al; ai++) {\r\n            const attr = attributes[ai];\r\n            child.attr(attr.name, attr.value);\r\n          }\r\n          if (isNonHtmlElementRootName(child.name)) {\r\n            nsSanitizer(nativeChild);\r\n            child.value = nativeChild.innerHTML;\r\n          }\r\n        } else if (isText$a(nativeChild)) {\r\n          child.value = nativeChild.data;\r\n          if (isSpecial) {\r\n            child.raw = true;\r\n          }\r\n        } else if (isComment(nativeChild) || isCData(nativeChild) || isPi(nativeChild)) {\r\n          child.value = nativeChild.data;\r\n        }\r\n        if (!isNonHtmlElementRootName(child.name)) {\r\n          transferChildren(child, nativeChild, specialElements, nsSanitizer);\r\n        }\r\n        parent.append(child);\r\n      }\r\n    };\r\n    const walkTree = (root, preprocessors, postprocessors) => {\r\n      const traverseOrder = [];\r\n      for (let node = root, lastNode = node; node; lastNode = node, node = node.walk()) {\r\n        const tempNode = node;\r\n        each$e(preprocessors, preprocess => preprocess(tempNode));\r\n        if (isNullable(tempNode.parent) && tempNode !== root) {\r\n          node = lastNode;\r\n        } else {\r\n          traverseOrder.push(tempNode);\r\n        }\r\n      }\r\n      for (let i = traverseOrder.length - 1; i >= 0; i--) {\r\n        const node = traverseOrder[i];\r\n        each$e(postprocessors, postprocess => postprocess(node));\r\n      }\r\n    };\r\n    const whitespaceCleaner = (root, schema, settings, args) => {\r\n      const validate = settings.validate;\r\n      const nonEmptyElements = schema.getNonEmptyElements();\r\n      const whitespaceElements = schema.getWhitespaceElements();\r\n      const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\r\n      const textRootBlockElements = getTextRootBlockElements(schema);\r\n      const allWhiteSpaceRegExp = /[ \\t\\r\\n]+/g;\r\n      const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\r\n      const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\r\n      const hasWhitespaceParent = node => {\r\n        let tempNode = node.parent;\r\n        while (isNonNullable(tempNode)) {\r\n          if (tempNode.name in whitespaceElements) {\r\n            return true;\r\n          } else {\r\n            tempNode = tempNode.parent;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      const isTextRootBlockEmpty = node => {\r\n        let tempNode = node;\r\n        while (isNonNullable(tempNode)) {\r\n          if (tempNode.name in textRootBlockElements) {\r\n            return isEmpty(schema, nonEmptyElements, whitespaceElements, tempNode);\r\n          } else {\r\n            tempNode = tempNode.parent;\r\n          }\r\n        }\r\n        return false;\r\n      };\r\n      const isBlock = node => node.name in blockElements || isTransparentAstBlock(schema, node) || isNonHtmlElementRootName(node.name) && node.parent === root;\r\n      const isAtEdgeOfBlock = (node, start) => {\r\n        const neighbour = start ? node.prev : node.next;\r\n        if (isNonNullable(neighbour) || isNullable(node.parent)) {\r\n          return false;\r\n        }\r\n        return isBlock(node.parent) && (node.parent !== root || args.isRootContent === true);\r\n      };\r\n      const preprocess = node => {\r\n        var _a;\r\n        if (node.type === 3) {\r\n          if (!hasWhitespaceParent(node)) {\r\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\r\n            text = text.replace(allWhiteSpaceRegExp, ' ');\r\n            if (isLineBreakNode(node.prev, isBlock) || isAtEdgeOfBlock(node, true)) {\r\n              text = text.replace(startWhiteSpaceRegExp, '');\r\n            }\r\n            if (text.length === 0) {\r\n              node.remove();\r\n            } else {\r\n              node.value = text;\r\n            }\r\n          }\r\n        }\r\n      };\r\n      const postprocess = node => {\r\n        var _a;\r\n        if (node.type === 1) {\r\n          const elementRule = schema.getElementRule(node.name);\r\n          if (validate && elementRule) {\r\n            const isNodeEmpty = isEmpty(schema, nonEmptyElements, whitespaceElements, node);\r\n            if (elementRule.paddInEmptyBlock && isNodeEmpty && isTextRootBlockEmpty(node)) {\r\n              paddEmptyNode(settings, args, isBlock, node);\r\n            } else if (elementRule.removeEmpty && isNodeEmpty) {\r\n              if (isBlock(node)) {\r\n                node.remove();\r\n              } else {\r\n                node.unwrap();\r\n              }\r\n            } else if (elementRule.paddEmpty && (isNodeEmpty || isPaddedWithNbsp(node))) {\r\n              paddEmptyNode(settings, args, isBlock, node);\r\n            }\r\n          }\r\n        } else if (node.type === 3) {\r\n          if (!hasWhitespaceParent(node)) {\r\n            let text = (_a = node.value) !== null && _a !== void 0 ? _a : '';\r\n            if (node.next && isBlock(node.next) || isAtEdgeOfBlock(node, false)) {\r\n              text = text.replace(endWhiteSpaceRegExp, '');\r\n            }\r\n            if (text.length === 0) {\r\n              node.remove();\r\n            } else {\r\n              node.value = text;\r\n            }\r\n          }\r\n        }\r\n      };\r\n      return [\r\n        preprocess,\r\n        postprocess\r\n      ];\r\n    };\r\n    const getRootBlockName = (settings, args) => {\r\n      var _a;\r\n      const name = (_a = args.forced_root_block) !== null && _a !== void 0 ? _a : settings.forced_root_block;\r\n      if (name === false) {\r\n        return '';\r\n      } else if (name === true) {\r\n        return 'p';\r\n      } else {\r\n        return name;\r\n      }\r\n    };\r\n    const DomParser = (settings = {}, schema = Schema()) => {\r\n      const nodeFilterRegistry = create$8();\r\n      const attributeFilterRegistry = create$8();\r\n      const defaultedSettings = {\r\n        validate: true,\r\n        root_name: 'body',\r\n        sanitize: true,\r\n        ...settings\r\n      };\r\n      const parser = new DOMParser();\r\n      const sanitizer = getSanitizer(defaultedSettings, schema);\r\n      const parseAndSanitizeWithContext = (html, rootName, format = 'html') => {\r\n        const mimeType = format === 'xhtml' ? 'application/xhtml+xml' : 'text/html';\r\n        const isSpecialRoot = has$2(schema.getSpecialElements(), rootName.toLowerCase());\r\n        const content = isSpecialRoot ? `<${ rootName }>${ html }</${ rootName }>` : html;\r\n        const wrappedHtml = format === 'xhtml' ? `<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>${ content }</body></html>` : `<body>${ content }</body>`;\r\n        const body = parser.parseFromString(wrappedHtml, mimeType).body;\r\n        sanitizer.sanitizeHtmlElement(body, mimeType);\r\n        return isSpecialRoot ? body.firstChild : body;\r\n      };\r\n      const addNodeFilter = nodeFilterRegistry.addFilter;\r\n      const getNodeFilters = nodeFilterRegistry.getFilters;\r\n      const removeNodeFilter = nodeFilterRegistry.removeFilter;\r\n      const addAttributeFilter = attributeFilterRegistry.addFilter;\r\n      const getAttributeFilters = attributeFilterRegistry.getFilters;\r\n      const removeAttributeFilter = attributeFilterRegistry.removeFilter;\r\n      const findInvalidChildren = (node, invalidChildren) => {\r\n        if (isInvalid(schema, node)) {\r\n          invalidChildren.push(node);\r\n        }\r\n      };\r\n      const isWrappableNode = (blockElements, node) => {\r\n        const isInternalElement = isString(node.attr(internalElementAttr));\r\n        const isInlineElement = node.type === 1 && (!has$2(blockElements, node.name) && !isTransparentAstBlock(schema, node)) && !isNonHtmlElementRootName(node.name);\r\n        return node.type === 3 || isInlineElement && !isInternalElement;\r\n      };\r\n      const addRootBlocks = (rootNode, rootBlockName) => {\r\n        const blockElements = extend$1(makeMap('script,style,head,html,body,title,meta,param'), schema.getBlockElements());\r\n        const startWhiteSpaceRegExp = /^[ \\t\\r\\n]+/;\r\n        const endWhiteSpaceRegExp = /[ \\t\\r\\n]+$/;\r\n        let node = rootNode.firstChild, rootBlockNode = null;\r\n        const trim = rootBlock => {\r\n          var _a, _b;\r\n          if (rootBlock) {\r\n            node = rootBlock.firstChild;\r\n            if (node && node.type === 3) {\r\n              node.value = (_a = node.value) === null || _a === void 0 ? void 0 : _a.replace(startWhiteSpaceRegExp, '');\r\n            }\r\n            node = rootBlock.lastChild;\r\n            if (node && node.type === 3) {\r\n              node.value = (_b = node.value) === null || _b === void 0 ? void 0 : _b.replace(endWhiteSpaceRegExp, '');\r\n            }\r\n          }\r\n        };\r\n        if (!schema.isValidChild(rootNode.name, rootBlockName.toLowerCase())) {\r\n          return;\r\n        }\r\n        while (node) {\r\n          const next = node.next;\r\n          if (isWrappableNode(blockElements, node)) {\r\n            if (!rootBlockNode) {\r\n              rootBlockNode = new AstNode(rootBlockName, 1);\r\n              rootBlockNode.attr(defaultedSettings.forced_root_block_attrs);\r\n              rootNode.insert(rootBlockNode, node);\r\n              rootBlockNode.append(node);\r\n            } else {\r\n              rootBlockNode.append(node);\r\n            }\r\n          } else {\r\n            trim(rootBlockNode);\r\n            rootBlockNode = null;\r\n          }\r\n          node = next;\r\n        }\r\n        trim(rootBlockNode);\r\n      };\r\n      const parse = (html, args = {}) => {\r\n        var _a;\r\n        const validate = defaultedSettings.validate;\r\n        const rootName = (_a = args.context) !== null && _a !== void 0 ? _a : defaultedSettings.root_name;\r\n        const element = parseAndSanitizeWithContext(html, rootName, args.format);\r\n        updateChildren(schema, element);\r\n        const rootNode = new AstNode(rootName, 11);\r\n        transferChildren(rootNode, element, schema.getSpecialElements(), sanitizer.sanitizeNamespaceElement);\r\n        element.innerHTML = '';\r\n        const [whitespacePre, whitespacePost] = whitespaceCleaner(rootNode, schema, defaultedSettings, args);\r\n        const invalidChildren = [];\r\n        const invalidFinder = validate ? node => findInvalidChildren(node, invalidChildren) : noop;\r\n        const matches = {\r\n          nodes: {},\r\n          attributes: {}\r\n        };\r\n        const matchFinder = node => matchNode$1(getNodeFilters(), getAttributeFilters(), node, matches);\r\n        walkTree(rootNode, [\r\n          whitespacePre,\r\n          matchFinder\r\n        ], [\r\n          whitespacePost,\r\n          invalidFinder\r\n        ]);\r\n        invalidChildren.reverse();\r\n        if (validate && invalidChildren.length > 0) {\r\n          if (args.context) {\r\n            const {\r\n              pass: topLevelChildren,\r\n              fail: otherChildren\r\n            } = partition$2(invalidChildren, child => child.parent === rootNode);\r\n            cleanInvalidNodes(otherChildren, schema, rootNode, matchFinder);\r\n            args.invalid = topLevelChildren.length > 0;\r\n          } else {\r\n            cleanInvalidNodes(invalidChildren, schema, rootNode, matchFinder);\r\n          }\r\n        }\r\n        const rootBlockName = getRootBlockName(defaultedSettings, args);\r\n        if (rootBlockName && (rootNode.name === 'body' || args.isRootContent)) {\r\n          addRootBlocks(rootNode, rootBlockName);\r\n        }\r\n        if (!args.invalid) {\r\n          runFilters(matches, args);\r\n        }\r\n        return rootNode;\r\n      };\r\n      const exports = {\r\n        schema,\r\n        addAttributeFilter,\r\n        getAttributeFilters,\r\n        removeAttributeFilter,\r\n        addNodeFilter,\r\n        getNodeFilters,\r\n        removeNodeFilter,\r\n        parse\r\n      };\r\n      register$4(exports, defaultedSettings);\r\n      register$5(exports, defaultedSettings, schema);\r\n      return exports;\r\n    };\r\n\r\n    const serializeContent = content => isTreeNode(content) ? HtmlSerializer({ validate: false }).serialize(content) : content;\r\n    const withSerializedContent = (content, fireEvent, parserSettings) => {\r\n      const serializedContent = serializeContent(content);\r\n      const eventArgs = fireEvent(serializedContent);\r\n      if (eventArgs.isDefaultPrevented()) {\r\n        return eventArgs;\r\n      } else if (isTreeNode(content)) {\r\n        if (eventArgs.content !== serializedContent) {\r\n          const rootNode = DomParser({\r\n            validate: false,\r\n            forced_root_block: false,\r\n            ...parserSettings\r\n          }).parse(eventArgs.content, { context: content.name });\r\n          return {\r\n            ...eventArgs,\r\n            content: rootNode\r\n          };\r\n        } else {\r\n          return {\r\n            ...eventArgs,\r\n            content\r\n          };\r\n        }\r\n      } else {\r\n        return eventArgs;\r\n      }\r\n    };\r\n    const preProcessGetContent = (editor, args) => {\r\n      if (args.no_events) {\r\n        return Result.value(args);\r\n      } else {\r\n        const eventArgs = fireBeforeGetContent(editor, args);\r\n        if (eventArgs.isDefaultPrevented()) {\r\n          return Result.error(fireGetContent(editor, {\r\n            content: '',\r\n            ...eventArgs\r\n          }).content);\r\n        } else {\r\n          return Result.value(eventArgs);\r\n        }\r\n      }\r\n    };\r\n    const postProcessGetContent = (editor, content, args) => {\r\n      if (args.no_events) {\r\n        return content;\r\n      } else {\r\n        const processedEventArgs = withSerializedContent(content, content => fireGetContent(editor, {\r\n          ...args,\r\n          content\r\n        }), {\r\n          sanitize: shouldSanitizeXss(editor),\r\n          sandbox_iframes: shouldSandboxIframes(editor)\r\n        });\r\n        return processedEventArgs.content;\r\n      }\r\n    };\r\n    const preProcessSetContent = (editor, args) => {\r\n      if (args.no_events) {\r\n        return Result.value(args);\r\n      } else {\r\n        const processedEventArgs = withSerializedContent(args.content, content => fireBeforeSetContent(editor, {\r\n          ...args,\r\n          content\r\n        }), {\r\n          sanitize: shouldSanitizeXss(editor),\r\n          sandbox_iframes: shouldSandboxIframes(editor)\r\n        });\r\n        if (processedEventArgs.isDefaultPrevented()) {\r\n          fireSetContent(editor, processedEventArgs);\r\n          return Result.error(undefined);\r\n        } else {\r\n          return Result.value(processedEventArgs);\r\n        }\r\n      }\r\n    };\r\n    const postProcessSetContent = (editor, content, args) => {\r\n      if (!args.no_events) {\r\n        fireSetContent(editor, {\r\n          ...args,\r\n          content\r\n        });\r\n      }\r\n    };\r\n\r\n    const tableModel = (element, width, rows) => ({\r\n      element,\r\n      width,\r\n      rows\r\n    });\r\n    const tableRow = (element, cells) => ({\r\n      element,\r\n      cells\r\n    });\r\n    const cellPosition = (x, y) => ({\r\n      x,\r\n      y\r\n    });\r\n    const getSpan = (td, key) => {\r\n      return getOpt(td, key).bind(toInt).getOr(1);\r\n    };\r\n    const fillout = (table, x, y, tr, td) => {\r\n      const rowspan = getSpan(td, 'rowspan');\r\n      const colspan = getSpan(td, 'colspan');\r\n      const rows = table.rows;\r\n      for (let y2 = y; y2 < y + rowspan; y2++) {\r\n        if (!rows[y2]) {\r\n          rows[y2] = tableRow(deep$1(tr), []);\r\n        }\r\n        for (let x2 = x; x2 < x + colspan; x2++) {\r\n          const cells = rows[y2].cells;\r\n          cells[x2] = y2 === y && x2 === x ? td : shallow$1(td);\r\n        }\r\n      }\r\n    };\r\n    const cellExists = (table, x, y) => {\r\n      const rows = table.rows;\r\n      const cells = rows[y] ? rows[y].cells : [];\r\n      return !!cells[x];\r\n    };\r\n    const skipCellsX = (table, x, y) => {\r\n      while (cellExists(table, x, y)) {\r\n        x++;\r\n      }\r\n      return x;\r\n    };\r\n    const getWidth = rows => {\r\n      return foldl(rows, (acc, row) => {\r\n        return row.cells.length > acc ? row.cells.length : acc;\r\n      }, 0);\r\n    };\r\n    const findElementPos = (table, element) => {\r\n      const rows = table.rows;\r\n      for (let y = 0; y < rows.length; y++) {\r\n        const cells = rows[y].cells;\r\n        for (let x = 0; x < cells.length; x++) {\r\n          if (eq(cells[x], element)) {\r\n            return Optional.some(cellPosition(x, y));\r\n          }\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const extractRows = (table, sx, sy, ex, ey) => {\r\n      const newRows = [];\r\n      const rows = table.rows;\r\n      for (let y = sy; y <= ey; y++) {\r\n        const cells = rows[y].cells;\r\n        const slice = sx < ex ? cells.slice(sx, ex + 1) : cells.slice(ex, sx + 1);\r\n        newRows.push(tableRow(rows[y].element, slice));\r\n      }\r\n      return newRows;\r\n    };\r\n    const subTable = (table, startPos, endPos) => {\r\n      const sx = startPos.x, sy = startPos.y;\r\n      const ex = endPos.x, ey = endPos.y;\r\n      const newRows = sy < ey ? extractRows(table, sx, sy, ex, ey) : extractRows(table, sx, ey, ex, sy);\r\n      return tableModel(table.element, getWidth(newRows), newRows);\r\n    };\r\n    const createDomTable = (table, rows) => {\r\n      const tableElement = shallow$1(table.element);\r\n      const tableBody = SugarElement.fromTag('tbody');\r\n      append(tableBody, rows);\r\n      append$1(tableElement, tableBody);\r\n      return tableElement;\r\n    };\r\n    const modelRowsToDomRows = table => {\r\n      return map$3(table.rows, row => {\r\n        const cells = map$3(row.cells, cell => {\r\n          const td = deep$1(cell);\r\n          remove$a(td, 'colspan');\r\n          remove$a(td, 'rowspan');\r\n          return td;\r\n        });\r\n        const tr = shallow$1(row.element);\r\n        append(tr, cells);\r\n        return tr;\r\n      });\r\n    };\r\n    const fromDom = tableElm => {\r\n      const table = tableModel(shallow$1(tableElm), 0, []);\r\n      each$e(descendants(tableElm, 'tr'), (tr, y) => {\r\n        each$e(descendants(tr, 'td,th'), (td, x) => {\r\n          fillout(table, skipCellsX(table, x, y), y, tr, td);\r\n        });\r\n      });\r\n      return tableModel(table.element, getWidth(table.rows), table.rows);\r\n    };\r\n    const toDom = table => {\r\n      return createDomTable(table, modelRowsToDomRows(table));\r\n    };\r\n    const subsection = (table, startElement, endElement) => {\r\n      return findElementPos(table, startElement).bind(startPos => {\r\n        return findElementPos(table, endElement).map(endPos => {\r\n          return subTable(table, startPos, endPos);\r\n        });\r\n      });\r\n    };\r\n\r\n    const findParentListContainer = parents => find$2(parents, elm => name(elm) === 'ul' || name(elm) === 'ol');\r\n    const getFullySelectedListWrappers = (parents, rng) => find$2(parents, elm => name(elm) === 'li' && hasAllContentsSelected(elm, rng)).fold(constant([]), _li => findParentListContainer(parents).map(listCont => {\r\n      const listElm = SugarElement.fromTag(name(listCont));\r\n      const listStyles = filter$4(getAllRaw(listCont), (_style, name) => startsWith(name, 'list-style'));\r\n      setAll(listElm, listStyles);\r\n      return [\r\n        SugarElement.fromTag('li'),\r\n        listElm\r\n      ];\r\n    }).getOr([]));\r\n    const wrap = (innerElm, elms) => {\r\n      const wrapped = foldl(elms, (acc, elm) => {\r\n        append$1(elm, acc);\r\n        return elm;\r\n      }, innerElm);\r\n      return elms.length > 0 ? fromElements([wrapped]) : wrapped;\r\n    };\r\n    const directListWrappers = commonAnchorContainer => {\r\n      if (isListItem$1(commonAnchorContainer)) {\r\n        return parent(commonAnchorContainer).filter(isList).fold(constant([]), listElm => [\r\n          commonAnchorContainer,\r\n          listElm\r\n        ]);\r\n      } else {\r\n        return isList(commonAnchorContainer) ? [commonAnchorContainer] : [];\r\n      }\r\n    };\r\n    const getWrapElements = (rootNode, rng, schema) => {\r\n      const commonAnchorContainer = SugarElement.fromDom(rng.commonAncestorContainer);\r\n      const parents = parentsAndSelf(commonAnchorContainer, rootNode);\r\n      const wrapElements = filter$5(parents, el => schema.isWrapper(name(el)));\r\n      const listWrappers = getFullySelectedListWrappers(parents, rng);\r\n      const allWrappers = wrapElements.concat(listWrappers.length ? listWrappers : directListWrappers(commonAnchorContainer));\r\n      return map$3(allWrappers, shallow$1);\r\n    };\r\n    const emptyFragment = () => fromElements([]);\r\n    const getFragmentFromRange = (rootNode, rng, schema) => wrap(SugarElement.fromDom(rng.cloneContents()), getWrapElements(rootNode, rng, schema));\r\n    const getParentTable = (rootElm, cell) => ancestor$3(cell, 'table', curry(eq, rootElm));\r\n    const getTableFragment = (rootNode, selectedTableCells) => getParentTable(rootNode, selectedTableCells[0]).bind(tableElm => {\r\n      const firstCell = selectedTableCells[0];\r\n      const lastCell = selectedTableCells[selectedTableCells.length - 1];\r\n      const fullTableModel = fromDom(tableElm);\r\n      return subsection(fullTableModel, firstCell, lastCell).map(sectionedTableModel => fromElements([toDom(sectionedTableModel)]));\r\n    }).getOrThunk(emptyFragment);\r\n    const getSelectionFragment = (rootNode, ranges, schema) => ranges.length > 0 && ranges[0].collapsed ? emptyFragment() : getFragmentFromRange(rootNode, ranges[0], schema);\r\n    const read$3 = (rootNode, ranges, schema) => {\r\n      const selectedCells = getCellsFromElementOrRanges(ranges, rootNode);\r\n      return selectedCells.length > 0 ? getTableFragment(rootNode, selectedCells) : getSelectionFragment(rootNode, ranges, schema);\r\n    };\r\n\r\n    const isCollapsibleWhitespace = (text, index) => index >= 0 && index < text.length && isWhiteSpace(text.charAt(index));\r\n    const getInnerText = bin => {\r\n      return trim$2(bin.innerText);\r\n    };\r\n    const getContextNodeName = parentBlockOpt => parentBlockOpt.map(block => block.nodeName).getOr('div').toLowerCase();\r\n    const getTextContent = editor => Optional.from(editor.selection.getRng()).map(rng => {\r\n      var _a;\r\n      const parentBlockOpt = Optional.from(editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock));\r\n      const body = editor.getBody();\r\n      const contextNodeName = getContextNodeName(parentBlockOpt);\r\n      const rangeContentClone = SugarElement.fromDom(rng.cloneContents());\r\n      cleanupBogusElements(rangeContentClone);\r\n      cleanupInputNames(rangeContentClone);\r\n      const bin = editor.dom.add(body, contextNodeName, {\r\n        'data-mce-bogus': 'all',\r\n        'style': 'overflow: hidden; opacity: 0;'\r\n      }, rangeContentClone.dom);\r\n      const text = getInnerText(bin);\r\n      const nonRenderedText = trim$2((_a = bin.textContent) !== null && _a !== void 0 ? _a : '');\r\n      editor.dom.remove(bin);\r\n      if (isCollapsibleWhitespace(nonRenderedText, 0) || isCollapsibleWhitespace(nonRenderedText, nonRenderedText.length - 1)) {\r\n        const parentBlock = parentBlockOpt.getOr(body);\r\n        const parentBlockText = getInnerText(parentBlock);\r\n        const textIndex = parentBlockText.indexOf(text);\r\n        if (textIndex === -1) {\r\n          return text;\r\n        } else {\r\n          const hasProceedingSpace = isCollapsibleWhitespace(parentBlockText, textIndex - 1);\r\n          const hasTrailingSpace = isCollapsibleWhitespace(parentBlockText, textIndex + text.length);\r\n          return (hasProceedingSpace ? ' ' : '') + text + (hasTrailingSpace ? ' ' : '');\r\n        }\r\n      } else {\r\n        return text;\r\n      }\r\n    }).getOr('');\r\n    const getSerializedContent = (editor, args) => {\r\n      const rng = editor.selection.getRng(), tmpElm = editor.dom.create('body');\r\n      const sel = editor.selection.getSel();\r\n      const ranges = processRanges(editor, getRanges$1(sel));\r\n      const fragment = args.contextual ? read$3(SugarElement.fromDom(editor.getBody()), ranges, editor.schema).dom : rng.cloneContents();\r\n      if (fragment) {\r\n        tmpElm.appendChild(fragment);\r\n      }\r\n      return editor.selection.serializer.serialize(tmpElm, args);\r\n    };\r\n    const extractSelectedContent = (editor, args) => {\r\n      if (args.format === 'text') {\r\n        return getTextContent(editor);\r\n      } else {\r\n        const content = getSerializedContent(editor, args);\r\n        if (args.format === 'tree') {\r\n          return content;\r\n        } else {\r\n          return editor.selection.isCollapsed() ? '' : content;\r\n        }\r\n      }\r\n    };\r\n    const setupArgs$3 = (args, format) => ({\r\n      ...args,\r\n      format,\r\n      get: true,\r\n      selection: true,\r\n      getInner: true\r\n    });\r\n    const getSelectedContentInternal = (editor, format, args = {}) => {\r\n      const defaultedArgs = setupArgs$3(args, format);\r\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\r\n        const content = extractSelectedContent(editor, updatedArgs);\r\n        return postProcessGetContent(editor, content, updatedArgs);\r\n      });\r\n    };\r\n\r\n    const KEEP = 0, INSERT = 1, DELETE = 2;\r\n    const diff = (left, right) => {\r\n      const size = left.length + right.length + 2;\r\n      const vDown = new Array(size);\r\n      const vUp = new Array(size);\r\n      const snake = (start, end, diag) => {\r\n        return {\r\n          start,\r\n          end,\r\n          diag\r\n        };\r\n      };\r\n      const buildScript = (start1, end1, start2, end2, script) => {\r\n        const middle = getMiddleSnake(start1, end1, start2, end2);\r\n        if (middle === null || middle.start === end1 && middle.diag === end1 - end2 || middle.end === start1 && middle.diag === start1 - start2) {\r\n          let i = start1;\r\n          let j = start2;\r\n          while (i < end1 || j < end2) {\r\n            if (i < end1 && j < end2 && left[i] === right[j]) {\r\n              script.push([\r\n                KEEP,\r\n                left[i]\r\n              ]);\r\n              ++i;\r\n              ++j;\r\n            } else {\r\n              if (end1 - start1 > end2 - start2) {\r\n                script.push([\r\n                  DELETE,\r\n                  left[i]\r\n                ]);\r\n                ++i;\r\n              } else {\r\n                script.push([\r\n                  INSERT,\r\n                  right[j]\r\n                ]);\r\n                ++j;\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          buildScript(start1, middle.start, start2, middle.start - middle.diag, script);\r\n          for (let i2 = middle.start; i2 < middle.end; ++i2) {\r\n            script.push([\r\n              KEEP,\r\n              left[i2]\r\n            ]);\r\n          }\r\n          buildScript(middle.end, end1, middle.end - middle.diag, end2, script);\r\n        }\r\n      };\r\n      const buildSnake = (start, diag, end1, end2) => {\r\n        let end = start;\r\n        while (end - diag < end2 && end < end1 && left[end] === right[end - diag]) {\r\n          ++end;\r\n        }\r\n        return snake(start, end, diag);\r\n      };\r\n      const getMiddleSnake = (start1, end1, start2, end2) => {\r\n        const m = end1 - start1;\r\n        const n = end2 - start2;\r\n        if (m === 0 || n === 0) {\r\n          return null;\r\n        }\r\n        const delta = m - n;\r\n        const sum = n + m;\r\n        const offset = (sum % 2 === 0 ? sum : sum + 1) / 2;\r\n        vDown[1 + offset] = start1;\r\n        vUp[1 + offset] = end1 + 1;\r\n        let d, k, i, x, y;\r\n        for (d = 0; d <= offset; ++d) {\r\n          for (k = -d; k <= d; k += 2) {\r\n            i = k + offset;\r\n            if (k === -d || k !== d && vDown[i - 1] < vDown[i + 1]) {\r\n              vDown[i] = vDown[i + 1];\r\n            } else {\r\n              vDown[i] = vDown[i - 1] + 1;\r\n            }\r\n            x = vDown[i];\r\n            y = x - start1 + start2 - k;\r\n            while (x < end1 && y < end2 && left[x] === right[y]) {\r\n              vDown[i] = ++x;\r\n              ++y;\r\n            }\r\n            if (delta % 2 !== 0 && delta - d <= k && k <= delta + d) {\r\n              if (vUp[i - delta] <= vDown[i]) {\r\n                return buildSnake(vUp[i - delta], k + start1 - start2, end1, end2);\r\n              }\r\n            }\r\n          }\r\n          for (k = delta - d; k <= delta + d; k += 2) {\r\n            i = k + offset - delta;\r\n            if (k === delta - d || k !== delta + d && vUp[i + 1] <= vUp[i - 1]) {\r\n              vUp[i] = vUp[i + 1] - 1;\r\n            } else {\r\n              vUp[i] = vUp[i - 1];\r\n            }\r\n            x = vUp[i] - 1;\r\n            y = x - start1 + start2 - k;\r\n            while (x >= start1 && y >= start2 && left[x] === right[y]) {\r\n              vUp[i] = x--;\r\n              y--;\r\n            }\r\n            if (delta % 2 === 0 && -d <= k && k <= d) {\r\n              if (vUp[i] <= vDown[i + delta]) {\r\n                return buildSnake(vUp[i], k + start1 - start2, end1, end2);\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return null;\r\n      };\r\n      const script = [];\r\n      buildScript(0, left.length, 0, right.length, script);\r\n      return script;\r\n    };\r\n\r\n    const getOuterHtml = elm => {\r\n      if (isElement$6(elm)) {\r\n        return elm.outerHTML;\r\n      } else if (isText$a(elm)) {\r\n        return Entities.encodeRaw(elm.data, false);\r\n      } else if (isComment(elm)) {\r\n        return '<!--' + elm.data + '-->';\r\n      }\r\n      return '';\r\n    };\r\n    const createFragment = html => {\r\n      let node;\r\n      const container = document.createElement('div');\r\n      const frag = document.createDocumentFragment();\r\n      if (html) {\r\n        container.innerHTML = html;\r\n      }\r\n      while (node = container.firstChild) {\r\n        frag.appendChild(node);\r\n      }\r\n      return frag;\r\n    };\r\n    const insertAt = (elm, html, index) => {\r\n      const fragment = createFragment(html);\r\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\r\n        const target = elm.childNodes[index];\r\n        elm.insertBefore(fragment, target);\r\n      } else {\r\n        elm.appendChild(fragment);\r\n      }\r\n    };\r\n    const removeAt = (elm, index) => {\r\n      if (elm.hasChildNodes() && index < elm.childNodes.length) {\r\n        const target = elm.childNodes[index];\r\n        elm.removeChild(target);\r\n      }\r\n    };\r\n    const applyDiff = (diff, elm) => {\r\n      let index = 0;\r\n      each$e(diff, action => {\r\n        if (action[0] === KEEP) {\r\n          index++;\r\n        } else if (action[0] === INSERT) {\r\n          insertAt(elm, action[1], index);\r\n          index++;\r\n        } else if (action[0] === DELETE) {\r\n          removeAt(elm, index);\r\n        }\r\n      });\r\n    };\r\n    const read$2 = (elm, trimZwsp) => filter$5(map$3(from(elm.childNodes), trimZwsp ? compose(trim$2, getOuterHtml) : getOuterHtml), item => {\r\n      return item.length > 0;\r\n    });\r\n    const write = (fragments, elm) => {\r\n      const currentFragments = map$3(from(elm.childNodes), getOuterHtml);\r\n      applyDiff(diff(currentFragments, fragments), elm);\r\n      return elm;\r\n    };\r\n\r\n    const lazyTempDocument = cached(() => document.implementation.createHTMLDocument('undo'));\r\n    const hasIframes = body => body.querySelector('iframe') !== null;\r\n    const createFragmentedLevel = fragments => {\r\n      return {\r\n        type: 'fragmented',\r\n        fragments,\r\n        content: '',\r\n        bookmark: null,\r\n        beforeBookmark: null\r\n      };\r\n    };\r\n    const createCompleteLevel = content => {\r\n      return {\r\n        type: 'complete',\r\n        fragments: null,\r\n        content,\r\n        bookmark: null,\r\n        beforeBookmark: null\r\n      };\r\n    };\r\n    const createFromEditor = editor => {\r\n      const tempAttrs = editor.serializer.getTempAttrs();\r\n      const body = trim$1(editor.getBody(), tempAttrs);\r\n      return hasIframes(body) ? createFragmentedLevel(read$2(body, true)) : createCompleteLevel(trim$2(body.innerHTML));\r\n    };\r\n    const applyToEditor = (editor, level, before) => {\r\n      const bookmark = before ? level.beforeBookmark : level.bookmark;\r\n      if (level.type === 'fragmented') {\r\n        write(level.fragments, editor.getBody());\r\n      } else {\r\n        editor.setContent(level.content, {\r\n          format: 'raw',\r\n          no_selection: isNonNullable(bookmark) && isPathBookmark(bookmark) ? !bookmark.isFakeCaret : true\r\n        });\r\n      }\r\n      if (bookmark) {\r\n        editor.selection.moveToBookmark(bookmark);\r\n        editor.selection.scrollIntoView();\r\n      }\r\n    };\r\n    const getLevelContent = level => {\r\n      return level.type === 'fragmented' ? level.fragments.join('') : level.content;\r\n    };\r\n    const getCleanLevelContent = level => {\r\n      const elm = SugarElement.fromTag('body', lazyTempDocument());\r\n      set$1(elm, getLevelContent(level));\r\n      each$e(descendants(elm, '*[data-mce-bogus]'), unwrap);\r\n      return get$6(elm);\r\n    };\r\n    const hasEqualContent = (level1, level2) => getLevelContent(level1) === getLevelContent(level2);\r\n    const hasEqualCleanedContent = (level1, level2) => getCleanLevelContent(level1) === getCleanLevelContent(level2);\r\n    const isEq$1 = (level1, level2) => {\r\n      if (!level1 || !level2) {\r\n        return false;\r\n      } else if (hasEqualContent(level1, level2)) {\r\n        return true;\r\n      } else {\r\n        return hasEqualCleanedContent(level1, level2);\r\n      }\r\n    };\r\n\r\n    const isUnlocked = locks => locks.get() === 0;\r\n\r\n    const setTyping = (undoManager, typing, locks) => {\r\n      if (isUnlocked(locks)) {\r\n        undoManager.typing = typing;\r\n      }\r\n    };\r\n    const endTyping = (undoManager, locks) => {\r\n      if (undoManager.typing) {\r\n        setTyping(undoManager, false, locks);\r\n        undoManager.add();\r\n      }\r\n    };\r\n    const endTypingLevelIgnoreLocks = undoManager => {\r\n      if (undoManager.typing) {\r\n        undoManager.typing = false;\r\n        undoManager.add();\r\n      }\r\n    };\r\n\r\n    const beforeChange$1 = (editor, locks, beforeBookmark) => {\r\n      if (isUnlocked(locks)) {\r\n        beforeBookmark.set(getUndoBookmark(editor.selection));\r\n      }\r\n    };\r\n    const addUndoLevel$1 = (editor, undoManager, index, locks, beforeBookmark, level, event) => {\r\n      const currentLevel = createFromEditor(editor);\r\n      const newLevel = Tools.extend(level || {}, currentLevel);\r\n      if (!isUnlocked(locks) || editor.removed) {\r\n        return null;\r\n      }\r\n      const lastLevel = undoManager.data[index.get()];\r\n      if (editor.dispatch('BeforeAddUndo', {\r\n          level: newLevel,\r\n          lastLevel,\r\n          originalEvent: event\r\n        }).isDefaultPrevented()) {\r\n        return null;\r\n      }\r\n      if (lastLevel && isEq$1(lastLevel, newLevel)) {\r\n        return null;\r\n      }\r\n      if (undoManager.data[index.get()]) {\r\n        beforeBookmark.get().each(bm => {\r\n          undoManager.data[index.get()].beforeBookmark = bm;\r\n        });\r\n      }\r\n      const customUndoRedoLevels = getCustomUndoRedoLevels(editor);\r\n      if (customUndoRedoLevels) {\r\n        if (undoManager.data.length > customUndoRedoLevels) {\r\n          for (let i = 0; i < undoManager.data.length - 1; i++) {\r\n            undoManager.data[i] = undoManager.data[i + 1];\r\n          }\r\n          undoManager.data.length--;\r\n          index.set(undoManager.data.length);\r\n        }\r\n      }\r\n      newLevel.bookmark = getUndoBookmark(editor.selection);\r\n      if (index.get() < undoManager.data.length - 1) {\r\n        undoManager.data.length = index.get() + 1;\r\n      }\r\n      undoManager.data.push(newLevel);\r\n      index.set(undoManager.data.length - 1);\r\n      const args = {\r\n        level: newLevel,\r\n        lastLevel,\r\n        originalEvent: event\r\n      };\r\n      if (index.get() > 0) {\r\n        editor.setDirty(true);\r\n        editor.dispatch('AddUndo', args);\r\n        editor.dispatch('change', args);\r\n      } else {\r\n        editor.dispatch('AddUndo', args);\r\n      }\r\n      return newLevel;\r\n    };\r\n    const clear$1 = (editor, undoManager, index) => {\r\n      undoManager.data = [];\r\n      index.set(0);\r\n      undoManager.typing = false;\r\n      editor.dispatch('ClearUndos');\r\n    };\r\n    const extra$1 = (editor, undoManager, index, callback1, callback2) => {\r\n      if (undoManager.transact(callback1)) {\r\n        const bookmark = undoManager.data[index.get()].bookmark;\r\n        const lastLevel = undoManager.data[index.get() - 1];\r\n        applyToEditor(editor, lastLevel, true);\r\n        if (undoManager.transact(callback2)) {\r\n          undoManager.data[index.get() - 1].beforeBookmark = bookmark;\r\n        }\r\n      }\r\n    };\r\n    const redo$1 = (editor, index, data) => {\r\n      let level;\r\n      if (index.get() < data.length - 1) {\r\n        index.set(index.get() + 1);\r\n        level = data[index.get()];\r\n        applyToEditor(editor, level, false);\r\n        editor.setDirty(true);\r\n        editor.dispatch('Redo', { level });\r\n      }\r\n      return level;\r\n    };\r\n    const undo$1 = (editor, undoManager, locks, index) => {\r\n      let level;\r\n      if (undoManager.typing) {\r\n        undoManager.add();\r\n        undoManager.typing = false;\r\n        setTyping(undoManager, false, locks);\r\n      }\r\n      if (index.get() > 0) {\r\n        index.set(index.get() - 1);\r\n        level = undoManager.data[index.get()];\r\n        applyToEditor(editor, level, true);\r\n        editor.setDirty(true);\r\n        editor.dispatch('Undo', { level });\r\n      }\r\n      return level;\r\n    };\r\n    const reset$1 = undoManager => {\r\n      undoManager.clear();\r\n      undoManager.add();\r\n    };\r\n    const hasUndo$1 = (editor, undoManager, index) => index.get() > 0 || undoManager.typing && undoManager.data[0] && !isEq$1(createFromEditor(editor), undoManager.data[0]);\r\n    const hasRedo$1 = (undoManager, index) => index.get() < undoManager.data.length - 1 && !undoManager.typing;\r\n    const transact$1 = (undoManager, locks, callback) => {\r\n      endTyping(undoManager, locks);\r\n      undoManager.beforeChange();\r\n      undoManager.ignore(callback);\r\n      return undoManager.add();\r\n    };\r\n    const ignore$1 = (locks, callback) => {\r\n      try {\r\n        locks.set(locks.get() + 1);\r\n        callback();\r\n      } finally {\r\n        locks.set(locks.get() - 1);\r\n      }\r\n    };\r\n\r\n    const addVisualInternal = (editor, elm) => {\r\n      const dom = editor.dom;\r\n      const scope = isNonNullable(elm) ? elm : editor.getBody();\r\n      each$e(dom.select('table,a', scope), matchedElm => {\r\n        switch (matchedElm.nodeName) {\r\n        case 'TABLE':\r\n          const cls = getVisualAidsTableClass(editor);\r\n          const value = dom.getAttrib(matchedElm, 'border');\r\n          if ((!value || value === '0') && editor.hasVisual) {\r\n            dom.addClass(matchedElm, cls);\r\n          } else {\r\n            dom.removeClass(matchedElm, cls);\r\n          }\r\n          break;\r\n        case 'A':\r\n          if (!dom.getAttrib(matchedElm, 'href')) {\r\n            const value = dom.getAttrib(matchedElm, 'name') || matchedElm.id;\r\n            const cls = getVisualAidsAnchorClass(editor);\r\n            if (value && editor.hasVisual) {\r\n              dom.addClass(matchedElm, cls);\r\n            } else {\r\n              dom.removeClass(matchedElm, cls);\r\n            }\r\n          }\r\n          break;\r\n        }\r\n      });\r\n      editor.dispatch('VisualAid', {\r\n        element: elm,\r\n        hasVisual: editor.hasVisual\r\n      });\r\n    };\r\n\r\n    const makePlainAdaptor = editor => ({\r\n      init: { bindEvents: noop },\r\n      undoManager: {\r\n        beforeChange: (locks, beforeBookmark) => beforeChange$1(editor, locks, beforeBookmark),\r\n        add: (undoManager, index, locks, beforeBookmark, level, event) => addUndoLevel$1(editor, undoManager, index, locks, beforeBookmark, level, event),\r\n        undo: (undoManager, locks, index) => undo$1(editor, undoManager, locks, index),\r\n        redo: (index, data) => redo$1(editor, index, data),\r\n        clear: (undoManager, index) => clear$1(editor, undoManager, index),\r\n        reset: undoManager => reset$1(undoManager),\r\n        hasUndo: (undoManager, index) => hasUndo$1(editor, undoManager, index),\r\n        hasRedo: (undoManager, index) => hasRedo$1(undoManager, index),\r\n        transact: (undoManager, locks, callback) => transact$1(undoManager, locks, callback),\r\n        ignore: (locks, callback) => ignore$1(locks, callback),\r\n        extra: (undoManager, index, callback1, callback2) => extra$1(editor, undoManager, index, callback1, callback2)\r\n      },\r\n      formatter: {\r\n        match: (name, vars, node, similar) => match$2(editor, name, vars, node, similar),\r\n        matchAll: (names, vars) => matchAll(editor, names, vars),\r\n        matchNode: (node, name, vars, similar) => matchNode(editor, node, name, vars, similar),\r\n        canApply: name => canApply(editor, name),\r\n        closest: names => closest(editor, names),\r\n        apply: (name, vars, node) => applyFormat$1(editor, name, vars, node),\r\n        remove: (name, vars, node, similar) => removeFormat$1(editor, name, vars, node, similar),\r\n        toggle: (name, vars, node) => toggle(editor, name, vars, node),\r\n        formatChanged: (registeredFormatListeners, formats, callback, similar, vars) => formatChangedInternal(editor, registeredFormatListeners, formats, callback, similar, vars)\r\n      },\r\n      editor: {\r\n        getContent: args => getContentInternal(editor, args),\r\n        setContent: (content, args) => setContentInternal(editor, content, args),\r\n        insertContent: (value, details) => insertHtmlAtCaret(editor, value, details),\r\n        addVisual: elm => addVisualInternal(editor, elm)\r\n      },\r\n      selection: { getContent: (format, args) => getSelectedContentInternal(editor, format, args) },\r\n      autocompleter: {\r\n        addDecoration: range => create$9(editor, range),\r\n        removeDecoration: () => remove$2(editor, SugarElement.fromDom(editor.getBody()))\r\n      },\r\n      raw: { getModel: () => Optional.none() }\r\n    });\r\n    const makeRtcAdaptor = rtcEditor => {\r\n      const defaultVars = vars => isObject(vars) ? vars : {};\r\n      const {init, undoManager, formatter, editor, selection, autocompleter, raw} = rtcEditor;\r\n      return {\r\n        init: { bindEvents: init.bindEvents },\r\n        undoManager: {\r\n          beforeChange: undoManager.beforeChange,\r\n          add: undoManager.add,\r\n          undo: undoManager.undo,\r\n          redo: undoManager.redo,\r\n          clear: undoManager.clear,\r\n          reset: undoManager.reset,\r\n          hasUndo: undoManager.hasUndo,\r\n          hasRedo: undoManager.hasRedo,\r\n          transact: (_undoManager, _locks, fn) => undoManager.transact(fn),\r\n          ignore: (_locks, callback) => undoManager.ignore(callback),\r\n          extra: (_undoManager, _index, callback1, callback2) => undoManager.extra(callback1, callback2)\r\n        },\r\n        formatter: {\r\n          match: (name, vars, _node, similar) => formatter.match(name, defaultVars(vars), similar),\r\n          matchAll: formatter.matchAll,\r\n          matchNode: formatter.matchNode,\r\n          canApply: name => formatter.canApply(name),\r\n          closest: names => formatter.closest(names),\r\n          apply: (name, vars, _node) => formatter.apply(name, defaultVars(vars)),\r\n          remove: (name, vars, _node, _similar) => formatter.remove(name, defaultVars(vars)),\r\n          toggle: (name, vars, _node) => formatter.toggle(name, defaultVars(vars)),\r\n          formatChanged: (_rfl, formats, callback, similar, vars) => formatter.formatChanged(formats, callback, similar, vars)\r\n        },\r\n        editor: {\r\n          getContent: args => editor.getContent(args),\r\n          setContent: (content, args) => {\r\n            return {\r\n              content: editor.setContent(content, args),\r\n              html: ''\r\n            };\r\n          },\r\n          insertContent: (content, _details) => {\r\n            editor.insertContent(content);\r\n            return '';\r\n          },\r\n          addVisual: editor.addVisual\r\n        },\r\n        selection: { getContent: (_format, args) => selection.getContent(args) },\r\n        autocompleter: {\r\n          addDecoration: autocompleter.addDecoration,\r\n          removeDecoration: autocompleter.removeDecoration\r\n        },\r\n        raw: { getModel: () => Optional.some(raw.getRawModel()) }\r\n      };\r\n    };\r\n    const makeNoopAdaptor = () => {\r\n      const nul = constant(null);\r\n      const empty = constant('');\r\n      return {\r\n        init: { bindEvents: noop },\r\n        undoManager: {\r\n          beforeChange: noop,\r\n          add: nul,\r\n          undo: nul,\r\n          redo: nul,\r\n          clear: noop,\r\n          reset: noop,\r\n          hasUndo: never,\r\n          hasRedo: never,\r\n          transact: nul,\r\n          ignore: noop,\r\n          extra: noop\r\n        },\r\n        formatter: {\r\n          match: never,\r\n          matchAll: constant([]),\r\n          matchNode: constant(undefined),\r\n          canApply: never,\r\n          closest: empty,\r\n          apply: noop,\r\n          remove: noop,\r\n          toggle: noop,\r\n          formatChanged: constant({ unbind: noop })\r\n        },\r\n        editor: {\r\n          getContent: empty,\r\n          setContent: constant({\r\n            content: '',\r\n            html: ''\r\n          }),\r\n          insertContent: constant(''),\r\n          addVisual: noop\r\n        },\r\n        selection: { getContent: empty },\r\n        autocompleter: {\r\n          addDecoration: noop,\r\n          removeDecoration: noop\r\n        },\r\n        raw: { getModel: constant(Optional.none()) }\r\n      };\r\n    };\r\n    const isRtc = editor => has$2(editor.plugins, 'rtc');\r\n    const getRtcSetup = editor => get$a(editor.plugins, 'rtc').bind(rtcPlugin => Optional.from(rtcPlugin.setup));\r\n    const setup$t = editor => {\r\n      const editorCast = editor;\r\n      return getRtcSetup(editor).fold(() => {\r\n        editorCast.rtcInstance = makePlainAdaptor(editor);\r\n        return Optional.none();\r\n      }, setup => {\r\n        editorCast.rtcInstance = makeNoopAdaptor();\r\n        return Optional.some(() => setup().then(rtcEditor => {\r\n          editorCast.rtcInstance = makeRtcAdaptor(rtcEditor);\r\n          return rtcEditor.rtc.isRemote;\r\n        }));\r\n      });\r\n    };\r\n    const getRtcInstanceWithFallback = editor => editor.rtcInstance ? editor.rtcInstance : makePlainAdaptor(editor);\r\n    const getRtcInstanceWithError = editor => {\r\n      const rtcInstance = editor.rtcInstance;\r\n      if (!rtcInstance) {\r\n        throw new Error('Failed to get RTC instance not yet initialized.');\r\n      } else {\r\n        return rtcInstance;\r\n      }\r\n    };\r\n    const beforeChange = (editor, locks, beforeBookmark) => {\r\n      getRtcInstanceWithError(editor).undoManager.beforeChange(locks, beforeBookmark);\r\n    };\r\n    const addUndoLevel = (editor, undoManager, index, locks, beforeBookmark, level, event) => getRtcInstanceWithError(editor).undoManager.add(undoManager, index, locks, beforeBookmark, level, event);\r\n    const undo = (editor, undoManager, locks, index) => getRtcInstanceWithError(editor).undoManager.undo(undoManager, locks, index);\r\n    const redo = (editor, index, data) => getRtcInstanceWithError(editor).undoManager.redo(index, data);\r\n    const clear = (editor, undoManager, index) => {\r\n      getRtcInstanceWithError(editor).undoManager.clear(undoManager, index);\r\n    };\r\n    const reset = (editor, undoManager) => {\r\n      getRtcInstanceWithError(editor).undoManager.reset(undoManager);\r\n    };\r\n    const hasUndo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasUndo(undoManager, index);\r\n    const hasRedo = (editor, undoManager, index) => getRtcInstanceWithError(editor).undoManager.hasRedo(undoManager, index);\r\n    const transact = (editor, undoManager, locks, callback) => getRtcInstanceWithError(editor).undoManager.transact(undoManager, locks, callback);\r\n    const ignore = (editor, locks, callback) => {\r\n      getRtcInstanceWithError(editor).undoManager.ignore(locks, callback);\r\n    };\r\n    const extra = (editor, undoManager, index, callback1, callback2) => {\r\n      getRtcInstanceWithError(editor).undoManager.extra(undoManager, index, callback1, callback2);\r\n    };\r\n    const matchFormat = (editor, name, vars, node, similar) => getRtcInstanceWithError(editor).formatter.match(name, vars, node, similar);\r\n    const matchAllFormats = (editor, names, vars) => getRtcInstanceWithError(editor).formatter.matchAll(names, vars);\r\n    const matchNodeFormat = (editor, node, name, vars, similar) => getRtcInstanceWithError(editor).formatter.matchNode(node, name, vars, similar);\r\n    const canApplyFormat = (editor, name) => getRtcInstanceWithError(editor).formatter.canApply(name);\r\n    const closestFormat = (editor, names) => getRtcInstanceWithError(editor).formatter.closest(names);\r\n    const applyFormat = (editor, name, vars, node) => {\r\n      getRtcInstanceWithError(editor).formatter.apply(name, vars, node);\r\n    };\r\n    const removeFormat = (editor, name, vars, node, similar) => {\r\n      getRtcInstanceWithError(editor).formatter.remove(name, vars, node, similar);\r\n    };\r\n    const toggleFormat = (editor, name, vars, node) => {\r\n      getRtcInstanceWithError(editor).formatter.toggle(name, vars, node);\r\n    };\r\n    const formatChanged = (editor, registeredFormatListeners, formats, callback, similar, vars) => getRtcInstanceWithError(editor).formatter.formatChanged(registeredFormatListeners, formats, callback, similar, vars);\r\n    const getContent$2 = (editor, args) => getRtcInstanceWithFallback(editor).editor.getContent(args);\r\n    const setContent$2 = (editor, content, args) => getRtcInstanceWithFallback(editor).editor.setContent(content, args);\r\n    const insertContent$1 = (editor, value, details) => getRtcInstanceWithFallback(editor).editor.insertContent(value, details);\r\n    const getSelectedContent = (editor, format, args) => getRtcInstanceWithError(editor).selection.getContent(format, args);\r\n    const addVisual$1 = (editor, elm) => getRtcInstanceWithError(editor).editor.addVisual(elm);\r\n    const bindEvents = editor => getRtcInstanceWithError(editor).init.bindEvents();\r\n    const addAutocompleterDecoration = (editor, range) => getRtcInstanceWithError(editor).autocompleter.addDecoration(range);\r\n    const removeAutocompleterDecoration = editor => getRtcInstanceWithError(editor).autocompleter.removeDecoration();\r\n\r\n    const getContent$1 = (editor, args = {}) => {\r\n      const format = args.format ? args.format : 'html';\r\n      return getSelectedContent(editor, format, args);\r\n    };\r\n\r\n    const removeEmpty = text => {\r\n      if (text.dom.length === 0) {\r\n        remove$5(text);\r\n        return Optional.none();\r\n      } else {\r\n        return Optional.some(text);\r\n      }\r\n    };\r\n    const walkPastBookmark = (node, start) => node.filter(elm => BookmarkManager.isBookmarkNode(elm.dom)).bind(start ? nextSibling : prevSibling);\r\n    const merge$1 = (outer, inner, rng, start, schema) => {\r\n      const outerElm = outer.dom;\r\n      const innerElm = inner.dom;\r\n      const oldLength = start ? outerElm.length : innerElm.length;\r\n      if (start) {\r\n        mergeTextNodes(outerElm, innerElm, schema, false, !start);\r\n        rng.setStart(innerElm, oldLength);\r\n      } else {\r\n        mergeTextNodes(innerElm, outerElm, schema, false, !start);\r\n        rng.setEnd(innerElm, oldLength);\r\n      }\r\n    };\r\n    const normalizeTextIfRequired = (inner, start, schema) => {\r\n      parent(inner).each(root => {\r\n        const text = inner.dom;\r\n        if (start && needsToBeNbspLeft(root, CaretPosition(text, 0), schema)) {\r\n          normalizeWhitespaceAfter(text, 0, schema);\r\n        } else if (!start && needsToBeNbspRight(root, CaretPosition(text, text.length), schema)) {\r\n          normalizeWhitespaceBefore(text, text.length, schema);\r\n        }\r\n      });\r\n    };\r\n    const mergeAndNormalizeText = (outerNode, innerNode, rng, start, schema) => {\r\n      outerNode.bind(outer => {\r\n        const normalizer = start ? normalizeWhitespaceBefore : normalizeWhitespaceAfter;\r\n        normalizer(outer.dom, start ? outer.dom.length : 0, schema);\r\n        return innerNode.filter(isText$b).map(inner => merge$1(outer, inner, rng, start, schema));\r\n      }).orThunk(() => {\r\n        const innerTextNode = walkPastBookmark(innerNode, start).or(innerNode).filter(isText$b);\r\n        return innerTextNode.map(inner => normalizeTextIfRequired(inner, start, schema));\r\n      });\r\n    };\r\n    const rngSetContent = (rng, fragment, schema) => {\r\n      const firstChild = Optional.from(fragment.firstChild).map(SugarElement.fromDom);\r\n      const lastChild = Optional.from(fragment.lastChild).map(SugarElement.fromDom);\r\n      rng.deleteContents();\r\n      rng.insertNode(fragment);\r\n      const prevText = firstChild.bind(prevSibling).filter(isText$b).bind(removeEmpty);\r\n      const nextText = lastChild.bind(nextSibling).filter(isText$b).bind(removeEmpty);\r\n      mergeAndNormalizeText(prevText, firstChild, rng, true, schema);\r\n      mergeAndNormalizeText(nextText, lastChild, rng, false, schema);\r\n      rng.collapse(false);\r\n    };\r\n    const setupArgs$2 = (args, content) => ({\r\n      format: 'html',\r\n      ...args,\r\n      set: true,\r\n      selection: true,\r\n      content\r\n    });\r\n    const cleanContent = (editor, args) => {\r\n      if (args.format !== 'raw') {\r\n        const rng = editor.selection.getRng();\r\n        const contextBlock = editor.dom.getParent(rng.commonAncestorContainer, editor.dom.isBlock);\r\n        const contextArgs = contextBlock ? { context: contextBlock.nodeName.toLowerCase() } : {};\r\n        const node = editor.parser.parse(args.content, {\r\n          forced_root_block: false,\r\n          ...contextArgs,\r\n          ...args\r\n        });\r\n        return HtmlSerializer({ validate: false }, editor.schema).serialize(node);\r\n      } else {\r\n        return args.content;\r\n      }\r\n    };\r\n    const setContent$1 = (editor, content, args = {}) => {\r\n      const defaultedArgs = setupArgs$2(args, content);\r\n      preProcessSetContent(editor, defaultedArgs).each(updatedArgs => {\r\n        const cleanedContent = cleanContent(editor, updatedArgs);\r\n        const rng = editor.selection.getRng();\r\n        rngSetContent(rng, rng.createContextualFragment(cleanedContent), editor.schema);\r\n        editor.selection.setRng(rng);\r\n        scrollRangeIntoView(editor, rng);\r\n        postProcessSetContent(editor, cleanedContent, updatedArgs);\r\n      });\r\n    };\r\n\r\n    const deleteFromCallbackMap = (callbackMap, selector, callback) => {\r\n      if (has$2(callbackMap, selector)) {\r\n        const newCallbacks = filter$5(callbackMap[selector], cb => cb !== callback);\r\n        if (newCallbacks.length === 0) {\r\n          delete callbackMap[selector];\r\n        } else {\r\n          callbackMap[selector] = newCallbacks;\r\n        }\r\n      }\r\n    };\r\n    var SelectorChanged = (dom, editor) => {\r\n      let selectorChangedData;\r\n      let currentSelectors;\r\n      const findMatchingNode = (selector, nodes) => find$2(nodes, node => dom.is(node, selector));\r\n      const getParents = elem => dom.getParents(elem, undefined, dom.getRoot());\r\n      const setup = () => {\r\n        selectorChangedData = {};\r\n        currentSelectors = {};\r\n        editor.on('NodeChange', e => {\r\n          const node = e.element;\r\n          const parents = getParents(node);\r\n          const matchedSelectors = {};\r\n          each$d(selectorChangedData, (callbacks, selector) => {\r\n            findMatchingNode(selector, parents).each(node => {\r\n              if (!currentSelectors[selector]) {\r\n                each$e(callbacks, callback => {\r\n                  callback(true, {\r\n                    node,\r\n                    selector,\r\n                    parents\r\n                  });\r\n                });\r\n                currentSelectors[selector] = callbacks;\r\n              }\r\n              matchedSelectors[selector] = callbacks;\r\n            });\r\n          });\r\n          each$d(currentSelectors, (callbacks, selector) => {\r\n            if (!matchedSelectors[selector]) {\r\n              delete currentSelectors[selector];\r\n              each$e(callbacks, callback => {\r\n                callback(false, {\r\n                  node,\r\n                  selector,\r\n                  parents\r\n                });\r\n              });\r\n            }\r\n          });\r\n        });\r\n      };\r\n      return {\r\n        selectorChangedWithUnbind: (selector, callback) => {\r\n          if (!selectorChangedData) {\r\n            setup();\r\n          }\r\n          if (!selectorChangedData[selector]) {\r\n            selectorChangedData[selector] = [];\r\n          }\r\n          selectorChangedData[selector].push(callback);\r\n          findMatchingNode(selector, getParents(editor.selection.getStart())).each(() => {\r\n            currentSelectors[selector] = selectorChangedData[selector];\r\n          });\r\n          return {\r\n            unbind: () => {\r\n              deleteFromCallbackMap(selectorChangedData, selector, callback);\r\n              deleteFromCallbackMap(currentSelectors, selector, callback);\r\n            }\r\n          };\r\n        }\r\n      };\r\n    };\r\n\r\n    const isAttachedToDom = node => {\r\n      return !!(node && node.ownerDocument) && contains(SugarElement.fromDom(node.ownerDocument), SugarElement.fromDom(node));\r\n    };\r\n    const isValidRange = rng => {\r\n      if (!rng) {\r\n        return false;\r\n      } else {\r\n        return isAttachedToDom(rng.startContainer) && isAttachedToDom(rng.endContainer);\r\n      }\r\n    };\r\n    const EditorSelection = (dom, win, serializer, editor) => {\r\n      let selectedRange;\r\n      let explicitRange;\r\n      const {selectorChangedWithUnbind} = SelectorChanged(dom, editor);\r\n      const setCursorLocation = (node, offset) => {\r\n        const rng = dom.createRng();\r\n        if (isNonNullable(node) && isNonNullable(offset)) {\r\n          rng.setStart(node, offset);\r\n          rng.setEnd(node, offset);\r\n          setRng(rng);\r\n          collapse(false);\r\n        } else {\r\n          moveEndPoint(dom, rng, editor.getBody(), true);\r\n          setRng(rng);\r\n        }\r\n      };\r\n      const getContent = args => getContent$1(editor, args);\r\n      const setContent = (content, args) => setContent$1(editor, content, args);\r\n      const getStart$1 = real => getStart(editor.getBody(), getRng$1(), real);\r\n      const getEnd = real => getEnd$1(editor.getBody(), getRng$1(), real);\r\n      const getBookmark = (type, normalized) => bookmarkManager.getBookmark(type, normalized);\r\n      const moveToBookmark = bookmark => bookmarkManager.moveToBookmark(bookmark);\r\n      const select$1 = (node, content) => {\r\n        select(dom, node, content).each(setRng);\r\n        return node;\r\n      };\r\n      const isCollapsed = () => {\r\n        const rng = getRng$1(), sel = getSel();\r\n        if (!rng || rng.item) {\r\n          return false;\r\n        }\r\n        if (rng.compareEndPoints) {\r\n          return rng.compareEndPoints('StartToEnd', rng) === 0;\r\n        }\r\n        return !sel || rng.collapsed;\r\n      };\r\n      const isEditable = () => {\r\n        const rng = getRng$1();\r\n        const fakeSelectedElements = editor.getBody().querySelectorAll('[data-mce-selected=\"1\"]');\r\n        if (fakeSelectedElements.length > 0) {\r\n          return forall(fakeSelectedElements, el => dom.isEditable(el.parentElement));\r\n        } else {\r\n          return isEditableRange(dom, rng);\r\n        }\r\n      };\r\n      const collapse = toStart => {\r\n        const rng = getRng$1();\r\n        rng.collapse(!!toStart);\r\n        setRng(rng);\r\n      };\r\n      const getSel = () => win.getSelection ? win.getSelection() : win.document.selection;\r\n      const getRng$1 = () => {\r\n        let rng;\r\n        const tryCompareBoundaryPoints = (how, sourceRange, destinationRange) => {\r\n          try {\r\n            return sourceRange.compareBoundaryPoints(how, destinationRange);\r\n          } catch (ex) {\r\n            return -1;\r\n          }\r\n        };\r\n        const doc = win.document;\r\n        if (isNonNullable(editor.bookmark) && !hasFocus(editor)) {\r\n          const bookmark = getRng(editor);\r\n          if (bookmark.isSome()) {\r\n            return bookmark.map(r => processRanges(editor, [r])[0]).getOr(doc.createRange());\r\n          }\r\n        }\r\n        try {\r\n          const selection = getSel();\r\n          if (selection && !isRestrictedNode(selection.anchorNode)) {\r\n            if (selection.rangeCount > 0) {\r\n              rng = selection.getRangeAt(0);\r\n            } else {\r\n              rng = doc.createRange();\r\n            }\r\n            rng = processRanges(editor, [rng])[0];\r\n          }\r\n        } catch (ex) {\r\n        }\r\n        if (!rng) {\r\n          rng = doc.createRange();\r\n        }\r\n        if (isDocument$1(rng.startContainer) && rng.collapsed) {\r\n          const elm = dom.getRoot();\r\n          rng.setStart(elm, 0);\r\n          rng.setEnd(elm, 0);\r\n        }\r\n        if (selectedRange && explicitRange) {\r\n          if (tryCompareBoundaryPoints(rng.START_TO_START, rng, selectedRange) === 0 && tryCompareBoundaryPoints(rng.END_TO_END, rng, selectedRange) === 0) {\r\n            rng = explicitRange;\r\n          } else {\r\n            selectedRange = null;\r\n            explicitRange = null;\r\n          }\r\n        }\r\n        return rng;\r\n      };\r\n      const setRng = (rng, forward) => {\r\n        if (!isValidRange(rng)) {\r\n          return;\r\n        }\r\n        const sel = getSel();\r\n        const evt = editor.dispatch('SetSelectionRange', {\r\n          range: rng,\r\n          forward\r\n        });\r\n        rng = evt.range;\r\n        if (sel) {\r\n          explicitRange = rng;\r\n          try {\r\n            sel.removeAllRanges();\r\n            sel.addRange(rng);\r\n          } catch (ex) {\r\n          }\r\n          if (forward === false && sel.extend) {\r\n            sel.collapse(rng.endContainer, rng.endOffset);\r\n            sel.extend(rng.startContainer, rng.startOffset);\r\n          }\r\n          selectedRange = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;\r\n        }\r\n        if (!rng.collapsed && rng.startContainer === rng.endContainer && (sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent)) {\r\n          if (rng.endOffset - rng.startOffset < 2) {\r\n            if (rng.startContainer.hasChildNodes()) {\r\n              const node = rng.startContainer.childNodes[rng.startOffset];\r\n              if (node && node.nodeName === 'IMG') {\r\n                sel.setBaseAndExtent(rng.startContainer, rng.startOffset, rng.endContainer, rng.endOffset);\r\n                if (sel.anchorNode !== rng.startContainer || sel.focusNode !== rng.endContainer) {\r\n                  sel.setBaseAndExtent(node, 0, node, 1);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        editor.dispatch('AfterSetSelectionRange', {\r\n          range: rng,\r\n          forward\r\n        });\r\n      };\r\n      const setNode = elm => {\r\n        setContent(dom.getOuterHTML(elm));\r\n        return elm;\r\n      };\r\n      const getNode$1 = () => getNode(editor.getBody(), getRng$1());\r\n      const getSelectedBlocks$1 = (startElm, endElm) => getSelectedBlocks(dom, getRng$1(), startElm, endElm);\r\n      const isForward = () => {\r\n        const sel = getSel();\r\n        const anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\r\n        const focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\r\n        if (!sel || !anchorNode || !focusNode || isRestrictedNode(anchorNode) || isRestrictedNode(focusNode)) {\r\n          return true;\r\n        }\r\n        const anchorRange = dom.createRng();\r\n        const focusRange = dom.createRng();\r\n        try {\r\n          anchorRange.setStart(anchorNode, sel.anchorOffset);\r\n          anchorRange.collapse(true);\r\n          focusRange.setStart(focusNode, sel.focusOffset);\r\n          focusRange.collapse(true);\r\n        } catch (e) {\r\n          return true;\r\n        }\r\n        return anchorRange.compareBoundaryPoints(anchorRange.START_TO_START, focusRange) <= 0;\r\n      };\r\n      const normalize = () => {\r\n        const rng = getRng$1();\r\n        const sel = getSel();\r\n        if (!hasMultipleRanges(sel) && hasAnyRanges(editor)) {\r\n          const normRng = normalize$2(dom, rng);\r\n          normRng.each(normRng => {\r\n            setRng(normRng, isForward());\r\n          });\r\n          return normRng.getOr(rng);\r\n        }\r\n        return rng;\r\n      };\r\n      const selectorChanged = (selector, callback) => {\r\n        selectorChangedWithUnbind(selector, callback);\r\n        return exports;\r\n      };\r\n      const getScrollContainer = () => {\r\n        let scrollContainer;\r\n        let node = dom.getRoot();\r\n        while (node && node.nodeName !== 'BODY') {\r\n          if (node.scrollHeight > node.clientHeight) {\r\n            scrollContainer = node;\r\n            break;\r\n          }\r\n          node = node.parentNode;\r\n        }\r\n        return scrollContainer;\r\n      };\r\n      const scrollIntoView = (elm, alignToTop) => {\r\n        if (isNonNullable(elm)) {\r\n          scrollElementIntoView(editor, elm, alignToTop);\r\n        } else {\r\n          scrollRangeIntoView(editor, getRng$1(), alignToTop);\r\n        }\r\n      };\r\n      const placeCaretAt = (clientX, clientY) => setRng(fromPoint(clientX, clientY, editor.getDoc()));\r\n      const getBoundingClientRect = () => {\r\n        const rng = getRng$1();\r\n        return rng.collapsed ? CaretPosition.fromRangeStart(rng).getClientRects()[0] : rng.getBoundingClientRect();\r\n      };\r\n      const destroy = () => {\r\n        win = selectedRange = explicitRange = null;\r\n        controlSelection.destroy();\r\n      };\r\n      const expand = (options = { type: 'word' }) => setRng(RangeUtils(dom).expand(getRng$1(), options));\r\n      const exports = {\r\n        dom,\r\n        win,\r\n        serializer,\r\n        editor,\r\n        expand,\r\n        collapse,\r\n        setCursorLocation,\r\n        getContent,\r\n        setContent,\r\n        getBookmark,\r\n        moveToBookmark,\r\n        select: select$1,\r\n        isCollapsed,\r\n        isEditable,\r\n        isForward,\r\n        setNode,\r\n        getNode: getNode$1,\r\n        getSel,\r\n        setRng,\r\n        getRng: getRng$1,\r\n        getStart: getStart$1,\r\n        getEnd,\r\n        getSelectedBlocks: getSelectedBlocks$1,\r\n        normalize,\r\n        selectorChanged,\r\n        selectorChangedWithUnbind,\r\n        getScrollContainer,\r\n        scrollIntoView,\r\n        placeCaretAt,\r\n        getBoundingClientRect,\r\n        destroy\r\n      };\r\n      const bookmarkManager = BookmarkManager(exports);\r\n      const controlSelection = ControlSelection(exports, editor);\r\n      exports.bookmarkManager = bookmarkManager;\r\n      exports.controlSelection = controlSelection;\r\n      return exports;\r\n    };\r\n\r\n    const register$3 = (htmlParser, settings, dom) => {\r\n      htmlParser.addAttributeFilter('data-mce-tabindex', (nodes, name) => {\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          node.attr('tabindex', node.attr('data-mce-tabindex'));\r\n          node.attr(name, null);\r\n        }\r\n      });\r\n      htmlParser.addAttributeFilter('src,href,style', (nodes, name) => {\r\n        const internalName = 'data-mce-' + name;\r\n        const urlConverter = settings.url_converter;\r\n        const urlConverterScope = settings.url_converter_scope;\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          let value = node.attr(internalName);\r\n          if (value !== undefined) {\r\n            node.attr(name, value.length > 0 ? value : null);\r\n            node.attr(internalName, null);\r\n          } else {\r\n            value = node.attr(name);\r\n            if (name === 'style') {\r\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\r\n            } else if (urlConverter) {\r\n              value = urlConverter.call(urlConverterScope, value, name, node.name);\r\n            }\r\n            node.attr(name, value.length > 0 ? value : null);\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addAttributeFilter('class', nodes => {\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          let value = node.attr('class');\r\n          if (value) {\r\n            value = value.replace(/(?:^|\\s)mce-item-\\w+(?!\\S)/g, '');\r\n            node.attr('class', value.length > 0 ? value : null);\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addAttributeFilter('data-mce-type', (nodes, name, args) => {\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          if (node.attr('data-mce-type') === 'bookmark' && !args.cleanup) {\r\n            const hasChildren = Optional.from(node.firstChild).exists(firstChild => {\r\n              var _a;\r\n              return !isZwsp$1((_a = firstChild.value) !== null && _a !== void 0 ? _a : '');\r\n            });\r\n            if (hasChildren) {\r\n              node.unwrap();\r\n            } else {\r\n              node.remove();\r\n            }\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addNodeFilter('noscript', nodes => {\r\n        var _a;\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i].firstChild;\r\n          if (node) {\r\n            node.value = Entities.decode((_a = node.value) !== null && _a !== void 0 ? _a : '');\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addNodeFilter('script,style', (nodes, name) => {\r\n        var _a;\r\n        const trim = value => {\r\n          return value.replace(/(<!--\\[CDATA\\[|\\]\\]-->)/g, '\\n').replace(/^[\\r\\n]*|[\\r\\n]*$/g, '').replace(/^\\s*((<!--)?(\\s*\\/\\/)?\\s*<!\\[CDATA\\[|(<!--\\s*)?\\/\\*\\s*<!\\[CDATA\\[\\s*\\*\\/|(\\/\\/)?\\s*<!--|\\/\\*\\s*<!--\\s*\\*\\/)\\s*[\\r\\n]*/gi, '').replace(/\\s*(\\/\\*\\s*\\]\\]>\\s*\\*\\/(-->)?|\\s*\\/\\/\\s*\\]\\]>(-->)?|\\/\\/\\s*(-->)?|\\]\\]>|\\/\\*\\s*-->\\s*\\*\\/|\\s*-->\\s*)\\s*$/g, '');\r\n        };\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          const firstChild = node.firstChild;\r\n          const value = (_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _a !== void 0 ? _a : '';\r\n          if (name === 'script') {\r\n            const type = node.attr('type');\r\n            if (type) {\r\n              node.attr('type', type === 'mce-no/type' ? null : type.replace(/^mce\\-/, ''));\r\n            }\r\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\r\n              firstChild.value = '// <![CDATA[\\n' + trim(value) + '\\n// ]]>';\r\n            }\r\n          } else {\r\n            if (settings.element_format === 'xhtml' && firstChild && value.length > 0) {\r\n              firstChild.value = '<!--\\n' + trim(value) + '\\n-->';\r\n            }\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addNodeFilter('#comment', nodes => {\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          const value = node.value;\r\n          if (settings.preserve_cdata && (value === null || value === void 0 ? void 0 : value.indexOf('[CDATA[')) === 0) {\r\n            node.name = '#cdata';\r\n            node.type = 4;\r\n            node.value = dom.decode(value.replace(/^\\[CDATA\\[|\\]\\]$/g, ''));\r\n          } else if ((value === null || value === void 0 ? void 0 : value.indexOf('mce:protected ')) === 0) {\r\n            node.name = '#text';\r\n            node.type = 3;\r\n            node.raw = true;\r\n            node.value = unescape(value).substr(14);\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addNodeFilter('xml:namespace,input', (nodes, name) => {\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          if (node.type === 7) {\r\n            node.remove();\r\n          } else if (node.type === 1) {\r\n            if (name === 'input' && !node.attr('type')) {\r\n              node.attr('type', 'text');\r\n            }\r\n          }\r\n        }\r\n      });\r\n      htmlParser.addAttributeFilter('data-mce-type', nodes => {\r\n        each$e(nodes, node => {\r\n          if (node.attr('data-mce-type') === 'format-caret') {\r\n            if (node.isEmpty(htmlParser.schema.getNonEmptyElements())) {\r\n              node.remove();\r\n            } else {\r\n              node.unwrap();\r\n            }\r\n          }\r\n        });\r\n      });\r\n      htmlParser.addAttributeFilter('data-mce-src,data-mce-href,data-mce-style,' + 'data-mce-selected,data-mce-expando,data-mce-block,' + 'data-mce-type,data-mce-resize,data-mce-placeholder', (nodes, name) => {\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          nodes[i].attr(name, null);\r\n        }\r\n      });\r\n      if (settings.remove_trailing_brs) {\r\n        addNodeFilter(settings, htmlParser, htmlParser.schema);\r\n      }\r\n    };\r\n    const trimTrailingBr = rootNode => {\r\n      const isBr = node => {\r\n        return (node === null || node === void 0 ? void 0 : node.name) === 'br';\r\n      };\r\n      const brNode1 = rootNode.lastChild;\r\n      if (isBr(brNode1)) {\r\n        const brNode2 = brNode1.prev;\r\n        if (isBr(brNode2)) {\r\n          brNode1.remove();\r\n          brNode2.remove();\r\n        }\r\n      }\r\n    };\r\n\r\n    const preProcess$1 = (editor, node, args) => {\r\n      let oldDoc;\r\n      const dom = editor.dom;\r\n      let clonedNode = node.cloneNode(true);\r\n      const impl = document.implementation;\r\n      if (impl.createHTMLDocument) {\r\n        const doc = impl.createHTMLDocument('');\r\n        Tools.each(clonedNode.nodeName === 'BODY' ? clonedNode.childNodes : [clonedNode], node => {\r\n          doc.body.appendChild(doc.importNode(node, true));\r\n        });\r\n        if (clonedNode.nodeName !== 'BODY') {\r\n          clonedNode = doc.body.firstChild;\r\n        } else {\r\n          clonedNode = doc.body;\r\n        }\r\n        oldDoc = dom.doc;\r\n        dom.doc = doc;\r\n      }\r\n      firePreProcess(editor, {\r\n        ...args,\r\n        node: clonedNode\r\n      });\r\n      if (oldDoc) {\r\n        dom.doc = oldDoc;\r\n      }\r\n      return clonedNode;\r\n    };\r\n    const shouldFireEvent = (editor, args) => {\r\n      return isNonNullable(editor) && editor.hasEventListeners('PreProcess') && !args.no_events;\r\n    };\r\n    const process$1 = (editor, node, args) => {\r\n      return shouldFireEvent(editor, args) ? preProcess$1(editor, node, args) : node;\r\n    };\r\n\r\n    const addTempAttr = (htmlParser, tempAttrs, name) => {\r\n      if (Tools.inArray(tempAttrs, name) === -1) {\r\n        htmlParser.addAttributeFilter(name, (nodes, name) => {\r\n          let i = nodes.length;\r\n          while (i--) {\r\n            nodes[i].attr(name, null);\r\n          }\r\n        });\r\n        tempAttrs.push(name);\r\n      }\r\n    };\r\n    const postProcess = (editor, args, content) => {\r\n      if (!args.no_events && editor) {\r\n        const outArgs = firePostProcess(editor, {\r\n          ...args,\r\n          content\r\n        });\r\n        return outArgs.content;\r\n      } else {\r\n        return content;\r\n      }\r\n    };\r\n    const getHtmlFromNode = (dom, node, args) => {\r\n      const html = trim$2(args.getInner ? node.innerHTML : dom.getOuterHTML(node));\r\n      return args.selection || isWsPreserveElement(SugarElement.fromDom(node)) ? html : Tools.trim(html);\r\n    };\r\n    const parseHtml = (htmlParser, html, args) => {\r\n      const parserArgs = args.selection ? {\r\n        forced_root_block: false,\r\n        ...args\r\n      } : args;\r\n      const rootNode = htmlParser.parse(html, parserArgs);\r\n      trimTrailingBr(rootNode);\r\n      return rootNode;\r\n    };\r\n    const serializeNode = (settings, schema, node) => {\r\n      const htmlSerializer = HtmlSerializer(settings, schema);\r\n      return htmlSerializer.serialize(node);\r\n    };\r\n    const toHtml = (editor, settings, schema, rootNode, args) => {\r\n      const content = serializeNode(settings, schema, rootNode);\r\n      return postProcess(editor, args, content);\r\n    };\r\n    const DomSerializerImpl = (settings, editor) => {\r\n      const tempAttrs = ['data-mce-selected'];\r\n      const defaultedSettings = {\r\n        entity_encoding: 'named',\r\n        remove_trailing_brs: true,\r\n        pad_empty_with_br: false,\r\n        ...settings\r\n      };\r\n      const dom = editor && editor.dom ? editor.dom : DOMUtils.DOM;\r\n      const schema = editor && editor.schema ? editor.schema : Schema(defaultedSettings);\r\n      const htmlParser = DomParser(defaultedSettings, schema);\r\n      register$3(htmlParser, defaultedSettings, dom);\r\n      const serialize = (node, parserArgs = {}) => {\r\n        const args = {\r\n          format: 'html',\r\n          ...parserArgs\r\n        };\r\n        const targetNode = process$1(editor, node, args);\r\n        const html = getHtmlFromNode(dom, targetNode, args);\r\n        const rootNode = parseHtml(htmlParser, html, args);\r\n        return args.format === 'tree' ? rootNode : toHtml(editor, defaultedSettings, schema, rootNode, args);\r\n      };\r\n      return {\r\n        schema,\r\n        addNodeFilter: htmlParser.addNodeFilter,\r\n        addAttributeFilter: htmlParser.addAttributeFilter,\r\n        serialize: serialize,\r\n        addRules: schema.addValidElements,\r\n        setRules: schema.setValidElements,\r\n        addTempAttr: curry(addTempAttr, htmlParser, tempAttrs),\r\n        getTempAttrs: constant(tempAttrs),\r\n        getNodeFilters: htmlParser.getNodeFilters,\r\n        getAttributeFilters: htmlParser.getAttributeFilters,\r\n        removeNodeFilter: htmlParser.removeNodeFilter,\r\n        removeAttributeFilter: htmlParser.removeAttributeFilter\r\n      };\r\n    };\r\n\r\n    const DomSerializer = (settings, editor) => {\r\n      const domSerializer = DomSerializerImpl(settings, editor);\r\n      return {\r\n        schema: domSerializer.schema,\r\n        addNodeFilter: domSerializer.addNodeFilter,\r\n        addAttributeFilter: domSerializer.addAttributeFilter,\r\n        serialize: domSerializer.serialize,\r\n        addRules: domSerializer.addRules,\r\n        setRules: domSerializer.setRules,\r\n        addTempAttr: domSerializer.addTempAttr,\r\n        getTempAttrs: domSerializer.getTempAttrs,\r\n        getNodeFilters: domSerializer.getNodeFilters,\r\n        getAttributeFilters: domSerializer.getAttributeFilters,\r\n        removeNodeFilter: domSerializer.removeNodeFilter,\r\n        removeAttributeFilter: domSerializer.removeAttributeFilter\r\n      };\r\n    };\r\n\r\n    const defaultFormat$1 = 'html';\r\n    const setupArgs$1 = (args, format) => ({\r\n      ...args,\r\n      format,\r\n      get: true,\r\n      getInner: true\r\n    });\r\n    const getContent = (editor, args = {}) => {\r\n      const format = args.format ? args.format : defaultFormat$1;\r\n      const defaultedArgs = setupArgs$1(args, format);\r\n      return preProcessGetContent(editor, defaultedArgs).fold(identity, updatedArgs => {\r\n        const content = getContent$2(editor, updatedArgs);\r\n        return postProcessGetContent(editor, content, updatedArgs);\r\n      });\r\n    };\r\n\r\n    const defaultFormat = 'html';\r\n    const setupArgs = (args, content) => ({\r\n      format: defaultFormat,\r\n      ...args,\r\n      set: true,\r\n      content\r\n    });\r\n    const setContent = (editor, content, args = {}) => {\r\n      const defaultedArgs = setupArgs(args, content);\r\n      return preProcessSetContent(editor, defaultedArgs).map(updatedArgs => {\r\n        const result = setContent$2(editor, updatedArgs.content, updatedArgs);\r\n        postProcessSetContent(editor, result.html, updatedArgs);\r\n        return result.content;\r\n      }).getOr(content);\r\n    };\r\n\r\n    const removedOptions = ('autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,' + 'boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,' + 'force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,' + 'non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,' + 'tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,' + 'paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists').split(',');\r\n    const deprecatedOptions = 'template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format'.split(',');\r\n    const removedPlugins = 'bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,textcolor'.split(',');\r\n    const deprecatedPlugins = [\r\n      {\r\n        name: 'template',\r\n        replacedWith: 'Advanced Template'\r\n      },\r\n      { name: 'rtc' }\r\n    ];\r\n    const getMatchingOptions = (options, searchingFor) => {\r\n      const settingNames = filter$5(searchingFor, setting => has$2(options, setting));\r\n      return sort(settingNames);\r\n    };\r\n    const getRemovedOptions = options => {\r\n      const settingNames = getMatchingOptions(options, removedOptions);\r\n      const forcedRootBlock = options.forced_root_block;\r\n      if (forcedRootBlock === false || forcedRootBlock === '') {\r\n        settingNames.push('forced_root_block (false only)');\r\n      }\r\n      return sort(settingNames);\r\n    };\r\n    const getDeprecatedOptions = options => getMatchingOptions(options, deprecatedOptions);\r\n    const getMatchingPlugins = (options, searchingFor) => {\r\n      const plugins = Tools.makeMap(options.plugins, ' ');\r\n      const hasPlugin = plugin => has$2(plugins, plugin);\r\n      const pluginNames = filter$5(searchingFor, hasPlugin);\r\n      return sort(pluginNames);\r\n    };\r\n    const getRemovedPlugins = options => getMatchingPlugins(options, removedPlugins);\r\n    const getDeprecatedPlugins = options => getMatchingPlugins(options, deprecatedPlugins.map(entry => entry.name));\r\n    const logRemovedWarnings = (rawOptions, normalizedOptions) => {\r\n      const removedOptions = getRemovedOptions(rawOptions);\r\n      const removedPlugins = getRemovedPlugins(normalizedOptions);\r\n      const hasRemovedPlugins = removedPlugins.length > 0;\r\n      const hasRemovedOptions = removedOptions.length > 0;\r\n      const isLegacyMobileTheme = normalizedOptions.theme === 'mobile';\r\n      if (hasRemovedPlugins || hasRemovedOptions || isLegacyMobileTheme) {\r\n        const listJoiner = '\\n- ';\r\n        const themesMessage = isLegacyMobileTheme ? `\\n\\nThemes:${ listJoiner }mobile` : '';\r\n        const pluginsMessage = hasRemovedPlugins ? `\\n\\nPlugins:${ listJoiner }${ removedPlugins.join(listJoiner) }` : '';\r\n        const optionsMessage = hasRemovedOptions ? `\\n\\nOptions:${ listJoiner }${ removedOptions.join(listJoiner) }` : '';\r\n        console.warn('The following deprecated features are currently enabled and have been removed in TinyMCE 6.0. These features will no longer work and should be removed from the TinyMCE configuration. ' + 'See https://www.tiny.cloud/docs/tinymce/6/migration-from-5x/ for more information.' + themesMessage + pluginsMessage + optionsMessage);\r\n      }\r\n    };\r\n    const getPluginDescription = name => find$2(deprecatedPlugins, entry => entry.name === name).fold(() => name, entry => {\r\n      if (entry.replacedWith) {\r\n        return `${ name }, replaced by ${ entry.replacedWith }`;\r\n      } else {\r\n        return name;\r\n      }\r\n    });\r\n    const logDeprecatedWarnings = (rawOptions, normalizedOptions) => {\r\n      const deprecatedOptions = getDeprecatedOptions(rawOptions);\r\n      const deprecatedPlugins = getDeprecatedPlugins(normalizedOptions);\r\n      const hasDeprecatedPlugins = deprecatedPlugins.length > 0;\r\n      const hasDeprecatedOptions = deprecatedOptions.length > 0;\r\n      if (hasDeprecatedPlugins || hasDeprecatedOptions) {\r\n        const listJoiner = '\\n- ';\r\n        const pluginsMessage = hasDeprecatedPlugins ? `\\n\\nPlugins:${ listJoiner }${ deprecatedPlugins.map(getPluginDescription).join(listJoiner) }` : '';\r\n        const optionsMessage = hasDeprecatedOptions ? `\\n\\nOptions:${ listJoiner }${ deprecatedOptions.join(listJoiner) }` : '';\r\n        console.warn('The following deprecated features are currently enabled but will be removed soon.' + pluginsMessage + optionsMessage);\r\n      }\r\n    };\r\n    const logWarnings = (rawOptions, normalizedOptions) => {\r\n      logRemovedWarnings(rawOptions, normalizedOptions);\r\n      logDeprecatedWarnings(rawOptions, normalizedOptions);\r\n    };\r\n\r\n    const DOM$8 = DOMUtils.DOM;\r\n    const restoreOriginalStyles = editor => {\r\n      DOM$8.setStyle(editor.id, 'display', editor.orgDisplay);\r\n    };\r\n    const safeDestroy = x => Optional.from(x).each(x => x.destroy());\r\n    const clearDomReferences = editor => {\r\n      const ed = editor;\r\n      ed.contentAreaContainer = ed.formElement = ed.container = ed.editorContainer = null;\r\n      ed.bodyElement = ed.contentDocument = ed.contentWindow = null;\r\n      ed.iframeElement = ed.targetElm = null;\r\n      const selection = editor.selection;\r\n      if (selection) {\r\n        const dom = selection.dom;\r\n        ed.selection = selection.win = selection.dom = dom.doc = null;\r\n      }\r\n    };\r\n    const restoreForm = editor => {\r\n      const form = editor.formElement;\r\n      if (form) {\r\n        if (form._mceOldSubmit) {\r\n          form.submit = form._mceOldSubmit;\r\n          delete form._mceOldSubmit;\r\n        }\r\n        DOM$8.unbind(form, 'submit reset', editor.formEventDelegate);\r\n      }\r\n    };\r\n    const remove$1 = editor => {\r\n      if (!editor.removed) {\r\n        const {_selectionOverrides, editorUpload} = editor;\r\n        const body = editor.getBody();\r\n        const element = editor.getElement();\r\n        if (body) {\r\n          editor.save({ is_removing: true });\r\n        }\r\n        editor.removed = true;\r\n        editor.unbindAllNativeEvents();\r\n        if (editor.hasHiddenInput && isNonNullable(element === null || element === void 0 ? void 0 : element.nextSibling)) {\r\n          DOM$8.remove(element.nextSibling);\r\n        }\r\n        fireRemove(editor);\r\n        editor.editorManager.remove(editor);\r\n        if (!editor.inline && body) {\r\n          restoreOriginalStyles(editor);\r\n        }\r\n        fireDetach(editor);\r\n        DOM$8.remove(editor.getContainer());\r\n        safeDestroy(_selectionOverrides);\r\n        safeDestroy(editorUpload);\r\n        editor.destroy();\r\n      }\r\n    };\r\n    const destroy = (editor, automatic) => {\r\n      const {selection, dom} = editor;\r\n      if (editor.destroyed) {\r\n        return;\r\n      }\r\n      if (!automatic && !editor.removed) {\r\n        editor.remove();\r\n        return;\r\n      }\r\n      if (!automatic) {\r\n        editor.editorManager.off('beforeunload', editor._beforeUnload);\r\n        if (editor.theme && editor.theme.destroy) {\r\n          editor.theme.destroy();\r\n        }\r\n        safeDestroy(selection);\r\n        safeDestroy(dom);\r\n      }\r\n      restoreForm(editor);\r\n      clearDomReferences(editor);\r\n      editor.destroyed = true;\r\n    };\r\n\r\n    const CreateIconManager = () => {\r\n      const lookup = {};\r\n      const add = (id, iconPack) => {\r\n        lookup[id] = iconPack;\r\n      };\r\n      const get = id => {\r\n        if (lookup[id]) {\r\n          return lookup[id];\r\n        } else {\r\n          return { icons: {} };\r\n        }\r\n      };\r\n      const has = id => has$2(lookup, id);\r\n      return {\r\n        add,\r\n        get,\r\n        has\r\n      };\r\n    };\r\n    const IconManager = CreateIconManager();\r\n\r\n    const ModelManager = AddOnManager.ModelManager;\r\n\r\n    const getProp = (propName, elm) => {\r\n      const rawElm = elm.dom;\r\n      return rawElm[propName];\r\n    };\r\n    const getComputedSizeProp = (propName, elm) => parseInt(get$7(elm, propName), 10);\r\n    const getClientWidth = curry(getProp, 'clientWidth');\r\n    const getClientHeight = curry(getProp, 'clientHeight');\r\n    const getMarginTop = curry(getComputedSizeProp, 'margin-top');\r\n    const getMarginLeft = curry(getComputedSizeProp, 'margin-left');\r\n    const getBoundingClientRect = elm => elm.dom.getBoundingClientRect();\r\n    const isInsideElementContentArea = (bodyElm, clientX, clientY) => {\r\n      const clientWidth = getClientWidth(bodyElm);\r\n      const clientHeight = getClientHeight(bodyElm);\r\n      return clientX >= 0 && clientY >= 0 && clientX <= clientWidth && clientY <= clientHeight;\r\n    };\r\n    const transpose = (inline, elm, clientX, clientY) => {\r\n      const clientRect = getBoundingClientRect(elm);\r\n      const deltaX = inline ? clientRect.left + elm.dom.clientLeft + getMarginLeft(elm) : 0;\r\n      const deltaY = inline ? clientRect.top + elm.dom.clientTop + getMarginTop(elm) : 0;\r\n      const x = clientX - deltaX;\r\n      const y = clientY - deltaY;\r\n      return {\r\n        x,\r\n        y\r\n      };\r\n    };\r\n    const isXYInContentArea = (editor, clientX, clientY) => {\r\n      const bodyElm = SugarElement.fromDom(editor.getBody());\r\n      const targetElm = editor.inline ? bodyElm : documentElement(bodyElm);\r\n      const transposedPoint = transpose(editor.inline, targetElm, clientX, clientY);\r\n      return isInsideElementContentArea(targetElm, transposedPoint.x, transposedPoint.y);\r\n    };\r\n    const fromDomSafe = node => Optional.from(node).map(SugarElement.fromDom);\r\n    const isEditorAttachedToDom = editor => {\r\n      const rawContainer = editor.inline ? editor.getBody() : editor.getContentAreaContainer();\r\n      return fromDomSafe(rawContainer).map(inBody).getOr(false);\r\n    };\r\n\r\n    var NotificationManagerImpl = () => {\r\n      const unimplemented = () => {\r\n        throw new Error('Theme did not provide a NotificationManager implementation.');\r\n      };\r\n      return {\r\n        open: unimplemented,\r\n        close: unimplemented,\r\n        getArgs: unimplemented\r\n      };\r\n    };\r\n\r\n    const NotificationManager = editor => {\r\n      const notifications = [];\r\n      const getImplementation = () => {\r\n        const theme = editor.theme;\r\n        return theme && theme.getNotificationManagerImpl ? theme.getNotificationManagerImpl() : NotificationManagerImpl();\r\n      };\r\n      const getTopNotification = () => {\r\n        return Optional.from(notifications[0]);\r\n      };\r\n      const isEqual = (a, b) => {\r\n        return a.type === b.type && a.text === b.text && !a.progressBar && !a.timeout && !b.progressBar && !b.timeout;\r\n      };\r\n      const reposition = () => {\r\n        each$e(notifications, notification => {\r\n          notification.reposition();\r\n        });\r\n      };\r\n      const addNotification = notification => {\r\n        notifications.push(notification);\r\n      };\r\n      const closeNotification = notification => {\r\n        findIndex$2(notifications, otherNotification => {\r\n          return otherNotification === notification;\r\n        }).each(index => {\r\n          notifications.splice(index, 1);\r\n        });\r\n      };\r\n      const open = (spec, fireEvent = true) => {\r\n        if (editor.removed || !isEditorAttachedToDom(editor)) {\r\n          return {};\r\n        }\r\n        if (fireEvent) {\r\n          editor.dispatch('BeforeOpenNotification', { notification: spec });\r\n        }\r\n        return find$2(notifications, notification => {\r\n          return isEqual(getImplementation().getArgs(notification), spec);\r\n        }).getOrThunk(() => {\r\n          editor.editorManager.setActive(editor);\r\n          const notification = getImplementation().open(spec, () => {\r\n            closeNotification(notification);\r\n            reposition();\r\n            if (hasEditorOrUiFocus(editor)) {\r\n              getTopNotification().fold(() => editor.focus(), top => focus$1(SugarElement.fromDom(top.getEl())));\r\n            }\r\n          });\r\n          addNotification(notification);\r\n          reposition();\r\n          editor.dispatch('OpenNotification', { notification: { ...notification } });\r\n          return notification;\r\n        });\r\n      };\r\n      const close = () => {\r\n        getTopNotification().each(notification => {\r\n          getImplementation().close(notification);\r\n          closeNotification(notification);\r\n          reposition();\r\n        });\r\n      };\r\n      const getNotifications = constant(notifications);\r\n      const registerEvents = editor => {\r\n        editor.on('SkinLoaded', () => {\r\n          const serviceMessage = getServiceMessage(editor);\r\n          if (serviceMessage) {\r\n            open({\r\n              text: serviceMessage,\r\n              type: 'warning',\r\n              timeout: 0\r\n            }, false);\r\n          }\r\n          reposition();\r\n        });\r\n        editor.on('show ResizeEditor ResizeWindow NodeChange', () => {\r\n          requestAnimationFrame(reposition);\r\n        });\r\n        editor.on('remove', () => {\r\n          each$e(notifications.slice(), notification => {\r\n            getImplementation().close(notification);\r\n          });\r\n        });\r\n      };\r\n      registerEvents(editor);\r\n      return {\r\n        open,\r\n        close,\r\n        getNotifications\r\n      };\r\n    };\r\n\r\n    const PluginManager = AddOnManager.PluginManager;\r\n\r\n    const ThemeManager = AddOnManager.ThemeManager;\r\n\r\n    var WindowManagerImpl = () => {\r\n      const unimplemented = () => {\r\n        throw new Error('Theme did not provide a WindowManager implementation.');\r\n      };\r\n      return {\r\n        open: unimplemented,\r\n        openUrl: unimplemented,\r\n        alert: unimplemented,\r\n        confirm: unimplemented,\r\n        close: unimplemented\r\n      };\r\n    };\r\n\r\n    const WindowManager = editor => {\r\n      let dialogs = [];\r\n      const getImplementation = () => {\r\n        const theme = editor.theme;\r\n        return theme && theme.getWindowManagerImpl ? theme.getWindowManagerImpl() : WindowManagerImpl();\r\n      };\r\n      const funcBind = (scope, f) => {\r\n        return (...args) => {\r\n          return f ? f.apply(scope, args) : undefined;\r\n        };\r\n      };\r\n      const fireOpenEvent = dialog => {\r\n        editor.dispatch('OpenWindow', { dialog });\r\n      };\r\n      const fireCloseEvent = dialog => {\r\n        editor.dispatch('CloseWindow', { dialog });\r\n      };\r\n      const addDialog = dialog => {\r\n        dialogs.push(dialog);\r\n        fireOpenEvent(dialog);\r\n      };\r\n      const closeDialog = dialog => {\r\n        fireCloseEvent(dialog);\r\n        dialogs = filter$5(dialogs, otherDialog => {\r\n          return otherDialog !== dialog;\r\n        });\r\n        if (dialogs.length === 0) {\r\n          editor.focus();\r\n        }\r\n      };\r\n      const getTopDialog = () => {\r\n        return Optional.from(dialogs[dialogs.length - 1]);\r\n      };\r\n      const storeSelectionAndOpenDialog = openDialog => {\r\n        editor.editorManager.setActive(editor);\r\n        store(editor);\r\n        editor.ui.show();\r\n        const dialog = openDialog();\r\n        addDialog(dialog);\r\n        return dialog;\r\n      };\r\n      const open = (args, params) => {\r\n        return storeSelectionAndOpenDialog(() => getImplementation().open(args, params, closeDialog));\r\n      };\r\n      const openUrl = args => {\r\n        return storeSelectionAndOpenDialog(() => getImplementation().openUrl(args, closeDialog));\r\n      };\r\n      const alert = (message, callback, scope) => {\r\n        const windowManagerImpl = getImplementation();\r\n        windowManagerImpl.alert(message, funcBind(scope ? scope : windowManagerImpl, callback));\r\n      };\r\n      const confirm = (message, callback, scope) => {\r\n        const windowManagerImpl = getImplementation();\r\n        windowManagerImpl.confirm(message, funcBind(scope ? scope : windowManagerImpl, callback));\r\n      };\r\n      const close = () => {\r\n        getTopDialog().each(dialog => {\r\n          getImplementation().close(dialog);\r\n          closeDialog(dialog);\r\n        });\r\n      };\r\n      editor.on('remove', () => {\r\n        each$e(dialogs, dialog => {\r\n          getImplementation().close(dialog);\r\n        });\r\n      });\r\n      return {\r\n        open,\r\n        openUrl,\r\n        alert,\r\n        confirm,\r\n        close\r\n      };\r\n    };\r\n\r\n    const displayNotification = (editor, message) => {\r\n      editor.notificationManager.open({\r\n        type: 'error',\r\n        text: message\r\n      });\r\n    };\r\n    const displayError = (editor, message) => {\r\n      if (editor._skinLoaded) {\r\n        displayNotification(editor, message);\r\n      } else {\r\n        editor.on('SkinLoaded', () => {\r\n          displayNotification(editor, message);\r\n        });\r\n      }\r\n    };\r\n    const uploadError = (editor, message) => {\r\n      displayError(editor, I18n.translate([\r\n        'Failed to upload image: {0}',\r\n        message\r\n      ]));\r\n    };\r\n    const logError = (editor, errorType, msg) => {\r\n      fireError(editor, errorType, { message: msg });\r\n      console.error(msg);\r\n    };\r\n    const createLoadError = (type, url, name) => name ? `Failed to load ${ type }: ${ name } from url ${ url }` : `Failed to load ${ type } url: ${ url }`;\r\n    const pluginLoadError = (editor, url, name) => {\r\n      logError(editor, 'PluginLoadError', createLoadError('plugin', url, name));\r\n    };\r\n    const iconsLoadError = (editor, url, name) => {\r\n      logError(editor, 'IconsLoadError', createLoadError('icons', url, name));\r\n    };\r\n    const languageLoadError = (editor, url, name) => {\r\n      logError(editor, 'LanguageLoadError', createLoadError('language', url, name));\r\n    };\r\n    const themeLoadError = (editor, url, name) => {\r\n      logError(editor, 'ThemeLoadError', createLoadError('theme', url, name));\r\n    };\r\n    const modelLoadError = (editor, url, name) => {\r\n      logError(editor, 'ModelLoadError', createLoadError('model', url, name));\r\n    };\r\n    const pluginInitError = (editor, name, err) => {\r\n      const message = I18n.translate([\r\n        'Failed to initialize plugin: {0}',\r\n        name\r\n      ]);\r\n      fireError(editor, 'PluginLoadError', { message });\r\n      initError(message, err);\r\n      displayError(editor, message);\r\n    };\r\n    const initError = (message, ...x) => {\r\n      const console = window.console;\r\n      if (console) {\r\n        if (console.error) {\r\n          console.error(message, ...x);\r\n        } else {\r\n          console.log(message, ...x);\r\n        }\r\n      }\r\n    };\r\n\r\n    const isContentCssSkinName = url => /^[a-z0-9\\-]+$/i.test(url);\r\n    const toContentSkinResourceName = url => 'content/' + url + '/content.css';\r\n    const isBundledCssSkinName = url => tinymce.Resource.has(toContentSkinResourceName(url));\r\n    const getContentCssUrls = editor => {\r\n      return transformToUrls(editor, getContentCss(editor));\r\n    };\r\n    const getFontCssUrls = editor => {\r\n      return transformToUrls(editor, getFontCss(editor));\r\n    };\r\n    const transformToUrls = (editor, cssLinks) => {\r\n      const skinUrl = editor.editorManager.baseURL + '/skins/content';\r\n      const suffix = editor.editorManager.suffix;\r\n      const contentCssFile = `content${ suffix }.css`;\r\n      return map$3(cssLinks, url => {\r\n        if (isBundledCssSkinName(url)) {\r\n          return url;\r\n        } else if (isContentCssSkinName(url) && !editor.inline) {\r\n          return `${ skinUrl }/${ url }/${ contentCssFile }`;\r\n        } else {\r\n          return editor.documentBaseURI.toAbsolute(url);\r\n        }\r\n      });\r\n    };\r\n    const appendContentCssFromSettings = editor => {\r\n      editor.contentCSS = editor.contentCSS.concat(getContentCssUrls(editor), getFontCssUrls(editor));\r\n    };\r\n\r\n    const getAllImages = elm => {\r\n      return elm ? from(elm.getElementsByTagName('img')) : [];\r\n    };\r\n    const ImageScanner = (uploadStatus, blobCache) => {\r\n      const cachedPromises = {};\r\n      const findAll = (elm, predicate = always) => {\r\n        const images = filter$5(getAllImages(elm), img => {\r\n          const src = img.src;\r\n          if (img.hasAttribute('data-mce-bogus')) {\r\n            return false;\r\n          }\r\n          if (img.hasAttribute('data-mce-placeholder')) {\r\n            return false;\r\n          }\r\n          if (!src || src === Env.transparentSrc) {\r\n            return false;\r\n          }\r\n          if (startsWith(src, 'blob:')) {\r\n            return !uploadStatus.isUploaded(src) && predicate(img);\r\n          }\r\n          if (startsWith(src, 'data:')) {\r\n            return predicate(img);\r\n          }\r\n          return false;\r\n        });\r\n        const promises = map$3(images, img => {\r\n          const imageSrc = img.src;\r\n          if (has$2(cachedPromises, imageSrc)) {\r\n            return cachedPromises[imageSrc].then(imageInfo => {\r\n              if (isString(imageInfo)) {\r\n                return imageInfo;\r\n              } else {\r\n                return {\r\n                  image: img,\r\n                  blobInfo: imageInfo.blobInfo\r\n                };\r\n              }\r\n            });\r\n          } else {\r\n            const newPromise = imageToBlobInfo(blobCache, imageSrc).then(blobInfo => {\r\n              delete cachedPromises[imageSrc];\r\n              return {\r\n                image: img,\r\n                blobInfo\r\n              };\r\n            }).catch(error => {\r\n              delete cachedPromises[imageSrc];\r\n              return error;\r\n            });\r\n            cachedPromises[imageSrc] = newPromise;\r\n            return newPromise;\r\n          }\r\n        });\r\n        return Promise.all(promises);\r\n      };\r\n      return { findAll };\r\n    };\r\n\r\n    const UploadStatus = () => {\r\n      const PENDING = 1, UPLOADED = 2;\r\n      let blobUriStatuses = {};\r\n      const createStatus = (status, resultUri) => {\r\n        return {\r\n          status,\r\n          resultUri\r\n        };\r\n      };\r\n      const hasBlobUri = blobUri => {\r\n        return blobUri in blobUriStatuses;\r\n      };\r\n      const getResultUri = blobUri => {\r\n        const result = blobUriStatuses[blobUri];\r\n        return result ? result.resultUri : null;\r\n      };\r\n      const isPending = blobUri => {\r\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === PENDING : false;\r\n      };\r\n      const isUploaded = blobUri => {\r\n        return hasBlobUri(blobUri) ? blobUriStatuses[blobUri].status === UPLOADED : false;\r\n      };\r\n      const markPending = blobUri => {\r\n        blobUriStatuses[blobUri] = createStatus(PENDING, null);\r\n      };\r\n      const markUploaded = (blobUri, resultUri) => {\r\n        blobUriStatuses[blobUri] = createStatus(UPLOADED, resultUri);\r\n      };\r\n      const removeFailed = blobUri => {\r\n        delete blobUriStatuses[blobUri];\r\n      };\r\n      const destroy = () => {\r\n        blobUriStatuses = {};\r\n      };\r\n      return {\r\n        hasBlobUri,\r\n        getResultUri,\r\n        isPending,\r\n        isUploaded,\r\n        markPending,\r\n        markUploaded,\r\n        removeFailed,\r\n        destroy\r\n      };\r\n    };\r\n\r\n    let count = 0;\r\n    const seed = () => {\r\n      const rnd = () => {\r\n        return Math.round(Math.random() * 4294967295).toString(36);\r\n      };\r\n      const now = new Date().getTime();\r\n      return 's' + now.toString(36) + rnd() + rnd() + rnd();\r\n    };\r\n    const uuid = prefix => {\r\n      return prefix + count++ + seed();\r\n    };\r\n\r\n    const BlobCache = () => {\r\n      let cache = [];\r\n      const mimeToExt = mime => {\r\n        const mimes = {\r\n          'image/jpeg': 'jpg',\r\n          'image/jpg': 'jpg',\r\n          'image/gif': 'gif',\r\n          'image/png': 'png',\r\n          'image/apng': 'apng',\r\n          'image/avif': 'avif',\r\n          'image/svg+xml': 'svg',\r\n          'image/webp': 'webp',\r\n          'image/bmp': 'bmp',\r\n          'image/tiff': 'tiff'\r\n        };\r\n        return mimes[mime.toLowerCase()] || 'dat';\r\n      };\r\n      const create = (o, blob, base64, name, filename) => {\r\n        if (isString(o)) {\r\n          const id = o;\r\n          return toBlobInfo({\r\n            id,\r\n            name,\r\n            filename,\r\n            blob: blob,\r\n            base64: base64\r\n          });\r\n        } else if (isObject(o)) {\r\n          return toBlobInfo(o);\r\n        } else {\r\n          throw new Error('Unknown input type');\r\n        }\r\n      };\r\n      const toBlobInfo = o => {\r\n        if (!o.blob || !o.base64) {\r\n          throw new Error('blob and base64 representations of the image are required for BlobInfo to be created');\r\n        }\r\n        const id = o.id || uuid('blobid');\r\n        const name = o.name || id;\r\n        const blob = o.blob;\r\n        return {\r\n          id: constant(id),\r\n          name: constant(name),\r\n          filename: constant(o.filename || name + '.' + mimeToExt(blob.type)),\r\n          blob: constant(blob),\r\n          base64: constant(o.base64),\r\n          blobUri: constant(o.blobUri || URL.createObjectURL(blob)),\r\n          uri: constant(o.uri)\r\n        };\r\n      };\r\n      const add = blobInfo => {\r\n        if (!get(blobInfo.id())) {\r\n          cache.push(blobInfo);\r\n        }\r\n      };\r\n      const findFirst = predicate => find$2(cache, predicate).getOrUndefined();\r\n      const get = id => findFirst(cachedBlobInfo => cachedBlobInfo.id() === id);\r\n      const getByUri = blobUri => findFirst(blobInfo => blobInfo.blobUri() === blobUri);\r\n      const getByData = (base64, type) => findFirst(blobInfo => blobInfo.base64() === base64 && blobInfo.blob().type === type);\r\n      const removeByUri = blobUri => {\r\n        cache = filter$5(cache, blobInfo => {\r\n          if (blobInfo.blobUri() === blobUri) {\r\n            URL.revokeObjectURL(blobInfo.blobUri());\r\n            return false;\r\n          }\r\n          return true;\r\n        });\r\n      };\r\n      const destroy = () => {\r\n        each$e(cache, cachedBlobInfo => {\r\n          URL.revokeObjectURL(cachedBlobInfo.blobUri());\r\n        });\r\n        cache = [];\r\n      };\r\n      return {\r\n        create,\r\n        add,\r\n        get,\r\n        getByUri,\r\n        getByData,\r\n        findFirst,\r\n        removeByUri,\r\n        destroy\r\n      };\r\n    };\r\n\r\n    const Uploader = (uploadStatus, settings) => {\r\n      const pendingPromises = {};\r\n      const pathJoin = (path1, path2) => {\r\n        if (path1) {\r\n          return path1.replace(/\\/$/, '') + '/' + path2.replace(/^\\//, '');\r\n        }\r\n        return path2;\r\n      };\r\n      const defaultHandler = (blobInfo, progress) => new Promise((success, failure) => {\r\n        const xhr = new XMLHttpRequest();\r\n        xhr.open('POST', settings.url);\r\n        xhr.withCredentials = settings.credentials;\r\n        xhr.upload.onprogress = e => {\r\n          progress(e.loaded / e.total * 100);\r\n        };\r\n        xhr.onerror = () => {\r\n          failure('Image upload failed due to a XHR Transport error. Code: ' + xhr.status);\r\n        };\r\n        xhr.onload = () => {\r\n          if (xhr.status < 200 || xhr.status >= 300) {\r\n            failure('HTTP Error: ' + xhr.status);\r\n            return;\r\n          }\r\n          const json = JSON.parse(xhr.responseText);\r\n          if (!json || !isString(json.location)) {\r\n            failure('Invalid JSON: ' + xhr.responseText);\r\n            return;\r\n          }\r\n          success(pathJoin(settings.basePath, json.location));\r\n        };\r\n        const formData = new FormData();\r\n        formData.append('file', blobInfo.blob(), blobInfo.filename());\r\n        xhr.send(formData);\r\n      });\r\n      const uploadHandler = isFunction(settings.handler) ? settings.handler : defaultHandler;\r\n      const noUpload = () => new Promise(resolve => {\r\n        resolve([]);\r\n      });\r\n      const handlerSuccess = (blobInfo, url) => ({\r\n        url,\r\n        blobInfo,\r\n        status: true\r\n      });\r\n      const handlerFailure = (blobInfo, error) => ({\r\n        url: '',\r\n        blobInfo,\r\n        status: false,\r\n        error\r\n      });\r\n      const resolvePending = (blobUri, result) => {\r\n        Tools.each(pendingPromises[blobUri], resolve => {\r\n          resolve(result);\r\n        });\r\n        delete pendingPromises[blobUri];\r\n      };\r\n      const uploadBlobInfo = (blobInfo, handler, openNotification) => {\r\n        uploadStatus.markPending(blobInfo.blobUri());\r\n        return new Promise(resolve => {\r\n          let notification;\r\n          let progress;\r\n          try {\r\n            const closeNotification = () => {\r\n              if (notification) {\r\n                notification.close();\r\n                progress = noop;\r\n              }\r\n            };\r\n            const success = url => {\r\n              closeNotification();\r\n              uploadStatus.markUploaded(blobInfo.blobUri(), url);\r\n              resolvePending(blobInfo.blobUri(), handlerSuccess(blobInfo, url));\r\n              resolve(handlerSuccess(blobInfo, url));\r\n            };\r\n            const failure = error => {\r\n              closeNotification();\r\n              uploadStatus.removeFailed(blobInfo.blobUri());\r\n              resolvePending(blobInfo.blobUri(), handlerFailure(blobInfo, error));\r\n              resolve(handlerFailure(blobInfo, error));\r\n            };\r\n            progress = percent => {\r\n              if (percent < 0 || percent > 100) {\r\n                return;\r\n              }\r\n              Optional.from(notification).orThunk(() => Optional.from(openNotification).map(apply$1)).each(n => {\r\n                notification = n;\r\n                n.progressBar.value(percent);\r\n              });\r\n            };\r\n            handler(blobInfo, progress).then(success, err => {\r\n              failure(isString(err) ? { message: err } : err);\r\n            });\r\n          } catch (ex) {\r\n            resolve(handlerFailure(blobInfo, ex));\r\n          }\r\n        });\r\n      };\r\n      const isDefaultHandler = handler => handler === defaultHandler;\r\n      const pendingUploadBlobInfo = blobInfo => {\r\n        const blobUri = blobInfo.blobUri();\r\n        return new Promise(resolve => {\r\n          pendingPromises[blobUri] = pendingPromises[blobUri] || [];\r\n          pendingPromises[blobUri].push(resolve);\r\n        });\r\n      };\r\n      const uploadBlobs = (blobInfos, openNotification) => {\r\n        blobInfos = Tools.grep(blobInfos, blobInfo => !uploadStatus.isUploaded(blobInfo.blobUri()));\r\n        return Promise.all(Tools.map(blobInfos, blobInfo => uploadStatus.isPending(blobInfo.blobUri()) ? pendingUploadBlobInfo(blobInfo) : uploadBlobInfo(blobInfo, uploadHandler, openNotification)));\r\n      };\r\n      const upload = (blobInfos, openNotification) => !settings.url && isDefaultHandler(uploadHandler) ? noUpload() : uploadBlobs(blobInfos, openNotification);\r\n      return { upload };\r\n    };\r\n\r\n    const openNotification = editor => () => editor.notificationManager.open({\r\n      text: editor.translate('Image uploading...'),\r\n      type: 'info',\r\n      timeout: -1,\r\n      progressBar: true\r\n    });\r\n    const createUploader = (editor, uploadStatus) => Uploader(uploadStatus, {\r\n      url: getImageUploadUrl(editor),\r\n      basePath: getImageUploadBasePath(editor),\r\n      credentials: getImagesUploadCredentials(editor),\r\n      handler: getImagesUploadHandler(editor)\r\n    });\r\n    const ImageUploader = editor => {\r\n      const uploadStatus = UploadStatus();\r\n      const uploader = createUploader(editor, uploadStatus);\r\n      return { upload: (blobInfos, showNotification = true) => uploader.upload(blobInfos, showNotification ? openNotification(editor) : undefined) };\r\n    };\r\n\r\n    const isEmptyForPadding = (editor, element) => editor.dom.isEmpty(element.dom) && isNonNullable(editor.schema.getTextBlockElements()[name(element)]);\r\n    const addPaddingToEmpty = editor => element => {\r\n      if (isEmptyForPadding(editor, element)) {\r\n        append$1(element, SugarElement.fromHtml('<br data-mce-bogus=\"1\" />'));\r\n      }\r\n    };\r\n    const EditorUpload = editor => {\r\n      const blobCache = BlobCache();\r\n      let uploader, imageScanner;\r\n      const uploadStatus = UploadStatus();\r\n      const urlFilters = [];\r\n      const aliveGuard = callback => {\r\n        return result => {\r\n          if (editor.selection) {\r\n            return callback(result);\r\n          }\r\n          return [];\r\n        };\r\n      };\r\n      const cacheInvalidator = url => url + (url.indexOf('?') === -1 ? '?' : '&') + new Date().getTime();\r\n      const replaceString = (content, search, replace) => {\r\n        let index = 0;\r\n        do {\r\n          index = content.indexOf(search, index);\r\n          if (index !== -1) {\r\n            content = content.substring(0, index) + replace + content.substr(index + search.length);\r\n            index += replace.length - search.length + 1;\r\n          }\r\n        } while (index !== -1);\r\n        return content;\r\n      };\r\n      const replaceImageUrl = (content, targetUrl, replacementUrl) => {\r\n        const replacementString = `src=\"${ replacementUrl }\"${ replacementUrl === Env.transparentSrc ? ' data-mce-placeholder=\"1\"' : '' }`;\r\n        content = replaceString(content, `src=\"${ targetUrl }\"`, replacementString);\r\n        content = replaceString(content, 'data-mce-src=\"' + targetUrl + '\"', 'data-mce-src=\"' + replacementUrl + '\"');\r\n        return content;\r\n      };\r\n      const replaceUrlInUndoStack = (targetUrl, replacementUrl) => {\r\n        each$e(editor.undoManager.data, level => {\r\n          if (level.type === 'fragmented') {\r\n            level.fragments = map$3(level.fragments, fragment => replaceImageUrl(fragment, targetUrl, replacementUrl));\r\n          } else {\r\n            level.content = replaceImageUrl(level.content, targetUrl, replacementUrl);\r\n          }\r\n        });\r\n      };\r\n      const replaceImageUriInView = (image, resultUri) => {\r\n        const src = editor.convertURL(resultUri, 'src');\r\n        replaceUrlInUndoStack(image.src, resultUri);\r\n        setAll$1(SugarElement.fromDom(image), {\r\n          'src': shouldReuseFileName(editor) ? cacheInvalidator(resultUri) : resultUri,\r\n          'data-mce-src': src\r\n        });\r\n      };\r\n      const uploadImages = () => {\r\n        if (!uploader) {\r\n          uploader = createUploader(editor, uploadStatus);\r\n        }\r\n        return scanForImages().then(aliveGuard(imageInfos => {\r\n          const blobInfos = map$3(imageInfos, imageInfo => imageInfo.blobInfo);\r\n          return uploader.upload(blobInfos, openNotification(editor)).then(aliveGuard(result => {\r\n            const imagesToRemove = [];\r\n            let shouldDispatchChange = false;\r\n            const filteredResult = map$3(result, (uploadInfo, index) => {\r\n              const {blobInfo, image} = imageInfos[index];\r\n              let removed = false;\r\n              if (uploadInfo.status && shouldReplaceBlobUris(editor)) {\r\n                if (uploadInfo.url && !contains$1(image.src, uploadInfo.url)) {\r\n                  shouldDispatchChange = true;\r\n                }\r\n                blobCache.removeByUri(image.src);\r\n                if (isRtc(editor)) ; else {\r\n                  replaceImageUriInView(image, uploadInfo.url);\r\n                }\r\n              } else if (uploadInfo.error) {\r\n                if (uploadInfo.error.remove) {\r\n                  replaceUrlInUndoStack(image.src, Env.transparentSrc);\r\n                  imagesToRemove.push(image);\r\n                  removed = true;\r\n                }\r\n                uploadError(editor, uploadInfo.error.message);\r\n              }\r\n              return {\r\n                element: image,\r\n                status: uploadInfo.status,\r\n                uploadUri: uploadInfo.url,\r\n                blobInfo,\r\n                removed\r\n              };\r\n            });\r\n            if (imagesToRemove.length > 0 && !isRtc(editor)) {\r\n              editor.undoManager.transact(() => {\r\n                each$e(fromDom$1(imagesToRemove), sugarElement => {\r\n                  const parentOpt = parent(sugarElement);\r\n                  remove$5(sugarElement);\r\n                  parentOpt.each(addPaddingToEmpty(editor));\r\n                  blobCache.removeByUri(sugarElement.dom.src);\r\n                });\r\n              });\r\n            } else if (shouldDispatchChange) {\r\n              editor.undoManager.dispatchChange();\r\n            }\r\n            return filteredResult;\r\n          }));\r\n        }));\r\n      };\r\n      const uploadImagesAuto = () => isAutomaticUploadsEnabled(editor) ? uploadImages() : Promise.resolve([]);\r\n      const isValidDataUriImage = imgElm => forall(urlFilters, filter => filter(imgElm));\r\n      const addFilter = filter => {\r\n        urlFilters.push(filter);\r\n      };\r\n      const scanForImages = () => {\r\n        if (!imageScanner) {\r\n          imageScanner = ImageScanner(uploadStatus, blobCache);\r\n        }\r\n        return imageScanner.findAll(editor.getBody(), isValidDataUriImage).then(aliveGuard(result => {\r\n          const filteredResult = filter$5(result, resultItem => {\r\n            if (isString(resultItem)) {\r\n              displayError(editor, resultItem);\r\n              return false;\r\n            } else if (resultItem.uriType === 'blob') {\r\n              return false;\r\n            } else {\r\n              return true;\r\n            }\r\n          });\r\n          if (isRtc(editor)) ; else {\r\n            each$e(filteredResult, resultItem => {\r\n              replaceUrlInUndoStack(resultItem.image.src, resultItem.blobInfo.blobUri());\r\n              resultItem.image.src = resultItem.blobInfo.blobUri();\r\n              resultItem.image.removeAttribute('data-mce-src');\r\n            });\r\n          }\r\n          return filteredResult;\r\n        }));\r\n      };\r\n      const destroy = () => {\r\n        blobCache.destroy();\r\n        uploadStatus.destroy();\r\n        imageScanner = uploader = null;\r\n      };\r\n      const replaceBlobUris = content => {\r\n        return content.replace(/src=\"(blob:[^\"]+)\"/g, (match, blobUri) => {\r\n          const resultUri = uploadStatus.getResultUri(blobUri);\r\n          if (resultUri) {\r\n            return 'src=\"' + resultUri + '\"';\r\n          }\r\n          let blobInfo = blobCache.getByUri(blobUri);\r\n          if (!blobInfo) {\r\n            blobInfo = foldl(editor.editorManager.get(), (result, editor) => {\r\n              return result || editor.editorUpload && editor.editorUpload.blobCache.getByUri(blobUri);\r\n            }, undefined);\r\n          }\r\n          if (blobInfo) {\r\n            const blob = blobInfo.blob();\r\n            return 'src=\"data:' + blob.type + ';base64,' + blobInfo.base64() + '\"';\r\n          }\r\n          return match;\r\n        });\r\n      };\r\n      editor.on('SetContent', () => {\r\n        if (isAutomaticUploadsEnabled(editor)) {\r\n          uploadImagesAuto();\r\n        } else {\r\n          scanForImages();\r\n        }\r\n      });\r\n      editor.on('RawSaveContent', e => {\r\n        e.content = replaceBlobUris(e.content);\r\n      });\r\n      editor.on('GetContent', e => {\r\n        if (e.source_view || e.format === 'raw' || e.format === 'tree') {\r\n          return;\r\n        }\r\n        e.content = replaceBlobUris(e.content);\r\n      });\r\n      editor.on('PostRender', () => {\r\n        editor.parser.addNodeFilter('img', images => {\r\n          each$e(images, img => {\r\n            const src = img.attr('src');\r\n            if (!src || blobCache.getByUri(src)) {\r\n              return;\r\n            }\r\n            const resultUri = uploadStatus.getResultUri(src);\r\n            if (resultUri) {\r\n              img.attr('src', resultUri);\r\n            }\r\n          });\r\n        });\r\n      });\r\n      return {\r\n        blobCache,\r\n        addFilter,\r\n        uploadImages,\r\n        uploadImagesAuto,\r\n        scanForImages,\r\n        destroy\r\n      };\r\n    };\r\n\r\n    const get$1 = editor => {\r\n      const dom = editor.dom;\r\n      const schemaType = editor.schema.type;\r\n      const formats = {\r\n        valigntop: [{\r\n            selector: 'td,th',\r\n            styles: { verticalAlign: 'top' }\r\n          }],\r\n        valignmiddle: [{\r\n            selector: 'td,th',\r\n            styles: { verticalAlign: 'middle' }\r\n          }],\r\n        valignbottom: [{\r\n            selector: 'td,th',\r\n            styles: { verticalAlign: 'bottom' }\r\n          }],\r\n        alignleft: [\r\n          {\r\n            selector: 'figure.image',\r\n            collapsed: false,\r\n            classes: 'align-left',\r\n            ceFalseOverride: true,\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\r\n            styles: { textAlign: 'left' },\r\n            inherit: false,\r\n            preview: false\r\n          },\r\n          {\r\n            selector: 'img,audio,video',\r\n            collapsed: false,\r\n            styles: { float: 'left' },\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: 'table',\r\n            collapsed: false,\r\n            styles: {\r\n              marginLeft: '0px',\r\n              marginRight: 'auto'\r\n            },\r\n            onformat: table => {\r\n              dom.setStyle(table, 'float', null);\r\n            },\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\r\n            ceFalseOverride: true,\r\n            styles: { float: 'left' }\r\n          }\r\n        ],\r\n        aligncenter: [\r\n          {\r\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\r\n            styles: { textAlign: 'center' },\r\n            inherit: false,\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: 'figure.image',\r\n            collapsed: false,\r\n            classes: 'align-center',\r\n            ceFalseOverride: true,\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: 'img,audio,video',\r\n            collapsed: false,\r\n            styles: {\r\n              display: 'block',\r\n              marginLeft: 'auto',\r\n              marginRight: 'auto'\r\n            },\r\n            preview: false\r\n          },\r\n          {\r\n            selector: 'table',\r\n            collapsed: false,\r\n            styles: {\r\n              marginLeft: 'auto',\r\n              marginRight: 'auto'\r\n            },\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: '.mce-preview-object',\r\n            ceFalseOverride: true,\r\n            styles: {\r\n              display: 'table',\r\n              marginLeft: 'auto',\r\n              marginRight: 'auto'\r\n            },\r\n            preview: false\r\n          },\r\n          {\r\n            selector: '[data-ephox-embed-iri]',\r\n            ceFalseOverride: true,\r\n            styles: {\r\n              marginLeft: 'auto',\r\n              marginRight: 'auto'\r\n            },\r\n            preview: false\r\n          }\r\n        ],\r\n        alignright: [\r\n          {\r\n            selector: 'figure.image',\r\n            collapsed: false,\r\n            classes: 'align-right',\r\n            ceFalseOverride: true,\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\r\n            styles: { textAlign: 'right' },\r\n            inherit: false,\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: 'img,audio,video',\r\n            collapsed: false,\r\n            styles: { float: 'right' },\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: 'table',\r\n            collapsed: false,\r\n            styles: {\r\n              marginRight: '0px',\r\n              marginLeft: 'auto'\r\n            },\r\n            onformat: table => {\r\n              dom.setStyle(table, 'float', null);\r\n            },\r\n            preview: 'font-family font-size'\r\n          },\r\n          {\r\n            selector: '.mce-preview-object,[data-ephox-embed-iri]',\r\n            ceFalseOverride: true,\r\n            styles: { float: 'right' },\r\n            preview: false\r\n          }\r\n        ],\r\n        alignjustify: [{\r\n            selector: 'figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre',\r\n            styles: { textAlign: 'justify' },\r\n            inherit: false,\r\n            preview: 'font-family font-size'\r\n          }],\r\n        bold: [\r\n          {\r\n            inline: 'strong',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          },\r\n          {\r\n            inline: 'span',\r\n            styles: { fontWeight: 'bold' }\r\n          },\r\n          {\r\n            inline: 'b',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          }\r\n        ],\r\n        italic: [\r\n          {\r\n            inline: 'em',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          },\r\n          {\r\n            inline: 'span',\r\n            styles: { fontStyle: 'italic' }\r\n          },\r\n          {\r\n            inline: 'i',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          }\r\n        ],\r\n        underline: [\r\n          {\r\n            inline: 'span',\r\n            styles: { textDecoration: 'underline' },\r\n            exact: true\r\n          },\r\n          {\r\n            inline: 'u',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          }\r\n        ],\r\n        strikethrough: (() => {\r\n          const span = {\r\n            inline: 'span',\r\n            styles: { textDecoration: 'line-through' },\r\n            exact: true\r\n          };\r\n          const strike = {\r\n            inline: 'strike',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          };\r\n          const s = {\r\n            inline: 's',\r\n            remove: 'all',\r\n            preserve_attributes: [\r\n              'class',\r\n              'style'\r\n            ]\r\n          };\r\n          return schemaType !== 'html4' ? [\r\n            s,\r\n            span,\r\n            strike\r\n          ] : [\r\n            span,\r\n            s,\r\n            strike\r\n          ];\r\n        })(),\r\n        forecolor: {\r\n          inline: 'span',\r\n          styles: { color: '%value' },\r\n          links: true,\r\n          remove_similar: true,\r\n          clear_child_styles: true\r\n        },\r\n        hilitecolor: {\r\n          inline: 'span',\r\n          styles: { backgroundColor: '%value' },\r\n          links: true,\r\n          remove_similar: true,\r\n          clear_child_styles: true\r\n        },\r\n        fontname: {\r\n          inline: 'span',\r\n          toggle: false,\r\n          styles: { fontFamily: '%value' },\r\n          clear_child_styles: true\r\n        },\r\n        fontsize: {\r\n          inline: 'span',\r\n          toggle: false,\r\n          styles: { fontSize: '%value' },\r\n          clear_child_styles: true\r\n        },\r\n        lineheight: {\r\n          selector: 'h1,h2,h3,h4,h5,h6,p,li,td,th,div',\r\n          styles: { lineHeight: '%value' }\r\n        },\r\n        fontsize_class: {\r\n          inline: 'span',\r\n          attributes: { class: '%value' }\r\n        },\r\n        blockquote: {\r\n          block: 'blockquote',\r\n          wrapper: true,\r\n          remove: 'all'\r\n        },\r\n        subscript: { inline: 'sub' },\r\n        superscript: { inline: 'sup' },\r\n        code: { inline: 'code' },\r\n        link: {\r\n          inline: 'a',\r\n          selector: 'a',\r\n          remove: 'all',\r\n          split: true,\r\n          deep: true,\r\n          onmatch: (node, _fmt, _itemName) => {\r\n            return isElement$6(node) && node.hasAttribute('href');\r\n          },\r\n          onformat: (elm, _fmt, vars) => {\r\n            Tools.each(vars, (value, key) => {\r\n              dom.setAttrib(elm, key, value);\r\n            });\r\n          }\r\n        },\r\n        lang: {\r\n          inline: 'span',\r\n          clear_child_styles: true,\r\n          remove_similar: true,\r\n          attributes: {\r\n            'lang': '%value',\r\n            'data-mce-lang': vars => {\r\n              var _a;\r\n              return (_a = vars === null || vars === void 0 ? void 0 : vars.customValue) !== null && _a !== void 0 ? _a : null;\r\n            }\r\n          }\r\n        },\r\n        removeformat: [\r\n          {\r\n            selector: 'b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small',\r\n            remove: 'all',\r\n            split: true,\r\n            expand: false,\r\n            block_expand: true,\r\n            deep: true\r\n          },\r\n          {\r\n            selector: 'span',\r\n            attributes: [\r\n              'style',\r\n              'class'\r\n            ],\r\n            remove: 'empty',\r\n            split: true,\r\n            expand: false,\r\n            deep: true\r\n          },\r\n          {\r\n            selector: '*',\r\n            attributes: [\r\n              'style',\r\n              'class'\r\n            ],\r\n            split: false,\r\n            expand: false,\r\n            deep: true\r\n          }\r\n        ]\r\n      };\r\n      Tools.each('p h1 h2 h3 h4 h5 h6 div address pre dt dd samp'.split(/\\s/), name => {\r\n        formats[name] = {\r\n          block: name,\r\n          remove: 'all'\r\n        };\r\n      });\r\n      return formats;\r\n    };\r\n\r\n    const genericBase = {\r\n      remove_similar: true,\r\n      inherit: false\r\n    };\r\n    const cellBase = {\r\n      selector: 'td,th',\r\n      ...genericBase\r\n    };\r\n    const cellFormats = {\r\n      tablecellbackgroundcolor: {\r\n        styles: { backgroundColor: '%value' },\r\n        ...cellBase\r\n      },\r\n      tablecellverticalalign: {\r\n        styles: { 'vertical-align': '%value' },\r\n        ...cellBase\r\n      },\r\n      tablecellbordercolor: {\r\n        styles: { borderColor: '%value' },\r\n        ...cellBase\r\n      },\r\n      tablecellclass: {\r\n        classes: ['%value'],\r\n        ...cellBase\r\n      },\r\n      tableclass: {\r\n        selector: 'table',\r\n        classes: ['%value'],\r\n        ...genericBase\r\n      },\r\n      tablecellborderstyle: {\r\n        styles: { borderStyle: '%value' },\r\n        ...cellBase\r\n      },\r\n      tablecellborderwidth: {\r\n        styles: { borderWidth: '%value' },\r\n        ...cellBase\r\n      }\r\n    };\r\n    const get = constant(cellFormats);\r\n\r\n    const FormatRegistry = editor => {\r\n      const formats = {};\r\n      const get$2 = name => isNonNullable(name) ? formats[name] : formats;\r\n      const has = name => has$2(formats, name);\r\n      const register = (name, format) => {\r\n        if (name) {\r\n          if (!isString(name)) {\r\n            each$d(name, (format, name) => {\r\n              register(name, format);\r\n            });\r\n          } else {\r\n            if (!isArray$1(format)) {\r\n              format = [format];\r\n            }\r\n            each$e(format, format => {\r\n              if (isUndefined(format.deep)) {\r\n                format.deep = !isSelectorFormat(format);\r\n              }\r\n              if (isUndefined(format.split)) {\r\n                format.split = !isSelectorFormat(format) || isInlineFormat(format);\r\n              }\r\n              if (isUndefined(format.remove) && isSelectorFormat(format) && !isInlineFormat(format)) {\r\n                format.remove = 'none';\r\n              }\r\n              if (isSelectorFormat(format) && isInlineFormat(format)) {\r\n                format.mixed = true;\r\n                format.block_expand = true;\r\n              }\r\n              if (isString(format.classes)) {\r\n                format.classes = format.classes.split(/\\s+/);\r\n              }\r\n            });\r\n            formats[name] = format;\r\n          }\r\n        }\r\n      };\r\n      const unregister = name => {\r\n        if (name && formats[name]) {\r\n          delete formats[name];\r\n        }\r\n        return formats;\r\n      };\r\n      register(get$1(editor));\r\n      register(get());\r\n      register(getFormats(editor));\r\n      return {\r\n        get: get$2,\r\n        has,\r\n        register,\r\n        unregister\r\n      };\r\n    };\r\n\r\n    const each$3 = Tools.each;\r\n    const dom = DOMUtils.DOM;\r\n    const isPreviewItem = item => isNonNullable(item) && isObject(item);\r\n    const parsedSelectorToHtml = (ancestry, editor) => {\r\n      const schema = editor && editor.schema || Schema({});\r\n      const decorate = (elm, item) => {\r\n        if (item.classes.length > 0) {\r\n          dom.addClass(elm, item.classes.join(' '));\r\n        }\r\n        dom.setAttribs(elm, item.attrs);\r\n      };\r\n      const createElement = sItem => {\r\n        const item = isString(sItem) ? {\r\n          name: sItem,\r\n          classes: [],\r\n          attrs: {}\r\n        } : sItem;\r\n        const elm = dom.create(item.name);\r\n        decorate(elm, item);\r\n        return elm;\r\n      };\r\n      const getRequiredParent = (elm, candidate) => {\r\n        const elmRule = schema.getElementRule(elm.nodeName.toLowerCase());\r\n        const parentsRequired = elmRule === null || elmRule === void 0 ? void 0 : elmRule.parentsRequired;\r\n        if (parentsRequired && parentsRequired.length) {\r\n          return candidate && contains$2(parentsRequired, candidate) ? candidate : parentsRequired[0];\r\n        } else {\r\n          return false;\r\n        }\r\n      };\r\n      const wrapInHtml = (elm, ancestors, siblings) => {\r\n        let parentCandidate;\r\n        const ancestor = ancestors[0];\r\n        const ancestorName = isPreviewItem(ancestor) ? ancestor.name : undefined;\r\n        const parentRequired = getRequiredParent(elm, ancestorName);\r\n        if (parentRequired) {\r\n          if (ancestorName === parentRequired) {\r\n            parentCandidate = ancestor;\r\n            ancestors = ancestors.slice(1);\r\n          } else {\r\n            parentCandidate = parentRequired;\r\n          }\r\n        } else if (ancestor) {\r\n          parentCandidate = ancestor;\r\n          ancestors = ancestors.slice(1);\r\n        } else if (!siblings) {\r\n          return elm;\r\n        }\r\n        const parent = parentCandidate ? createElement(parentCandidate) : dom.create('div');\r\n        parent.appendChild(elm);\r\n        if (siblings) {\r\n          Tools.each(siblings, sibling => {\r\n            const siblingElm = createElement(sibling);\r\n            parent.insertBefore(siblingElm, elm);\r\n          });\r\n        }\r\n        const parentSiblings = isPreviewItem(parentCandidate) ? parentCandidate.siblings : undefined;\r\n        return wrapInHtml(parent, ancestors, parentSiblings);\r\n      };\r\n      const fragment = dom.create('div');\r\n      if (ancestry.length > 0) {\r\n        const item = ancestry[0];\r\n        const elm = createElement(item);\r\n        const siblings = isPreviewItem(item) ? item.siblings : undefined;\r\n        fragment.appendChild(wrapInHtml(elm, ancestry.slice(1), siblings));\r\n      }\r\n      return fragment;\r\n    };\r\n    const parseSelectorItem = item => {\r\n      item = Tools.trim(item);\r\n      let tagName = 'div';\r\n      const obj = {\r\n        name: tagName,\r\n        classes: [],\r\n        attrs: {},\r\n        selector: item\r\n      };\r\n      if (item !== '*') {\r\n        tagName = item.replace(/(?:([#\\.]|::?)([\\w\\-]+)|(\\[)([^\\]]+)\\]?)/g, ($0, $1, $2, $3, $4) => {\r\n          switch ($1) {\r\n          case '#':\r\n            obj.attrs.id = $2;\r\n            break;\r\n          case '.':\r\n            obj.classes.push($2);\r\n            break;\r\n          case ':':\r\n            if (Tools.inArray('checked disabled enabled read-only required'.split(' '), $2) !== -1) {\r\n              obj.attrs[$2] = $2;\r\n            }\r\n            break;\r\n          }\r\n          if ($3 === '[') {\r\n            const m = $4.match(/([\\w\\-]+)(?:\\=\\\"([^\\\"]+))?/);\r\n            if (m) {\r\n              obj.attrs[m[1]] = m[2];\r\n            }\r\n          }\r\n          return '';\r\n        });\r\n      }\r\n      obj.name = tagName || 'div';\r\n      return obj;\r\n    };\r\n    const parseSelector = selector => {\r\n      if (!isString(selector)) {\r\n        return [];\r\n      }\r\n      selector = selector.split(/\\s*,\\s*/)[0];\r\n      selector = selector.replace(/\\s*(~\\+|~|\\+|>)\\s*/g, '$1');\r\n      return Tools.map(selector.split(/(?:>|\\s+(?![^\\[\\]]+\\]))/), item => {\r\n        const siblings = Tools.map(item.split(/(?:~\\+|~|\\+)/), parseSelectorItem);\r\n        const obj = siblings.pop();\r\n        if (siblings.length) {\r\n          obj.siblings = siblings;\r\n        }\r\n        return obj;\r\n      }).reverse();\r\n    };\r\n    const getCssText = (editor, format) => {\r\n      let previewCss = '';\r\n      let previewStyles = getPreviewStyles(editor);\r\n      if (previewStyles === '') {\r\n        return '';\r\n      }\r\n      const removeVars = val => {\r\n        return isString(val) ? val.replace(/%(\\w+)/g, '') : '';\r\n      };\r\n      const getComputedStyle = (name, elm) => {\r\n        return dom.getStyle(elm !== null && elm !== void 0 ? elm : editor.getBody(), name, true);\r\n      };\r\n      if (isString(format)) {\r\n        const formats = editor.formatter.get(format);\r\n        if (!formats) {\r\n          return '';\r\n        }\r\n        format = formats[0];\r\n      }\r\n      if ('preview' in format) {\r\n        const preview = format.preview;\r\n        if (preview === false) {\r\n          return '';\r\n        } else {\r\n          previewStyles = preview || previewStyles;\r\n        }\r\n      }\r\n      let name = format.block || format.inline || 'span';\r\n      let previewFrag;\r\n      const items = parseSelector(format.selector);\r\n      if (items.length > 0) {\r\n        if (!items[0].name) {\r\n          items[0].name = name;\r\n        }\r\n        name = format.selector;\r\n        previewFrag = parsedSelectorToHtml(items, editor);\r\n      } else {\r\n        previewFrag = parsedSelectorToHtml([name], editor);\r\n      }\r\n      const previewElm = dom.select(name, previewFrag)[0] || previewFrag.firstChild;\r\n      each$3(format.styles, (value, name) => {\r\n        const newValue = removeVars(value);\r\n        if (newValue) {\r\n          dom.setStyle(previewElm, name, newValue);\r\n        }\r\n      });\r\n      each$3(format.attributes, (value, name) => {\r\n        const newValue = removeVars(value);\r\n        if (newValue) {\r\n          dom.setAttrib(previewElm, name, newValue);\r\n        }\r\n      });\r\n      each$3(format.classes, value => {\r\n        const newValue = removeVars(value);\r\n        if (!dom.hasClass(previewElm, newValue)) {\r\n          dom.addClass(previewElm, newValue);\r\n        }\r\n      });\r\n      editor.dispatch('PreviewFormats');\r\n      dom.setStyles(previewFrag, {\r\n        position: 'absolute',\r\n        left: -65535\r\n      });\r\n      editor.getBody().appendChild(previewFrag);\r\n      const rawParentFontSize = getComputedStyle('fontSize');\r\n      const parentFontSize = /px$/.test(rawParentFontSize) ? parseInt(rawParentFontSize, 10) : 0;\r\n      each$3(previewStyles.split(' '), name => {\r\n        let value = getComputedStyle(name, previewElm);\r\n        if (name === 'background-color' && /transparent|rgba\\s*\\([^)]+,\\s*0\\)/.test(value)) {\r\n          value = getComputedStyle(name);\r\n          if (rgbaToHexString(value).toLowerCase() === '#ffffff') {\r\n            return;\r\n          }\r\n        }\r\n        if (name === 'color') {\r\n          if (rgbaToHexString(value).toLowerCase() === '#000000') {\r\n            return;\r\n          }\r\n        }\r\n        if (name === 'font-size') {\r\n          if (/em|%$/.test(value)) {\r\n            if (parentFontSize === 0) {\r\n              return;\r\n            }\r\n            const numValue = parseFloat(value) / (/%$/.test(value) ? 100 : 1);\r\n            value = numValue * parentFontSize + 'px';\r\n          }\r\n        }\r\n        if (name === 'border' && value) {\r\n          previewCss += 'padding:0 2px;';\r\n        }\r\n        previewCss += name + ':' + value + ';';\r\n      });\r\n      editor.dispatch('AfterPreviewFormats');\r\n      dom.remove(previewFrag);\r\n      return previewCss;\r\n    };\r\n\r\n    const setup$s = editor => {\r\n      editor.addShortcut('meta+b', '', 'Bold');\r\n      editor.addShortcut('meta+i', '', 'Italic');\r\n      editor.addShortcut('meta+u', '', 'Underline');\r\n      for (let i = 1; i <= 6; i++) {\r\n        editor.addShortcut('access+' + i, '', [\r\n          'FormatBlock',\r\n          false,\r\n          'h' + i\r\n        ]);\r\n      }\r\n      editor.addShortcut('access+7', '', [\r\n        'FormatBlock',\r\n        false,\r\n        'p'\r\n      ]);\r\n      editor.addShortcut('access+8', '', [\r\n        'FormatBlock',\r\n        false,\r\n        'div'\r\n      ]);\r\n      editor.addShortcut('access+9', '', [\r\n        'FormatBlock',\r\n        false,\r\n        'address'\r\n      ]);\r\n    };\r\n\r\n    const Formatter = editor => {\r\n      const formats = FormatRegistry(editor);\r\n      const formatChangeState = Cell({});\r\n      setup$s(editor);\r\n      setup$v(editor);\r\n      if (!isRtc(editor)) {\r\n        setup$u(formatChangeState, editor);\r\n      }\r\n      return {\r\n        get: formats.get,\r\n        has: formats.has,\r\n        register: formats.register,\r\n        unregister: formats.unregister,\r\n        apply: (name, vars, node) => {\r\n          applyFormat(editor, name, vars, node);\r\n        },\r\n        remove: (name, vars, node, similar) => {\r\n          removeFormat(editor, name, vars, node, similar);\r\n        },\r\n        toggle: (name, vars, node) => {\r\n          toggleFormat(editor, name, vars, node);\r\n        },\r\n        match: (name, vars, node, similar) => matchFormat(editor, name, vars, node, similar),\r\n        closest: names => closestFormat(editor, names),\r\n        matchAll: (names, vars) => matchAllFormats(editor, names, vars),\r\n        matchNode: (node, name, vars, similar) => matchNodeFormat(editor, node, name, vars, similar),\r\n        canApply: name => canApplyFormat(editor, name),\r\n        formatChanged: (formats, callback, similar, vars) => formatChanged(editor, formatChangeState, formats, callback, similar, vars),\r\n        getCssText: curry(getCssText, editor)\r\n      };\r\n    };\r\n\r\n    const shouldIgnoreCommand = cmd => {\r\n      switch (cmd.toLowerCase()) {\r\n      case 'undo':\r\n      case 'redo':\r\n      case 'mcefocus':\r\n        return true;\r\n      default:\r\n        return false;\r\n      }\r\n    };\r\n    const registerEvents = (editor, undoManager, locks) => {\r\n      const isFirstTypedCharacter = Cell(false);\r\n      const addNonTypingUndoLevel = e => {\r\n        setTyping(undoManager, false, locks);\r\n        undoManager.add({}, e);\r\n      };\r\n      editor.on('init', () => {\r\n        undoManager.add();\r\n      });\r\n      editor.on('BeforeExecCommand', e => {\r\n        const cmd = e.command;\r\n        if (!shouldIgnoreCommand(cmd)) {\r\n          endTyping(undoManager, locks);\r\n          undoManager.beforeChange();\r\n        }\r\n      });\r\n      editor.on('ExecCommand', e => {\r\n        const cmd = e.command;\r\n        if (!shouldIgnoreCommand(cmd)) {\r\n          addNonTypingUndoLevel(e);\r\n        }\r\n      });\r\n      editor.on('ObjectResizeStart cut', () => {\r\n        undoManager.beforeChange();\r\n      });\r\n      editor.on('SaveContent ObjectResized blur', addNonTypingUndoLevel);\r\n      editor.on('dragend', addNonTypingUndoLevel);\r\n      editor.on('keyup', e => {\r\n        const keyCode = e.keyCode;\r\n        if (e.isDefaultPrevented()) {\r\n          return;\r\n        }\r\n        const isMeta = Env.os.isMacOS() && e.key === 'Meta';\r\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45 || e.ctrlKey || isMeta) {\r\n          addNonTypingUndoLevel();\r\n          editor.nodeChanged();\r\n        }\r\n        if (keyCode === 46 || keyCode === 8) {\r\n          editor.nodeChanged();\r\n        }\r\n        if (isFirstTypedCharacter.get() && undoManager.typing && !isEq$1(createFromEditor(editor), undoManager.data[0])) {\r\n          if (!editor.isDirty()) {\r\n            editor.setDirty(true);\r\n          }\r\n          editor.dispatch('TypingUndo');\r\n          isFirstTypedCharacter.set(false);\r\n          editor.nodeChanged();\r\n        }\r\n      });\r\n      editor.on('keydown', e => {\r\n        const keyCode = e.keyCode;\r\n        if (e.isDefaultPrevented()) {\r\n          return;\r\n        }\r\n        if (keyCode >= 33 && keyCode <= 36 || keyCode >= 37 && keyCode <= 40 || keyCode === 45) {\r\n          if (undoManager.typing) {\r\n            addNonTypingUndoLevel(e);\r\n          }\r\n          return;\r\n        }\r\n        const modKey = e.ctrlKey && !e.altKey || e.metaKey;\r\n        if ((keyCode < 16 || keyCode > 20) && keyCode !== 224 && keyCode !== 91 && !undoManager.typing && !modKey) {\r\n          undoManager.beforeChange();\r\n          setTyping(undoManager, true, locks);\r\n          undoManager.add({}, e);\r\n          isFirstTypedCharacter.set(true);\r\n          return;\r\n        }\r\n        const hasOnlyMetaOrCtrlModifier = Env.os.isMacOS() ? e.metaKey : e.ctrlKey && !e.altKey;\r\n        if (hasOnlyMetaOrCtrlModifier) {\r\n          undoManager.beforeChange();\r\n        }\r\n      });\r\n      editor.on('mousedown', e => {\r\n        if (undoManager.typing) {\r\n          addNonTypingUndoLevel(e);\r\n        }\r\n      });\r\n      const isInsertReplacementText = event => event.inputType === 'insertReplacementText';\r\n      const isInsertTextDataNull = event => event.inputType === 'insertText' && event.data === null;\r\n      const isInsertFromPasteOrDrop = event => event.inputType === 'insertFromPaste' || event.inputType === 'insertFromDrop';\r\n      editor.on('input', e => {\r\n        if (e.inputType && (isInsertReplacementText(e) || isInsertTextDataNull(e) || isInsertFromPasteOrDrop(e))) {\r\n          addNonTypingUndoLevel(e);\r\n        }\r\n      });\r\n      editor.on('AddUndo Undo Redo ClearUndos', e => {\r\n        if (!e.isDefaultPrevented()) {\r\n          editor.nodeChanged();\r\n        }\r\n      });\r\n    };\r\n    const addKeyboardShortcuts = editor => {\r\n      editor.addShortcut('meta+z', '', 'Undo');\r\n      editor.addShortcut('meta+y,meta+shift+z', '', 'Redo');\r\n    };\r\n\r\n    const UndoManager = editor => {\r\n      const beforeBookmark = value$2();\r\n      const locks = Cell(0);\r\n      const index = Cell(0);\r\n      const undoManager = {\r\n        data: [],\r\n        typing: false,\r\n        beforeChange: () => {\r\n          beforeChange(editor, locks, beforeBookmark);\r\n        },\r\n        add: (level, event) => {\r\n          return addUndoLevel(editor, undoManager, index, locks, beforeBookmark, level, event);\r\n        },\r\n        dispatchChange: () => {\r\n          editor.setDirty(true);\r\n          const level = createFromEditor(editor);\r\n          level.bookmark = getUndoBookmark(editor.selection);\r\n          editor.dispatch('change', {\r\n            level,\r\n            lastLevel: get$b(undoManager.data, index.get()).getOrUndefined()\r\n          });\r\n        },\r\n        undo: () => {\r\n          return undo(editor, undoManager, locks, index);\r\n        },\r\n        redo: () => {\r\n          return redo(editor, index, undoManager.data);\r\n        },\r\n        clear: () => {\r\n          clear(editor, undoManager, index);\r\n        },\r\n        reset: () => {\r\n          reset(editor, undoManager);\r\n        },\r\n        hasUndo: () => {\r\n          return hasUndo(editor, undoManager, index);\r\n        },\r\n        hasRedo: () => {\r\n          return hasRedo(editor, undoManager, index);\r\n        },\r\n        transact: callback => {\r\n          return transact(editor, undoManager, locks, callback);\r\n        },\r\n        ignore: callback => {\r\n          ignore(editor, locks, callback);\r\n        },\r\n        extra: (callback1, callback2) => {\r\n          extra(editor, undoManager, index, callback1, callback2);\r\n        }\r\n      };\r\n      if (!isRtc(editor)) {\r\n        registerEvents(editor, undoManager, locks);\r\n      }\r\n      addKeyboardShortcuts(editor);\r\n      return undoManager;\r\n    };\r\n\r\n    const nonTypingKeycodes = [\r\n      9,\r\n      27,\r\n      VK.HOME,\r\n      VK.END,\r\n      19,\r\n      20,\r\n      44,\r\n      144,\r\n      145,\r\n      33,\r\n      34,\r\n      45,\r\n      16,\r\n      17,\r\n      18,\r\n      91,\r\n      92,\r\n      93,\r\n      VK.DOWN,\r\n      VK.UP,\r\n      VK.LEFT,\r\n      VK.RIGHT\r\n    ].concat(Env.browser.isFirefox() ? [224] : []);\r\n    const placeholderAttr = 'data-mce-placeholder';\r\n    const isKeyboardEvent = e => e.type === 'keydown' || e.type === 'keyup';\r\n    const isDeleteEvent = e => {\r\n      const keyCode = e.keyCode;\r\n      return keyCode === VK.BACKSPACE || keyCode === VK.DELETE;\r\n    };\r\n    const isNonTypingKeyboardEvent = e => {\r\n      if (isKeyboardEvent(e)) {\r\n        const keyCode = e.keyCode;\r\n        return !isDeleteEvent(e) && (VK.metaKeyPressed(e) || e.altKey || keyCode >= 112 && keyCode <= 123 || contains$2(nonTypingKeycodes, keyCode));\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const isTypingKeyboardEvent = e => isKeyboardEvent(e) && !(isDeleteEvent(e) || e.type === 'keyup' && e.keyCode === 229);\r\n    const isVisuallyEmpty = (dom, rootElm, forcedRootBlock) => {\r\n      if (isEmpty$2(SugarElement.fromDom(rootElm), false)) {\r\n        const firstElement = rootElm.firstElementChild;\r\n        if (!firstElement) {\r\n          return true;\r\n        } else if (dom.getStyle(rootElm.firstElementChild, 'padding-left') || dom.getStyle(rootElm.firstElementChild, 'padding-right')) {\r\n          return false;\r\n        } else {\r\n          return forcedRootBlock === firstElement.nodeName.toLowerCase();\r\n        }\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const setup$r = editor => {\r\n      var _a;\r\n      const dom = editor.dom;\r\n      const rootBlock = getForcedRootBlock(editor);\r\n      const placeholder = (_a = getPlaceholder(editor)) !== null && _a !== void 0 ? _a : '';\r\n      const updatePlaceholder = (e, initial) => {\r\n        if (isNonTypingKeyboardEvent(e)) {\r\n          return;\r\n        }\r\n        const body = editor.getBody();\r\n        const showPlaceholder = isTypingKeyboardEvent(e) ? false : isVisuallyEmpty(dom, body, rootBlock);\r\n        const isPlaceholderShown = dom.getAttrib(body, placeholderAttr) !== '';\r\n        if (isPlaceholderShown !== showPlaceholder || initial) {\r\n          dom.setAttrib(body, placeholderAttr, showPlaceholder ? placeholder : null);\r\n          dom.setAttrib(body, 'aria-placeholder', showPlaceholder ? placeholder : null);\r\n          firePlaceholderToggle(editor, showPlaceholder);\r\n          editor.on(showPlaceholder ? 'keydown' : 'keyup', updatePlaceholder);\r\n          editor.off(showPlaceholder ? 'keyup' : 'keydown', updatePlaceholder);\r\n        }\r\n      };\r\n      if (isNotEmpty(placeholder)) {\r\n        editor.on('init', e => {\r\n          updatePlaceholder(e, true);\r\n          editor.on('change SetContent ExecCommand', updatePlaceholder);\r\n          editor.on('paste', e => Delay.setEditorTimeout(editor, () => updatePlaceholder(e)));\r\n        });\r\n      }\r\n    };\r\n\r\n    const blockPosition = (block, position) => ({\r\n      block,\r\n      position\r\n    });\r\n    const blockBoundary = (from, to) => ({\r\n      from,\r\n      to\r\n    });\r\n    const getBlockPosition = (rootNode, pos) => {\r\n      const rootElm = SugarElement.fromDom(rootNode);\r\n      const containerElm = SugarElement.fromDom(pos.container());\r\n      return getParentBlock$2(rootElm, containerElm).map(block => blockPosition(block, pos));\r\n    };\r\n    const isDifferentBlocks = blockBoundary => !eq(blockBoundary.from.block, blockBoundary.to.block);\r\n    const getClosestHost = (root, scope) => {\r\n      const isRoot = node => eq(node, root);\r\n      const isHost = node => isTableCell$2(node) || isContentEditableTrue$3(node.dom);\r\n      return closest$4(scope, isHost, isRoot).filter(isElement$7).getOr(root);\r\n    };\r\n    const hasSameHost = (rootNode, blockBoundary) => {\r\n      const root = SugarElement.fromDom(rootNode);\r\n      return eq(getClosestHost(root, blockBoundary.from.block), getClosestHost(root, blockBoundary.to.block));\r\n    };\r\n    const isEditable$1 = blockBoundary => isContentEditableFalse$b(blockBoundary.from.block.dom) === false && isContentEditableFalse$b(blockBoundary.to.block.dom) === false;\r\n    const hasValidBlocks = blockBoundary => {\r\n      const isValidBlock = block => isTextBlock$2(block) || hasBlockAttr(block.dom);\r\n      return isValidBlock(blockBoundary.from.block) && isValidBlock(blockBoundary.to.block);\r\n    };\r\n    const skipLastBr = (rootNode, forward, blockPosition) => {\r\n      if (isBr$6(blockPosition.position.getNode()) && !isEmpty$2(blockPosition.block)) {\r\n        return positionIn(false, blockPosition.block.dom).bind(lastPositionInBlock => {\r\n          if (lastPositionInBlock.isEqual(blockPosition.position)) {\r\n            return fromPosition(forward, rootNode, lastPositionInBlock).bind(to => getBlockPosition(rootNode, to));\r\n          } else {\r\n            return Optional.some(blockPosition);\r\n          }\r\n        }).getOr(blockPosition);\r\n      } else {\r\n        return blockPosition;\r\n      }\r\n    };\r\n    const readFromRange = (rootNode, forward, rng) => {\r\n      const fromBlockPos = getBlockPosition(rootNode, CaretPosition.fromRangeStart(rng));\r\n      const toBlockPos = fromBlockPos.bind(blockPos => fromPosition(forward, rootNode, blockPos.position).bind(to => getBlockPosition(rootNode, to).map(blockPos => skipLastBr(rootNode, forward, blockPos))));\r\n      return lift2(fromBlockPos, toBlockPos, blockBoundary).filter(blockBoundary => isDifferentBlocks(blockBoundary) && hasSameHost(rootNode, blockBoundary) && isEditable$1(blockBoundary) && hasValidBlocks(blockBoundary));\r\n    };\r\n    const read$1 = (rootNode, forward, rng) => rng.collapsed ? readFromRange(rootNode, forward, rng) : Optional.none();\r\n\r\n    const getChildrenUntilBlockBoundary = (block, schema) => {\r\n      const children = children$1(block);\r\n      return findIndex$2(children, el => schema.isBlock(name(el))).fold(constant(children), index => children.slice(0, index));\r\n    };\r\n    const extractChildren = (block, schema) => {\r\n      const children = getChildrenUntilBlockBoundary(block, schema);\r\n      each$e(children, remove$5);\r\n      return children;\r\n    };\r\n    const removeEmptyRoot = (rootNode, block) => {\r\n      const parents = parentsAndSelf(block, rootNode);\r\n      return find$2(parents.reverse(), element => isEmpty$2(element)).each(remove$5);\r\n    };\r\n    const isEmptyBefore = el => filter$5(prevSiblings(el), el => !isEmpty$2(el)).length === 0;\r\n    const nestedBlockMerge = (rootNode, fromBlock, toBlock, schema, insertionPoint) => {\r\n      if (isEmpty$2(toBlock)) {\r\n        fillWithPaddingBr(toBlock);\r\n        return firstPositionIn(toBlock.dom);\r\n      }\r\n      if (isEmptyBefore(insertionPoint) && isEmpty$2(fromBlock)) {\r\n        before$3(insertionPoint, SugarElement.fromTag('br'));\r\n      }\r\n      const position = prevPosition(toBlock.dom, CaretPosition.before(insertionPoint.dom));\r\n      each$e(extractChildren(fromBlock, schema), child => {\r\n        before$3(insertionPoint, child);\r\n      });\r\n      removeEmptyRoot(rootNode, fromBlock);\r\n      return position;\r\n    };\r\n    const isInline = (schema, node) => schema.isInline(name(node));\r\n    const sidelongBlockMerge = (rootNode, fromBlock, toBlock, schema) => {\r\n      if (isEmpty$2(toBlock)) {\r\n        if (isEmpty$2(fromBlock)) {\r\n          const getInlineToBlockDescendants = el => {\r\n            const helper = (node, elements) => firstChild(node).fold(() => elements, child => isInline(schema, child) ? helper(child, elements.concat(shallow$1(child))) : elements);\r\n            return helper(el, []);\r\n          };\r\n          const newFromBlockDescendants = foldr(getInlineToBlockDescendants(toBlock), (element, descendant) => {\r\n            wrap$2(element, descendant);\r\n            return descendant;\r\n          }, createPaddingBr());\r\n          empty(fromBlock);\r\n          append$1(fromBlock, newFromBlockDescendants);\r\n        }\r\n        remove$5(toBlock);\r\n        return firstPositionIn(fromBlock.dom);\r\n      }\r\n      const position = lastPositionIn(toBlock.dom);\r\n      each$e(extractChildren(fromBlock, schema), child => {\r\n        append$1(toBlock, child);\r\n      });\r\n      removeEmptyRoot(rootNode, fromBlock);\r\n      return position;\r\n    };\r\n    const findInsertionPoint = (toBlock, block) => {\r\n      const parentsAndSelf$1 = parentsAndSelf(block, toBlock);\r\n      return Optional.from(parentsAndSelf$1[parentsAndSelf$1.length - 1]);\r\n    };\r\n    const getInsertionPoint = (fromBlock, toBlock) => contains(toBlock, fromBlock) ? findInsertionPoint(toBlock, fromBlock) : Optional.none();\r\n    const trimBr = (first, block) => {\r\n      positionIn(first, block.dom).bind(position => Optional.from(position.getNode())).map(SugarElement.fromDom).filter(isBr$5).each(remove$5);\r\n    };\r\n    const mergeBlockInto = (rootNode, fromBlock, toBlock, schema) => {\r\n      trimBr(true, fromBlock);\r\n      trimBr(false, toBlock);\r\n      return getInsertionPoint(fromBlock, toBlock).fold(curry(sidelongBlockMerge, rootNode, fromBlock, toBlock, schema), curry(nestedBlockMerge, rootNode, fromBlock, toBlock, schema));\r\n    };\r\n    const mergeBlocks = (rootNode, forward, block1, block2, schema) => forward ? mergeBlockInto(rootNode, block2, block1, schema) : mergeBlockInto(rootNode, block1, block2, schema);\r\n\r\n    const backspaceDelete$9 = (editor, forward) => {\r\n      const rootNode = SugarElement.fromDom(editor.getBody());\r\n      const position = read$1(rootNode.dom, forward, editor.selection.getRng()).map(blockBoundary => () => {\r\n        mergeBlocks(rootNode, forward, blockBoundary.from.block, blockBoundary.to.block, editor.schema).each(pos => {\r\n          editor.selection.setRng(pos.toRange());\r\n        });\r\n      });\r\n      return position;\r\n    };\r\n\r\n    const deleteRangeMergeBlocks = (rootNode, selection, schema) => {\r\n      const rng = selection.getRng();\r\n      return lift2(getParentBlock$2(rootNode, SugarElement.fromDom(rng.startContainer)), getParentBlock$2(rootNode, SugarElement.fromDom(rng.endContainer)), (block1, block2) => {\r\n        if (!eq(block1, block2)) {\r\n          return Optional.some(() => {\r\n            rng.deleteContents();\r\n            mergeBlocks(rootNode, true, block1, block2, schema).each(pos => {\r\n              selection.setRng(pos.toRange());\r\n            });\r\n          });\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      }).getOr(Optional.none());\r\n    };\r\n    const isRawNodeInTable = (root, rawNode) => {\r\n      const node = SugarElement.fromDom(rawNode);\r\n      const isRoot = curry(eq, root);\r\n      return ancestor$4(node, isTableCell$2, isRoot).isSome();\r\n    };\r\n    const isSelectionInTable = (root, rng) => isRawNodeInTable(root, rng.startContainer) || isRawNodeInTable(root, rng.endContainer);\r\n    const isEverythingSelected = (root, rng) => {\r\n      const noPrevious = prevPosition(root.dom, CaretPosition.fromRangeStart(rng)).isNone();\r\n      const noNext = nextPosition(root.dom, CaretPosition.fromRangeEnd(rng)).isNone();\r\n      return !isSelectionInTable(root, rng) && noPrevious && noNext;\r\n    };\r\n    const emptyEditor = editor => {\r\n      return Optional.some(() => {\r\n        editor.setContent('');\r\n        editor.selection.setCursorLocation();\r\n      });\r\n    };\r\n    const deleteRange$2 = editor => {\r\n      const rootNode = SugarElement.fromDom(editor.getBody());\r\n      const rng = editor.selection.getRng();\r\n      return isEverythingSelected(rootNode, rng) ? emptyEditor(editor) : deleteRangeMergeBlocks(rootNode, editor.selection, editor.schema);\r\n    };\r\n    const backspaceDelete$8 = (editor, _forward) => editor.selection.isCollapsed() ? Optional.none() : deleteRange$2(editor);\r\n\r\n    const showCaret = (direction, editor, node, before, scrollIntoView) => Optional.from(editor._selectionOverrides.showCaret(direction, node, before, scrollIntoView));\r\n    const getNodeRange = node => {\r\n      const rng = node.ownerDocument.createRange();\r\n      rng.selectNode(node);\r\n      return rng;\r\n    };\r\n    const selectNode = (editor, node) => {\r\n      const e = editor.dispatch('BeforeObjectSelected', { target: node });\r\n      if (e.isDefaultPrevented()) {\r\n        return Optional.none();\r\n      }\r\n      return Optional.some(getNodeRange(node));\r\n    };\r\n    const renderCaretAtRange = (editor, range, scrollIntoView) => {\r\n      const normalizedRange = normalizeRange(1, editor.getBody(), range);\r\n      const caretPosition = CaretPosition.fromRangeStart(normalizedRange);\r\n      const caretPositionNode = caretPosition.getNode();\r\n      if (isInlineFakeCaretTarget(caretPositionNode)) {\r\n        return showCaret(1, editor, caretPositionNode, !caretPosition.isAtEnd(), false);\r\n      }\r\n      const caretPositionBeforeNode = caretPosition.getNode(true);\r\n      if (isInlineFakeCaretTarget(caretPositionBeforeNode)) {\r\n        return showCaret(1, editor, caretPositionBeforeNode, false, false);\r\n      }\r\n      const ceRoot = getContentEditableRoot$1(editor.dom.getRoot(), caretPosition.getNode());\r\n      if (isInlineFakeCaretTarget(ceRoot)) {\r\n        return showCaret(1, editor, ceRoot, false, scrollIntoView);\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const renderRangeCaret = (editor, range, scrollIntoView) => range.collapsed ? renderCaretAtRange(editor, range, scrollIntoView).getOr(range) : range;\r\n\r\n    const isBeforeBoundary = pos => isBeforeContentEditableFalse(pos) || isBeforeMedia(pos);\r\n    const isAfterBoundary = pos => isAfterContentEditableFalse(pos) || isAfterMedia(pos);\r\n    const trimEmptyTextNode = (dom, node) => {\r\n      if (isText$a(node) && node.data.length === 0) {\r\n        dom.remove(node);\r\n      }\r\n    };\r\n    const deleteContentAndShowCaret = (editor, range, node, direction, forward, peekCaretPosition) => {\r\n      showCaret(direction, editor, peekCaretPosition.getNode(!forward), forward, true).each(caretRange => {\r\n        if (range.collapsed) {\r\n          const deleteRange = range.cloneRange();\r\n          if (forward) {\r\n            deleteRange.setEnd(caretRange.startContainer, caretRange.startOffset);\r\n          } else {\r\n            deleteRange.setStart(caretRange.endContainer, caretRange.endOffset);\r\n          }\r\n          deleteRange.deleteContents();\r\n        } else {\r\n          range.deleteContents();\r\n        }\r\n        editor.selection.setRng(caretRange);\r\n      });\r\n      trimEmptyTextNode(editor.dom, node);\r\n    };\r\n    const deleteBoundaryText = (editor, forward) => {\r\n      const range = editor.selection.getRng();\r\n      if (!isText$a(range.commonAncestorContainer)) {\r\n        return Optional.none();\r\n      }\r\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\r\n      const caretWalker = CaretWalker(editor.getBody());\r\n      const getNextPosFn = curry(getVisualCaretPosition, forward ? caretWalker.next : caretWalker.prev);\r\n      const isBeforeFn = forward ? isBeforeBoundary : isAfterBoundary;\r\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\r\n      const nextCaretPosition = getNextPosFn(caretPosition);\r\n      const normalizedNextCaretPosition = nextCaretPosition ? normalizePosition(forward, nextCaretPosition) : nextCaretPosition;\r\n      if (!normalizedNextCaretPosition || !isMoveInsideSameBlock(caretPosition, normalizedNextCaretPosition)) {\r\n        return Optional.none();\r\n      } else if (isBeforeFn(normalizedNextCaretPosition)) {\r\n        return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, normalizedNextCaretPosition));\r\n      }\r\n      const peekCaretPosition = getNextPosFn(normalizedNextCaretPosition);\r\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\r\n        if (isMoveInsideSameBlock(normalizedNextCaretPosition, peekCaretPosition)) {\r\n          return Optional.some(() => deleteContentAndShowCaret(editor, range, caretPosition.getNode(), direction, forward, peekCaretPosition));\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const backspaceDelete$7 = (editor, forward) => deleteBoundaryText(editor, forward);\r\n\r\n    const getEdgeCefPosition = (editor, atStart) => {\r\n      const root = editor.getBody();\r\n      return atStart ? firstPositionIn(root).filter(isBeforeContentEditableFalse) : lastPositionIn(root).filter(isAfterContentEditableFalse);\r\n    };\r\n    const isCefAtEdgeSelected = editor => {\r\n      const rng = editor.selection.getRng();\r\n      return !rng.collapsed && (getEdgeCefPosition(editor, true).exists(pos => pos.isEqual(CaretPosition.fromRangeStart(rng))) || getEdgeCefPosition(editor, false).exists(pos => pos.isEqual(CaretPosition.fromRangeEnd(rng))));\r\n    };\r\n\r\n    const isCompoundElement = node => isNonNullable(node) && (isTableCell$2(SugarElement.fromDom(node)) || isListItem$1(SugarElement.fromDom(node)));\r\n    const DeleteAction = Adt.generate([\r\n      { remove: ['element'] },\r\n      { moveToElement: ['element'] },\r\n      { moveToPosition: ['position'] }\r\n    ]);\r\n    const isAtContentEditableBlockCaret = (forward, from) => {\r\n      const elm = from.getNode(!forward);\r\n      const caretLocation = forward ? 'after' : 'before';\r\n      return isElement$6(elm) && elm.getAttribute('data-mce-caret') === caretLocation;\r\n    };\r\n    const isDeleteFromCefDifferentBlocks = (root, forward, from, to, schema) => {\r\n      const inSameBlock = elm => schema.isInline(elm.nodeName.toLowerCase()) && !isInSameBlock(from, to, root);\r\n      return getRelativeCefElm(!forward, from).fold(() => getRelativeCefElm(forward, to).fold(never, inSameBlock), inSameBlock);\r\n    };\r\n    const deleteEmptyBlockOrMoveToCef = (root, forward, from, to) => {\r\n      const toCefElm = to.getNode(!forward);\r\n      return getParentBlock$2(SugarElement.fromDom(root), SugarElement.fromDom(from.getNode())).map(blockElm => isEmpty$2(blockElm) ? DeleteAction.remove(blockElm.dom) : DeleteAction.moveToElement(toCefElm)).orThunk(() => Optional.some(DeleteAction.moveToElement(toCefElm)));\r\n    };\r\n    const findCefPosition = (root, forward, from, schema) => fromPosition(forward, root, from).bind(to => {\r\n      if (isCompoundElement(to.getNode())) {\r\n        return Optional.none();\r\n      } else if (isDeleteFromCefDifferentBlocks(root, forward, from, to, schema)) {\r\n        return Optional.none();\r\n      } else if (forward && isContentEditableFalse$b(to.getNode())) {\r\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\r\n      } else if (!forward && isContentEditableFalse$b(to.getNode(true))) {\r\n        return deleteEmptyBlockOrMoveToCef(root, forward, from, to);\r\n      } else if (forward && isAfterContentEditableFalse(from)) {\r\n        return Optional.some(DeleteAction.moveToPosition(to));\r\n      } else if (!forward && isBeforeContentEditableFalse(from)) {\r\n        return Optional.some(DeleteAction.moveToPosition(to));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    });\r\n    const getContentEditableBlockAction = (forward, elm) => {\r\n      if (isNullable(elm)) {\r\n        return Optional.none();\r\n      } else if (forward && isContentEditableFalse$b(elm.nextSibling)) {\r\n        return Optional.some(DeleteAction.moveToElement(elm.nextSibling));\r\n      } else if (!forward && isContentEditableFalse$b(elm.previousSibling)) {\r\n        return Optional.some(DeleteAction.moveToElement(elm.previousSibling));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const skipMoveToActionFromInlineCefToContent = (root, from, deleteAction) => deleteAction.fold(elm => Optional.some(DeleteAction.remove(elm)), elm => Optional.some(DeleteAction.moveToElement(elm)), to => {\r\n      if (isInSameBlock(from, to, root)) {\r\n        return Optional.none();\r\n      } else {\r\n        return Optional.some(DeleteAction.moveToPosition(to));\r\n      }\r\n    });\r\n    const getContentEditableAction = (root, forward, from, schema) => {\r\n      if (isAtContentEditableBlockCaret(forward, from)) {\r\n        return getContentEditableBlockAction(forward, from.getNode(!forward)).orThunk(() => findCefPosition(root, forward, from, schema));\r\n      } else {\r\n        return findCefPosition(root, forward, from, schema).bind(deleteAction => skipMoveToActionFromInlineCefToContent(root, from, deleteAction));\r\n      }\r\n    };\r\n    const read = (root, forward, rng, schema) => {\r\n      const normalizedRange = normalizeRange(forward ? 1 : -1, root, rng);\r\n      const from = CaretPosition.fromRangeStart(normalizedRange);\r\n      const rootElement = SugarElement.fromDom(root);\r\n      if (!forward && isAfterContentEditableFalse(from)) {\r\n        return Optional.some(DeleteAction.remove(from.getNode(true)));\r\n      } else if (forward && isBeforeContentEditableFalse(from)) {\r\n        return Optional.some(DeleteAction.remove(from.getNode()));\r\n      } else if (!forward && isBeforeContentEditableFalse(from) && isAfterBr(rootElement, from, schema)) {\r\n        return findPreviousBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\r\n      } else if (forward && isAfterContentEditableFalse(from) && isBeforeBr$1(rootElement, from, schema)) {\r\n        return findNextBr(rootElement, from, schema).map(br => DeleteAction.remove(br.getNode()));\r\n      } else {\r\n        return getContentEditableAction(root, forward, from, schema);\r\n      }\r\n    };\r\n\r\n    const deleteElement$1 = (editor, forward) => element => {\r\n      editor._selectionOverrides.hideFakeCaret();\r\n      deleteElement$2(editor, forward, SugarElement.fromDom(element));\r\n      return true;\r\n    };\r\n    const moveToElement = (editor, forward) => element => {\r\n      const pos = forward ? CaretPosition.before(element) : CaretPosition.after(element);\r\n      editor.selection.setRng(pos.toRange());\r\n      return true;\r\n    };\r\n    const moveToPosition = editor => pos => {\r\n      editor.selection.setRng(pos.toRange());\r\n      return true;\r\n    };\r\n    const getAncestorCe = (editor, node) => Optional.from(getContentEditableRoot$1(editor.getBody(), node));\r\n    const backspaceDeleteCaret = (editor, forward) => {\r\n      const selectedNode = editor.selection.getNode();\r\n      return getAncestorCe(editor, selectedNode).filter(isContentEditableFalse$b).fold(() => read(editor.getBody(), forward, editor.selection.getRng(), editor.schema).map(deleteAction => () => deleteAction.fold(deleteElement$1(editor, forward), moveToElement(editor, forward), moveToPosition(editor))), () => Optional.some(noop));\r\n    };\r\n    const deleteOffscreenSelection = rootElement => {\r\n      each$e(descendants(rootElement, '.mce-offscreen-selection'), remove$5);\r\n    };\r\n    const backspaceDeleteRange = (editor, forward) => {\r\n      const selectedNode = editor.selection.getNode();\r\n      if (isContentEditableFalse$b(selectedNode) && !isTableCell$3(selectedNode)) {\r\n        const hasCefAncestor = getAncestorCe(editor, selectedNode.parentNode).filter(isContentEditableFalse$b);\r\n        return hasCefAncestor.fold(() => Optional.some(() => {\r\n          deleteOffscreenSelection(SugarElement.fromDom(editor.getBody()));\r\n          deleteElement$2(editor, forward, SugarElement.fromDom(editor.selection.getNode()));\r\n          paddEmptyBody(editor);\r\n        }), () => Optional.some(noop));\r\n      }\r\n      if (isCefAtEdgeSelected(editor)) {\r\n        return Optional.some(() => {\r\n          deleteRangeContents(editor, editor.selection.getRng(), SugarElement.fromDom(editor.getBody()));\r\n        });\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const paddEmptyElement = editor => {\r\n      const dom = editor.dom, selection = editor.selection;\r\n      const ceRoot = getContentEditableRoot$1(editor.getBody(), selection.getNode());\r\n      if (isContentEditableTrue$3(ceRoot) && dom.isBlock(ceRoot) && dom.isEmpty(ceRoot)) {\r\n        const br = dom.create('br', { 'data-mce-bogus': '1' });\r\n        dom.setHTML(ceRoot, '');\r\n        ceRoot.appendChild(br);\r\n        selection.setRng(CaretPosition.before(br).toRange());\r\n      }\r\n      return true;\r\n    };\r\n    const backspaceDelete$6 = (editor, forward) => {\r\n      if (editor.selection.isCollapsed()) {\r\n        return backspaceDeleteCaret(editor, forward);\r\n      } else {\r\n        return backspaceDeleteRange(editor, forward);\r\n      }\r\n    };\r\n\r\n    const deleteCaret$2 = (editor, forward) => {\r\n      const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return fromPosition(forward, editor.getBody(), fromPos).filter(pos => forward ? isBeforeImageBlock(pos) : isAfterImageBlock(pos)).bind(pos => getChildNodeAtRelativeOffset(forward ? 0 : -1, pos)).map(elm => () => editor.selection.select(elm));\r\n    };\r\n    const backspaceDelete$5 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$2(editor, forward) : Optional.none();\r\n\r\n    const isText$2 = isText$a;\r\n    const startsWithCaretContainer = node => isText$2(node) && node.data[0] === ZWSP$1;\r\n    const endsWithCaretContainer = node => isText$2(node) && node.data[node.data.length - 1] === ZWSP$1;\r\n    const createZwsp = node => {\r\n      var _a;\r\n      const doc = (_a = node.ownerDocument) !== null && _a !== void 0 ? _a : document;\r\n      return doc.createTextNode(ZWSP$1);\r\n    };\r\n    const insertBefore$1 = node => {\r\n      var _a;\r\n      if (isText$2(node.previousSibling)) {\r\n        if (endsWithCaretContainer(node.previousSibling)) {\r\n          return node.previousSibling;\r\n        } else {\r\n          node.previousSibling.appendData(ZWSP$1);\r\n          return node.previousSibling;\r\n        }\r\n      } else if (isText$2(node)) {\r\n        if (startsWithCaretContainer(node)) {\r\n          return node;\r\n        } else {\r\n          node.insertData(0, ZWSP$1);\r\n          return node;\r\n        }\r\n      } else {\r\n        const newNode = createZwsp(node);\r\n        (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node);\r\n        return newNode;\r\n      }\r\n    };\r\n    const insertAfter$1 = node => {\r\n      var _a, _b;\r\n      if (isText$2(node.nextSibling)) {\r\n        if (startsWithCaretContainer(node.nextSibling)) {\r\n          return node.nextSibling;\r\n        } else {\r\n          node.nextSibling.insertData(0, ZWSP$1);\r\n          return node.nextSibling;\r\n        }\r\n      } else if (isText$2(node)) {\r\n        if (endsWithCaretContainer(node)) {\r\n          return node;\r\n        } else {\r\n          node.appendData(ZWSP$1);\r\n          return node;\r\n        }\r\n      } else {\r\n        const newNode = createZwsp(node);\r\n        if (node.nextSibling) {\r\n          (_a = node.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(newNode, node.nextSibling);\r\n        } else {\r\n          (_b = node.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(newNode);\r\n        }\r\n        return newNode;\r\n      }\r\n    };\r\n    const insertInline = (before, node) => before ? insertBefore$1(node) : insertAfter$1(node);\r\n    const insertInlineBefore = curry(insertInline, true);\r\n    const insertInlineAfter = curry(insertInline, false);\r\n\r\n    const insertInlinePos = (pos, before) => {\r\n      if (isText$a(pos.container())) {\r\n        return insertInline(before, pos.container());\r\n      } else {\r\n        return insertInline(before, pos.getNode());\r\n      }\r\n    };\r\n    const isPosCaretContainer = (pos, caret) => {\r\n      const caretNode = caret.get();\r\n      return caretNode && pos.container() === caretNode && isCaretContainerInline(caretNode);\r\n    };\r\n    const renderCaret = (caret, location) => location.fold(element => {\r\n      remove$3(caret.get());\r\n      const text = insertInlineBefore(element);\r\n      caret.set(text);\r\n      return Optional.some(CaretPosition(text, text.length - 1));\r\n    }, element => firstPositionIn(element).map(pos => {\r\n      if (!isPosCaretContainer(pos, caret)) {\r\n        remove$3(caret.get());\r\n        const text = insertInlinePos(pos, true);\r\n        caret.set(text);\r\n        return CaretPosition(text, 1);\r\n      } else {\r\n        const node = caret.get();\r\n        return CaretPosition(node, 1);\r\n      }\r\n    }), element => lastPositionIn(element).map(pos => {\r\n      if (!isPosCaretContainer(pos, caret)) {\r\n        remove$3(caret.get());\r\n        const text = insertInlinePos(pos, false);\r\n        caret.set(text);\r\n        return CaretPosition(text, text.length - 1);\r\n      } else {\r\n        const node = caret.get();\r\n        return CaretPosition(node, node.length - 1);\r\n      }\r\n    }), element => {\r\n      remove$3(caret.get());\r\n      const text = insertInlineAfter(element);\r\n      caret.set(text);\r\n      return Optional.some(CaretPosition(text, 1));\r\n    });\r\n\r\n    const evaluateUntil = (fns, args) => {\r\n      for (let i = 0; i < fns.length; i++) {\r\n        const result = fns[i].apply(null, args);\r\n        if (result.isSome()) {\r\n          return result;\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n\r\n    const Location = Adt.generate([\r\n      { before: ['element'] },\r\n      { start: ['element'] },\r\n      { end: ['element'] },\r\n      { after: ['element'] }\r\n    ]);\r\n    const rescope$1 = (rootNode, node) => {\r\n      const parentBlock = getParentBlock$3(node, rootNode);\r\n      return parentBlock ? parentBlock : rootNode;\r\n    };\r\n    const before = (isInlineTarget, rootNode, pos) => {\r\n      const nPos = normalizeForwards(pos);\r\n      const scope = rescope$1(rootNode, nPos.container());\r\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => nextPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.before(inline)), Optional.none);\r\n    };\r\n    const isNotInsideFormatCaretContainer = (rootNode, elm) => getParentCaretContainer(rootNode, elm) === null;\r\n    const findInsideRootInline = (isInlineTarget, rootNode, pos) => findRootInline(isInlineTarget, rootNode, pos).filter(curry(isNotInsideFormatCaretContainer, rootNode));\r\n    const start$1 = (isInlineTarget, rootNode, pos) => {\r\n      const nPos = normalizeBackwards(pos);\r\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\r\n        const prevPos = prevPosition(inline, nPos);\r\n        return prevPos.isNone() ? Optional.some(Location.start(inline)) : Optional.none();\r\n      });\r\n    };\r\n    const end = (isInlineTarget, rootNode, pos) => {\r\n      const nPos = normalizeForwards(pos);\r\n      return findInsideRootInline(isInlineTarget, rootNode, nPos).bind(inline => {\r\n        const nextPos = nextPosition(inline, nPos);\r\n        return nextPos.isNone() ? Optional.some(Location.end(inline)) : Optional.none();\r\n      });\r\n    };\r\n    const after = (isInlineTarget, rootNode, pos) => {\r\n      const nPos = normalizeBackwards(pos);\r\n      const scope = rescope$1(rootNode, nPos.container());\r\n      return findRootInline(isInlineTarget, scope, nPos).fold(() => prevPosition(scope, nPos).bind(curry(findRootInline, isInlineTarget, scope)).map(inline => Location.after(inline)), Optional.none);\r\n    };\r\n    const isValidLocation = location => !isRtl(getElement(location));\r\n    const readLocation = (isInlineTarget, rootNode, pos) => {\r\n      const location = evaluateUntil([\r\n        before,\r\n        start$1,\r\n        end,\r\n        after\r\n      ], [\r\n        isInlineTarget,\r\n        rootNode,\r\n        pos\r\n      ]);\r\n      return location.filter(isValidLocation);\r\n    };\r\n    const getElement = location => location.fold(identity, identity, identity, identity);\r\n    const getName = location => location.fold(constant('before'), constant('start'), constant('end'), constant('after'));\r\n    const outside = location => location.fold(Location.before, Location.before, Location.after, Location.after);\r\n    const inside = location => location.fold(Location.start, Location.start, Location.end, Location.end);\r\n    const isEq = (location1, location2) => getName(location1) === getName(location2) && getElement(location1) === getElement(location2);\r\n    const betweenInlines = (forward, isInlineTarget, rootNode, from, to, location) => lift2(findRootInline(isInlineTarget, rootNode, from), findRootInline(isInlineTarget, rootNode, to), (fromInline, toInline) => {\r\n      if (fromInline !== toInline && hasSameParentBlock(rootNode, fromInline, toInline)) {\r\n        return Location.after(forward ? fromInline : toInline);\r\n      } else {\r\n        return location;\r\n      }\r\n    }).getOr(location);\r\n    const skipNoMovement = (fromLocation, toLocation) => fromLocation.fold(always, fromLocation => !isEq(fromLocation, toLocation));\r\n    const findLocationTraverse = (forward, isInlineTarget, rootNode, fromLocation, pos) => {\r\n      const from = normalizePosition(forward, pos);\r\n      const to = fromPosition(forward, rootNode, from).map(curry(normalizePosition, forward));\r\n      const location = to.fold(() => fromLocation.map(outside), to => readLocation(isInlineTarget, rootNode, to).map(curry(betweenInlines, forward, isInlineTarget, rootNode, from, to)).filter(curry(skipNoMovement, fromLocation)));\r\n      return location.filter(isValidLocation);\r\n    };\r\n    const findLocationSimple = (forward, location) => {\r\n      if (forward) {\r\n        return location.fold(compose(Optional.some, Location.start), Optional.none, compose(Optional.some, Location.after), Optional.none);\r\n      } else {\r\n        return location.fold(Optional.none, compose(Optional.some, Location.before), Optional.none, compose(Optional.some, Location.end));\r\n      }\r\n    };\r\n    const findLocation$1 = (forward, isInlineTarget, rootNode, pos) => {\r\n      const from = normalizePosition(forward, pos);\r\n      const fromLocation = readLocation(isInlineTarget, rootNode, from);\r\n      return readLocation(isInlineTarget, rootNode, from).bind(curry(findLocationSimple, forward)).orThunk(() => findLocationTraverse(forward, isInlineTarget, rootNode, fromLocation, pos));\r\n    };\r\n\r\n    const hasSelectionModifyApi = editor => {\r\n      return isFunction(editor.selection.getSel().modify);\r\n    };\r\n    const moveRel = (forward, selection, pos) => {\r\n      const delta = forward ? 1 : -1;\r\n      selection.setRng(CaretPosition(pos.container(), pos.offset() + delta).toRange());\r\n      selection.getSel().modify('move', forward ? 'forward' : 'backward', 'word');\r\n      return true;\r\n    };\r\n    const moveByWord = (forward, editor) => {\r\n      const rng = editor.selection.getRng();\r\n      const pos = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\r\n      if (!hasSelectionModifyApi(editor)) {\r\n        return false;\r\n      } else if (forward && isBeforeInline(pos)) {\r\n        return moveRel(true, editor.selection, pos);\r\n      } else if (!forward && isAfterInline(pos)) {\r\n        return moveRel(false, editor.selection, pos);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    var BreakType;\r\n    (function (BreakType) {\r\n      BreakType[BreakType['Br'] = 0] = 'Br';\r\n      BreakType[BreakType['Block'] = 1] = 'Block';\r\n      BreakType[BreakType['Wrap'] = 2] = 'Wrap';\r\n      BreakType[BreakType['Eol'] = 3] = 'Eol';\r\n    }(BreakType || (BreakType = {})));\r\n    const flip = (direction, positions) => direction === HDirection.Backwards ? reverse(positions) : positions;\r\n    const walk$1 = (direction, caretWalker, pos) => direction === HDirection.Forwards ? caretWalker.next(pos) : caretWalker.prev(pos);\r\n    const getBreakType = (scope, direction, currentPos, nextPos) => {\r\n      if (isBr$6(nextPos.getNode(direction === HDirection.Forwards))) {\r\n        return BreakType.Br;\r\n      } else if (isInSameBlock(currentPos, nextPos) === false) {\r\n        return BreakType.Block;\r\n      } else {\r\n        return BreakType.Wrap;\r\n      }\r\n    };\r\n    const getPositionsUntil = (predicate, direction, scope, start) => {\r\n      const caretWalker = CaretWalker(scope);\r\n      let currentPos = start;\r\n      const positions = [];\r\n      while (currentPos) {\r\n        const nextPos = walk$1(direction, caretWalker, currentPos);\r\n        if (!nextPos) {\r\n          break;\r\n        }\r\n        if (isBr$6(nextPos.getNode(false))) {\r\n          if (direction === HDirection.Forwards) {\r\n            return {\r\n              positions: flip(direction, positions).concat([nextPos]),\r\n              breakType: BreakType.Br,\r\n              breakAt: Optional.some(nextPos)\r\n            };\r\n          } else {\r\n            return {\r\n              positions: flip(direction, positions),\r\n              breakType: BreakType.Br,\r\n              breakAt: Optional.some(nextPos)\r\n            };\r\n          }\r\n        }\r\n        if (!nextPos.isVisible()) {\r\n          currentPos = nextPos;\r\n          continue;\r\n        }\r\n        if (predicate(currentPos, nextPos)) {\r\n          const breakType = getBreakType(scope, direction, currentPos, nextPos);\r\n          return {\r\n            positions: flip(direction, positions),\r\n            breakType,\r\n            breakAt: Optional.some(nextPos)\r\n          };\r\n        }\r\n        positions.push(nextPos);\r\n        currentPos = nextPos;\r\n      }\r\n      return {\r\n        positions: flip(direction, positions),\r\n        breakType: BreakType.Eol,\r\n        breakAt: Optional.none()\r\n      };\r\n    };\r\n    const getAdjacentLinePositions = (direction, getPositionsUntilBreak, scope, start) => getPositionsUntilBreak(scope, start).breakAt.map(pos => {\r\n      const positions = getPositionsUntilBreak(scope, pos).positions;\r\n      return direction === HDirection.Backwards ? positions.concat(pos) : [pos].concat(positions);\r\n    }).getOr([]);\r\n    const findClosestHorizontalPositionFromPoint = (positions, x) => foldl(positions, (acc, newPos) => acc.fold(() => Optional.some(newPos), lastPos => lift2(head(lastPos.getClientRects()), head(newPos.getClientRects()), (lastRect, newRect) => {\r\n      const lastDist = Math.abs(x - lastRect.left);\r\n      const newDist = Math.abs(x - newRect.left);\r\n      return newDist <= lastDist ? newPos : lastPos;\r\n    }).or(acc)), Optional.none());\r\n    const findClosestHorizontalPosition = (positions, pos) => head(pos.getClientRects()).bind(targetRect => findClosestHorizontalPositionFromPoint(positions, targetRect.left));\r\n    const getPositionsUntilPreviousLine = curry(getPositionsUntil, CaretPosition.isAbove, -1);\r\n    const getPositionsUntilNextLine = curry(getPositionsUntil, CaretPosition.isBelow, 1);\r\n    const getPositionsAbove = curry(getAdjacentLinePositions, -1, getPositionsUntilPreviousLine);\r\n    const getPositionsBelow = curry(getAdjacentLinePositions, 1, getPositionsUntilNextLine);\r\n    const isAtFirstLine = (scope, pos) => getPositionsUntilPreviousLine(scope, pos).breakAt.isNone();\r\n    const isAtLastLine = (scope, pos) => getPositionsUntilNextLine(scope, pos).breakAt.isNone();\r\n    const getFirstLinePositions = scope => firstPositionIn(scope).map(pos => [pos].concat(getPositionsUntilNextLine(scope, pos).positions)).getOr([]);\r\n    const getLastLinePositions = scope => lastPositionIn(scope).map(pos => getPositionsUntilPreviousLine(scope, pos).positions.concat(pos)).getOr([]);\r\n    const getClosestPositionAbove = (scope, pos) => findClosestHorizontalPosition(getPositionsAbove(scope, pos), pos);\r\n    const getClosestPositionBelow = (scope, pos) => findClosestHorizontalPosition(getPositionsBelow(scope, pos), pos);\r\n\r\n    const isContentEditableFalse$4 = isContentEditableFalse$b;\r\n    const distanceToRectLeft$1 = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\r\n    const distanceToRectRight$1 = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\r\n    const isNodeClientRect = rect => hasNonNullableKey(rect, 'node');\r\n    const findClosestClientRect = (clientRects, clientX) => reduce(clientRects, (oldClientRect, clientRect) => {\r\n      const oldDistance = Math.min(distanceToRectLeft$1(oldClientRect, clientX), distanceToRectRight$1(oldClientRect, clientX));\r\n      const newDistance = Math.min(distanceToRectLeft$1(clientRect, clientX), distanceToRectRight$1(clientRect, clientX));\r\n      if (newDistance === oldDistance && isNodeClientRect(clientRect) && isContentEditableFalse$4(clientRect.node)) {\r\n        return clientRect;\r\n      }\r\n      if (newDistance < oldDistance) {\r\n        return clientRect;\r\n      }\r\n      return oldClientRect;\r\n    });\r\n\r\n    const getNodeClientRects = node => {\r\n      const toArrayWithNode = clientRects => {\r\n        return map$3(clientRects, rect => {\r\n          const clientRect = clone$1(rect);\r\n          clientRect.node = node;\r\n          return clientRect;\r\n        });\r\n      };\r\n      if (isElement$6(node)) {\r\n        return toArrayWithNode(node.getClientRects());\r\n      } else if (isText$a(node)) {\r\n        const rng = node.ownerDocument.createRange();\r\n        rng.setStart(node, 0);\r\n        rng.setEnd(node, node.data.length);\r\n        return toArrayWithNode(rng.getClientRects());\r\n      } else {\r\n        return [];\r\n      }\r\n    };\r\n    const getClientRects = nodes => bind$3(nodes, getNodeClientRects);\r\n\r\n    var VDirection;\r\n    (function (VDirection) {\r\n      VDirection[VDirection['Up'] = -1] = 'Up';\r\n      VDirection[VDirection['Down'] = 1] = 'Down';\r\n    }(VDirection || (VDirection = {})));\r\n    const findUntil = (direction, root, predicateFn, node) => {\r\n      let currentNode = node;\r\n      while (currentNode = findNode(currentNode, direction, isEditableCaretCandidate$1, root)) {\r\n        if (predicateFn(currentNode)) {\r\n          return;\r\n        }\r\n      }\r\n    };\r\n    const walkUntil = (direction, isAboveFn, isBeflowFn, root, predicateFn, caretPosition) => {\r\n      let line = 0;\r\n      const result = [];\r\n      const add = node => {\r\n        let clientRects = getClientRects([node]);\r\n        if (direction === -1) {\r\n          clientRects = clientRects.reverse();\r\n        }\r\n        for (let i = 0; i < clientRects.length; i++) {\r\n          const clientRect = clientRects[i];\r\n          if (isBeflowFn(clientRect, targetClientRect)) {\r\n            continue;\r\n          }\r\n          if (result.length > 0 && isAboveFn(clientRect, last$2(result))) {\r\n            line++;\r\n          }\r\n          clientRect.line = line;\r\n          if (predicateFn(clientRect)) {\r\n            return true;\r\n          }\r\n          result.push(clientRect);\r\n        }\r\n        return false;\r\n      };\r\n      const targetClientRect = last$2(caretPosition.getClientRects());\r\n      if (!targetClientRect) {\r\n        return result;\r\n      }\r\n      const node = caretPosition.getNode();\r\n      if (node) {\r\n        add(node);\r\n        findUntil(direction, root, add, node);\r\n      }\r\n      return result;\r\n    };\r\n    const aboveLineNumber = (lineNumber, clientRect) => clientRect.line > lineNumber;\r\n    const isLineNumber = (lineNumber, clientRect) => clientRect.line === lineNumber;\r\n    const upUntil = curry(walkUntil, VDirection.Up, isAbove$1, isBelow$1);\r\n    const downUntil = curry(walkUntil, VDirection.Down, isBelow$1, isAbove$1);\r\n    const getLastClientRect = caretPosition => {\r\n      return last$2(caretPosition.getClientRects());\r\n    };\r\n    const positionsUntil = (direction, root, predicateFn, node) => {\r\n      const caretWalker = CaretWalker(root);\r\n      let walkFn;\r\n      let isBelowFn;\r\n      let isAboveFn;\r\n      let caretPosition;\r\n      const result = [];\r\n      let line = 0;\r\n      if (direction === 1) {\r\n        walkFn = caretWalker.next;\r\n        isBelowFn = isBelow$1;\r\n        isAboveFn = isAbove$1;\r\n        caretPosition = CaretPosition.after(node);\r\n      } else {\r\n        walkFn = caretWalker.prev;\r\n        isBelowFn = isAbove$1;\r\n        isAboveFn = isBelow$1;\r\n        caretPosition = CaretPosition.before(node);\r\n      }\r\n      const targetClientRect = getLastClientRect(caretPosition);\r\n      do {\r\n        if (!caretPosition.isVisible()) {\r\n          continue;\r\n        }\r\n        const rect = getLastClientRect(caretPosition);\r\n        if (isAboveFn(rect, targetClientRect)) {\r\n          continue;\r\n        }\r\n        if (result.length > 0 && isBelowFn(rect, last$2(result))) {\r\n          line++;\r\n        }\r\n        const clientRect = clone$1(rect);\r\n        clientRect.position = caretPosition;\r\n        clientRect.line = line;\r\n        if (predicateFn(clientRect)) {\r\n          return result;\r\n        }\r\n        result.push(clientRect);\r\n      } while (caretPosition = walkFn(caretPosition));\r\n      return result;\r\n    };\r\n    const isAboveLine = lineNumber => clientRect => aboveLineNumber(lineNumber, clientRect);\r\n    const isLine = lineNumber => clientRect => isLineNumber(lineNumber, clientRect);\r\n\r\n    const moveToRange = (editor, rng) => {\r\n      editor.selection.setRng(rng);\r\n      scrollRangeIntoView(editor, editor.selection.getRng());\r\n    };\r\n    const renderRangeCaretOpt = (editor, range, scrollIntoView) => Optional.some(renderRangeCaret(editor, range, scrollIntoView));\r\n    const moveHorizontally = (editor, direction, range, isBefore, isAfter, isElement) => {\r\n      const forwards = direction === HDirection.Forwards;\r\n      const caretWalker = CaretWalker(editor.getBody());\r\n      const getNextPosFn = curry(getVisualCaretPosition, forwards ? caretWalker.next : caretWalker.prev);\r\n      const isBeforeFn = forwards ? isBefore : isAfter;\r\n      if (!range.collapsed) {\r\n        const node = getSelectedNode(range);\r\n        if (isElement(node)) {\r\n          return showCaret(direction, editor, node, direction === HDirection.Backwards, false);\r\n        } else if (isCefAtEdgeSelected(editor)) {\r\n          const newRange = range.cloneRange();\r\n          newRange.collapse(direction === HDirection.Backwards);\r\n          return Optional.from(newRange);\r\n        }\r\n      }\r\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\r\n      if (isBeforeFn(caretPosition)) {\r\n        return selectNode(editor, caretPosition.getNode(!forwards));\r\n      }\r\n      let nextCaretPosition = getNextPosFn(caretPosition);\r\n      const rangeIsInContainerBlock = isRangeInCaretContainerBlock(range);\r\n      if (!nextCaretPosition) {\r\n        return rangeIsInContainerBlock ? Optional.some(range) : Optional.none();\r\n      } else {\r\n        nextCaretPosition = normalizePosition(forwards, nextCaretPosition);\r\n      }\r\n      if (isBeforeFn(nextCaretPosition)) {\r\n        return showCaret(direction, editor, nextCaretPosition.getNode(!forwards), forwards, false);\r\n      }\r\n      const peekCaretPosition = getNextPosFn(nextCaretPosition);\r\n      if (peekCaretPosition && isBeforeFn(peekCaretPosition)) {\r\n        if (isMoveInsideSameBlock(nextCaretPosition, peekCaretPosition)) {\r\n          return showCaret(direction, editor, peekCaretPosition.getNode(!forwards), forwards, false);\r\n        }\r\n      }\r\n      if (rangeIsInContainerBlock) {\r\n        return renderRangeCaretOpt(editor, nextCaretPosition.toRange(), false);\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const moveVertically = (editor, direction, range, isBefore, isAfter, isElement) => {\r\n      const caretPosition = getNormalizedRangeEndPoint(direction, editor.getBody(), range);\r\n      const caretClientRect = last$2(caretPosition.getClientRects());\r\n      const forwards = direction === VDirection.Down;\r\n      const root = editor.getBody();\r\n      if (!caretClientRect) {\r\n        return Optional.none();\r\n      }\r\n      if (isCefAtEdgeSelected(editor)) {\r\n        const caretPosition = forwards ? CaretPosition.fromRangeEnd(range) : CaretPosition.fromRangeStart(range);\r\n        const getClosestFn = !forwards ? getClosestPositionAbove : getClosestPositionBelow;\r\n        return getClosestFn(root, caretPosition).orThunk(() => Optional.from(caretPosition)).map(pos => pos.toRange());\r\n      }\r\n      const walkerFn = forwards ? downUntil : upUntil;\r\n      const linePositions = walkerFn(root, isAboveLine(1), caretPosition);\r\n      const nextLinePositions = filter$5(linePositions, isLine(1));\r\n      const clientX = caretClientRect.left;\r\n      const nextLineRect = findClosestClientRect(nextLinePositions, clientX);\r\n      if (nextLineRect && isElement(nextLineRect.node)) {\r\n        const dist1 = Math.abs(clientX - nextLineRect.left);\r\n        const dist2 = Math.abs(clientX - nextLineRect.right);\r\n        return showCaret(direction, editor, nextLineRect.node, dist1 < dist2, false);\r\n      }\r\n      let currentNode;\r\n      if (isBefore(caretPosition)) {\r\n        currentNode = caretPosition.getNode();\r\n      } else if (isAfter(caretPosition)) {\r\n        currentNode = caretPosition.getNode(true);\r\n      } else {\r\n        currentNode = getSelectedNode(range);\r\n      }\r\n      if (currentNode) {\r\n        const caretPositions = positionsUntil(direction, root, isAboveLine(1), currentNode);\r\n        let closestNextLineRect = findClosestClientRect(filter$5(caretPositions, isLine(1)), clientX);\r\n        if (closestNextLineRect) {\r\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\r\n        }\r\n        closestNextLineRect = last$2(filter$5(caretPositions, isLine(0)));\r\n        if (closestNextLineRect) {\r\n          return renderRangeCaretOpt(editor, closestNextLineRect.position.toRange(), false);\r\n        }\r\n      }\r\n      if (nextLinePositions.length === 0) {\r\n        return getLineEndPoint(editor, forwards).filter(forwards ? isAfter : isBefore).map(pos => renderRangeCaret(editor, pos.toRange(), false));\r\n      }\r\n      return Optional.none();\r\n    };\r\n    const getLineEndPoint = (editor, forward) => {\r\n      const rng = editor.selection.getRng();\r\n      const from = forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\r\n      const host = getEditingHost(from.container(), editor.getBody());\r\n      if (forward) {\r\n        const lineInfo = getPositionsUntilNextLine(host, from);\r\n        return last$3(lineInfo.positions);\r\n      } else {\r\n        const lineInfo = getPositionsUntilPreviousLine(host, from);\r\n        return head(lineInfo.positions);\r\n      }\r\n    };\r\n    const moveToLineEndPoint$3 = (editor, forward, isElementPosition) => getLineEndPoint(editor, forward).filter(isElementPosition).exists(pos => {\r\n      editor.selection.setRng(pos.toRange());\r\n      return true;\r\n    });\r\n\r\n    const setCaretPosition = (editor, pos) => {\r\n      const rng = editor.dom.createRng();\r\n      rng.setStart(pos.container(), pos.offset());\r\n      rng.setEnd(pos.container(), pos.offset());\r\n      editor.selection.setRng(rng);\r\n    };\r\n    const setSelected = (state, elm) => {\r\n      if (state) {\r\n        elm.setAttribute('data-mce-selected', 'inline-boundary');\r\n      } else {\r\n        elm.removeAttribute('data-mce-selected');\r\n      }\r\n    };\r\n    const renderCaretLocation = (editor, caret, location) => renderCaret(caret, location).map(pos => {\r\n      setCaretPosition(editor, pos);\r\n      return location;\r\n    });\r\n    const getPositionFromRange = (range, root, forward) => {\r\n      const start = CaretPosition.fromRangeStart(range);\r\n      if (range.collapsed) {\r\n        return start;\r\n      } else {\r\n        const end = CaretPosition.fromRangeEnd(range);\r\n        return forward ? prevPosition(root, end).getOr(end) : nextPosition(root, start).getOr(start);\r\n      }\r\n    };\r\n    const findLocation = (editor, caret, forward) => {\r\n      const rootNode = editor.getBody();\r\n      const from = getPositionFromRange(editor.selection.getRng(), rootNode, forward);\r\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\r\n      const location = findLocation$1(forward, isInlineTarget$1, rootNode, from);\r\n      return location.bind(location => renderCaretLocation(editor, caret, location));\r\n    };\r\n    const toggleInlines = (isInlineTarget, dom, elms) => {\r\n      const inlineBoundaries = map$3(descendants(SugarElement.fromDom(dom.getRoot()), '*[data-mce-selected=\"inline-boundary\"]'), e => e.dom);\r\n      const selectedInlines = filter$5(inlineBoundaries, isInlineTarget);\r\n      const targetInlines = filter$5(elms, isInlineTarget);\r\n      each$e(difference(selectedInlines, targetInlines), curry(setSelected, false));\r\n      each$e(difference(targetInlines, selectedInlines), curry(setSelected, true));\r\n    };\r\n    const safeRemoveCaretContainer = (editor, caret) => {\r\n      const caretValue = caret.get();\r\n      if (editor.selection.isCollapsed() && !editor.composing && caretValue) {\r\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n        if (CaretPosition.isTextPosition(pos) && !isAtZwsp(pos)) {\r\n          setCaretPosition(editor, removeAndReposition(caretValue, pos));\r\n          caret.set(null);\r\n        }\r\n      }\r\n    };\r\n    const renderInsideInlineCaret = (isInlineTarget, editor, caret, elms) => {\r\n      if (editor.selection.isCollapsed()) {\r\n        const inlines = filter$5(elms, isInlineTarget);\r\n        each$e(inlines, _inline => {\r\n          const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n          readLocation(isInlineTarget, editor.getBody(), pos).bind(location => renderCaretLocation(editor, caret, location));\r\n        });\r\n      }\r\n    };\r\n    const move$3 = (editor, caret, forward) => isInlineBoundariesEnabled(editor) ? findLocation(editor, caret, forward).isSome() : false;\r\n    const moveWord = (forward, editor, _caret) => isInlineBoundariesEnabled(editor) ? moveByWord(forward, editor) : false;\r\n    const setupSelectedState = editor => {\r\n      const caret = Cell(null);\r\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\r\n      editor.on('NodeChange', e => {\r\n        if (isInlineBoundariesEnabled(editor)) {\r\n          toggleInlines(isInlineTarget$1, editor.dom, e.parents);\r\n          safeRemoveCaretContainer(editor, caret);\r\n          renderInsideInlineCaret(isInlineTarget$1, editor, caret, e.parents);\r\n        }\r\n      });\r\n      return caret;\r\n    };\r\n    const moveNextWord = curry(moveWord, true);\r\n    const movePrevWord = curry(moveWord, false);\r\n    const moveToLineEndPoint$2 = (editor, forward, caret) => {\r\n      if (isInlineBoundariesEnabled(editor)) {\r\n        const linePoint = getLineEndPoint(editor, forward).getOrThunk(() => {\r\n          const rng = editor.selection.getRng();\r\n          return forward ? CaretPosition.fromRangeEnd(rng) : CaretPosition.fromRangeStart(rng);\r\n        });\r\n        return readLocation(curry(isInlineTarget, editor), editor.getBody(), linePoint).exists(loc => {\r\n          const outsideLoc = outside(loc);\r\n          return renderCaret(caret, outsideLoc).exists(pos => {\r\n            setCaretPosition(editor, pos);\r\n            return true;\r\n          });\r\n        });\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    const rangeFromPositions = (from, to) => {\r\n      const range = document.createRange();\r\n      range.setStart(from.container(), from.offset());\r\n      range.setEnd(to.container(), to.offset());\r\n      return range;\r\n    };\r\n    const hasOnlyTwoOrLessPositionsLeft = elm => lift2(firstPositionIn(elm), lastPositionIn(elm), (firstPos, lastPos) => {\r\n      const normalizedFirstPos = normalizePosition(true, firstPos);\r\n      const normalizedLastPos = normalizePosition(false, lastPos);\r\n      return nextPosition(elm, normalizedFirstPos).forall(pos => pos.isEqual(normalizedLastPos));\r\n    }).getOr(true);\r\n    const setCaretLocation = (editor, caret) => location => renderCaret(caret, location).map(pos => () => setCaretPosition(editor, pos));\r\n    const deleteFromTo = (editor, caret, from, to) => {\r\n      const rootNode = editor.getBody();\r\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\r\n      editor.undoManager.ignore(() => {\r\n        editor.selection.setRng(rangeFromPositions(from, to));\r\n        execNativeDeleteCommand(editor);\r\n        readLocation(isInlineTarget$1, rootNode, CaretPosition.fromRangeStart(editor.selection.getRng())).map(inside).bind(setCaretLocation(editor, caret)).each(call);\r\n      });\r\n      editor.nodeChanged();\r\n    };\r\n    const rescope = (rootNode, node) => {\r\n      const parentBlock = getParentBlock$3(node, rootNode);\r\n      return parentBlock ? parentBlock : rootNode;\r\n    };\r\n    const backspaceDeleteCollapsed = (editor, caret, forward, from) => {\r\n      const rootNode = rescope(editor.getBody(), from.container());\r\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\r\n      const fromLocation = readLocation(isInlineTarget$1, rootNode, from);\r\n      const location = fromLocation.bind(location => {\r\n        if (forward) {\r\n          return location.fold(constant(Optional.some(inside(location))), Optional.none, constant(Optional.some(outside(location))), Optional.none);\r\n        } else {\r\n          return location.fold(Optional.none, constant(Optional.some(outside(location))), Optional.none, constant(Optional.some(inside(location))));\r\n        }\r\n      });\r\n      return location.map(setCaretLocation(editor, caret)).getOrThunk(() => {\r\n        const toPosition = navigate(forward, rootNode, from);\r\n        const toLocation = toPosition.bind(pos => readLocation(isInlineTarget$1, rootNode, pos));\r\n        return lift2(fromLocation, toLocation, () => findRootInline(isInlineTarget$1, rootNode, from).bind(elm => {\r\n          if (hasOnlyTwoOrLessPositionsLeft(elm)) {\r\n            return Optional.some(() => {\r\n              deleteElement$2(editor, forward, SugarElement.fromDom(elm));\r\n            });\r\n          } else {\r\n            return Optional.none();\r\n          }\r\n        })).getOrThunk(() => toLocation.bind(() => toPosition.map(to => {\r\n          return () => {\r\n            if (forward) {\r\n              deleteFromTo(editor, caret, from, to);\r\n            } else {\r\n              deleteFromTo(editor, caret, to, from);\r\n            }\r\n          };\r\n        })));\r\n      });\r\n    };\r\n    const backspaceDelete$4 = (editor, caret, forward) => {\r\n      if (editor.selection.isCollapsed() && isInlineBoundariesEnabled(editor)) {\r\n        const from = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n        return backspaceDeleteCollapsed(editor, caret, forward, from);\r\n      }\r\n      return Optional.none();\r\n    };\r\n\r\n    const hasMultipleChildren = elm => childNodesCount(elm) > 1;\r\n    const getParentsUntil = (editor, pred) => {\r\n      const rootElm = SugarElement.fromDom(editor.getBody());\r\n      const startElm = SugarElement.fromDom(editor.selection.getStart());\r\n      const parents = parentsAndSelf(startElm, rootElm);\r\n      return findIndex$2(parents, pred).fold(constant(parents), index => parents.slice(0, index));\r\n    };\r\n    const hasOnlyOneChild = elm => childNodesCount(elm) === 1;\r\n    const getParentInlinesUntilMultichildInline = editor => getParentsUntil(editor, elm => editor.schema.isBlock(name(elm)) || hasMultipleChildren(elm));\r\n    const getParentInlines = editor => getParentsUntil(editor, el => editor.schema.isBlock(name(el)));\r\n    const getFormatNodes = (editor, parentInlines) => {\r\n      const isFormatElement$1 = curry(isFormatElement, editor);\r\n      return bind$3(parentInlines, elm => isFormatElement$1(elm) ? [elm.dom] : []);\r\n    };\r\n    const getFormatNodesAtStart = editor => {\r\n      const parentInlines = getParentInlines(editor);\r\n      return getFormatNodes(editor, parentInlines);\r\n    };\r\n    const deleteLastPosition = (forward, editor, target, parentInlines) => {\r\n      const formatNodes = getFormatNodes(editor, parentInlines);\r\n      if (formatNodes.length === 0) {\r\n        deleteElement$2(editor, forward, target);\r\n      } else {\r\n        const pos = replaceWithCaretFormat(target.dom, formatNodes);\r\n        editor.selection.setRng(pos.toRange());\r\n      }\r\n    };\r\n    const deleteCaret$1 = (editor, forward) => {\r\n      const parentInlines = filter$5(getParentInlinesUntilMultichildInline(editor), hasOnlyOneChild);\r\n      return last$3(parentInlines).bind(target => {\r\n        const fromPos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n        if (willDeleteLastPositionInElement(forward, fromPos, target.dom) && !isEmptyCaretFormatElement(target)) {\r\n          return Optional.some(() => deleteLastPosition(forward, editor, target, parentInlines));\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      });\r\n    };\r\n    const isBrInEmptyElement = (editor, elm) => {\r\n      const parentElm = elm.parentElement;\r\n      return isBr$6(elm) && !isNull(parentElm) && editor.dom.isEmpty(parentElm);\r\n    };\r\n    const isEmptyCaret = elm => isEmptyCaretFormatElement(SugarElement.fromDom(elm));\r\n    const createCaretFormatAtStart = (editor, formatNodes) => {\r\n      const startElm = editor.selection.getStart();\r\n      const pos = isBrInEmptyElement(editor, startElm) || isEmptyCaret(startElm) ? replaceWithCaretFormat(startElm, formatNodes) : createCaretFormatAtStart$1(editor.selection.getRng(), formatNodes);\r\n      editor.selection.setRng(pos.toRange());\r\n    };\r\n    const updateCaretFormat = (editor, updateFormats) => {\r\n      const missingFormats = difference(updateFormats, getFormatNodesAtStart(editor));\r\n      if (missingFormats.length > 0) {\r\n        createCaretFormatAtStart(editor, missingFormats);\r\n      }\r\n    };\r\n    const rangeStartsAtTextContainer = rng => isText$a(rng.startContainer);\r\n    const rangeStartsAtStartOfTextContainer = rng => rng.startOffset === 0 && rangeStartsAtTextContainer(rng);\r\n    const rangeStartParentIsFormatElement = (editor, rng) => {\r\n      const startParent = rng.startContainer.parentElement;\r\n      return !isNull(startParent) && isFormatElement(editor, SugarElement.fromDom(startParent));\r\n    };\r\n    const rangeStartAndEndHaveSameParent = rng => {\r\n      const startParent = rng.startContainer.parentNode;\r\n      const endParent = rng.endContainer.parentNode;\r\n      return !isNull(startParent) && !isNull(endParent) && startParent.isEqualNode(endParent);\r\n    };\r\n    const rangeEndsAtEndOfEndContainer = rng => {\r\n      const endContainer = rng.endContainer;\r\n      return rng.endOffset === (isText$a(endContainer) ? endContainer.length : endContainer.childNodes.length);\r\n    };\r\n    const rangeEndsAtEndOfStartContainer = rng => rangeStartAndEndHaveSameParent(rng) && rangeEndsAtEndOfEndContainer(rng);\r\n    const rangeEndsAfterEndOfStartContainer = rng => !rng.endContainer.isEqualNode(rng.commonAncestorContainer);\r\n    const rangeEndsAtOrAfterEndOfStartContainer = rng => rangeEndsAtEndOfStartContainer(rng) || rangeEndsAfterEndOfStartContainer(rng);\r\n    const requiresDeleteRangeOverride = editor => {\r\n      const rng = editor.selection.getRng();\r\n      return rangeStartsAtStartOfTextContainer(rng) && rangeStartParentIsFormatElement(editor, rng) && rangeEndsAtOrAfterEndOfStartContainer(rng);\r\n    };\r\n    const deleteRange$1 = editor => {\r\n      if (requiresDeleteRangeOverride(editor)) {\r\n        const formatNodes = getFormatNodesAtStart(editor);\r\n        return Optional.some(() => {\r\n          execNativeDeleteCommand(editor);\r\n          updateCaretFormat(editor, formatNodes);\r\n        });\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const backspaceDelete$3 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret$1(editor, forward) : deleteRange$1(editor);\r\n    const hasAncestorInlineCaret = (elm, schema) => ancestor$1(elm, node => isCaretNode(node.dom), el => schema.isBlock(name(el)));\r\n    const hasAncestorInlineCaretAtStart = editor => hasAncestorInlineCaret(SugarElement.fromDom(editor.selection.getStart()), editor.schema);\r\n    const requiresRefreshCaretOverride = editor => {\r\n      const rng = editor.selection.getRng();\r\n      return rng.collapsed && (rangeStartsAtTextContainer(rng) || editor.dom.isEmpty(rng.startContainer)) && !hasAncestorInlineCaretAtStart(editor);\r\n    };\r\n    const refreshCaret = editor => {\r\n      if (requiresRefreshCaretOverride(editor)) {\r\n        createCaretFormatAtStart(editor, []);\r\n      }\r\n      return true;\r\n    };\r\n\r\n    const deleteElement = (editor, forward, element) => {\r\n      if (isNonNullable(element)) {\r\n        return Optional.some(() => {\r\n          editor._selectionOverrides.hideFakeCaret();\r\n          deleteElement$2(editor, forward, SugarElement.fromDom(element));\r\n        });\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const deleteCaret = (editor, forward) => {\r\n      const isNearMedia = forward ? isBeforeMedia : isAfterMedia;\r\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\r\n      const fromPos = getNormalizedRangeEndPoint(direction, editor.getBody(), editor.selection.getRng());\r\n      if (isNearMedia(fromPos)) {\r\n        return deleteElement(editor, forward, fromPos.getNode(!forward));\r\n      } else {\r\n        return Optional.from(normalizePosition(forward, fromPos)).filter(pos => isNearMedia(pos) && isMoveInsideSameBlock(fromPos, pos)).bind(pos => deleteElement(editor, forward, pos.getNode(!forward)));\r\n      }\r\n    };\r\n    const deleteRange = (editor, forward) => {\r\n      const selectedNode = editor.selection.getNode();\r\n      return isMedia$2(selectedNode) ? deleteElement(editor, forward, selectedNode) : Optional.none();\r\n    };\r\n    const backspaceDelete$2 = (editor, forward) => editor.selection.isCollapsed() ? deleteCaret(editor, forward) : deleteRange(editor, forward);\r\n\r\n    const isEditable = target => closest$4(target, elm => isContentEditableTrue$3(elm.dom) || isContentEditableFalse$b(elm.dom)).exists(elm => isContentEditableTrue$3(elm.dom));\r\n    const parseIndentValue = value => toInt(value !== null && value !== void 0 ? value : '').getOr(0);\r\n    const getIndentStyleName = (useMargin, element) => {\r\n      const indentStyleName = useMargin || isTable$1(element) ? 'margin' : 'padding';\r\n      const suffix = get$7(element, 'direction') === 'rtl' ? '-right' : '-left';\r\n      return indentStyleName + suffix;\r\n    };\r\n    const indentElement = (dom, command, useMargin, value, unit, element) => {\r\n      const indentStyleName = getIndentStyleName(useMargin, SugarElement.fromDom(element));\r\n      const parsedValue = parseIndentValue(dom.getStyle(element, indentStyleName));\r\n      if (command === 'outdent') {\r\n        const styleValue = Math.max(0, parsedValue - value);\r\n        dom.setStyle(element, indentStyleName, styleValue ? styleValue + unit : '');\r\n      } else {\r\n        const styleValue = parsedValue + value + unit;\r\n        dom.setStyle(element, indentStyleName, styleValue);\r\n      }\r\n    };\r\n    const validateBlocks = (editor, blocks) => forall(blocks, block => {\r\n      const indentStyleName = getIndentStyleName(shouldIndentUseMargin(editor), block);\r\n      const intentValue = getRaw(block, indentStyleName).map(parseIndentValue).getOr(0);\r\n      const contentEditable = editor.dom.getContentEditable(block.dom);\r\n      return contentEditable !== 'false' && intentValue > 0;\r\n    });\r\n    const canOutdent = editor => {\r\n      const blocks = getBlocksToIndent(editor);\r\n      return !editor.mode.isReadOnly() && (blocks.length > 1 || validateBlocks(editor, blocks));\r\n    };\r\n    const isListComponent = el => isList(el) || isListItem$1(el);\r\n    const parentIsListComponent = el => parent(el).exists(isListComponent);\r\n    const getBlocksToIndent = editor => filter$5(fromDom$1(editor.selection.getSelectedBlocks()), el => !isListComponent(el) && !parentIsListComponent(el) && isEditable(el));\r\n    const handle = (editor, command) => {\r\n      var _a, _b;\r\n      const {dom} = editor;\r\n      const indentation = getIndentation(editor);\r\n      const indentUnit = (_b = (_a = /[a-z%]+$/i.exec(indentation)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : 'px';\r\n      const indentValue = parseIndentValue(indentation);\r\n      const useMargin = shouldIndentUseMargin(editor);\r\n      each$e(getBlocksToIndent(editor), block => {\r\n        indentElement(dom, command, useMargin, indentValue, indentUnit, block.dom);\r\n      });\r\n    };\r\n    const indent = editor => handle(editor, 'indent');\r\n    const outdent = editor => handle(editor, 'outdent');\r\n\r\n    const backspaceDelete$1 = editor => {\r\n      if (editor.selection.isCollapsed() && canOutdent(editor)) {\r\n        const dom = editor.dom;\r\n        const rng = editor.selection.getRng();\r\n        const pos = CaretPosition.fromRangeStart(rng);\r\n        const block = dom.getParent(rng.startContainer, dom.isBlock);\r\n        if (block !== null && isAtStartOfBlock(SugarElement.fromDom(block), pos, editor.schema)) {\r\n          return Optional.some(() => outdent(editor));\r\n        }\r\n      }\r\n      return Optional.none();\r\n    };\r\n\r\n    const findAction = (editor, caret, forward) => findMap([\r\n      backspaceDelete$1,\r\n      backspaceDelete$6,\r\n      backspaceDelete$7,\r\n      (editor, forward) => backspaceDelete$4(editor, caret, forward),\r\n      backspaceDelete$9,\r\n      backspaceDelete$a,\r\n      backspaceDelete$5,\r\n      backspaceDelete$2,\r\n      backspaceDelete$8,\r\n      backspaceDelete$3\r\n    ], item => item(editor, forward)).filter(_ => editor.selection.isEditable());\r\n    const deleteCommand = (editor, caret) => {\r\n      const result = findAction(editor, caret, false);\r\n      result.fold(() => {\r\n        if (editor.selection.isEditable()) {\r\n          execNativeDeleteCommand(editor);\r\n          paddEmptyBody(editor);\r\n        }\r\n      }, call);\r\n    };\r\n    const forwardDeleteCommand = (editor, caret) => {\r\n      const result = findAction(editor, caret, true);\r\n      result.fold(() => {\r\n        if (editor.selection.isEditable()) {\r\n          execNativeForwardDeleteCommand(editor);\r\n        }\r\n      }, call);\r\n    };\r\n    const setup$q = (editor, caret) => {\r\n      editor.addCommand('delete', () => {\r\n        deleteCommand(editor, caret);\r\n      });\r\n      editor.addCommand('forwardDelete', () => {\r\n        forwardDeleteCommand(editor, caret);\r\n      });\r\n    };\r\n\r\n    const SIGNIFICANT_MOVE = 5;\r\n    const LONGPRESS_DELAY = 400;\r\n    const getTouch = event => {\r\n      if (event.touches === undefined || event.touches.length !== 1) {\r\n        return Optional.none();\r\n      }\r\n      return Optional.some(event.touches[0]);\r\n    };\r\n    const isFarEnough = (touch, data) => {\r\n      const distX = Math.abs(touch.clientX - data.x);\r\n      const distY = Math.abs(touch.clientY - data.y);\r\n      return distX > SIGNIFICANT_MOVE || distY > SIGNIFICANT_MOVE;\r\n    };\r\n    const setup$p = editor => {\r\n      const startData = value$2();\r\n      const longpressFired = Cell(false);\r\n      const debounceLongpress = last$1(e => {\r\n        editor.dispatch('longpress', {\r\n          ...e,\r\n          type: 'longpress'\r\n        });\r\n        longpressFired.set(true);\r\n      }, LONGPRESS_DELAY);\r\n      editor.on('touchstart', e => {\r\n        getTouch(e).each(touch => {\r\n          debounceLongpress.cancel();\r\n          const data = {\r\n            x: touch.clientX,\r\n            y: touch.clientY,\r\n            target: e.target\r\n          };\r\n          debounceLongpress.throttle(e);\r\n          longpressFired.set(false);\r\n          startData.set(data);\r\n        });\r\n      }, true);\r\n      editor.on('touchmove', e => {\r\n        debounceLongpress.cancel();\r\n        getTouch(e).each(touch => {\r\n          startData.on(data => {\r\n            if (isFarEnough(touch, data)) {\r\n              startData.clear();\r\n              longpressFired.set(false);\r\n              editor.dispatch('longpresscancel');\r\n            }\r\n          });\r\n        });\r\n      }, true);\r\n      editor.on('touchend touchcancel', e => {\r\n        debounceLongpress.cancel();\r\n        if (e.type === 'touchcancel') {\r\n          return;\r\n        }\r\n        startData.get().filter(data => data.target.isEqualNode(e.target)).each(() => {\r\n          if (longpressFired.get()) {\r\n            e.preventDefault();\r\n          } else {\r\n            editor.dispatch('tap', {\r\n              ...e,\r\n              type: 'tap'\r\n            });\r\n          }\r\n        });\r\n      }, true);\r\n    };\r\n\r\n    const isBlockElement = (blockElements, node) => has$2(blockElements, node.nodeName);\r\n    const isValidTarget = (schema, node) => {\r\n      if (isText$a(node)) {\r\n        return true;\r\n      } else if (isElement$6(node)) {\r\n        return !isBlockElement(schema.getBlockElements(), node) && !isBookmarkNode$1(node) && !isTransparentBlock(schema, node) && !isNonHtmlElementRoot(node);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const hasBlockParent = (blockElements, root, node) => {\r\n      return exists(parents(SugarElement.fromDom(node), SugarElement.fromDom(root)), elm => {\r\n        return isBlockElement(blockElements, elm.dom);\r\n      });\r\n    };\r\n    const shouldRemoveTextNode = (blockElements, node) => {\r\n      if (isText$a(node)) {\r\n        if (node.data.length === 0) {\r\n          return true;\r\n        } else if (/^\\s+$/.test(node.data)) {\r\n          return !node.nextSibling || isBlockElement(blockElements, node.nextSibling) || isNonHtmlElementRoot(node.nextSibling);\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    const createRootBlock = editor => editor.dom.create(getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\r\n    const addRootBlocks = editor => {\r\n      const dom = editor.dom, selection = editor.selection;\r\n      const schema = editor.schema;\r\n      const blockElements = schema.getBlockElements();\r\n      const startNode = selection.getStart();\r\n      const rootNode = editor.getBody();\r\n      let rootBlockNode;\r\n      let tempNode;\r\n      let wrapped = false;\r\n      const forcedRootBlock = getForcedRootBlock(editor);\r\n      if (!startNode || !isElement$6(startNode)) {\r\n        return;\r\n      }\r\n      const rootNodeName = rootNode.nodeName.toLowerCase();\r\n      if (!schema.isValidChild(rootNodeName, forcedRootBlock.toLowerCase()) || hasBlockParent(blockElements, rootNode, startNode)) {\r\n        return;\r\n      }\r\n      const rng = selection.getRng();\r\n      const {startContainer, startOffset, endContainer, endOffset} = rng;\r\n      const restoreSelection = hasFocus(editor);\r\n      let node = rootNode.firstChild;\r\n      while (node) {\r\n        if (isElement$6(node)) {\r\n          updateElement(schema, node);\r\n        }\r\n        if (isValidTarget(schema, node)) {\r\n          if (shouldRemoveTextNode(blockElements, node)) {\r\n            tempNode = node;\r\n            node = node.nextSibling;\r\n            dom.remove(tempNode);\r\n            continue;\r\n          }\r\n          if (!rootBlockNode) {\r\n            rootBlockNode = createRootBlock(editor);\r\n            rootNode.insertBefore(rootBlockNode, node);\r\n            wrapped = true;\r\n          }\r\n          tempNode = node;\r\n          node = node.nextSibling;\r\n          rootBlockNode.appendChild(tempNode);\r\n        } else {\r\n          rootBlockNode = null;\r\n          node = node.nextSibling;\r\n        }\r\n      }\r\n      if (wrapped && restoreSelection) {\r\n        rng.setStart(startContainer, startOffset);\r\n        rng.setEnd(endContainer, endOffset);\r\n        selection.setRng(rng);\r\n        editor.nodeChanged();\r\n      }\r\n    };\r\n    const insertEmptyLine = (editor, root, insertBlock) => {\r\n      const block = SugarElement.fromDom(createRootBlock(editor));\r\n      const br = createPaddingBr();\r\n      append$1(block, br);\r\n      insertBlock(root, block);\r\n      const rng = document.createRange();\r\n      rng.setStartBefore(br.dom);\r\n      rng.setEndBefore(br.dom);\r\n      return rng;\r\n    };\r\n    const setup$o = editor => {\r\n      editor.on('NodeChange', curry(addRootBlocks, editor));\r\n    };\r\n\r\n    const hasClass = checkClassName => node => (' ' + node.attr('class') + ' ').indexOf(checkClassName) !== -1;\r\n    const replaceMatchWithSpan = (editor, content, cls) => {\r\n      return function (match) {\r\n        const args = arguments, index = args[args.length - 2];\r\n        const prevChar = index > 0 ? content.charAt(index - 1) : '';\r\n        if (prevChar === '\"') {\r\n          return match;\r\n        }\r\n        if (prevChar === '>') {\r\n          const findStartTagIndex = content.lastIndexOf('<', index);\r\n          if (findStartTagIndex !== -1) {\r\n            const tagHtml = content.substring(findStartTagIndex, index);\r\n            if (tagHtml.indexOf('contenteditable=\"false\"') !== -1) {\r\n              return match;\r\n            }\r\n          }\r\n        }\r\n        return '<span class=\"' + cls + '\" data-mce-content=\"' + editor.dom.encode(args[0]) + '\">' + editor.dom.encode(typeof args[1] === 'string' ? args[1] : args[0]) + '</span>';\r\n      };\r\n    };\r\n    const convertRegExpsToNonEditable = (editor, nonEditableRegExps, e) => {\r\n      let i = nonEditableRegExps.length, content = e.content;\r\n      if (e.format === 'raw') {\r\n        return;\r\n      }\r\n      while (i--) {\r\n        content = content.replace(nonEditableRegExps[i], replaceMatchWithSpan(editor, content, getNonEditableClass(editor)));\r\n      }\r\n      e.content = content;\r\n    };\r\n    const setup$n = editor => {\r\n      const contentEditableAttrName = 'contenteditable';\r\n      const editClass = ' ' + Tools.trim(getEditableClass(editor)) + ' ';\r\n      const nonEditClass = ' ' + Tools.trim(getNonEditableClass(editor)) + ' ';\r\n      const hasEditClass = hasClass(editClass);\r\n      const hasNonEditClass = hasClass(nonEditClass);\r\n      const nonEditableRegExps = getNonEditableRegExps(editor);\r\n      if (nonEditableRegExps.length > 0) {\r\n        editor.on('BeforeSetContent', e => {\r\n          convertRegExpsToNonEditable(editor, nonEditableRegExps, e);\r\n        });\r\n      }\r\n      editor.parser.addAttributeFilter('class', nodes => {\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          if (hasEditClass(node)) {\r\n            node.attr(contentEditableAttrName, 'true');\r\n          } else if (hasNonEditClass(node)) {\r\n            node.attr(contentEditableAttrName, 'false');\r\n          }\r\n        }\r\n      });\r\n      editor.serializer.addAttributeFilter(contentEditableAttrName, nodes => {\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          if (!hasEditClass(node) && !hasNonEditClass(node)) {\r\n            continue;\r\n          }\r\n          if (nonEditableRegExps.length > 0 && node.attr('data-mce-content')) {\r\n            node.name = '#text';\r\n            node.type = 3;\r\n            node.raw = true;\r\n            node.value = node.attr('data-mce-content');\r\n          } else {\r\n            node.attr(contentEditableAttrName, null);\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    const findBlockCaretContainer = editor => descendant$1(SugarElement.fromDom(editor.getBody()), '*[data-mce-caret]').map(elm => elm.dom).getOrNull();\r\n    const showBlockCaretContainer = (editor, blockCaretContainer) => {\r\n      if (blockCaretContainer.hasAttribute('data-mce-caret')) {\r\n        showCaretContainerBlock(blockCaretContainer);\r\n        editor.selection.setRng(editor.selection.getRng());\r\n        editor.selection.scrollIntoView(blockCaretContainer);\r\n      }\r\n    };\r\n    const handleBlockContainer = (editor, e) => {\r\n      const blockCaretContainer = findBlockCaretContainer(editor);\r\n      if (!blockCaretContainer) {\r\n        return;\r\n      }\r\n      if (e.type === 'compositionstart') {\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        showBlockCaretContainer(editor, blockCaretContainer);\r\n        return;\r\n      }\r\n      if (hasContent(blockCaretContainer)) {\r\n        showBlockCaretContainer(editor, blockCaretContainer);\r\n        editor.undoManager.add();\r\n      }\r\n    };\r\n    const setup$m = editor => {\r\n      editor.on('keyup compositionstart', curry(handleBlockContainer, editor));\r\n    };\r\n\r\n    const isContentEditableFalse$3 = isContentEditableFalse$b;\r\n    const moveToCeFalseHorizontally = (direction, editor, range) => moveHorizontally(editor, direction, range, isBeforeContentEditableFalse, isAfterContentEditableFalse, isContentEditableFalse$3);\r\n    const moveToCeFalseVertically = (direction, editor, range) => {\r\n      const isBefore = caretPosition => isBeforeContentEditableFalse(caretPosition) || isBeforeTable(caretPosition);\r\n      const isAfter = caretPosition => isAfterContentEditableFalse(caretPosition) || isAfterTable(caretPosition);\r\n      return moveVertically(editor, direction, range, isBefore, isAfter, isContentEditableFalse$3);\r\n    };\r\n    const createTextBlock = editor => {\r\n      const textBlock = editor.dom.create(getForcedRootBlock(editor));\r\n      textBlock.innerHTML = '<br data-mce-bogus=\"1\">';\r\n      return textBlock;\r\n    };\r\n    const exitPreBlock = (editor, direction, range) => {\r\n      const caretWalker = CaretWalker(editor.getBody());\r\n      const getVisualCaretPosition$1 = curry(getVisualCaretPosition, direction === 1 ? caretWalker.next : caretWalker.prev);\r\n      if (range.collapsed) {\r\n        const pre = editor.dom.getParent(range.startContainer, 'PRE');\r\n        if (!pre) {\r\n          return;\r\n        }\r\n        const caretPos = getVisualCaretPosition$1(CaretPosition.fromRangeStart(range));\r\n        if (!caretPos) {\r\n          const newBlock = SugarElement.fromDom(createTextBlock(editor));\r\n          if (direction === 1) {\r\n            after$4(SugarElement.fromDom(pre), newBlock);\r\n          } else {\r\n            before$3(SugarElement.fromDom(pre), newBlock);\r\n          }\r\n          editor.selection.select(newBlock.dom, true);\r\n          editor.selection.collapse();\r\n        }\r\n      }\r\n    };\r\n    const getHorizontalRange = (editor, forward) => {\r\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\r\n      const range = editor.selection.getRng();\r\n      return moveToCeFalseHorizontally(direction, editor, range).orThunk(() => {\r\n        exitPreBlock(editor, direction, range);\r\n        return Optional.none();\r\n      });\r\n    };\r\n    const getVerticalRange = (editor, down) => {\r\n      const direction = down ? 1 : -1;\r\n      const range = editor.selection.getRng();\r\n      return moveToCeFalseVertically(direction, editor, range).orThunk(() => {\r\n        exitPreBlock(editor, direction, range);\r\n        return Optional.none();\r\n      });\r\n    };\r\n    const flipDirection = (selection, forward) => {\r\n      const elm = forward ? selection.getEnd(true) : selection.getStart(true);\r\n      return isRtl(elm) ? !forward : forward;\r\n    };\r\n    const moveH$2 = (editor, forward) => getHorizontalRange(editor, flipDirection(editor.selection, forward)).exists(newRange => {\r\n      moveToRange(editor, newRange);\r\n      return true;\r\n    });\r\n    const moveV$4 = (editor, down) => getVerticalRange(editor, down).exists(newRange => {\r\n      moveToRange(editor, newRange);\r\n      return true;\r\n    });\r\n    const moveToLineEndPoint$1 = (editor, forward) => {\r\n      const isCefPosition = forward ? isAfterContentEditableFalse : isBeforeContentEditableFalse;\r\n      return moveToLineEndPoint$3(editor, forward, isCefPosition);\r\n    };\r\n    const selectToEndPoint = (editor, forward) => getEdgeCefPosition(editor, !forward).map(pos => {\r\n      const rng = pos.toRange();\r\n      const curRng = editor.selection.getRng();\r\n      if (forward) {\r\n        rng.setStart(curRng.startContainer, curRng.startOffset);\r\n      } else {\r\n        rng.setEnd(curRng.endContainer, curRng.endOffset);\r\n      }\r\n      return rng;\r\n    }).exists(rng => {\r\n      moveToRange(editor, rng);\r\n      return true;\r\n    });\r\n\r\n    const isTarget = node => contains$2(['figcaption'], name(node));\r\n    const getClosestTargetBlock = (pos, root, schema) => {\r\n      const isRoot = curry(eq, root);\r\n      return closest$4(SugarElement.fromDom(pos.container()), el => schema.isBlock(name(el)), isRoot).filter(isTarget);\r\n    };\r\n    const isAtFirstOrLastLine = (root, forward, pos) => forward ? isAtLastLine(root.dom, pos) : isAtFirstLine(root.dom, pos);\r\n    const moveCaretToNewEmptyLine = (editor, forward) => {\r\n      const root = SugarElement.fromDom(editor.getBody());\r\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return getClosestTargetBlock(pos, root, editor.schema).exists(() => {\r\n        if (isAtFirstOrLastLine(root, forward, pos)) {\r\n          const insertFn = forward ? append$1 : prepend;\r\n          const rng = insertEmptyLine(editor, root, insertFn);\r\n          editor.selection.setRng(rng);\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      });\r\n    };\r\n    const moveV$3 = (editor, forward) => {\r\n      if (editor.selection.isCollapsed()) {\r\n        return moveCaretToNewEmptyLine(editor, forward);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n\r\n    const moveUp = (editor, details, summary) => {\r\n      const rng = editor.selection.getRng();\r\n      const pos = CaretPosition.fromRangeStart(rng);\r\n      const root = editor.getBody();\r\n      if (root.firstChild === details && isAtFirstLine(summary, pos)) {\r\n        editor.execCommand('InsertNewBlockBefore');\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const moveDown = (editor, details) => {\r\n      const rng = editor.selection.getRng();\r\n      const pos = CaretPosition.fromRangeStart(rng);\r\n      const root = editor.getBody();\r\n      if (root.lastChild === details && isAtLastLine(details, pos)) {\r\n        editor.execCommand('InsertNewBlockAfter');\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const move$2 = (editor, forward) => {\r\n      if (forward) {\r\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'details')).map(details => moveDown(editor, details)).getOr(false);\r\n      } else {\r\n        return Optional.from(editor.dom.getParent(editor.selection.getNode(), 'summary')).bind(summary => Optional.from(editor.dom.getParent(summary, 'details')).map(details => moveUp(editor, details, summary))).getOr(false);\r\n      }\r\n    };\r\n    const moveV$2 = (editor, forward) => move$2(editor, forward);\r\n\r\n    const baseKeyPattern = {\r\n      shiftKey: false,\r\n      altKey: false,\r\n      ctrlKey: false,\r\n      metaKey: false,\r\n      keyCode: 0\r\n    };\r\n    const defaultPatterns = patterns => map$3(patterns, pattern => ({\r\n      ...baseKeyPattern,\r\n      ...pattern\r\n    }));\r\n    const defaultDelayedPatterns = patterns => map$3(patterns, pattern => ({\r\n      ...baseKeyPattern,\r\n      ...pattern\r\n    }));\r\n    const matchesEvent = (pattern, evt) => evt.keyCode === pattern.keyCode && evt.shiftKey === pattern.shiftKey && evt.altKey === pattern.altKey && evt.ctrlKey === pattern.ctrlKey && evt.metaKey === pattern.metaKey;\r\n    const match$1 = (patterns, evt) => bind$3(defaultPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\r\n    const matchDelayed = (patterns, evt) => bind$3(defaultDelayedPatterns(patterns), pattern => matchesEvent(pattern, evt) ? [pattern] : []);\r\n    const action = (f, ...x) => () => f.apply(null, x);\r\n    const execute = (patterns, evt) => find$2(match$1(patterns, evt), pattern => pattern.action());\r\n    const executeWithDelayedAction = (patterns, evt) => findMap(matchDelayed(patterns, evt), pattern => pattern.action());\r\n\r\n    const moveH$1 = (editor, forward) => {\r\n      const direction = forward ? HDirection.Forwards : HDirection.Backwards;\r\n      const range = editor.selection.getRng();\r\n      return moveHorizontally(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\r\n        moveToRange(editor, newRange);\r\n        return true;\r\n      });\r\n    };\r\n    const moveV$1 = (editor, down) => {\r\n      const direction = down ? 1 : -1;\r\n      const range = editor.selection.getRng();\r\n      return moveVertically(editor, direction, range, isBeforeMedia, isAfterMedia, isMedia$2).exists(newRange => {\r\n        moveToRange(editor, newRange);\r\n        return true;\r\n      });\r\n    };\r\n    const moveToLineEndPoint = (editor, forward) => {\r\n      const isNearMedia = forward ? isAfterMedia : isBeforeMedia;\r\n      return moveToLineEndPoint$3(editor, forward, isNearMedia);\r\n    };\r\n\r\n    const adt = Adt.generate([\r\n      { none: ['current'] },\r\n      { first: ['current'] },\r\n      {\r\n        middle: [\r\n          'current',\r\n          'target'\r\n        ]\r\n      },\r\n      { last: ['current'] }\r\n    ]);\r\n    const none = current => adt.none(current);\r\n    const CellLocation = {\r\n      ...adt,\r\n      none\r\n    };\r\n\r\n    const firstLayer = (scope, selector) => {\r\n      return filterFirstLayer(scope, selector, always);\r\n    };\r\n    const filterFirstLayer = (scope, selector, predicate) => {\r\n      return bind$3(children$1(scope), x => {\r\n        if (is$1(x, selector)) {\r\n          return predicate(x) ? [x] : [];\r\n        } else {\r\n          return filterFirstLayer(x, selector, predicate);\r\n        }\r\n      });\r\n    };\r\n\r\n    const lookup$1 = (tags, element, isRoot = never) => {\r\n      if (isRoot(element)) {\r\n        return Optional.none();\r\n      }\r\n      if (contains$2(tags, name(element))) {\r\n        return Optional.some(element);\r\n      }\r\n      const isRootOrUpperTable = elm => is$1(elm, 'table') || isRoot(elm);\r\n      return ancestor$3(element, tags.join(','), isRootOrUpperTable);\r\n    };\r\n    const cell = (element, isRoot) => lookup$1([\r\n      'td',\r\n      'th'\r\n    ], element, isRoot);\r\n    const cells = ancestor => firstLayer(ancestor, 'th,td');\r\n    const table = (element, isRoot) => closest$3(element, 'table', isRoot);\r\n\r\n    const walk = (all, current, index, direction, isEligible = always) => {\r\n      const forwards = direction === 1;\r\n      if (!forwards && index <= 0) {\r\n        return CellLocation.first(all[0]);\r\n      } else if (forwards && index >= all.length - 1) {\r\n        return CellLocation.last(all[all.length - 1]);\r\n      } else {\r\n        const newIndex = index + direction;\r\n        const elem = all[newIndex];\r\n        return isEligible(elem) ? CellLocation.middle(current, elem) : walk(all, current, newIndex, direction, isEligible);\r\n      }\r\n    };\r\n    const detect = (current, isRoot) => {\r\n      return table(current, isRoot).bind(table => {\r\n        const all = cells(table);\r\n        const index = findIndex$2(all, x => eq(current, x));\r\n        return index.map(index => ({\r\n          index,\r\n          all\r\n        }));\r\n      });\r\n    };\r\n    const next = (current, isEligible, isRoot) => {\r\n      const detection = detect(current, isRoot);\r\n      return detection.fold(() => {\r\n        return CellLocation.none(current);\r\n      }, info => {\r\n        return walk(info.all, current, info.index, 1, isEligible);\r\n      });\r\n    };\r\n    const prev = (current, isEligible, isRoot) => {\r\n      const detection = detect(current, isRoot);\r\n      return detection.fold(() => {\r\n        return CellLocation.none();\r\n      }, info => {\r\n        return walk(info.all, current, info.index, -1, isEligible);\r\n      });\r\n    };\r\n\r\n    const deflate = (rect, delta) => ({\r\n      left: rect.left - delta,\r\n      top: rect.top - delta,\r\n      right: rect.right + delta * 2,\r\n      bottom: rect.bottom + delta * 2,\r\n      width: rect.width + delta,\r\n      height: rect.height + delta\r\n    });\r\n    const getCorners = (getYAxisValue, tds) => bind$3(tds, td => {\r\n      const rect = deflate(clone$1(td.getBoundingClientRect()), -1);\r\n      return [\r\n        {\r\n          x: rect.left,\r\n          y: getYAxisValue(rect),\r\n          cell: td\r\n        },\r\n        {\r\n          x: rect.right,\r\n          y: getYAxisValue(rect),\r\n          cell: td\r\n        }\r\n      ];\r\n    });\r\n    const findClosestCorner = (corners, x, y) => foldl(corners, (acc, newCorner) => acc.fold(() => Optional.some(newCorner), oldCorner => {\r\n      const oldDist = Math.sqrt(Math.abs(oldCorner.x - x) + Math.abs(oldCorner.y - y));\r\n      const newDist = Math.sqrt(Math.abs(newCorner.x - x) + Math.abs(newCorner.y - y));\r\n      return Optional.some(newDist < oldDist ? newCorner : oldCorner);\r\n    }), Optional.none());\r\n    const getClosestCell = (getYAxisValue, isTargetCorner, table, x, y) => {\r\n      const cells = descendants(SugarElement.fromDom(table), 'td,th,caption').map(e => e.dom);\r\n      const corners = filter$5(getCorners(getYAxisValue, cells), corner => isTargetCorner(corner, y));\r\n      return findClosestCorner(corners, x, y).map(corner => corner.cell);\r\n    };\r\n    const getBottomValue = rect => rect.bottom;\r\n    const getTopValue = rect => rect.top;\r\n    const isAbove = (corner, y) => corner.y < y;\r\n    const isBelow = (corner, y) => corner.y > y;\r\n    const getClosestCellAbove = curry(getClosestCell, getBottomValue, isAbove);\r\n    const getClosestCellBelow = curry(getClosestCell, getTopValue, isBelow);\r\n    const findClosestPositionInAboveCell = (table, pos) => head(pos.getClientRects()).bind(rect => getClosestCellAbove(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getLastLinePositions(cell), pos));\r\n    const findClosestPositionInBelowCell = (table, pos) => last$3(pos.getClientRects()).bind(rect => getClosestCellBelow(table, rect.left, rect.top)).bind(cell => findClosestHorizontalPosition(getFirstLinePositions(cell), pos));\r\n\r\n    const hasNextBreak = (getPositionsUntil, scope, lineInfo) => lineInfo.breakAt.exists(breakPos => getPositionsUntil(scope, breakPos).breakAt.isSome());\r\n    const startsWithWrapBreak = lineInfo => lineInfo.breakType === BreakType.Wrap && lineInfo.positions.length === 0;\r\n    const startsWithBrBreak = lineInfo => lineInfo.breakType === BreakType.Br && lineInfo.positions.length === 1;\r\n    const isAtTableCellLine = (getPositionsUntil, scope, pos) => {\r\n      const lineInfo = getPositionsUntil(scope, pos);\r\n      if (startsWithWrapBreak(lineInfo) || !isBr$6(pos.getNode()) && startsWithBrBreak(lineInfo)) {\r\n        return !hasNextBreak(getPositionsUntil, scope, lineInfo);\r\n      } else {\r\n        return lineInfo.breakAt.isNone();\r\n      }\r\n    };\r\n    const isAtFirstTableCellLine = curry(isAtTableCellLine, getPositionsUntilPreviousLine);\r\n    const isAtLastTableCellLine = curry(isAtTableCellLine, getPositionsUntilNextLine);\r\n    const isCaretAtStartOrEndOfTable = (forward, rng, table) => {\r\n      const caretPos = CaretPosition.fromRangeStart(rng);\r\n      return positionIn(!forward, table).exists(pos => pos.isEqual(caretPos));\r\n    };\r\n    const navigateHorizontally = (editor, forward, table, _td) => {\r\n      const rng = editor.selection.getRng();\r\n      const direction = forward ? 1 : -1;\r\n      if (isFakeCaretTableBrowser() && isCaretAtStartOrEndOfTable(forward, rng, table)) {\r\n        showCaret(direction, editor, table, !forward, false).each(newRng => {\r\n          moveToRange(editor, newRng);\r\n        });\r\n        return true;\r\n      }\r\n      return false;\r\n    };\r\n    const getClosestAbovePosition = (root, table, start) => findClosestPositionInAboveCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsAbove(root, CaretPosition.before(table)), rect.left))).getOr(CaretPosition.before(table));\r\n    const getClosestBelowPosition = (root, table, start) => findClosestPositionInBelowCell(table, start).orThunk(() => head(start.getClientRects()).bind(rect => findClosestHorizontalPositionFromPoint(getPositionsBelow(root, CaretPosition.after(table)), rect.left))).getOr(CaretPosition.after(table));\r\n    const getTable = (previous, pos) => {\r\n      const node = pos.getNode(previous);\r\n      return isTable$2(node) ? Optional.some(node) : Optional.none();\r\n    };\r\n    const renderBlock = (down, editor, table) => {\r\n      editor.undoManager.transact(() => {\r\n        const insertFn = down ? after$4 : before$3;\r\n        const rng = insertEmptyLine(editor, SugarElement.fromDom(table), insertFn);\r\n        moveToRange(editor, rng);\r\n      });\r\n    };\r\n    const moveCaret = (editor, down, pos) => {\r\n      const table = down ? getTable(true, pos) : getTable(false, pos);\r\n      const last = down === false;\r\n      table.fold(() => moveToRange(editor, pos.toRange()), table => positionIn(last, editor.getBody()).filter(lastPos => lastPos.isEqual(pos)).fold(() => moveToRange(editor, pos.toRange()), _ => renderBlock(down, editor, table)));\r\n    };\r\n    const navigateVertically = (editor, down, table, td) => {\r\n      const rng = editor.selection.getRng();\r\n      const pos = CaretPosition.fromRangeStart(rng);\r\n      const root = editor.getBody();\r\n      if (!down && isAtFirstTableCellLine(td, pos)) {\r\n        const newPos = getClosestAbovePosition(root, table, pos);\r\n        moveCaret(editor, down, newPos);\r\n        return true;\r\n      } else if (down && isAtLastTableCellLine(td, pos)) {\r\n        const newPos = getClosestBelowPosition(root, table, pos);\r\n        moveCaret(editor, down, newPos);\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const move$1 = (editor, forward, mover) => Optional.from(editor.dom.getParent(editor.selection.getNode(), 'td,th')).bind(td => Optional.from(editor.dom.getParent(td, 'table')).map(table => mover(editor, forward, table, td))).getOr(false);\r\n    const moveH = (editor, forward) => move$1(editor, forward, navigateHorizontally);\r\n    const moveV = (editor, forward) => move$1(editor, forward, navigateVertically);\r\n    const getCellFirstCursorPosition = cell => {\r\n      const selection = SimSelection.exact(cell, 0, cell, 0);\r\n      return toNative(selection);\r\n    };\r\n    const tabGo = (editor, isRoot, cell) => {\r\n      return cell.fold(Optional.none, Optional.none, (_current, next) => {\r\n        return first(next).map(cell => {\r\n          return getCellFirstCursorPosition(cell);\r\n        });\r\n      }, current => {\r\n        editor.execCommand('mceTableInsertRowAfter');\r\n        return tabForward(editor, isRoot, current);\r\n      });\r\n    };\r\n    const tabForward = (editor, isRoot, cell) => tabGo(editor, isRoot, next(cell, isEditable$2));\r\n    const tabBackward = (editor, isRoot, cell) => tabGo(editor, isRoot, prev(cell, isEditable$2));\r\n    const handleTab = (editor, forward) => {\r\n      const rootElements = [\r\n        'table',\r\n        'li',\r\n        'dl'\r\n      ];\r\n      const body = SugarElement.fromDom(editor.getBody());\r\n      const isRoot = element => {\r\n        const name$1 = name(element);\r\n        return eq(element, body) || contains$2(rootElements, name$1);\r\n      };\r\n      const rng = editor.selection.getRng();\r\n      const container = SugarElement.fromDom(!forward ? rng.startContainer : rng.endContainer);\r\n      return cell(container, isRoot).map(cell => {\r\n        table(cell, isRoot).each(table => {\r\n          editor.model.table.clearSelectedCells(table.dom);\r\n        });\r\n        editor.selection.collapse(!forward);\r\n        const navigation = !forward ? tabBackward : tabForward;\r\n        const rng = navigation(editor, isRoot, cell);\r\n        rng.each(range => {\r\n          editor.selection.setRng(range);\r\n        });\r\n        return true;\r\n      }).getOr(false);\r\n    };\r\n\r\n    const executeKeydownOverride$4 = (editor, caret, evt) => {\r\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\r\n      execute([\r\n        {\r\n          keyCode: VK.RIGHT,\r\n          action: action(moveH$2, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.LEFT,\r\n          action: action(moveH$2, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.UP,\r\n          action: action(moveV$4, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DOWN,\r\n          action: action(moveV$4, editor, true)\r\n        },\r\n        ...isMac ? [\r\n          {\r\n            keyCode: VK.UP,\r\n            action: action(selectToEndPoint, editor, false),\r\n            metaKey: true,\r\n            shiftKey: true\r\n          },\r\n          {\r\n            keyCode: VK.DOWN,\r\n            action: action(selectToEndPoint, editor, true),\r\n            metaKey: true,\r\n            shiftKey: true\r\n          }\r\n        ] : [],\r\n        {\r\n          keyCode: VK.RIGHT,\r\n          action: action(moveH, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.LEFT,\r\n          action: action(moveH, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.UP,\r\n          action: action(moveV, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DOWN,\r\n          action: action(moveV, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.UP,\r\n          action: action(moveV, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.UP,\r\n          action: action(moveV$2, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DOWN,\r\n          action: action(moveV$2, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.RIGHT,\r\n          action: action(moveH$1, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.LEFT,\r\n          action: action(moveH$1, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.UP,\r\n          action: action(moveV$1, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DOWN,\r\n          action: action(moveV$1, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.RIGHT,\r\n          action: action(move$3, editor, caret, true)\r\n        },\r\n        {\r\n          keyCode: VK.LEFT,\r\n          action: action(move$3, editor, caret, false)\r\n        },\r\n        {\r\n          keyCode: VK.RIGHT,\r\n          ctrlKey: !isMac,\r\n          altKey: isMac,\r\n          action: action(moveNextWord, editor, caret)\r\n        },\r\n        {\r\n          keyCode: VK.LEFT,\r\n          ctrlKey: !isMac,\r\n          altKey: isMac,\r\n          action: action(movePrevWord, editor, caret)\r\n        },\r\n        {\r\n          keyCode: VK.UP,\r\n          action: action(moveV$3, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DOWN,\r\n          action: action(moveV$3, editor, true)\r\n        }\r\n      ], evt).each(_ => {\r\n        evt.preventDefault();\r\n      });\r\n    };\r\n    const setup$l = (editor, caret) => {\r\n      editor.on('keydown', evt => {\r\n        if (!evt.isDefaultPrevented()) {\r\n          executeKeydownOverride$4(editor, caret, evt);\r\n        }\r\n      });\r\n    };\r\n\r\n    const point = (container, offset) => ({\r\n      container,\r\n      offset\r\n    });\r\n\r\n    const DOM$7 = DOMUtils.DOM;\r\n    const alwaysNext = startNode => node => startNode === node ? -1 : 0;\r\n    const isBoundary = dom => node => dom.isBlock(node) || contains$2([\r\n      'BR',\r\n      'IMG',\r\n      'HR',\r\n      'INPUT'\r\n    ], node.nodeName) || dom.getContentEditable(node) === 'false';\r\n    const textBefore = (node, offset, rootNode) => {\r\n      if (isText$a(node) && offset >= 0) {\r\n        return Optional.some(point(node, offset));\r\n      } else {\r\n        const textSeeker = TextSeeker(DOM$7);\r\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, prev.container.data.length));\r\n      }\r\n    };\r\n    const textAfter = (node, offset, rootNode) => {\r\n      if (isText$a(node) && offset >= node.length) {\r\n        return Optional.some(point(node, offset));\r\n      } else {\r\n        const textSeeker = TextSeeker(DOM$7);\r\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).map(prev => point(prev.container, 0));\r\n      }\r\n    };\r\n    const scanLeft = (node, offset, rootNode) => {\r\n      if (!isText$a(node)) {\r\n        return Optional.none();\r\n      }\r\n      const text = node.data;\r\n      if (offset >= 0 && offset <= text.length) {\r\n        return Optional.some(point(node, offset));\r\n      } else {\r\n        const textSeeker = TextSeeker(DOM$7);\r\n        return Optional.from(textSeeker.backwards(node, offset, alwaysNext(node), rootNode)).bind(prev => {\r\n          const prevText = prev.container.data;\r\n          return scanLeft(prev.container, offset + prevText.length, rootNode);\r\n        });\r\n      }\r\n    };\r\n    const scanRight = (node, offset, rootNode) => {\r\n      if (!isText$a(node)) {\r\n        return Optional.none();\r\n      }\r\n      const text = node.data;\r\n      if (offset <= text.length) {\r\n        return Optional.some(point(node, offset));\r\n      } else {\r\n        const textSeeker = TextSeeker(DOM$7);\r\n        return Optional.from(textSeeker.forwards(node, offset, alwaysNext(node), rootNode)).bind(next => scanRight(next.container, offset - text.length, rootNode));\r\n      }\r\n    };\r\n    const repeatLeft = (dom, node, offset, process, rootNode) => {\r\n      const search = TextSeeker(dom, isBoundary(dom));\r\n      return Optional.from(search.backwards(node, offset, process, rootNode));\r\n    };\r\n\r\n    const isValidTextRange = rng => rng.collapsed && isText$a(rng.startContainer);\r\n    const getText = rng => trim$2(rng.toString().replace(/\\u00A0/g, ' '));\r\n    const isWhitespace = chr => chr !== '' && ' \\xA0\\f\\n\\r\\t\\x0B'.indexOf(chr) !== -1;\r\n\r\n    const stripTrigger = (text, trigger) => text.substring(trigger.length);\r\n    const findTrigger = (text, index, trigger) => {\r\n      let i;\r\n      const firstChar = trigger.charAt(0);\r\n      for (i = index - 1; i >= 0; i--) {\r\n        const char = text.charAt(i);\r\n        if (isWhitespace(char)) {\r\n          return Optional.none();\r\n        }\r\n        if (firstChar === char && contains$1(text, trigger, i, index)) {\r\n          break;\r\n        }\r\n      }\r\n      return Optional.some(i);\r\n    };\r\n    const findStart = (dom, initRange, trigger, minChars = 0) => {\r\n      if (!isValidTextRange(initRange)) {\r\n        return Optional.none();\r\n      }\r\n      const buffer = {\r\n        text: '',\r\n        offset: 0\r\n      };\r\n      const findTriggerIndex = (element, offset, text) => {\r\n        buffer.text = text + buffer.text;\r\n        buffer.offset += offset;\r\n        return findTrigger(buffer.text, buffer.offset, trigger).getOr(offset);\r\n      };\r\n      const root = dom.getParent(initRange.startContainer, dom.isBlock) || dom.getRoot();\r\n      return repeatLeft(dom, initRange.startContainer, initRange.startOffset, findTriggerIndex, root).bind(spot => {\r\n        const range = initRange.cloneRange();\r\n        range.setStart(spot.container, spot.offset);\r\n        range.setEnd(initRange.endContainer, initRange.endOffset);\r\n        if (range.collapsed) {\r\n          return Optional.none();\r\n        }\r\n        const text = getText(range);\r\n        const triggerIndex = text.lastIndexOf(trigger);\r\n        if (triggerIndex !== 0 || stripTrigger(text, trigger).length < minChars) {\r\n          return Optional.none();\r\n        } else {\r\n          return Optional.some({\r\n            text: stripTrigger(text, trigger),\r\n            range,\r\n            trigger\r\n          });\r\n        }\r\n      });\r\n    };\r\n    const getContext = (dom, initRange, trigger, minChars = 0) => detect$1(SugarElement.fromDom(initRange.startContainer)).fold(() => findStart(dom, initRange, trigger, minChars), elm => {\r\n      const range = dom.createRng();\r\n      range.selectNode(elm.dom);\r\n      const text = getText(range);\r\n      return Optional.some({\r\n        range,\r\n        text: stripTrigger(text, trigger),\r\n        trigger\r\n      });\r\n    });\r\n\r\n    const isText$1 = node => node.nodeType === TEXT;\r\n    const isElement = node => node.nodeType === ELEMENT;\r\n    const toLast = node => {\r\n      if (isText$1(node)) {\r\n        return point(node, node.data.length);\r\n      } else {\r\n        const children = node.childNodes;\r\n        return children.length > 0 ? toLast(children[children.length - 1]) : point(node, children.length);\r\n      }\r\n    };\r\n    const toLeaf = (node, offset) => {\r\n      const children = node.childNodes;\r\n      if (children.length > 0 && offset < children.length) {\r\n        return toLeaf(children[offset], 0);\r\n      } else if (children.length > 0 && isElement(node) && children.length === offset) {\r\n        return toLast(children[children.length - 1]);\r\n      } else {\r\n        return point(node, offset);\r\n      }\r\n    };\r\n\r\n    const isPreviousCharContent = (dom, leaf) => {\r\n      var _a;\r\n      const root = (_a = dom.getParent(leaf.container, dom.isBlock)) !== null && _a !== void 0 ? _a : dom.getRoot();\r\n      return repeatLeft(dom, leaf.container, leaf.offset, (_element, offset) => offset === 0 ? -1 : offset, root).filter(spot => {\r\n        const char = spot.container.data.charAt(spot.offset - 1);\r\n        return !isWhitespace(char);\r\n      }).isSome();\r\n    };\r\n    const isStartOfWord = dom => rng => {\r\n      const leaf = toLeaf(rng.startContainer, rng.startOffset);\r\n      return !isPreviousCharContent(dom, leaf);\r\n    };\r\n    const getTriggerContext = (dom, initRange, database) => findMap(database.triggers, trigger => getContext(dom, initRange, trigger));\r\n    const lookup = (editor, getDatabase) => {\r\n      const database = getDatabase();\r\n      const rng = editor.selection.getRng();\r\n      return getTriggerContext(editor.dom, rng, database).bind(context => lookupWithContext(editor, getDatabase, context));\r\n    };\r\n    const lookupWithContext = (editor, getDatabase, context, fetchOptions = {}) => {\r\n      var _a;\r\n      const database = getDatabase();\r\n      const rng = editor.selection.getRng();\r\n      const startText = (_a = rng.startContainer.nodeValue) !== null && _a !== void 0 ? _a : '';\r\n      const autocompleters = filter$5(database.lookupByTrigger(context.trigger), autocompleter => context.text.length >= autocompleter.minChars && autocompleter.matches.getOrThunk(() => isStartOfWord(editor.dom))(context.range, startText, context.text));\r\n      if (autocompleters.length === 0) {\r\n        return Optional.none();\r\n      }\r\n      const lookupData = Promise.all(map$3(autocompleters, ac => {\r\n        const fetchResult = ac.fetch(context.text, ac.maxResults, fetchOptions);\r\n        return fetchResult.then(results => ({\r\n          matchText: context.text,\r\n          items: results,\r\n          columns: ac.columns,\r\n          onAction: ac.onAction,\r\n          highlightOn: ac.highlightOn\r\n        }));\r\n      }));\r\n      return Optional.some({\r\n        lookupData,\r\n        context\r\n      });\r\n    };\r\n\r\n    var SimpleResultType;\r\n    (function (SimpleResultType) {\r\n      SimpleResultType[SimpleResultType['Error'] = 0] = 'Error';\r\n      SimpleResultType[SimpleResultType['Value'] = 1] = 'Value';\r\n    }(SimpleResultType || (SimpleResultType = {})));\r\n    const fold$1 = (res, onError, onValue) => res.stype === SimpleResultType.Error ? onError(res.serror) : onValue(res.svalue);\r\n    const partition = results => {\r\n      const values = [];\r\n      const errors = [];\r\n      each$e(results, obj => {\r\n        fold$1(obj, err => errors.push(err), val => values.push(val));\r\n      });\r\n      return {\r\n        values,\r\n        errors\r\n      };\r\n    };\r\n    const mapError = (res, f) => {\r\n      if (res.stype === SimpleResultType.Error) {\r\n        return {\r\n          stype: SimpleResultType.Error,\r\n          serror: f(res.serror)\r\n        };\r\n      } else {\r\n        return res;\r\n      }\r\n    };\r\n    const map = (res, f) => {\r\n      if (res.stype === SimpleResultType.Value) {\r\n        return {\r\n          stype: SimpleResultType.Value,\r\n          svalue: f(res.svalue)\r\n        };\r\n      } else {\r\n        return res;\r\n      }\r\n    };\r\n    const bind$1 = (res, f) => {\r\n      if (res.stype === SimpleResultType.Value) {\r\n        return f(res.svalue);\r\n      } else {\r\n        return res;\r\n      }\r\n    };\r\n    const bindError = (res, f) => {\r\n      if (res.stype === SimpleResultType.Error) {\r\n        return f(res.serror);\r\n      } else {\r\n        return res;\r\n      }\r\n    };\r\n    const svalue = v => ({\r\n      stype: SimpleResultType.Value,\r\n      svalue: v\r\n    });\r\n    const serror = e => ({\r\n      stype: SimpleResultType.Error,\r\n      serror: e\r\n    });\r\n    const toResult = res => fold$1(res, Result.error, Result.value);\r\n    const fromResult = res => res.fold(serror, svalue);\r\n    const SimpleResult = {\r\n      fromResult,\r\n      toResult,\r\n      svalue,\r\n      partition,\r\n      serror,\r\n      bind: bind$1,\r\n      bindError,\r\n      map,\r\n      mapError,\r\n      fold: fold$1\r\n    };\r\n\r\n    const formatObj = input => {\r\n      return isObject(input) && keys(input).length > 100 ? ' removed due to size' : JSON.stringify(input, null, 2);\r\n    };\r\n    const formatErrors = errors => {\r\n      const es = errors.length > 10 ? errors.slice(0, 10).concat([{\r\n          path: [],\r\n          getErrorInfo: constant('... (only showing first ten failures)')\r\n        }]) : errors;\r\n      return map$3(es, e => {\r\n        return 'Failed path: (' + e.path.join(' > ') + ')\\n' + e.getErrorInfo();\r\n      });\r\n    };\r\n\r\n    const nu = (path, getErrorInfo) => {\r\n      return SimpleResult.serror([{\r\n          path,\r\n          getErrorInfo\r\n        }]);\r\n    };\r\n    const missingRequired = (path, key, obj) => nu(path, () => 'Could not find valid *required* value for \"' + key + '\" in ' + formatObj(obj));\r\n    const missingKey = (path, key) => nu(path, () => 'Choice schema did not contain choice key: \"' + key + '\"');\r\n    const missingBranch = (path, branches, branch) => nu(path, () => 'The chosen schema: \"' + branch + '\" did not exist in branches: ' + formatObj(branches));\r\n    const custom = (path, err) => nu(path, constant(err));\r\n\r\n    const chooseFrom = (path, input, branches, ch) => {\r\n      const fields = get$a(branches, ch);\r\n      return fields.fold(() => missingBranch(path, branches, ch), vp => vp.extract(path.concat(['branch: ' + ch]), input));\r\n    };\r\n    const choose$1 = (key, branches) => {\r\n      const extract = (path, input) => {\r\n        const choice = get$a(input, key);\r\n        return choice.fold(() => missingKey(path, key), chosen => chooseFrom(path, input, branches, chosen));\r\n      };\r\n      const toString = () => 'chooseOn(' + key + '). Possible values: ' + keys(branches);\r\n      return {\r\n        extract,\r\n        toString\r\n      };\r\n    };\r\n\r\n    const shallow = (old, nu) => {\r\n      return nu;\r\n    };\r\n    const deep = (old, nu) => {\r\n      const bothObjects = isPlainObject(old) && isPlainObject(nu);\r\n      return bothObjects ? deepMerge(old, nu) : nu;\r\n    };\r\n    const baseMerge = merger => {\r\n      return (...objects) => {\r\n        if (objects.length === 0) {\r\n          throw new Error(`Can't merge zero objects`);\r\n        }\r\n        const ret = {};\r\n        for (let j = 0; j < objects.length; j++) {\r\n          const curObject = objects[j];\r\n          for (const key in curObject) {\r\n            if (has$2(curObject, key)) {\r\n              ret[key] = merger(ret[key], curObject[key]);\r\n            }\r\n          }\r\n        }\r\n        return ret;\r\n      };\r\n    };\r\n    const deepMerge = baseMerge(deep);\r\n    const merge = baseMerge(shallow);\r\n\r\n    const required = () => ({\r\n      tag: 'required',\r\n      process: {}\r\n    });\r\n    const defaultedThunk = fallbackThunk => ({\r\n      tag: 'defaultedThunk',\r\n      process: fallbackThunk\r\n    });\r\n    const defaulted$1 = fallback => defaultedThunk(constant(fallback));\r\n    const asOption = () => ({\r\n      tag: 'option',\r\n      process: {}\r\n    });\r\n\r\n    const mergeValues = (values, base) => values.length > 0 ? SimpleResult.svalue(deepMerge(base, merge.apply(undefined, values))) : SimpleResult.svalue(base);\r\n    const mergeErrors = errors => compose(SimpleResult.serror, flatten)(errors);\r\n    const consolidateObj = (objects, base) => {\r\n      const partition = SimpleResult.partition(objects);\r\n      return partition.errors.length > 0 ? mergeErrors(partition.errors) : mergeValues(partition.values, base);\r\n    };\r\n    const consolidateArr = objects => {\r\n      const partitions = SimpleResult.partition(objects);\r\n      return partitions.errors.length > 0 ? mergeErrors(partitions.errors) : SimpleResult.svalue(partitions.values);\r\n    };\r\n    const ResultCombine = {\r\n      consolidateObj,\r\n      consolidateArr\r\n    };\r\n\r\n    const field$1 = (key, newKey, presence, prop) => ({\r\n      tag: 'field',\r\n      key,\r\n      newKey,\r\n      presence,\r\n      prop\r\n    });\r\n    const customField$1 = (newKey, instantiator) => ({\r\n      tag: 'custom',\r\n      newKey,\r\n      instantiator\r\n    });\r\n    const fold = (value, ifField, ifCustom) => {\r\n      switch (value.tag) {\r\n      case 'field':\r\n        return ifField(value.key, value.newKey, value.presence, value.prop);\r\n      case 'custom':\r\n        return ifCustom(value.newKey, value.instantiator);\r\n      }\r\n    };\r\n\r\n    const value = validator => {\r\n      const extract = (path, val) => {\r\n        return SimpleResult.bindError(validator(val), err => custom(path, err));\r\n      };\r\n      const toString = constant('val');\r\n      return {\r\n        extract,\r\n        toString\r\n      };\r\n    };\r\n    const anyValue$1 = value(SimpleResult.svalue);\r\n\r\n    const requiredAccess = (path, obj, key, bundle) => get$a(obj, key).fold(() => missingRequired(path, key, obj), bundle);\r\n    const fallbackAccess = (obj, key, fallback, bundle) => {\r\n      const v = get$a(obj, key).getOrThunk(() => fallback(obj));\r\n      return bundle(v);\r\n    };\r\n    const optionAccess = (obj, key, bundle) => bundle(get$a(obj, key));\r\n    const optionDefaultedAccess = (obj, key, fallback, bundle) => {\r\n      const opt = get$a(obj, key).map(val => val === true ? fallback(obj) : val);\r\n      return bundle(opt);\r\n    };\r\n    const extractField = (field, path, obj, key, prop) => {\r\n      const bundle = av => prop.extract(path.concat([key]), av);\r\n      const bundleAsOption = optValue => optValue.fold(() => SimpleResult.svalue(Optional.none()), ov => {\r\n        const result = prop.extract(path.concat([key]), ov);\r\n        return SimpleResult.map(result, Optional.some);\r\n      });\r\n      switch (field.tag) {\r\n      case 'required':\r\n        return requiredAccess(path, obj, key, bundle);\r\n      case 'defaultedThunk':\r\n        return fallbackAccess(obj, key, field.process, bundle);\r\n      case 'option':\r\n        return optionAccess(obj, key, bundleAsOption);\r\n      case 'defaultedOptionThunk':\r\n        return optionDefaultedAccess(obj, key, field.process, bundleAsOption);\r\n      case 'mergeWithThunk': {\r\n          return fallbackAccess(obj, key, constant({}), v => {\r\n            const result = deepMerge(field.process(obj), v);\r\n            return bundle(result);\r\n          });\r\n        }\r\n      }\r\n    };\r\n    const extractFields = (path, obj, fields) => {\r\n      const success = {};\r\n      const errors = [];\r\n      for (const field of fields) {\r\n        fold(field, (key, newKey, presence, prop) => {\r\n          const result = extractField(presence, path, obj, key, prop);\r\n          SimpleResult.fold(result, err => {\r\n            errors.push(...err);\r\n          }, res => {\r\n            success[newKey] = res;\r\n          });\r\n        }, (newKey, instantiator) => {\r\n          success[newKey] = instantiator(obj);\r\n        });\r\n      }\r\n      return errors.length > 0 ? SimpleResult.serror(errors) : SimpleResult.svalue(success);\r\n    };\r\n    const objOf = values => {\r\n      const extract = (path, o) => extractFields(path, o, values);\r\n      const toString = () => {\r\n        const fieldStrings = map$3(values, value => fold(value, (key, _okey, _presence, prop) => key + ' -> ' + prop.toString(), (newKey, _instantiator) => 'state(' + newKey + ')'));\r\n        return 'obj{\\n' + fieldStrings.join('\\n') + '}';\r\n      };\r\n      return {\r\n        extract,\r\n        toString\r\n      };\r\n    };\r\n    const arrOf = prop => {\r\n      const extract = (path, array) => {\r\n        const results = map$3(array, (a, i) => prop.extract(path.concat(['[' + i + ']']), a));\r\n        return ResultCombine.consolidateArr(results);\r\n      };\r\n      const toString = () => 'array(' + prop.toString() + ')';\r\n      return {\r\n        extract,\r\n        toString\r\n      };\r\n    };\r\n\r\n    const valueOf = validator => value(v => validator(v).fold(SimpleResult.serror, SimpleResult.svalue));\r\n    const extractValue = (label, prop, obj) => {\r\n      const res = prop.extract([label], obj);\r\n      return SimpleResult.mapError(res, errs => ({\r\n        input: obj,\r\n        errors: errs\r\n      }));\r\n    };\r\n    const asRaw = (label, prop, obj) => SimpleResult.toResult(extractValue(label, prop, obj));\r\n    const formatError = errInfo => {\r\n      return 'Errors: \\n' + formatErrors(errInfo.errors).join('\\n') + '\\n\\nInput object: ' + formatObj(errInfo.input);\r\n    };\r\n    const choose = (key, branches) => choose$1(key, map$2(branches, objOf));\r\n\r\n    const anyValue = constant(anyValue$1);\r\n    const typedValue = (validator, expectedType) => value(a => {\r\n      const actualType = typeof a;\r\n      return validator(a) ? SimpleResult.svalue(a) : SimpleResult.serror(`Expected type: ${ expectedType } but got: ${ actualType }`);\r\n    });\r\n    const number = typedValue(isNumber, 'number');\r\n    const string = typedValue(isString, 'string');\r\n    const boolean = typedValue(isBoolean, 'boolean');\r\n    const functionProcessor = typedValue(isFunction, 'function');\r\n\r\n    const field = field$1;\r\n    const customField = customField$1;\r\n    const validateEnum = values => valueOf(value => contains$2(values, value) ? Result.value(value) : Result.error(`Unsupported value: \"${ value }\", choose one of \"${ values.join(', ') }\".`));\r\n    const requiredOf = (key, schema) => field(key, key, required(), schema);\r\n    const requiredString = key => requiredOf(key, string);\r\n    const requiredFunction = key => requiredOf(key, functionProcessor);\r\n    const requiredArrayOf = (key, schema) => field(key, key, required(), arrOf(schema));\r\n    const optionOf = (key, schema) => field(key, key, asOption(), schema);\r\n    const optionString = key => optionOf(key, string);\r\n    const optionFunction = key => optionOf(key, functionProcessor);\r\n    const defaulted = (key, fallback) => field(key, key, defaulted$1(fallback), anyValue());\r\n    const defaultedOf = (key, fallback, schema) => field(key, key, defaulted$1(fallback), schema);\r\n    const defaultedNumber = (key, fallback) => defaultedOf(key, fallback, number);\r\n    const defaultedString = (key, fallback) => defaultedOf(key, fallback, string);\r\n    const defaultedStringEnum = (key, fallback, values) => defaultedOf(key, fallback, validateEnum(values));\r\n    const defaultedBoolean = (key, fallback) => defaultedOf(key, fallback, boolean);\r\n    const defaultedFunction = (key, fallback) => defaultedOf(key, fallback, functionProcessor);\r\n    const defaultedArrayOf = (key, fallback, schema) => defaultedOf(key, fallback, arrOf(schema));\r\n\r\n    const type = requiredString('type');\r\n    const fetch$1 = requiredFunction('fetch');\r\n    const onAction = requiredFunction('onAction');\r\n    const onSetup = defaultedFunction('onSetup', () => noop);\r\n    const optionalText = optionString('text');\r\n    const optionalIcon = optionString('icon');\r\n    const optionalTooltip = optionString('tooltip');\r\n    const optionalLabel = optionString('label');\r\n    const active = defaultedBoolean('active', false);\r\n    const enabled = defaultedBoolean('enabled', true);\r\n    const primary = defaultedBoolean('primary', false);\r\n    const defaultedColumns = num => defaulted('columns', num);\r\n    const defaultedType = type => defaultedString('type', type);\r\n\r\n    const autocompleterSchema = objOf([\r\n      type,\r\n      requiredString('trigger'),\r\n      defaultedNumber('minChars', 1),\r\n      defaultedColumns(1),\r\n      defaultedNumber('maxResults', 10),\r\n      optionFunction('matches'),\r\n      fetch$1,\r\n      onAction,\r\n      defaultedArrayOf('highlightOn', [], string)\r\n    ]);\r\n    const createAutocompleter = spec => asRaw('Autocompleter', autocompleterSchema, {\r\n      trigger: spec.ch,\r\n      ...spec\r\n    });\r\n\r\n    const baseToolbarButtonFields = [\r\n      enabled,\r\n      optionalTooltip,\r\n      optionalIcon,\r\n      optionalText,\r\n      onSetup\r\n    ];\r\n\r\n    const baseToolbarToggleButtonFields = [active].concat(baseToolbarButtonFields);\r\n\r\n    const contextBarFields = [\r\n      defaultedFunction('predicate', never),\r\n      defaultedStringEnum('scope', 'node', [\r\n        'node',\r\n        'editor'\r\n      ]),\r\n      defaultedStringEnum('position', 'selection', [\r\n        'node',\r\n        'selection',\r\n        'line'\r\n      ])\r\n    ];\r\n\r\n    const contextButtonFields = baseToolbarButtonFields.concat([\r\n      defaultedType('contextformbutton'),\r\n      primary,\r\n      onAction,\r\n      customField('original', identity)\r\n    ]);\r\n    const contextToggleButtonFields = baseToolbarToggleButtonFields.concat([\r\n      defaultedType('contextformbutton'),\r\n      primary,\r\n      onAction,\r\n      customField('original', identity)\r\n    ]);\r\n    const launchButtonFields = baseToolbarButtonFields.concat([defaultedType('contextformbutton')]);\r\n    const launchToggleButtonFields = baseToolbarToggleButtonFields.concat([defaultedType('contextformtogglebutton')]);\r\n    const toggleOrNormal = choose('type', {\r\n      contextformbutton: contextButtonFields,\r\n      contextformtogglebutton: contextToggleButtonFields\r\n    });\r\n    objOf([\r\n      defaultedType('contextform'),\r\n      defaultedFunction('initValue', constant('')),\r\n      optionalLabel,\r\n      requiredArrayOf('commands', toggleOrNormal),\r\n      optionOf('launch', choose('type', {\r\n        contextformbutton: launchButtonFields,\r\n        contextformtogglebutton: launchToggleButtonFields\r\n      }))\r\n    ].concat(contextBarFields));\r\n\r\n    const register$2 = editor => {\r\n      const popups = editor.ui.registry.getAll().popups;\r\n      const dataset = map$2(popups, popup => createAutocompleter(popup).fold(err => {\r\n        throw new Error(formatError(err));\r\n      }, identity));\r\n      const triggers = stringArray(mapToArray(dataset, v => v.trigger));\r\n      const datasetValues = values(dataset);\r\n      const lookupByTrigger = trigger => filter$5(datasetValues, dv => dv.trigger === trigger);\r\n      return {\r\n        dataset,\r\n        triggers,\r\n        lookupByTrigger\r\n      };\r\n    };\r\n\r\n    const setupEditorInput = (editor, api) => {\r\n      const update = last$1(api.load, 50);\r\n      editor.on('keypress compositionend', e => {\r\n        if (e.which === 27) {\r\n          return;\r\n        }\r\n        update.throttle();\r\n      });\r\n      editor.on('keydown', e => {\r\n        const keyCode = e.which;\r\n        if (keyCode === 8) {\r\n          update.throttle();\r\n        } else if (keyCode === 27) {\r\n          api.cancelIfNecessary();\r\n        }\r\n      });\r\n      editor.on('remove', update.cancel);\r\n    };\r\n    const setup$k = editor => {\r\n      const activeAutocompleter = value$2();\r\n      const uiActive = Cell(false);\r\n      const isActive = activeAutocompleter.isSet;\r\n      const cancelIfNecessary = () => {\r\n        if (isActive()) {\r\n          removeAutocompleterDecoration(editor);\r\n          fireAutocompleterEnd(editor);\r\n          uiActive.set(false);\r\n          activeAutocompleter.clear();\r\n        }\r\n      };\r\n      const commenceIfNecessary = context => {\r\n        if (!isActive()) {\r\n          addAutocompleterDecoration(editor, context.range);\r\n          activeAutocompleter.set({\r\n            trigger: context.trigger,\r\n            matchLength: context.text.length\r\n          });\r\n        }\r\n      };\r\n      const getAutocompleters = cached(() => register$2(editor));\r\n      const doLookup = fetchOptions => activeAutocompleter.get().map(ac => getContext(editor.dom, editor.selection.getRng(), ac.trigger).bind(newContext => lookupWithContext(editor, getAutocompleters, newContext, fetchOptions))).getOrThunk(() => lookup(editor, getAutocompleters));\r\n      const load = fetchOptions => {\r\n        doLookup(fetchOptions).fold(cancelIfNecessary, lookupInfo => {\r\n          commenceIfNecessary(lookupInfo.context);\r\n          lookupInfo.lookupData.then(lookupData => {\r\n            activeAutocompleter.get().map(ac => {\r\n              const context = lookupInfo.context;\r\n              if (ac.trigger === context.trigger) {\r\n                if (context.text.length - ac.matchLength >= 10) {\r\n                  cancelIfNecessary();\r\n                } else {\r\n                  activeAutocompleter.set({\r\n                    ...ac,\r\n                    matchLength: context.text.length\r\n                  });\r\n                  if (uiActive.get()) {\r\n                    fireAutocompleterUpdate(editor, { lookupData });\r\n                  } else {\r\n                    uiActive.set(true);\r\n                    fireAutocompleterStart(editor, { lookupData });\r\n                  }\r\n                }\r\n              }\r\n            });\r\n          });\r\n        });\r\n      };\r\n      editor.addCommand('mceAutocompleterReload', (_ui, value) => {\r\n        const fetchOptions = isObject(value) ? value.fetchOptions : {};\r\n        load(fetchOptions);\r\n      });\r\n      editor.addCommand('mceAutocompleterClose', cancelIfNecessary);\r\n      setupEditorInput(editor, {\r\n        cancelIfNecessary,\r\n        load\r\n      });\r\n    };\r\n\r\n    const browser$1 = detect$2().browser;\r\n    const isSafari = browser$1.isSafari();\r\n    const emptyNodeContents = node => fillWithPaddingBr(SugarElement.fromDom(node));\r\n    const isEntireNodeSelected = (rng, node) => {\r\n      var _a;\r\n      return rng.startOffset === 0 && rng.endOffset === ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length);\r\n    };\r\n    const getParentDetailsElementAtPos = (dom, pos) => Optional.from(dom.getParent(pos.container(), 'details'));\r\n    const isInDetailsElement = (dom, pos) => getParentDetailsElementAtPos(dom, pos).isSome();\r\n    const getDetailsElements = (dom, rng) => {\r\n      const startDetails = Optional.from(dom.getParent(rng.startContainer, 'details'));\r\n      const endDetails = Optional.from(dom.getParent(rng.endContainer, 'details'));\r\n      if (startDetails.isSome() || endDetails.isSome()) {\r\n        const startSummary = startDetails.bind(details => Optional.from(dom.select('summary', details)[0]));\r\n        return Optional.some({\r\n          startSummary,\r\n          startDetails,\r\n          endDetails\r\n        });\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const isCaretInTheBeginningOf = (caretPos, element) => firstPositionIn(element).exists(pos => pos.isEqual(caretPos));\r\n    const isCaretInTheEndOf = (caretPos, element) => {\r\n      return lastPositionIn(element).exists(pos => {\r\n        if (isBr$6(pos.getNode())) {\r\n          return prevPosition(element, pos).exists(pos2 => pos2.isEqual(caretPos)) || pos.isEqual(caretPos);\r\n        } else {\r\n          return pos.isEqual(caretPos);\r\n        }\r\n      });\r\n    };\r\n    const isCaretAtStartOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheBeginningOf(caretPos, summary));\r\n    const isCaretAtEndOfSummary = (caretPos, detailsElements) => detailsElements.startSummary.exists(summary => isCaretInTheEndOf(caretPos, summary));\r\n    const isCaretInFirstPositionInBody = (caretPos, detailsElements) => detailsElements.startDetails.exists(details => prevPosition(details, caretPos).forall(pos => detailsElements.startSummary.exists(summary => !summary.contains(caretPos.container()) && summary.contains(pos.container()))));\r\n    const isCaretInLastPositionInBody = (root, caretPos, detailsElements) => detailsElements.startDetails.exists(details => nextPosition(root, caretPos).forall(pos => !details.contains(pos.container())));\r\n    const setCaretToPosition = (editor, position) => {\r\n      const node = position.getNode();\r\n      if (!isUndefined(node)) {\r\n        editor.selection.setCursorLocation(node, position.offset());\r\n      }\r\n    };\r\n    const moveCaretToDetailsPos = (editor, pos, forward) => {\r\n      const details = editor.dom.getParent(pos.container(), 'details');\r\n      if (details && !details.open) {\r\n        const summary = editor.dom.select('summary', details)[0];\r\n        if (summary) {\r\n          const newPos = forward ? firstPositionIn(summary) : lastPositionIn(summary);\r\n          newPos.each(pos => setCaretToPosition(editor, pos));\r\n        }\r\n      } else {\r\n        setCaretToPosition(editor, pos);\r\n      }\r\n    };\r\n    const isPartialDelete = (rng, detailsElements) => {\r\n      const containsStart = element => element.contains(rng.startContainer);\r\n      const containsEnd = element => element.contains(rng.endContainer);\r\n      const startInSummary = detailsElements.startSummary.exists(containsStart);\r\n      const endInSummary = detailsElements.startSummary.exists(containsEnd);\r\n      const isPartiallySelectedDetailsElements = detailsElements.startDetails.forall(startDetails => detailsElements.endDetails.forall(endDetails => startDetails !== endDetails));\r\n      const isInPartiallySelectedSummary = (startInSummary || endInSummary) && !(startInSummary && endInSummary);\r\n      return isInPartiallySelectedSummary || isPartiallySelectedDetailsElements;\r\n    };\r\n    const shouldPreventDeleteIntoDetails = (editor, forward, granularity) => {\r\n      const {dom, selection} = editor;\r\n      const root = editor.getBody();\r\n      if (granularity === 'character') {\r\n        const caretPos = CaretPosition.fromRangeStart(selection.getRng());\r\n        const parentBlock = dom.getParent(caretPos.container(), dom.isBlock);\r\n        const parentDetailsAtCaret = getParentDetailsElementAtPos(dom, caretPos);\r\n        const inEmptyParentBlock = parentBlock && dom.isEmpty(parentBlock);\r\n        const isFirstBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.previousSibling);\r\n        const isLastBlock = isNull(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.nextSibling);\r\n        if (inEmptyParentBlock) {\r\n          const firstOrLast = forward ? isLastBlock : isFirstBlock;\r\n          if (firstOrLast) {\r\n            const isBeforeAfterDetails = navigate(!forward, root, caretPos).exists(pos => {\r\n              return isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, getParentDetailsElementAtPos(dom, pos));\r\n            });\r\n            if (isBeforeAfterDetails) {\r\n              return true;\r\n            }\r\n          }\r\n        }\r\n        return navigate(forward, root, caretPos).fold(never, pos => {\r\n          const parentDetailsAtNewPos = getParentDetailsElementAtPos(dom, pos);\r\n          if (isInDetailsElement(dom, pos) && !equals(parentDetailsAtCaret, parentDetailsAtNewPos)) {\r\n            if (!forward) {\r\n              moveCaretToDetailsPos(editor, pos, false);\r\n            }\r\n            if (parentBlock && inEmptyParentBlock) {\r\n              if (forward && isFirstBlock) {\r\n                return true;\r\n              } else if (!forward && isLastBlock) {\r\n                return true;\r\n              }\r\n              moveCaretToDetailsPos(editor, pos, forward);\r\n              editor.dom.remove(parentBlock);\r\n            }\r\n            return true;\r\n          } else {\r\n            return false;\r\n          }\r\n        });\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const shouldPreventDeleteSummaryAction = (editor, detailElements, forward, granularity) => {\r\n      const selection = editor.selection;\r\n      const rng = selection.getRng();\r\n      const caretPos = CaretPosition.fromRangeStart(rng);\r\n      const root = editor.getBody();\r\n      if (granularity === 'selection') {\r\n        return isPartialDelete(rng, detailElements);\r\n      } else if (forward) {\r\n        return isCaretAtEndOfSummary(caretPos, detailElements) || isCaretInLastPositionInBody(root, caretPos, detailElements);\r\n      } else {\r\n        return isCaretAtStartOfSummary(caretPos, detailElements) || isCaretInFirstPositionInBody(caretPos, detailElements);\r\n      }\r\n    };\r\n    const shouldPreventDeleteAction = (editor, forward, granularity) => getDetailsElements(editor.dom, editor.selection.getRng()).fold(() => shouldPreventDeleteIntoDetails(editor, forward, granularity), detailsElements => shouldPreventDeleteSummaryAction(editor, detailsElements, forward, granularity) || shouldPreventDeleteIntoDetails(editor, forward, granularity));\r\n    const handleDeleteActionSafari = (editor, forward, granularity) => {\r\n      const selection = editor.selection;\r\n      const node = selection.getNode();\r\n      const rng = selection.getRng();\r\n      const caretPos = CaretPosition.fromRangeStart(rng);\r\n      if (isSummary$1(node)) {\r\n        if (granularity === 'selection' && isEntireNodeSelected(rng, node) || willDeleteLastPositionInElement(forward, caretPos, node)) {\r\n          emptyNodeContents(node);\r\n        } else {\r\n          editor.undoManager.transact(() => {\r\n            const sel = selection.getSel();\r\n            let {anchorNode, anchorOffset, focusNode, focusOffset} = sel !== null && sel !== void 0 ? sel : {};\r\n            const applySelection = () => {\r\n              if (isNonNullable(anchorNode) && isNonNullable(anchorOffset) && isNonNullable(focusNode) && isNonNullable(focusOffset)) {\r\n                sel === null || sel === void 0 ? void 0 : sel.setBaseAndExtent(anchorNode, anchorOffset, focusNode, focusOffset);\r\n              }\r\n            };\r\n            const updateSelection = () => {\r\n              anchorNode = sel === null || sel === void 0 ? void 0 : sel.anchorNode;\r\n              anchorOffset = sel === null || sel === void 0 ? void 0 : sel.anchorOffset;\r\n              focusNode = sel === null || sel === void 0 ? void 0 : sel.focusNode;\r\n              focusOffset = sel === null || sel === void 0 ? void 0 : sel.focusOffset;\r\n            };\r\n            const appendAllChildNodes = (from, to) => {\r\n              each$e(from.childNodes, child => {\r\n                if (isNode(child)) {\r\n                  to.appendChild(child);\r\n                }\r\n              });\r\n            };\r\n            const container = editor.dom.create('span', { 'data-mce-bogus': '1' });\r\n            appendAllChildNodes(node, container);\r\n            node.appendChild(container);\r\n            applySelection();\r\n            if (granularity === 'word' || granularity === 'line') {\r\n              sel === null || sel === void 0 ? void 0 : sel.modify('extend', forward ? 'right' : 'left', granularity);\r\n            }\r\n            if (!selection.isCollapsed() && isEntireNodeSelected(selection.getRng(), container)) {\r\n              emptyNodeContents(node);\r\n            } else {\r\n              editor.execCommand(forward ? 'ForwardDelete' : 'Delete');\r\n              updateSelection();\r\n              appendAllChildNodes(container, node);\r\n              applySelection();\r\n            }\r\n            editor.dom.remove(container);\r\n          });\r\n        }\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const backspaceDelete = (editor, forward, granularity) => shouldPreventDeleteAction(editor, forward, granularity) || isSafari && handleDeleteActionSafari(editor, forward, granularity) ? Optional.some(noop) : Optional.none();\r\n\r\n    const createAndFireInputEvent = eventType => (editor, inputType, specifics = {}) => {\r\n      const target = editor.getBody();\r\n      const overrides = {\r\n        bubbles: true,\r\n        composed: true,\r\n        data: null,\r\n        isComposing: false,\r\n        detail: 0,\r\n        view: null,\r\n        target,\r\n        currentTarget: target,\r\n        eventPhase: Event.AT_TARGET,\r\n        originalTarget: target,\r\n        explicitOriginalTarget: target,\r\n        isTrusted: false,\r\n        srcElement: target,\r\n        cancelable: false,\r\n        preventDefault: noop,\r\n        inputType\r\n      };\r\n      const input = clone$3(new InputEvent(eventType));\r\n      return editor.dispatch(eventType, {\r\n        ...input,\r\n        ...overrides,\r\n        ...specifics\r\n      });\r\n    };\r\n    const fireInputEvent = createAndFireInputEvent('input');\r\n    const fireBeforeInputEvent = createAndFireInputEvent('beforeinput');\r\n\r\n    const platform$2 = detect$2();\r\n    const os = platform$2.os;\r\n    const isMacOSOriOS = os.isMacOS() || os.isiOS();\r\n    const browser = platform$2.browser;\r\n    const isFirefox = browser.isFirefox();\r\n    const executeKeydownOverride$3 = (editor, caret, evt) => {\r\n      const inputType = evt.keyCode === VK.BACKSPACE ? 'deleteContentBackward' : 'deleteContentForward';\r\n      const isCollapsed = editor.selection.isCollapsed();\r\n      const unmodifiedGranularity = isCollapsed ? 'character' : 'selection';\r\n      const getModifiedGranularity = isWord => {\r\n        if (isCollapsed) {\r\n          return isWord ? 'word' : 'line';\r\n        } else {\r\n          return 'selection';\r\n        }\r\n      };\r\n      executeWithDelayedAction([\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$1, editor)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$6, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$6, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$7, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$7, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$4, editor, caret, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$4, editor, caret, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$a, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$a, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete, editor, false, unmodifiedGranularity)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete, editor, true, unmodifiedGranularity)\r\n        },\r\n        ...isMacOSOriOS ? [\r\n          {\r\n            keyCode: VK.BACKSPACE,\r\n            altKey: true,\r\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\r\n          },\r\n          {\r\n            keyCode: VK.DELETE,\r\n            altKey: true,\r\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\r\n          },\r\n          {\r\n            keyCode: VK.BACKSPACE,\r\n            metaKey: true,\r\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(false))\r\n          }\r\n        ] : [\r\n          {\r\n            keyCode: VK.BACKSPACE,\r\n            ctrlKey: true,\r\n            action: action(backspaceDelete, editor, false, getModifiedGranularity(true))\r\n          },\r\n          {\r\n            keyCode: VK.DELETE,\r\n            ctrlKey: true,\r\n            action: action(backspaceDelete, editor, true, getModifiedGranularity(true))\r\n          }\r\n        ],\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$5, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$5, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$2, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$2, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$8, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$8, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$9, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$9, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          action: action(backspaceDelete$3, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          action: action(backspaceDelete$3, editor, true)\r\n        }\r\n      ], evt).filter(_ => editor.selection.isEditable()).each(applyAction => {\r\n        evt.preventDefault();\r\n        const beforeInput = fireBeforeInputEvent(editor, inputType);\r\n        if (!beforeInput.isDefaultPrevented()) {\r\n          applyAction();\r\n          fireInputEvent(editor, inputType);\r\n        }\r\n      });\r\n    };\r\n    const executeKeyupOverride = (editor, evt, isBackspaceKeydown) => execute([\r\n      {\r\n        keyCode: VK.BACKSPACE,\r\n        action: action(paddEmptyElement, editor)\r\n      },\r\n      {\r\n        keyCode: VK.DELETE,\r\n        action: action(paddEmptyElement, editor)\r\n      },\r\n      ...isMacOSOriOS ? [\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          altKey: true,\r\n          action: action(refreshCaret, editor)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          altKey: true,\r\n          action: action(refreshCaret, editor)\r\n        },\r\n        ...isBackspaceKeydown ? [{\r\n            keyCode: isFirefox ? 224 : 91,\r\n            action: action(refreshCaret, editor)\r\n          }] : []\r\n      ] : [\r\n        {\r\n          keyCode: VK.BACKSPACE,\r\n          ctrlKey: true,\r\n          action: action(refreshCaret, editor)\r\n        },\r\n        {\r\n          keyCode: VK.DELETE,\r\n          ctrlKey: true,\r\n          action: action(refreshCaret, editor)\r\n        }\r\n      ]\r\n    ], evt);\r\n    const setup$j = (editor, caret) => {\r\n      let isBackspaceKeydown = false;\r\n      editor.on('keydown', evt => {\r\n        isBackspaceKeydown = evt.keyCode === VK.BACKSPACE;\r\n        if (!evt.isDefaultPrevented()) {\r\n          executeKeydownOverride$3(editor, caret, evt);\r\n        }\r\n      });\r\n      editor.on('keyup', evt => {\r\n        if (!evt.isDefaultPrevented()) {\r\n          executeKeyupOverride(editor, evt, isBackspaceKeydown);\r\n        }\r\n        isBackspaceKeydown = false;\r\n      });\r\n    };\r\n\r\n    const firstNonWhiteSpaceNodeSibling = node => {\r\n      while (node) {\r\n        if (isElement$6(node) || isText$a(node) && node.data && /[\\r\\n\\s]/.test(node.data)) {\r\n          return node;\r\n        }\r\n        node = node.nextSibling;\r\n      }\r\n      return null;\r\n    };\r\n    const moveToCaretPosition = (editor, root) => {\r\n      const dom = editor.dom;\r\n      const moveCaretBeforeOnEnterElementsMap = editor.schema.getMoveCaretBeforeOnEnterElements();\r\n      if (!root) {\r\n        return;\r\n      }\r\n      if (/^(LI|DT|DD)$/.test(root.nodeName)) {\r\n        const firstChild = firstNonWhiteSpaceNodeSibling(root.firstChild);\r\n        if (firstChild && /^(UL|OL|DL)$/.test(firstChild.nodeName)) {\r\n          root.insertBefore(dom.doc.createTextNode(nbsp), root.firstChild);\r\n        }\r\n      }\r\n      const rng = dom.createRng();\r\n      root.normalize();\r\n      if (root.hasChildNodes()) {\r\n        const walker = new DomTreeWalker(root, root);\r\n        let lastNode = root;\r\n        let node;\r\n        while (node = walker.current()) {\r\n          if (isText$a(node)) {\r\n            rng.setStart(node, 0);\r\n            rng.setEnd(node, 0);\r\n            break;\r\n          }\r\n          if (moveCaretBeforeOnEnterElementsMap[node.nodeName.toLowerCase()]) {\r\n            rng.setStartBefore(node);\r\n            rng.setEndBefore(node);\r\n            break;\r\n          }\r\n          lastNode = node;\r\n          node = walker.next();\r\n        }\r\n        if (!node) {\r\n          rng.setStart(lastNode, 0);\r\n          rng.setEnd(lastNode, 0);\r\n        }\r\n      } else {\r\n        if (isBr$6(root)) {\r\n          if (root.nextSibling && dom.isBlock(root.nextSibling)) {\r\n            rng.setStartBefore(root);\r\n            rng.setEndBefore(root);\r\n          } else {\r\n            rng.setStartAfter(root);\r\n            rng.setEndAfter(root);\r\n          }\r\n        } else {\r\n          rng.setStart(root, 0);\r\n          rng.setEnd(root, 0);\r\n        }\r\n      }\r\n      editor.selection.setRng(rng);\r\n      scrollRangeIntoView(editor, rng);\r\n    };\r\n    const getEditableRoot = (dom, node) => {\r\n      const root = dom.getRoot();\r\n      let editableRoot;\r\n      let parent = node;\r\n      while (parent !== root && parent && dom.getContentEditable(parent) !== 'false') {\r\n        if (dom.getContentEditable(parent) === 'true') {\r\n          editableRoot = parent;\r\n          break;\r\n        }\r\n        parent = parent.parentNode;\r\n      }\r\n      return parent !== root ? editableRoot : root;\r\n    };\r\n    const getParentBlock$1 = editor => {\r\n      return Optional.from(editor.dom.getParent(editor.selection.getStart(true), editor.dom.isBlock));\r\n    };\r\n    const getParentBlockName = editor => {\r\n      return getParentBlock$1(editor).fold(constant(''), parentBlock => {\r\n        return parentBlock.nodeName.toUpperCase();\r\n      });\r\n    };\r\n    const isListItemParentBlock = editor => {\r\n      return getParentBlock$1(editor).filter(elm => {\r\n        return isListItem$1(SugarElement.fromDom(elm));\r\n      }).isSome();\r\n    };\r\n    const emptyBlock = elm => {\r\n      elm.innerHTML = '<br data-mce-bogus=\"1\">';\r\n    };\r\n    const applyAttributes = (editor, node, forcedRootBlockAttrs) => {\r\n      const dom = editor.dom;\r\n      Optional.from(forcedRootBlockAttrs.style).map(dom.parseStyle).each(attrStyles => {\r\n        const currentStyles = getAllRaw(SugarElement.fromDom(node));\r\n        const newStyles = {\r\n          ...currentStyles,\r\n          ...attrStyles\r\n        };\r\n        dom.setStyles(node, newStyles);\r\n      });\r\n      const attrClassesOpt = Optional.from(forcedRootBlockAttrs.class).map(attrClasses => attrClasses.split(/\\s+/));\r\n      const currentClassesOpt = Optional.from(node.className).map(currentClasses => filter$5(currentClasses.split(/\\s+/), clazz => clazz !== ''));\r\n      lift2(attrClassesOpt, currentClassesOpt, (attrClasses, currentClasses) => {\r\n        const filteredClasses = filter$5(currentClasses, clazz => !contains$2(attrClasses, clazz));\r\n        const newClasses = [\r\n          ...attrClasses,\r\n          ...filteredClasses\r\n        ];\r\n        dom.setAttrib(node, 'class', newClasses.join(' '));\r\n      });\r\n      const appliedAttrs = [\r\n        'style',\r\n        'class'\r\n      ];\r\n      const remainingAttrs = filter$4(forcedRootBlockAttrs, (_, attrs) => !contains$2(appliedAttrs, attrs));\r\n      dom.setAttribs(node, remainingAttrs);\r\n    };\r\n    const setForcedBlockAttrs = (editor, node) => {\r\n      const forcedRootBlockName = getForcedRootBlock(editor);\r\n      if (forcedRootBlockName.toLowerCase() === node.tagName.toLowerCase()) {\r\n        const forcedRootBlockAttrs = getForcedRootBlockAttrs(editor);\r\n        applyAttributes(editor, node, forcedRootBlockAttrs);\r\n      }\r\n    };\r\n    const createNewBlock = (editor, container, parentBlock, editableRoot, keepStyles = true, name, styles) => {\r\n      const dom = editor.dom;\r\n      const schema = editor.schema;\r\n      const newBlockName = getForcedRootBlock(editor);\r\n      const parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\r\n      let node = container;\r\n      const textInlineElements = schema.getTextInlineElements();\r\n      let block;\r\n      if (name || parentBlockName === 'TABLE' || parentBlockName === 'HR') {\r\n        block = dom.create(name || newBlockName, styles || {});\r\n      } else {\r\n        block = parentBlock.cloneNode(false);\r\n      }\r\n      let caretNode = block;\r\n      if (!keepStyles) {\r\n        dom.setAttrib(block, 'style', null);\r\n        dom.setAttrib(block, 'class', null);\r\n      } else {\r\n        do {\r\n          if (textInlineElements[node.nodeName]) {\r\n            if (isCaretNode(node) || isBookmarkNode$1(node)) {\r\n              continue;\r\n            }\r\n            const clonedNode = node.cloneNode(false);\r\n            dom.setAttrib(clonedNode, 'id', '');\r\n            if (block.hasChildNodes()) {\r\n              clonedNode.appendChild(block.firstChild);\r\n              block.appendChild(clonedNode);\r\n            } else {\r\n              caretNode = clonedNode;\r\n              block.appendChild(clonedNode);\r\n            }\r\n          }\r\n        } while ((node = node.parentNode) && node !== editableRoot);\r\n      }\r\n      setForcedBlockAttrs(editor, block);\r\n      emptyBlock(caretNode);\r\n      return block;\r\n    };\r\n\r\n    const getDetailsRoot = (editor, element) => editor.dom.getParent(element, isDetails);\r\n    const isAtDetailsEdge = (root, element, isTextBlock) => {\r\n      let node = element;\r\n      while (node && node !== root && isNull(node.nextSibling)) {\r\n        const parent = node.parentElement;\r\n        if (!parent || !isTextBlock(parent)) {\r\n          return isDetails(parent);\r\n        }\r\n        node = parent;\r\n      }\r\n      return false;\r\n    };\r\n    const isLastEmptyBlockInDetails = (editor, shiftKey, element) => !shiftKey && element.nodeName.toLowerCase() === getForcedRootBlock(editor) && editor.dom.isEmpty(element) && isAtDetailsEdge(editor.getBody(), element, el => has$2(editor.schema.getTextBlockElements(), el.nodeName.toLowerCase()));\r\n    const insertNewLine = (editor, createNewBlock, parentBlock) => {\r\n      var _a, _b, _c;\r\n      const newBlock = createNewBlock(getForcedRootBlock(editor));\r\n      const root = getDetailsRoot(editor, parentBlock);\r\n      if (!root) {\r\n        return;\r\n      }\r\n      editor.dom.insertAfter(newBlock, root);\r\n      moveToCaretPosition(editor, newBlock);\r\n      if (((_c = (_b = (_a = parentBlock.parentElement) === null || _a === void 0 ? void 0 : _a.childNodes) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0) > 1) {\r\n        editor.dom.remove(parentBlock);\r\n      }\r\n    };\r\n\r\n    const hasFirstChild = (elm, name) => {\r\n      return elm.firstChild && elm.firstChild.nodeName === name;\r\n    };\r\n    const isFirstChild = elm => {\r\n      var _a;\r\n      return ((_a = elm.parentNode) === null || _a === void 0 ? void 0 : _a.firstChild) === elm;\r\n    };\r\n    const hasParent = (elm, parentName) => {\r\n      const parentNode = elm === null || elm === void 0 ? void 0 : elm.parentNode;\r\n      return isNonNullable(parentNode) && parentNode.nodeName === parentName;\r\n    };\r\n    const isListBlock = elm => {\r\n      return isNonNullable(elm) && /^(OL|UL|LI)$/.test(elm.nodeName);\r\n    };\r\n    const isListItem = elm => {\r\n      return isNonNullable(elm) && /^(LI|DT|DD)$/.test(elm.nodeName);\r\n    };\r\n    const isNestedList = elm => {\r\n      return isListBlock(elm) && isListBlock(elm.parentNode);\r\n    };\r\n    const getContainerBlock = containerBlock => {\r\n      const containerBlockParent = containerBlock.parentNode;\r\n      return isListItem(containerBlockParent) ? containerBlockParent : containerBlock;\r\n    };\r\n    const isFirstOrLastLi = (containerBlock, parentBlock, first) => {\r\n      let node = containerBlock[first ? 'firstChild' : 'lastChild'];\r\n      while (node) {\r\n        if (isElement$6(node)) {\r\n          break;\r\n        }\r\n        node = node[first ? 'nextSibling' : 'previousSibling'];\r\n      }\r\n      return node === parentBlock;\r\n    };\r\n    const getStyles = elm => foldl(mapToArray(getAllRaw(SugarElement.fromDom(elm)), (style, styleName) => `${ styleName }: ${ style };`), (acc, s) => acc + s, '');\r\n    const insert$4 = (editor, createNewBlock, containerBlock, parentBlock, newBlockName) => {\r\n      const dom = editor.dom;\r\n      const rng = editor.selection.getRng();\r\n      const containerParent = containerBlock.parentNode;\r\n      if (containerBlock === editor.getBody() || !containerParent) {\r\n        return;\r\n      }\r\n      if (isNestedList(containerBlock)) {\r\n        newBlockName = 'LI';\r\n      }\r\n      const parentBlockStyles = isListItem(parentBlock) ? getStyles(parentBlock) : undefined;\r\n      let newBlock = isListItem(parentBlock) && parentBlockStyles ? createNewBlock(newBlockName, { style: getStyles(parentBlock) }) : createNewBlock(newBlockName);\r\n      if (isFirstOrLastLi(containerBlock, parentBlock, true) && isFirstOrLastLi(containerBlock, parentBlock, false)) {\r\n        if (hasParent(containerBlock, 'LI')) {\r\n          const containerBlockParent = getContainerBlock(containerBlock);\r\n          dom.insertAfter(newBlock, containerBlockParent);\r\n          if (isFirstChild(containerBlock)) {\r\n            dom.remove(containerBlockParent);\r\n          } else {\r\n            dom.remove(containerBlock);\r\n          }\r\n        } else {\r\n          dom.replace(newBlock, containerBlock);\r\n        }\r\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, true)) {\r\n        if (hasParent(containerBlock, 'LI')) {\r\n          dom.insertAfter(newBlock, getContainerBlock(containerBlock));\r\n          newBlock.appendChild(dom.doc.createTextNode(' '));\r\n          newBlock.appendChild(containerBlock);\r\n        } else {\r\n          containerParent.insertBefore(newBlock, containerBlock);\r\n        }\r\n        dom.remove(parentBlock);\r\n      } else if (isFirstOrLastLi(containerBlock, parentBlock, false)) {\r\n        dom.insertAfter(newBlock, getContainerBlock(containerBlock));\r\n        dom.remove(parentBlock);\r\n      } else {\r\n        containerBlock = getContainerBlock(containerBlock);\r\n        const tmpRng = rng.cloneRange();\r\n        tmpRng.setStartAfter(parentBlock);\r\n        tmpRng.setEndAfter(containerBlock);\r\n        const fragment = tmpRng.extractContents();\r\n        if (newBlockName === 'LI' && hasFirstChild(fragment, 'LI')) {\r\n          const previousChildren = filter$5(map$3(newBlock.children, SugarElement.fromDom), not(isTag('br')));\r\n          newBlock = fragment.firstChild;\r\n          dom.insertAfter(fragment, containerBlock);\r\n          each$e(previousChildren, child => prepend(SugarElement.fromDom(newBlock), child));\r\n          if (parentBlockStyles) {\r\n            newBlock.setAttribute('style', parentBlockStyles);\r\n          }\r\n        } else {\r\n          dom.insertAfter(fragment, containerBlock);\r\n          dom.insertAfter(newBlock, containerBlock);\r\n        }\r\n        dom.remove(parentBlock);\r\n      }\r\n      moveToCaretPosition(editor, newBlock);\r\n    };\r\n\r\n    const trimZwsp = fragment => {\r\n      each$e(descendants$1(SugarElement.fromDom(fragment), isText$b), text => {\r\n        const rawNode = text.dom;\r\n        rawNode.nodeValue = trim$2(rawNode.data);\r\n      });\r\n    };\r\n    const isWithinNonEditableList = (editor, node) => {\r\n      const parentList = editor.dom.getParent(node, 'ol,ul,dl');\r\n      return parentList !== null && editor.dom.getContentEditableParent(parentList) === 'false';\r\n    };\r\n    const isEmptyAnchor = (dom, elm) => {\r\n      return elm && elm.nodeName === 'A' && dom.isEmpty(elm);\r\n    };\r\n    const containerAndSiblingName = (container, nodeName) => {\r\n      return container.nodeName === nodeName || container.previousSibling && container.previousSibling.nodeName === nodeName;\r\n    };\r\n    const canSplitBlock = (dom, node) => {\r\n      return isNonNullable(node) && dom.isBlock(node) && !/^(TD|TH|CAPTION|FORM)$/.test(node.nodeName) && !/^(fixed|absolute)/i.test(node.style.position) && dom.isEditable(node.parentNode) && dom.getContentEditable(node) !== 'false';\r\n    };\r\n    const trimInlineElementsOnLeftSideOfBlock = (dom, nonEmptyElementsMap, block) => {\r\n      var _a;\r\n      const firstChilds = [];\r\n      if (!block) {\r\n        return;\r\n      }\r\n      let currentNode = block;\r\n      while (currentNode = currentNode.firstChild) {\r\n        if (dom.isBlock(currentNode)) {\r\n          return;\r\n        }\r\n        if (isElement$6(currentNode) && !nonEmptyElementsMap[currentNode.nodeName.toLowerCase()]) {\r\n          firstChilds.push(currentNode);\r\n        }\r\n      }\r\n      let i = firstChilds.length;\r\n      while (i--) {\r\n        currentNode = firstChilds[i];\r\n        if (!currentNode.hasChildNodes() || currentNode.firstChild === currentNode.lastChild && ((_a = currentNode.firstChild) === null || _a === void 0 ? void 0 : _a.nodeValue) === '') {\r\n          dom.remove(currentNode);\r\n        } else {\r\n          if (isEmptyAnchor(dom, currentNode)) {\r\n            dom.remove(currentNode);\r\n          }\r\n        }\r\n      }\r\n    };\r\n    const normalizeZwspOffset = (start, container, offset) => {\r\n      if (!isText$a(container)) {\r\n        return offset;\r\n      } else if (start) {\r\n        return offset === 1 && container.data.charAt(offset - 1) === ZWSP$1 ? 0 : offset;\r\n      } else {\r\n        return offset === container.data.length - 1 && container.data.charAt(offset) === ZWSP$1 ? container.data.length : offset;\r\n      }\r\n    };\r\n    const includeZwspInRange = rng => {\r\n      const newRng = rng.cloneRange();\r\n      newRng.setStart(rng.startContainer, normalizeZwspOffset(true, rng.startContainer, rng.startOffset));\r\n      newRng.setEnd(rng.endContainer, normalizeZwspOffset(false, rng.endContainer, rng.endOffset));\r\n      return newRng;\r\n    };\r\n    const trimLeadingLineBreaks = node => {\r\n      let currentNode = node;\r\n      do {\r\n        if (isText$a(currentNode)) {\r\n          currentNode.data = currentNode.data.replace(/^[\\r\\n]+/, '');\r\n        }\r\n        currentNode = currentNode.firstChild;\r\n      } while (currentNode);\r\n    };\r\n    const wrapSelfAndSiblingsInDefaultBlock = (editor, newBlockName, rng, container, offset) => {\r\n      var _a, _b;\r\n      const dom = editor.dom;\r\n      const editableRoot = (_a = getEditableRoot(dom, container)) !== null && _a !== void 0 ? _a : dom.getRoot();\r\n      let parentBlock = dom.getParent(container, dom.isBlock);\r\n      if (!parentBlock || !canSplitBlock(dom, parentBlock)) {\r\n        parentBlock = parentBlock || editableRoot;\r\n        if (!parentBlock.hasChildNodes()) {\r\n          const newBlock = dom.create(newBlockName);\r\n          setForcedBlockAttrs(editor, newBlock);\r\n          parentBlock.appendChild(newBlock);\r\n          rng.setStart(newBlock, 0);\r\n          rng.setEnd(newBlock, 0);\r\n          return newBlock;\r\n        }\r\n        let node = container;\r\n        while (node && node.parentNode !== parentBlock) {\r\n          node = node.parentNode;\r\n        }\r\n        let startNode;\r\n        while (node && !dom.isBlock(node)) {\r\n          startNode = node;\r\n          node = node.previousSibling;\r\n        }\r\n        const startNodeName = (_b = startNode === null || startNode === void 0 ? void 0 : startNode.parentElement) === null || _b === void 0 ? void 0 : _b.nodeName;\r\n        if (startNode && startNodeName && editor.schema.isValidChild(startNodeName, newBlockName.toLowerCase())) {\r\n          const startNodeParent = startNode.parentNode;\r\n          const newBlock = dom.create(newBlockName);\r\n          setForcedBlockAttrs(editor, newBlock);\r\n          startNodeParent.insertBefore(newBlock, startNode);\r\n          node = startNode;\r\n          while (node && !dom.isBlock(node)) {\r\n            const next = node.nextSibling;\r\n            newBlock.appendChild(node);\r\n            node = next;\r\n          }\r\n          rng.setStart(container, offset);\r\n          rng.setEnd(container, offset);\r\n        }\r\n      }\r\n      return container;\r\n    };\r\n    const addBrToBlockIfNeeded = (dom, block) => {\r\n      block.normalize();\r\n      const lastChild = block.lastChild;\r\n      if (!lastChild || isElement$6(lastChild) && /^(left|right)$/gi.test(dom.getStyle(lastChild, 'float', true))) {\r\n        dom.add(block, 'br');\r\n      }\r\n    };\r\n    const shouldEndContainer = (editor, container) => {\r\n      const optionValue = shouldEndContainerOnEmptyBlock(editor);\r\n      if (isNullable(container)) {\r\n        return false;\r\n      } else if (isString(optionValue)) {\r\n        return contains$2(Tools.explode(optionValue), container.nodeName.toLowerCase());\r\n      } else {\r\n        return optionValue;\r\n      }\r\n    };\r\n    const insert$3 = (editor, evt) => {\r\n      let container;\r\n      let offset;\r\n      let parentBlockName;\r\n      let containerBlock;\r\n      let isAfterLastNodeInContainer = false;\r\n      const dom = editor.dom;\r\n      const schema = editor.schema, nonEmptyElementsMap = schema.getNonEmptyElements();\r\n      const rng = editor.selection.getRng();\r\n      const newBlockName = getForcedRootBlock(editor);\r\n      const start = SugarElement.fromDom(rng.startContainer);\r\n      const child = child$1(start, rng.startOffset);\r\n      const isCef = child.exists(element => isHTMLElement$1(element) && !isEditable$2(element));\r\n      const collapsedAndCef = rng.collapsed && isCef;\r\n      const createNewBlock$1 = (name, styles) => {\r\n        return createNewBlock(editor, container, parentBlock, editableRoot, shouldKeepStyles(editor), name, styles);\r\n      };\r\n      const isCaretAtStartOrEndOfBlock = start => {\r\n        const normalizedOffset = normalizeZwspOffset(start, container, offset);\r\n        if (isText$a(container) && (start ? normalizedOffset > 0 : normalizedOffset < container.data.length)) {\r\n          return false;\r\n        }\r\n        if (container.parentNode === parentBlock && isAfterLastNodeInContainer && !start) {\r\n          return true;\r\n        }\r\n        if (start && isElement$6(container) && container === parentBlock.firstChild) {\r\n          return true;\r\n        }\r\n        if (containerAndSiblingName(container, 'TABLE') || containerAndSiblingName(container, 'HR')) {\r\n          return isAfterLastNodeInContainer && !start || !isAfterLastNodeInContainer && start;\r\n        }\r\n        const walker = new DomTreeWalker(container, parentBlock);\r\n        if (isText$a(container)) {\r\n          if (start && normalizedOffset === 0) {\r\n            walker.prev();\r\n          } else if (!start && normalizedOffset === container.data.length) {\r\n            walker.next();\r\n          }\r\n        }\r\n        let node;\r\n        while (node = walker.current()) {\r\n          if (isElement$6(node)) {\r\n            if (!node.getAttribute('data-mce-bogus')) {\r\n              const name = node.nodeName.toLowerCase();\r\n              if (nonEmptyElementsMap[name] && name !== 'br') {\r\n                return false;\r\n              }\r\n            }\r\n          } else if (isText$a(node) && !isWhitespaceText(node.data)) {\r\n            return false;\r\n          }\r\n          if (start) {\r\n            walker.prev();\r\n          } else {\r\n            walker.next();\r\n          }\r\n        }\r\n        return true;\r\n      };\r\n      const insertNewBlockAfter = () => {\r\n        let block;\r\n        if (/^(H[1-6]|PRE|FIGURE)$/.test(parentBlockName) && containerBlockName !== 'HGROUP') {\r\n          block = createNewBlock$1(newBlockName);\r\n        } else {\r\n          block = createNewBlock$1();\r\n        }\r\n        if (shouldEndContainer(editor, containerBlock) && canSplitBlock(dom, containerBlock) && dom.isEmpty(parentBlock, undefined, { includeZwsp: true })) {\r\n          block = dom.split(containerBlock, parentBlock);\r\n        } else {\r\n          dom.insertAfter(block, parentBlock);\r\n        }\r\n        moveToCaretPosition(editor, block);\r\n        return block;\r\n      };\r\n      normalize$2(dom, rng).each(normRng => {\r\n        rng.setStart(normRng.startContainer, normRng.startOffset);\r\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\r\n      });\r\n      container = rng.startContainer;\r\n      offset = rng.startOffset;\r\n      const shiftKey = !!(evt && evt.shiftKey);\r\n      const ctrlKey = !!(evt && evt.ctrlKey);\r\n      if (isElement$6(container) && container.hasChildNodes() && !collapsedAndCef) {\r\n        isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\r\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\r\n        if (isAfterLastNodeInContainer && isText$a(container)) {\r\n          offset = container.data.length;\r\n        } else {\r\n          offset = 0;\r\n        }\r\n      }\r\n      const editableRoot = getEditableRoot(dom, container);\r\n      if (!editableRoot || isWithinNonEditableList(editor, container)) {\r\n        return;\r\n      }\r\n      if (!shiftKey) {\r\n        container = wrapSelfAndSiblingsInDefaultBlock(editor, newBlockName, rng, container, offset);\r\n      }\r\n      let parentBlock = dom.getParent(container, dom.isBlock) || dom.getRoot();\r\n      containerBlock = isNonNullable(parentBlock === null || parentBlock === void 0 ? void 0 : parentBlock.parentNode) ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\r\n      parentBlockName = parentBlock ? parentBlock.nodeName.toUpperCase() : '';\r\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\r\n      if (containerBlockName === 'LI' && !ctrlKey) {\r\n        const liBlock = containerBlock;\r\n        parentBlock = liBlock;\r\n        containerBlock = liBlock.parentNode;\r\n        parentBlockName = containerBlockName;\r\n      }\r\n      if (isElement$6(containerBlock) && isLastEmptyBlockInDetails(editor, shiftKey, parentBlock)) {\r\n        return insertNewLine(editor, createNewBlock$1, parentBlock);\r\n      }\r\n      if (/^(LI|DT|DD)$/.test(parentBlockName) && isElement$6(containerBlock)) {\r\n        if (dom.isEmpty(parentBlock)) {\r\n          insert$4(editor, createNewBlock$1, containerBlock, parentBlock, newBlockName);\r\n          return;\r\n        }\r\n      }\r\n      if (!collapsedAndCef && (parentBlock === editor.getBody() || !canSplitBlock(dom, parentBlock))) {\r\n        return;\r\n      }\r\n      const parentBlockParent = parentBlock.parentNode;\r\n      let newBlock;\r\n      if (collapsedAndCef) {\r\n        newBlock = createNewBlock$1(newBlockName);\r\n        child.fold(() => {\r\n          append$1(start, SugarElement.fromDom(newBlock));\r\n        }, child => {\r\n          before$3(child, SugarElement.fromDom(newBlock));\r\n        });\r\n        editor.selection.setCursorLocation(newBlock, 0);\r\n      } else if (isCaretContainerBlock$1(parentBlock)) {\r\n        newBlock = showCaretContainerBlock(parentBlock);\r\n        if (dom.isEmpty(parentBlock)) {\r\n          emptyBlock(parentBlock);\r\n        }\r\n        setForcedBlockAttrs(editor, newBlock);\r\n        moveToCaretPosition(editor, newBlock);\r\n      } else if (isCaretAtStartOrEndOfBlock(false)) {\r\n        newBlock = insertNewBlockAfter();\r\n      } else if (isCaretAtStartOrEndOfBlock(true) && parentBlockParent) {\r\n        newBlock = parentBlockParent.insertBefore(createNewBlock$1(), parentBlock);\r\n        const isNearChildren = hasChildNodes(SugarElement.fromDom(rng.startContainer)) && rng.collapsed;\r\n        moveToCaretPosition(editor, containerAndSiblingName(parentBlock, 'HR') || isNearChildren ? newBlock : parentBlock);\r\n      } else {\r\n        const tmpRng = includeZwspInRange(rng).cloneRange();\r\n        tmpRng.setEndAfter(parentBlock);\r\n        const fragment = tmpRng.extractContents();\r\n        trimZwsp(fragment);\r\n        trimLeadingLineBreaks(fragment);\r\n        newBlock = fragment.firstChild;\r\n        dom.insertAfter(fragment, parentBlock);\r\n        trimInlineElementsOnLeftSideOfBlock(dom, nonEmptyElementsMap, newBlock);\r\n        addBrToBlockIfNeeded(dom, parentBlock);\r\n        if (dom.isEmpty(parentBlock)) {\r\n          emptyBlock(parentBlock);\r\n        }\r\n        newBlock.normalize();\r\n        if (dom.isEmpty(newBlock)) {\r\n          dom.remove(newBlock);\r\n          insertNewBlockAfter();\r\n        } else {\r\n          setForcedBlockAttrs(editor, newBlock);\r\n          moveToCaretPosition(editor, newBlock);\r\n        }\r\n      }\r\n      dom.setAttrib(newBlock, 'id', '');\r\n      editor.dispatch('NewBlock', { newBlock });\r\n    };\r\n    const fakeEventName$1 = 'insertParagraph';\r\n    const blockbreak = {\r\n      insert: insert$3,\r\n      fakeEventName: fakeEventName$1\r\n    };\r\n\r\n    const hasRightSideContent = (schema, container, parentBlock) => {\r\n      const walker = new DomTreeWalker(container, parentBlock);\r\n      let node;\r\n      const nonEmptyElementsMap = schema.getNonEmptyElements();\r\n      while (node = walker.next()) {\r\n        if (nonEmptyElementsMap[node.nodeName.toLowerCase()] || isText$a(node) && node.length > 0) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    const moveSelectionToBr = (editor, brElm, extraBr) => {\r\n      const rng = editor.dom.createRng();\r\n      if (!extraBr) {\r\n        rng.setStartAfter(brElm);\r\n        rng.setEndAfter(brElm);\r\n      } else {\r\n        rng.setStartBefore(brElm);\r\n        rng.setEndBefore(brElm);\r\n      }\r\n      editor.selection.setRng(rng);\r\n      scrollRangeIntoView(editor, rng);\r\n    };\r\n    const insertBrAtCaret = (editor, evt) => {\r\n      const selection = editor.selection;\r\n      const dom = editor.dom;\r\n      const rng = selection.getRng();\r\n      let brElm;\r\n      let extraBr = false;\r\n      normalize$2(dom, rng).each(normRng => {\r\n        rng.setStart(normRng.startContainer, normRng.startOffset);\r\n        rng.setEnd(normRng.endContainer, normRng.endOffset);\r\n      });\r\n      let offset = rng.startOffset;\r\n      let container = rng.startContainer;\r\n      if (isElement$6(container) && container.hasChildNodes()) {\r\n        const isAfterLastNodeInContainer = offset > container.childNodes.length - 1;\r\n        container = container.childNodes[Math.min(offset, container.childNodes.length - 1)] || container;\r\n        if (isAfterLastNodeInContainer && isText$a(container)) {\r\n          offset = container.data.length;\r\n        } else {\r\n          offset = 0;\r\n        }\r\n      }\r\n      let parentBlock = dom.getParent(container, dom.isBlock);\r\n      const containerBlock = parentBlock && parentBlock.parentNode ? dom.getParent(parentBlock.parentNode, dom.isBlock) : null;\r\n      const containerBlockName = containerBlock ? containerBlock.nodeName.toUpperCase() : '';\r\n      const isControlKey = !!(evt && evt.ctrlKey);\r\n      if (containerBlockName === 'LI' && !isControlKey) {\r\n        parentBlock = containerBlock;\r\n      }\r\n      if (isText$a(container) && offset >= container.data.length) {\r\n        if (!hasRightSideContent(editor.schema, container, parentBlock || dom.getRoot())) {\r\n          brElm = dom.create('br');\r\n          rng.insertNode(brElm);\r\n          rng.setStartAfter(brElm);\r\n          rng.setEndAfter(brElm);\r\n          extraBr = true;\r\n        }\r\n      }\r\n      brElm = dom.create('br');\r\n      rangeInsertNode(dom, rng, brElm);\r\n      moveSelectionToBr(editor, brElm, extraBr);\r\n      editor.undoManager.add();\r\n    };\r\n    const insertBrBefore = (editor, inline) => {\r\n      const br = SugarElement.fromTag('br');\r\n      before$3(SugarElement.fromDom(inline), br);\r\n      editor.undoManager.add();\r\n    };\r\n    const insertBrAfter = (editor, inline) => {\r\n      if (!hasBrAfter(editor.getBody(), inline)) {\r\n        after$4(SugarElement.fromDom(inline), SugarElement.fromTag('br'));\r\n      }\r\n      const br = SugarElement.fromTag('br');\r\n      after$4(SugarElement.fromDom(inline), br);\r\n      moveSelectionToBr(editor, br.dom, false);\r\n      editor.undoManager.add();\r\n    };\r\n    const isBeforeBr = pos => {\r\n      return isBr$6(pos.getNode());\r\n    };\r\n    const hasBrAfter = (rootNode, startNode) => {\r\n      if (isBeforeBr(CaretPosition.after(startNode))) {\r\n        return true;\r\n      } else {\r\n        return nextPosition(rootNode, CaretPosition.after(startNode)).map(pos => {\r\n          return isBr$6(pos.getNode());\r\n        }).getOr(false);\r\n      }\r\n    };\r\n    const isAnchorLink = elm => {\r\n      return elm && elm.nodeName === 'A' && 'href' in elm;\r\n    };\r\n    const isInsideAnchor = location => {\r\n      return location.fold(never, isAnchorLink, isAnchorLink, never);\r\n    };\r\n    const readInlineAnchorLocation = editor => {\r\n      const isInlineTarget$1 = curry(isInlineTarget, editor);\r\n      const position = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      return readLocation(isInlineTarget$1, editor.getBody(), position).filter(isInsideAnchor);\r\n    };\r\n    const insertBrOutsideAnchor = (editor, location) => {\r\n      location.fold(noop, curry(insertBrBefore, editor), curry(insertBrAfter, editor), noop);\r\n    };\r\n    const insert$2 = (editor, evt) => {\r\n      const anchorLocation = readInlineAnchorLocation(editor);\r\n      if (anchorLocation.isSome()) {\r\n        anchorLocation.each(curry(insertBrOutsideAnchor, editor));\r\n      } else {\r\n        insertBrAtCaret(editor, evt);\r\n      }\r\n    };\r\n    const fakeEventName = 'insertLineBreak';\r\n    const linebreak = {\r\n      insert: insert$2,\r\n      fakeEventName\r\n    };\r\n\r\n    const matchesSelector = (editor, selector) => {\r\n      return getParentBlock$1(editor).filter(parentBlock => {\r\n        return selector.length > 0 && is$1(SugarElement.fromDom(parentBlock), selector);\r\n      }).isSome();\r\n    };\r\n    const shouldInsertBr = editor => {\r\n      return matchesSelector(editor, getBrNewLineSelector(editor));\r\n    };\r\n    const shouldBlockNewLine$1 = editor => {\r\n      return matchesSelector(editor, getNoNewLineSelector(editor));\r\n    };\r\n\r\n    const newLineAction = Adt.generate([\r\n      { br: [] },\r\n      { block: [] },\r\n      { none: [] }\r\n    ]);\r\n    const shouldBlockNewLine = (editor, _shiftKey) => {\r\n      return shouldBlockNewLine$1(editor);\r\n    };\r\n    const inListBlock = requiredState => {\r\n      return (editor, _shiftKey) => {\r\n        return isListItemParentBlock(editor) === requiredState;\r\n      };\r\n    };\r\n    const inBlock = (blockName, requiredState) => (editor, _shiftKey) => {\r\n      const state = getParentBlockName(editor) === blockName.toUpperCase();\r\n      return state === requiredState;\r\n    };\r\n    const inCefBlock = editor => {\r\n      const editableRoot = getEditableRoot(editor.dom, editor.selection.getStart());\r\n      return isNullable(editableRoot);\r\n    };\r\n    const inPreBlock = requiredState => inBlock('pre', requiredState);\r\n    const inSummaryBlock = () => inBlock('summary', true);\r\n    const shouldPutBrInPre = requiredState => {\r\n      return (editor, _shiftKey) => {\r\n        return shouldPutBrInPre$1(editor) === requiredState;\r\n      };\r\n    };\r\n    const inBrContext = (editor, _shiftKey) => {\r\n      return shouldInsertBr(editor);\r\n    };\r\n    const hasShiftKey = (_editor, shiftKey) => {\r\n      return shiftKey;\r\n    };\r\n    const canInsertIntoEditableRoot = editor => {\r\n      const forcedRootBlock = getForcedRootBlock(editor);\r\n      const rootEditable = getEditableRoot(editor.dom, editor.selection.getStart());\r\n      return isNonNullable(rootEditable) && editor.schema.isValidChild(rootEditable.nodeName, forcedRootBlock);\r\n    };\r\n    const isInRootWithEmptyOrCEF = editor => {\r\n      const rng = editor.selection.getRng();\r\n      const start = SugarElement.fromDom(rng.startContainer);\r\n      const child = child$1(start, rng.startOffset);\r\n      const isCefOpt = child.map(element => isHTMLElement$1(element) && !isEditable$2(element));\r\n      return rng.collapsed && isCefOpt.getOr(true);\r\n    };\r\n    const match = (predicates, action) => {\r\n      return (editor, shiftKey) => {\r\n        const isMatch = foldl(predicates, (res, p) => {\r\n          return res && p(editor, shiftKey);\r\n        }, true);\r\n        return isMatch ? Optional.some(action) : Optional.none();\r\n      };\r\n    };\r\n    const getAction = (editor, evt) => {\r\n      return evaluateUntil([\r\n        match([shouldBlockNewLine], newLineAction.none()),\r\n        match([\r\n          inPreBlock(true),\r\n          inCefBlock\r\n        ], newLineAction.none()),\r\n        match([inSummaryBlock()], newLineAction.br()),\r\n        match([\r\n          inPreBlock(true),\r\n          shouldPutBrInPre(false),\r\n          hasShiftKey\r\n        ], newLineAction.br()),\r\n        match([\r\n          inPreBlock(true),\r\n          shouldPutBrInPre(false)\r\n        ], newLineAction.block()),\r\n        match([\r\n          inPreBlock(true),\r\n          shouldPutBrInPre(true),\r\n          hasShiftKey\r\n        ], newLineAction.block()),\r\n        match([\r\n          inPreBlock(true),\r\n          shouldPutBrInPre(true)\r\n        ], newLineAction.br()),\r\n        match([\r\n          inListBlock(true),\r\n          hasShiftKey\r\n        ], newLineAction.br()),\r\n        match([inListBlock(true)], newLineAction.block()),\r\n        match([inBrContext], newLineAction.br()),\r\n        match([hasShiftKey], newLineAction.br()),\r\n        match([canInsertIntoEditableRoot], newLineAction.block()),\r\n        match([isInRootWithEmptyOrCEF], newLineAction.block())\r\n      ], [\r\n        editor,\r\n        !!(evt && evt.shiftKey)\r\n      ]).getOr(newLineAction.none());\r\n    };\r\n\r\n    const insertBreak = (breakType, editor, evt) => {\r\n      if (!editor.selection.isCollapsed()) {\r\n        execEditorDeleteCommand(editor);\r\n      }\r\n      if (isNonNullable(evt)) {\r\n        const event = fireBeforeInputEvent(editor, breakType.fakeEventName);\r\n        if (event.isDefaultPrevented()) {\r\n          return;\r\n        }\r\n      }\r\n      breakType.insert(editor, evt);\r\n      if (isNonNullable(evt)) {\r\n        fireInputEvent(editor, breakType.fakeEventName);\r\n      }\r\n    };\r\n    const insert$1 = (editor, evt) => {\r\n      const br = () => insertBreak(linebreak, editor, evt);\r\n      const block = () => insertBreak(blockbreak, editor, evt);\r\n      const logicalAction = getAction(editor, evt);\r\n      switch (getNewlineBehavior(editor)) {\r\n      case 'linebreak':\r\n        logicalAction.fold(br, br, noop);\r\n        break;\r\n      case 'block':\r\n        logicalAction.fold(block, block, noop);\r\n        break;\r\n      case 'invert':\r\n        logicalAction.fold(block, br, noop);\r\n        break;\r\n      default:\r\n        logicalAction.fold(br, block, noop);\r\n        break;\r\n      }\r\n    };\r\n\r\n    const platform$1 = detect$2();\r\n    const isIOSSafari = platform$1.os.isiOS() && platform$1.browser.isSafari();\r\n    const handleEnterKeyEvent = (editor, event) => {\r\n      if (event.isDefaultPrevented()) {\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n      endTypingLevelIgnoreLocks(editor.undoManager);\r\n      editor.undoManager.transact(() => {\r\n        insert$1(editor, event);\r\n      });\r\n    };\r\n    const isCaretAfterKoreanCharacter = rng => {\r\n      if (!rng.collapsed) {\r\n        return false;\r\n      }\r\n      const startContainer = rng.startContainer;\r\n      if (isText$a(startContainer)) {\r\n        const koreanCharRegex = /^[\\uAC00-\\uD7AF\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uD7B0-\\uD7FF]$/;\r\n        const char = startContainer.data.charAt(rng.startOffset - 1);\r\n        return koreanCharRegex.test(char);\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const setup$i = editor => {\r\n      let iOSSafariKeydownBookmark = Optional.none();\r\n      const iOSSafariKeydownOverride = editor => {\r\n        iOSSafariKeydownBookmark = Optional.some(editor.selection.getBookmark());\r\n        editor.undoManager.add();\r\n      };\r\n      const iOSSafariKeyupOverride = (editor, event) => {\r\n        editor.undoManager.undo();\r\n        iOSSafariKeydownBookmark.fold(noop, b => editor.selection.moveToBookmark(b));\r\n        handleEnterKeyEvent(editor, event);\r\n        iOSSafariKeydownBookmark = Optional.none();\r\n      };\r\n      editor.on('keydown', event => {\r\n        if (event.keyCode === VK.ENTER) {\r\n          if (isIOSSafari && isCaretAfterKoreanCharacter(editor.selection.getRng())) {\r\n            iOSSafariKeydownOverride(editor);\r\n          } else {\r\n            handleEnterKeyEvent(editor, event);\r\n          }\r\n        }\r\n      });\r\n      editor.on('keyup', event => {\r\n        if (event.keyCode === VK.ENTER) {\r\n          iOSSafariKeydownBookmark.each(() => iOSSafariKeyupOverride(editor, event));\r\n        }\r\n      });\r\n    };\r\n\r\n    const executeKeydownOverride$2 = (editor, caret, evt) => {\r\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\r\n      execute([\r\n        {\r\n          keyCode: VK.END,\r\n          action: action(moveToLineEndPoint$1, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.HOME,\r\n          action: action(moveToLineEndPoint$1, editor, false)\r\n        },\r\n        ...!isMac ? [\r\n          {\r\n            keyCode: VK.HOME,\r\n            action: action(selectToEndPoint, editor, false),\r\n            ctrlKey: true,\r\n            shiftKey: true\r\n          },\r\n          {\r\n            keyCode: VK.END,\r\n            action: action(selectToEndPoint, editor, true),\r\n            ctrlKey: true,\r\n            shiftKey: true\r\n          }\r\n        ] : [],\r\n        {\r\n          keyCode: VK.END,\r\n          action: action(moveToLineEndPoint, editor, true)\r\n        },\r\n        {\r\n          keyCode: VK.HOME,\r\n          action: action(moveToLineEndPoint, editor, false)\r\n        },\r\n        {\r\n          keyCode: VK.END,\r\n          action: action(moveToLineEndPoint$2, editor, true, caret)\r\n        },\r\n        {\r\n          keyCode: VK.HOME,\r\n          action: action(moveToLineEndPoint$2, editor, false, caret)\r\n        }\r\n      ], evt).each(_ => {\r\n        evt.preventDefault();\r\n      });\r\n    };\r\n    const setup$h = (editor, caret) => {\r\n      editor.on('keydown', evt => {\r\n        if (!evt.isDefaultPrevented()) {\r\n          executeKeydownOverride$2(editor, caret, evt);\r\n        }\r\n      });\r\n    };\r\n\r\n    const setup$g = editor => {\r\n      editor.on('input', e => {\r\n        if (!e.isComposing) {\r\n          normalizeNbspsInEditor(editor);\r\n        }\r\n      });\r\n    };\r\n\r\n    const platform = detect$2();\r\n    const executeKeyupAction = (editor, caret, evt) => {\r\n      execute([\r\n        {\r\n          keyCode: VK.PAGE_UP,\r\n          action: action(moveToLineEndPoint$2, editor, false, caret)\r\n        },\r\n        {\r\n          keyCode: VK.PAGE_DOWN,\r\n          action: action(moveToLineEndPoint$2, editor, true, caret)\r\n        }\r\n      ], evt);\r\n    };\r\n    const stopImmediatePropagation = e => e.stopImmediatePropagation();\r\n    const isPageUpDown = evt => evt.keyCode === VK.PAGE_UP || evt.keyCode === VK.PAGE_DOWN;\r\n    const setNodeChangeBlocker = (blocked, editor, block) => {\r\n      if (block && !blocked.get()) {\r\n        editor.on('NodeChange', stopImmediatePropagation, true);\r\n      } else if (!block && blocked.get()) {\r\n        editor.off('NodeChange', stopImmediatePropagation);\r\n      }\r\n      blocked.set(block);\r\n    };\r\n    const setup$f = (editor, caret) => {\r\n      if (platform.os.isMacOS()) {\r\n        return;\r\n      }\r\n      const blocked = Cell(false);\r\n      editor.on('keydown', evt => {\r\n        if (isPageUpDown(evt)) {\r\n          setNodeChangeBlocker(blocked, editor, true);\r\n        }\r\n      });\r\n      editor.on('keyup', evt => {\r\n        if (!evt.isDefaultPrevented()) {\r\n          executeKeyupAction(editor, caret, evt);\r\n        }\r\n        if (isPageUpDown(evt) && blocked.get()) {\r\n          setNodeChangeBlocker(blocked, editor, false);\r\n          editor.nodeChanged();\r\n        }\r\n      });\r\n    };\r\n\r\n    const setup$e = editor => {\r\n      editor.on('beforeinput', e => {\r\n        if (!editor.selection.isEditable() || exists(e.getTargetRanges(), rng => !isEditableRange(editor.dom, rng))) {\r\n          e.preventDefault();\r\n        }\r\n      });\r\n    };\r\n\r\n    const insertTextAtPosition = (text, pos) => {\r\n      const container = pos.container();\r\n      const offset = pos.offset();\r\n      if (isText$a(container)) {\r\n        container.insertData(offset, text);\r\n        return Optional.some(CaretPosition(container, offset + text.length));\r\n      } else {\r\n        return getElementFromPosition(pos).map(elm => {\r\n          const textNode = SugarElement.fromText(text);\r\n          if (pos.isAtEnd()) {\r\n            after$4(elm, textNode);\r\n          } else {\r\n            before$3(elm, textNode);\r\n          }\r\n          return CaretPosition(textNode.dom, text.length);\r\n        });\r\n      }\r\n    };\r\n    const insertNbspAtPosition = curry(insertTextAtPosition, nbsp);\r\n    const insertSpaceAtPosition = curry(insertTextAtPosition, ' ');\r\n\r\n    const insertSpaceOrNbspAtPosition = (root, pos, schema) => needsToHaveNbsp(root, pos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\r\n    const locationToCaretPosition = root => location => location.fold(element => prevPosition(root.dom, CaretPosition.before(element)), element => firstPositionIn(element), element => lastPositionIn(element), element => nextPosition(root.dom, CaretPosition.after(element)));\r\n    const insertInlineBoundarySpaceOrNbsp = (root, pos, schema) => checkPos => needsToHaveNbsp(root, checkPos, schema) ? insertNbspAtPosition(pos) : insertSpaceAtPosition(pos);\r\n    const setSelection = editor => pos => {\r\n      editor.selection.setRng(pos.toRange());\r\n      editor.nodeChanged();\r\n    };\r\n    const isInsideSummary = (domUtils, node) => domUtils.isEditable(domUtils.getParent(node, 'summary'));\r\n    const insertSpaceOrNbspAtSelection = editor => {\r\n      const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n      const root = SugarElement.fromDom(editor.getBody());\r\n      if (editor.selection.isCollapsed()) {\r\n        const isInlineTarget$1 = curry(isInlineTarget, editor);\r\n        const caretPosition = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n        return readLocation(isInlineTarget$1, editor.getBody(), caretPosition).bind(locationToCaretPosition(root)).map(checkPos => () => insertInlineBoundarySpaceOrNbsp(root, pos, editor.schema)(checkPos).each(setSelection(editor)));\r\n      } else {\r\n        return Optional.none();\r\n      }\r\n    };\r\n    const insertSpaceInSummaryAtSelectionOnFirefox = editor => {\r\n      const insertSpaceThunk = () => {\r\n        const root = SugarElement.fromDom(editor.getBody());\r\n        if (!editor.selection.isCollapsed()) {\r\n          editor.getDoc().execCommand('Delete');\r\n        }\r\n        const pos = CaretPosition.fromRangeStart(editor.selection.getRng());\r\n        insertSpaceOrNbspAtPosition(root, pos, editor.schema).each(setSelection(editor));\r\n      };\r\n      return someIf(Env.browser.isFirefox() && editor.selection.isEditable() && isInsideSummary(editor.dom, editor.selection.getRng().startContainer), insertSpaceThunk);\r\n    };\r\n\r\n    const executeKeydownOverride$1 = (editor, evt) => {\r\n      executeWithDelayedAction([\r\n        {\r\n          keyCode: VK.SPACEBAR,\r\n          action: action(insertSpaceOrNbspAtSelection, editor)\r\n        },\r\n        {\r\n          keyCode: VK.SPACEBAR,\r\n          action: action(insertSpaceInSummaryAtSelectionOnFirefox, editor)\r\n        }\r\n      ], evt).each(applyAction => {\r\n        evt.preventDefault();\r\n        const event = fireBeforeInputEvent(editor, 'insertText', { data: ' ' });\r\n        if (!event.isDefaultPrevented()) {\r\n          applyAction();\r\n          fireInputEvent(editor, 'insertText', { data: ' ' });\r\n        }\r\n      });\r\n    };\r\n    const setup$d = editor => {\r\n      editor.on('keydown', evt => {\r\n        if (!evt.isDefaultPrevented()) {\r\n          executeKeydownOverride$1(editor, evt);\r\n        }\r\n      });\r\n    };\r\n\r\n    const tableTabNavigation = editor => {\r\n      if (hasTableTabNavigation(editor)) {\r\n        return [\r\n          {\r\n            keyCode: VK.TAB,\r\n            action: action(handleTab, editor, true)\r\n          },\r\n          {\r\n            keyCode: VK.TAB,\r\n            shiftKey: true,\r\n            action: action(handleTab, editor, false)\r\n          }\r\n        ];\r\n      } else {\r\n        return [];\r\n      }\r\n    };\r\n    const executeKeydownOverride = (editor, evt) => {\r\n      execute([...tableTabNavigation(editor)], evt).each(_ => {\r\n        evt.preventDefault();\r\n      });\r\n    };\r\n    const setup$c = editor => {\r\n      editor.on('keydown', evt => {\r\n        if (!evt.isDefaultPrevented()) {\r\n          executeKeydownOverride(editor, evt);\r\n        }\r\n      });\r\n    };\r\n\r\n    const setup$b = editor => {\r\n      editor.addShortcut('Meta+P', '', 'mcePrint');\r\n      setup$k(editor);\r\n      if (isRtc(editor)) {\r\n        return Cell(null);\r\n      } else {\r\n        const caret = setupSelectedState(editor);\r\n        setup$e(editor);\r\n        setup$m(editor);\r\n        setup$l(editor, caret);\r\n        setup$j(editor, caret);\r\n        setup$i(editor);\r\n        setup$d(editor);\r\n        setup$g(editor);\r\n        setup$c(editor);\r\n        setup$h(editor, caret);\r\n        setup$f(editor, caret);\r\n        return caret;\r\n      }\r\n    };\r\n\r\n    class NodeChange {\r\n      constructor(editor) {\r\n        this.lastPath = [];\r\n        this.editor = editor;\r\n        let lastRng;\r\n        const self = this;\r\n        if (!('onselectionchange' in editor.getDoc())) {\r\n          editor.on('NodeChange click mouseup keyup focus', e => {\r\n            const nativeRng = editor.selection.getRng();\r\n            const fakeRng = {\r\n              startContainer: nativeRng.startContainer,\r\n              startOffset: nativeRng.startOffset,\r\n              endContainer: nativeRng.endContainer,\r\n              endOffset: nativeRng.endOffset\r\n            };\r\n            if (e.type === 'nodechange' || !isEq$4(fakeRng, lastRng)) {\r\n              editor.dispatch('SelectionChange');\r\n            }\r\n            lastRng = fakeRng;\r\n          });\r\n        }\r\n        editor.on('contextmenu', () => {\r\n          editor.dispatch('SelectionChange');\r\n        });\r\n        editor.on('SelectionChange', () => {\r\n          const startElm = editor.selection.getStart(true);\r\n          if (!startElm) {\r\n            return;\r\n          }\r\n          if (hasAnyRanges(editor) && !self.isSameElementPath(startElm) && editor.dom.isChildOf(startElm, editor.getBody())) {\r\n            editor.nodeChanged({ selectionChange: true });\r\n          }\r\n        });\r\n        editor.on('mouseup', e => {\r\n          if (!e.isDefaultPrevented() && hasAnyRanges(editor)) {\r\n            if (editor.selection.getNode().nodeName === 'IMG') {\r\n              Delay.setEditorTimeout(editor, () => {\r\n                editor.nodeChanged();\r\n              });\r\n            } else {\r\n              editor.nodeChanged();\r\n            }\r\n          }\r\n        });\r\n      }\r\n      nodeChanged(args = {}) {\r\n        const selection = this.editor.selection;\r\n        let node;\r\n        if (this.editor.initialized && selection && !shouldDisableNodeChange(this.editor) && !this.editor.mode.isReadOnly()) {\r\n          const root = this.editor.getBody();\r\n          node = selection.getStart(true) || root;\r\n          if (node.ownerDocument !== this.editor.getDoc() || !this.editor.dom.isChildOf(node, root)) {\r\n            node = root;\r\n          }\r\n          const parents = [];\r\n          this.editor.dom.getParent(node, node => {\r\n            if (node === root) {\r\n              return true;\r\n            } else {\r\n              parents.push(node);\r\n              return false;\r\n            }\r\n          });\r\n          this.editor.dispatch('NodeChange', {\r\n            ...args,\r\n            element: node,\r\n            parents\r\n          });\r\n        }\r\n      }\r\n      isSameElementPath(startElm) {\r\n        let i;\r\n        const editor = this.editor;\r\n        const currentPath = reverse(editor.dom.getParents(startElm, always, editor.getBody()));\r\n        if (currentPath.length === this.lastPath.length) {\r\n          for (i = currentPath.length; i >= 0; i--) {\r\n            if (currentPath[i] !== this.lastPath[i]) {\r\n              break;\r\n            }\r\n          }\r\n          if (i === -1) {\r\n            this.lastPath = currentPath;\r\n            return true;\r\n          }\r\n        }\r\n        this.lastPath = currentPath;\r\n        return false;\r\n      }\r\n    }\r\n\r\n    const imageId = generate$1('image');\r\n    const getDragImage = transfer => {\r\n      const dt = transfer;\r\n      return Optional.from(dt[imageId]);\r\n    };\r\n    const setDragImage = (transfer, imageData) => {\r\n      const dt = transfer;\r\n      dt[imageId] = imageData;\r\n    };\r\n\r\n    const eventId = generate$1('event');\r\n    const getEvent = transfer => {\r\n      const dt = transfer;\r\n      return Optional.from(dt[eventId]);\r\n    };\r\n    const mkSetEventFn = type => transfer => {\r\n      const dt = transfer;\r\n      dt[eventId] = type;\r\n    };\r\n    const setEvent = (transfer, type) => mkSetEventFn(type)(transfer);\r\n    const setDragstartEvent = mkSetEventFn(0);\r\n    const setDropEvent = mkSetEventFn(2);\r\n    const setDragendEvent = mkSetEventFn(1);\r\n    const checkEvent = expectedType => transfer => {\r\n      const dt = transfer;\r\n      return Optional.from(dt[eventId]).exists(type => type === expectedType);\r\n    };\r\n    const isInDragStartEvent = checkEvent(0);\r\n\r\n    const createEmptyFileList = () => Object.freeze({\r\n      length: 0,\r\n      item: _ => null\r\n    });\r\n\r\n    const modeId = generate$1('mode');\r\n    const getMode = transfer => {\r\n      const dt = transfer;\r\n      return Optional.from(dt[modeId]);\r\n    };\r\n    const mkSetModeFn = mode => transfer => {\r\n      const dt = transfer;\r\n      dt[modeId] = mode;\r\n    };\r\n    const setMode$1 = (transfer, mode) => mkSetModeFn(mode)(transfer);\r\n    const setReadWriteMode = mkSetModeFn(0);\r\n    const setReadOnlyMode = mkSetModeFn(2);\r\n    const setProtectedMode = mkSetModeFn(1);\r\n    const checkMode = expectedMode => transfer => {\r\n      const dt = transfer;\r\n      return Optional.from(dt[modeId]).exists(mode => mode === expectedMode);\r\n    };\r\n    const isInReadWriteMode = checkMode(0);\r\n    const isInProtectedMode = checkMode(1);\r\n\r\n    const normalizeItems = (dataTransfer, itemsImpl) => ({\r\n      ...itemsImpl,\r\n      get length() {\r\n        return itemsImpl.length;\r\n      },\r\n      add: (data, type) => {\r\n        if (isInReadWriteMode(dataTransfer)) {\r\n          if (isString(data)) {\r\n            if (!isUndefined(type)) {\r\n              return itemsImpl.add(data, type);\r\n            }\r\n          } else {\r\n            return itemsImpl.add(data);\r\n          }\r\n        }\r\n        return null;\r\n      },\r\n      remove: idx => {\r\n        if (isInReadWriteMode(dataTransfer)) {\r\n          itemsImpl.remove(idx);\r\n        }\r\n      },\r\n      clear: () => {\r\n        if (isInReadWriteMode(dataTransfer)) {\r\n          itemsImpl.clear();\r\n        }\r\n      }\r\n    });\r\n\r\n    const validDropEffects = [\r\n      'none',\r\n      'copy',\r\n      'link',\r\n      'move'\r\n    ];\r\n    const validEffectAlloweds = [\r\n      'none',\r\n      'copy',\r\n      'copyLink',\r\n      'copyMove',\r\n      'link',\r\n      'linkMove',\r\n      'move',\r\n      'all',\r\n      'uninitialized'\r\n    ];\r\n    const createDataTransfer = () => {\r\n      const dataTransferImpl = new window.DataTransfer();\r\n      let dropEffect = 'move';\r\n      let effectAllowed = 'all';\r\n      const dataTransfer = {\r\n        get dropEffect() {\r\n          return dropEffect;\r\n        },\r\n        set dropEffect(effect) {\r\n          if (contains$2(validDropEffects, effect)) {\r\n            dropEffect = effect;\r\n          }\r\n        },\r\n        get effectAllowed() {\r\n          return effectAllowed;\r\n        },\r\n        set effectAllowed(allowed) {\r\n          if (isInDragStartEvent(dataTransfer) && contains$2(validEffectAlloweds, allowed)) {\r\n            effectAllowed = allowed;\r\n          }\r\n        },\r\n        get items() {\r\n          return normalizeItems(dataTransfer, dataTransferImpl.items);\r\n        },\r\n        get files() {\r\n          if (isInProtectedMode(dataTransfer)) {\r\n            return createEmptyFileList();\r\n          } else {\r\n            return dataTransferImpl.files;\r\n          }\r\n        },\r\n        get types() {\r\n          return dataTransferImpl.types;\r\n        },\r\n        setDragImage: (image, x, y) => {\r\n          if (isInReadWriteMode(dataTransfer)) {\r\n            setDragImage(dataTransfer, {\r\n              image,\r\n              x,\r\n              y\r\n            });\r\n            dataTransferImpl.setDragImage(image, x, y);\r\n          }\r\n        },\r\n        getData: format => {\r\n          if (isInProtectedMode(dataTransfer)) {\r\n            return '';\r\n          } else {\r\n            return dataTransferImpl.getData(format);\r\n          }\r\n        },\r\n        setData: (format, data) => {\r\n          if (isInReadWriteMode(dataTransfer)) {\r\n            dataTransferImpl.setData(format, data);\r\n          }\r\n        },\r\n        clearData: format => {\r\n          if (isInReadWriteMode(dataTransfer)) {\r\n            dataTransferImpl.clearData(format);\r\n          }\r\n        }\r\n      };\r\n      setReadWriteMode(dataTransfer);\r\n      return dataTransfer;\r\n    };\r\n    const cloneDataTransfer = original => {\r\n      const clone = createDataTransfer();\r\n      const originalMode = getMode(original);\r\n      setReadOnlyMode(original);\r\n      setDragstartEvent(clone);\r\n      clone.dropEffect = original.dropEffect;\r\n      clone.effectAllowed = original.effectAllowed;\r\n      getDragImage(original).each(imageData => clone.setDragImage(imageData.image, imageData.x, imageData.y));\r\n      each$e(original.types, type => {\r\n        if (type !== 'Files') {\r\n          clone.setData(type, original.getData(type));\r\n        }\r\n      });\r\n      each$e(original.files, file => clone.items.add(file));\r\n      getEvent(original).each(type => {\r\n        setEvent(clone, type);\r\n      });\r\n      originalMode.each(mode => {\r\n        setMode$1(original, mode);\r\n        setMode$1(clone, mode);\r\n      });\r\n      return clone;\r\n    };\r\n\r\n    const getHtmlData = dataTransfer => {\r\n      const html = dataTransfer.getData('text/html');\r\n      return html === '' ? Optional.none() : Optional.some(html);\r\n    };\r\n    const setHtmlData = (dataTransfer, html) => dataTransfer.setData('text/html', html);\r\n\r\n    const internalMimeType = 'x-tinymce/html';\r\n    const internalHtmlMime = constant(internalMimeType);\r\n    const internalMark = '<!-- ' + internalMimeType + ' -->';\r\n    const mark = html => internalMark + html;\r\n    const unmark = html => html.replace(internalMark, '');\r\n    const isMarked = html => html.indexOf(internalMark) !== -1;\r\n\r\n    const isPlainText = text => {\r\n      return !/<(?:\\/?(?!(?:div|p|br|span)>)\\w+|(?:(?!(?:span style=\"white-space:\\s?pre;?\">)|br\\s?\\/>))\\w+\\s[^>]+)>/i.test(text);\r\n    };\r\n    const openContainer = (rootTag, rootAttrs) => {\r\n      let tag = '<' + rootTag;\r\n      const attrs = mapToArray(rootAttrs, (value, key) => key + '=\"' + Entities.encodeAllRaw(value) + '\"');\r\n      if (attrs.length) {\r\n        tag += ' ' + attrs.join(' ');\r\n      }\r\n      return tag + '>';\r\n    };\r\n    const toBlockElements = (text, rootTag, rootAttrs) => {\r\n      const blocks = text.split(/\\n\\n/);\r\n      const tagOpen = openContainer(rootTag, rootAttrs);\r\n      const tagClose = '</' + rootTag + '>';\r\n      const paragraphs = map$3(blocks, p => {\r\n        return p.split(/\\n/).join('<br />');\r\n      });\r\n      const stitch = p => {\r\n        return tagOpen + p + tagClose;\r\n      };\r\n      return paragraphs.length === 1 ? paragraphs[0] : map$3(paragraphs, stitch).join('');\r\n    };\r\n\r\n    const pasteBinDefaultContent = '%MCEPASTEBIN%';\r\n    const create$6 = (editor, lastRngCell) => {\r\n      const {dom, selection} = editor;\r\n      const body = editor.getBody();\r\n      lastRngCell.set(selection.getRng());\r\n      const pasteBinElm = dom.add(editor.getBody(), 'div', {\r\n        'id': 'mcepastebin',\r\n        'class': 'mce-pastebin',\r\n        'contentEditable': true,\r\n        'data-mce-bogus': 'all',\r\n        'style': 'position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0'\r\n      }, pasteBinDefaultContent);\r\n      if (Env.browser.isFirefox()) {\r\n        dom.setStyle(pasteBinElm, 'left', dom.getStyle(body, 'direction', true) === 'rtl' ? 65535 : -65535);\r\n      }\r\n      dom.bind(pasteBinElm, 'beforedeactivate focusin focusout', e => {\r\n        e.stopPropagation();\r\n      });\r\n      pasteBinElm.focus();\r\n      selection.select(pasteBinElm, true);\r\n    };\r\n    const remove = (editor, lastRngCell) => {\r\n      const dom = editor.dom;\r\n      if (getEl(editor)) {\r\n        let pasteBinClone;\r\n        const lastRng = lastRngCell.get();\r\n        while (pasteBinClone = getEl(editor)) {\r\n          dom.remove(pasteBinClone);\r\n          dom.unbind(pasteBinClone);\r\n        }\r\n        if (lastRng) {\r\n          editor.selection.setRng(lastRng);\r\n        }\r\n      }\r\n      lastRngCell.set(null);\r\n    };\r\n    const getEl = editor => editor.dom.get('mcepastebin');\r\n    const isPasteBin = elm => isNonNullable(elm) && elm.id === 'mcepastebin';\r\n    const getHtml = editor => {\r\n      const dom = editor.dom;\r\n      const copyAndRemove = (toElm, fromElm) => {\r\n        toElm.appendChild(fromElm);\r\n        dom.remove(fromElm, true);\r\n      };\r\n      const [pasteBinElm, ...pasteBinClones] = filter$5(editor.getBody().childNodes, isPasteBin);\r\n      each$e(pasteBinClones, pasteBinClone => {\r\n        copyAndRemove(pasteBinElm, pasteBinClone);\r\n      });\r\n      const dirtyWrappers = dom.select('div[id=mcepastebin]', pasteBinElm);\r\n      for (let i = dirtyWrappers.length - 1; i >= 0; i--) {\r\n        const cleanWrapper = dom.create('div');\r\n        pasteBinElm.insertBefore(cleanWrapper, dirtyWrappers[i]);\r\n        copyAndRemove(cleanWrapper, dirtyWrappers[i]);\r\n      }\r\n      return pasteBinElm ? pasteBinElm.innerHTML : '';\r\n    };\r\n    const isDefaultPasteBinContent = content => content === pasteBinDefaultContent;\r\n    const PasteBin = editor => {\r\n      const lastRng = Cell(null);\r\n      return {\r\n        create: () => create$6(editor, lastRng),\r\n        remove: () => remove(editor, lastRng),\r\n        getEl: () => getEl(editor),\r\n        getHtml: () => getHtml(editor),\r\n        getLastRng: lastRng.get\r\n      };\r\n    };\r\n\r\n    const filter$1 = (content, items) => {\r\n      Tools.each(items, v => {\r\n        if (is$4(v, RegExp)) {\r\n          content = content.replace(v, '');\r\n        } else {\r\n          content = content.replace(v[0], v[1]);\r\n        }\r\n      });\r\n      return content;\r\n    };\r\n    const innerText = html => {\r\n      const schema = Schema();\r\n      const domParser = DomParser({}, schema);\r\n      let text = '';\r\n      const voidElements = schema.getVoidElements();\r\n      const ignoreElements = Tools.makeMap('script noscript style textarea video audio iframe object', ' ');\r\n      const blockElements = schema.getBlockElements();\r\n      const walk = node => {\r\n        const name = node.name, currentNode = node;\r\n        if (name === 'br') {\r\n          text += '\\n';\r\n          return;\r\n        }\r\n        if (name === 'wbr') {\r\n          return;\r\n        }\r\n        if (voidElements[name]) {\r\n          text += ' ';\r\n        }\r\n        if (ignoreElements[name]) {\r\n          text += ' ';\r\n          return;\r\n        }\r\n        if (node.type === 3) {\r\n          text += node.value;\r\n        }\r\n        if (!(node.name in schema.getVoidElements())) {\r\n          let currentNode = node.firstChild;\r\n          if (currentNode) {\r\n            do {\r\n              walk(currentNode);\r\n            } while (currentNode = currentNode.next);\r\n          }\r\n        }\r\n        if (blockElements[name] && currentNode.next) {\r\n          text += '\\n';\r\n          if (name === 'p') {\r\n            text += '\\n';\r\n          }\r\n        }\r\n      };\r\n      html = filter$1(html, [/<!\\[[^\\]]+\\]>/g]);\r\n      walk(domParser.parse(html));\r\n      return text;\r\n    };\r\n    const trimHtml = html => {\r\n      const trimSpaces = (all, s1, s2) => {\r\n        if (!s1 && !s2) {\r\n          return ' ';\r\n        }\r\n        return nbsp;\r\n      };\r\n      html = filter$1(html, [\r\n        /^[\\s\\S]*<body[^>]*>\\s*|\\s*<\\/body[^>]*>[\\s\\S]*$/ig,\r\n        /<!--StartFragment-->|<!--EndFragment-->/g,\r\n        [\r\n          /( ?)<span class=\"Apple-converted-space\">\\u00a0<\\/span>( ?)/g,\r\n          trimSpaces\r\n        ],\r\n        /<br class=\"Apple-interchange-newline\">/g,\r\n        /<br>$/i\r\n      ]);\r\n      return html;\r\n    };\r\n    const createIdGenerator = prefix => {\r\n      let count = 0;\r\n      return () => {\r\n        return prefix + count++;\r\n      };\r\n    };\r\n    const getImageMimeType = ext => {\r\n      const lowerExt = ext.toLowerCase();\r\n      const mimeOverrides = {\r\n        jpg: 'jpeg',\r\n        jpe: 'jpeg',\r\n        jfi: 'jpeg',\r\n        jif: 'jpeg',\r\n        jfif: 'jpeg',\r\n        pjpeg: 'jpeg',\r\n        pjp: 'jpeg',\r\n        svg: 'svg+xml'\r\n      };\r\n      return Tools.hasOwn(mimeOverrides, lowerExt) ? 'image/' + mimeOverrides[lowerExt] : 'image/' + lowerExt;\r\n    };\r\n\r\n    const preProcess = (editor, html) => {\r\n      const parser = DomParser({\r\n        sanitize: shouldSanitizeXss(editor),\r\n        sandbox_iframes: shouldSandboxIframes(editor)\r\n      }, editor.schema);\r\n      parser.addNodeFilter('meta', nodes => {\r\n        Tools.each(nodes, node => {\r\n          node.remove();\r\n        });\r\n      });\r\n      const fragment = parser.parse(html, {\r\n        forced_root_block: false,\r\n        isRootContent: true\r\n      });\r\n      return HtmlSerializer({ validate: true }, editor.schema).serialize(fragment);\r\n    };\r\n    const processResult = (content, cancelled) => ({\r\n      content,\r\n      cancelled\r\n    });\r\n    const postProcessFilter = (editor, html, internal) => {\r\n      const tempBody = editor.dom.create('div', { style: 'display:none' }, html);\r\n      const postProcessArgs = firePastePostProcess(editor, tempBody, internal);\r\n      return processResult(postProcessArgs.node.innerHTML, postProcessArgs.isDefaultPrevented());\r\n    };\r\n    const filterContent = (editor, content, internal) => {\r\n      const preProcessArgs = firePastePreProcess(editor, content, internal);\r\n      const filteredContent = preProcess(editor, preProcessArgs.content);\r\n      if (editor.hasEventListeners('PastePostProcess') && !preProcessArgs.isDefaultPrevented()) {\r\n        return postProcessFilter(editor, filteredContent, internal);\r\n      } else {\r\n        return processResult(filteredContent, preProcessArgs.isDefaultPrevented());\r\n      }\r\n    };\r\n    const process = (editor, html, internal) => {\r\n      return filterContent(editor, html, internal);\r\n    };\r\n\r\n    const pasteHtml$1 = (editor, html) => {\r\n      editor.insertContent(html, {\r\n        merge: shouldPasteMergeFormats(editor),\r\n        paste: true\r\n      });\r\n      return true;\r\n    };\r\n    const isAbsoluteUrl = url => /^https?:\\/\\/[\\w\\-\\/+=.,!;:&%@^~(){}?#]+$/i.test(url);\r\n    const isImageUrl = (editor, url) => {\r\n      return isAbsoluteUrl(url) && exists(getAllowedImageFileTypes(editor), type => endsWith(url.toLowerCase(), `.${ type.toLowerCase() }`));\r\n    };\r\n    const createImage = (editor, url, pasteHtmlFn) => {\r\n      editor.undoManager.extra(() => {\r\n        pasteHtmlFn(editor, url);\r\n      }, () => {\r\n        editor.insertContent('<img src=\"' + url + '\">');\r\n      });\r\n      return true;\r\n    };\r\n    const createLink = (editor, url, pasteHtmlFn) => {\r\n      editor.undoManager.extra(() => {\r\n        pasteHtmlFn(editor, url);\r\n      }, () => {\r\n        editor.execCommand('mceInsertLink', false, url);\r\n      });\r\n      return true;\r\n    };\r\n    const linkSelection = (editor, html, pasteHtmlFn) => !editor.selection.isCollapsed() && isAbsoluteUrl(html) ? createLink(editor, html, pasteHtmlFn) : false;\r\n    const insertImage = (editor, html, pasteHtmlFn) => isImageUrl(editor, html) ? createImage(editor, html, pasteHtmlFn) : false;\r\n    const smartInsertContent = (editor, html) => {\r\n      Tools.each([\r\n        linkSelection,\r\n        insertImage,\r\n        pasteHtml$1\r\n      ], action => {\r\n        return !action(editor, html, pasteHtml$1);\r\n      });\r\n    };\r\n    const insertContent = (editor, html, pasteAsText) => {\r\n      if (pasteAsText || !isSmartPasteEnabled(editor)) {\r\n        pasteHtml$1(editor, html);\r\n      } else {\r\n        smartInsertContent(editor, html);\r\n      }\r\n    };\r\n\r\n    const uniqueId = createIdGenerator('mceclip');\r\n    const createPasteDataTransfer = html => {\r\n      const dataTransfer = createDataTransfer();\r\n      setHtmlData(dataTransfer, html);\r\n      setReadOnlyMode(dataTransfer);\r\n      return dataTransfer;\r\n    };\r\n    const doPaste = (editor, content, internal, pasteAsText, shouldSimulateInputEvent) => {\r\n      const res = process(editor, content, internal);\r\n      if (!res.cancelled) {\r\n        const content = res.content;\r\n        const doPasteAction = () => insertContent(editor, content, pasteAsText);\r\n        if (shouldSimulateInputEvent) {\r\n          const args = fireBeforeInputEvent(editor, 'insertFromPaste', { dataTransfer: createPasteDataTransfer(content) });\r\n          if (!args.isDefaultPrevented()) {\r\n            doPasteAction();\r\n            fireInputEvent(editor, 'insertFromPaste');\r\n          }\r\n        } else {\r\n          doPasteAction();\r\n        }\r\n      }\r\n    };\r\n    const pasteHtml = (editor, html, internalFlag, shouldSimulateInputEvent) => {\r\n      const internal = internalFlag ? internalFlag : isMarked(html);\r\n      doPaste(editor, unmark(html), internal, false, shouldSimulateInputEvent);\r\n    };\r\n    const pasteText = (editor, text, shouldSimulateInputEvent) => {\r\n      const encodedText = editor.dom.encode(text).replace(/\\r\\n/g, '\\n');\r\n      const normalizedText = normalize$4(encodedText, getPasteTabSpaces(editor));\r\n      const html = toBlockElements(normalizedText, getForcedRootBlock(editor), getForcedRootBlockAttrs(editor));\r\n      doPaste(editor, html, false, true, shouldSimulateInputEvent);\r\n    };\r\n    const getDataTransferItems = dataTransfer => {\r\n      const items = {};\r\n      if (dataTransfer && dataTransfer.types) {\r\n        for (let i = 0; i < dataTransfer.types.length; i++) {\r\n          const contentType = dataTransfer.types[i];\r\n          try {\r\n            items[contentType] = dataTransfer.getData(contentType);\r\n          } catch (ex) {\r\n            items[contentType] = '';\r\n          }\r\n        }\r\n      }\r\n      return items;\r\n    };\r\n    const hasContentType = (clipboardContent, mimeType) => mimeType in clipboardContent && clipboardContent[mimeType].length > 0;\r\n    const hasHtmlOrText = content => hasContentType(content, 'text/html') || hasContentType(content, 'text/plain');\r\n    const extractFilename = (editor, str) => {\r\n      const m = str.match(/([\\s\\S]+?)(?:\\.[a-z0-9.]+)$/i);\r\n      return isNonNullable(m) ? editor.dom.encode(m[1]) : undefined;\r\n    };\r\n    const createBlobInfo = (editor, blobCache, file, base64) => {\r\n      const id = uniqueId();\r\n      const useFileName = shouldReuseFileName(editor) && isNonNullable(file.name);\r\n      const name = useFileName ? extractFilename(editor, file.name) : id;\r\n      const filename = useFileName ? file.name : undefined;\r\n      const blobInfo = blobCache.create(id, file, base64, name, filename);\r\n      blobCache.add(blobInfo);\r\n      return blobInfo;\r\n    };\r\n    const pasteImage = (editor, imageItem) => {\r\n      parseDataUri(imageItem.uri).each(({data, type, base64Encoded}) => {\r\n        const base64 = base64Encoded ? data : btoa(data);\r\n        const file = imageItem.file;\r\n        const blobCache = editor.editorUpload.blobCache;\r\n        const existingBlobInfo = blobCache.getByData(base64, type);\r\n        const blobInfo = existingBlobInfo !== null && existingBlobInfo !== void 0 ? existingBlobInfo : createBlobInfo(editor, blobCache, file, base64);\r\n        pasteHtml(editor, `<img src=\"${ blobInfo.blobUri() }\">`, false, true);\r\n      });\r\n    };\r\n    const isClipboardEvent = event => event.type === 'paste';\r\n    const readFilesAsDataUris = items => Promise.all(map$3(items, file => {\r\n      return blobToDataUri(file).then(uri => ({\r\n        file,\r\n        uri\r\n      }));\r\n    }));\r\n    const isImage = editor => {\r\n      const allowedExtensions = getAllowedImageFileTypes(editor);\r\n      return file => startsWith(file.type, 'image/') && exists(allowedExtensions, extension => {\r\n        return getImageMimeType(extension) === file.type;\r\n      });\r\n    };\r\n    const getImagesFromDataTransfer = (editor, dataTransfer) => {\r\n      const items = dataTransfer.items ? bind$3(from(dataTransfer.items), item => {\r\n        return item.kind === 'file' ? [item.getAsFile()] : [];\r\n      }) : [];\r\n      const files = dataTransfer.files ? from(dataTransfer.files) : [];\r\n      return filter$5(items.length > 0 ? items : files, isImage(editor));\r\n    };\r\n    const pasteImageData = (editor, e, rng) => {\r\n      const dataTransfer = isClipboardEvent(e) ? e.clipboardData : e.dataTransfer;\r\n      if (shouldPasteDataImages(editor) && dataTransfer) {\r\n        const images = getImagesFromDataTransfer(editor, dataTransfer);\r\n        if (images.length > 0) {\r\n          e.preventDefault();\r\n          readFilesAsDataUris(images).then(fileResults => {\r\n            if (rng) {\r\n              editor.selection.setRng(rng);\r\n            }\r\n            each$e(fileResults, result => {\r\n              pasteImage(editor, result);\r\n            });\r\n          });\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    const isBrokenAndroidClipboardEvent = e => {\r\n      var _a, _b;\r\n      return Env.os.isAndroid() && ((_b = (_a = e.clipboardData) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) === 0;\r\n    };\r\n    const isKeyboardPasteEvent = e => VK.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45;\r\n    const insertClipboardContent = (editor, clipboardContent, html, plainTextMode, shouldSimulateInputEvent) => {\r\n      let content = trimHtml(html);\r\n      const isInternal = hasContentType(clipboardContent, internalHtmlMime()) || isMarked(html);\r\n      const isPlainTextHtml = !isInternal && isPlainText(content);\r\n      const isAbsoluteUrl$1 = isAbsoluteUrl(content);\r\n      if (isDefaultPasteBinContent(content) || !content.length || isPlainTextHtml && !isAbsoluteUrl$1) {\r\n        plainTextMode = true;\r\n      }\r\n      if (plainTextMode || isAbsoluteUrl$1) {\r\n        if (hasContentType(clipboardContent, 'text/plain') && isPlainTextHtml) {\r\n          content = clipboardContent['text/plain'];\r\n        } else {\r\n          content = innerText(content);\r\n        }\r\n      }\r\n      if (isDefaultPasteBinContent(content)) {\r\n        return;\r\n      }\r\n      if (plainTextMode) {\r\n        pasteText(editor, content, shouldSimulateInputEvent);\r\n      } else {\r\n        pasteHtml(editor, content, isInternal, shouldSimulateInputEvent);\r\n      }\r\n    };\r\n    const registerEventHandlers = (editor, pasteBin, pasteFormat) => {\r\n      let keyboardPastePlainTextState;\r\n      const getLastRng = () => pasteBin.getLastRng() || editor.selection.getRng();\r\n      editor.on('keydown', e => {\r\n        if (isKeyboardPasteEvent(e) && !e.isDefaultPrevented()) {\r\n          keyboardPastePlainTextState = e.shiftKey && e.keyCode === 86;\r\n        }\r\n      });\r\n      editor.on('paste', e => {\r\n        if (e.isDefaultPrevented() || isBrokenAndroidClipboardEvent(e)) {\r\n          return;\r\n        }\r\n        const plainTextMode = pasteFormat.get() === 'text' || keyboardPastePlainTextState;\r\n        keyboardPastePlainTextState = false;\r\n        const clipboardContent = getDataTransferItems(e.clipboardData);\r\n        if (!hasHtmlOrText(clipboardContent) && pasteImageData(editor, e, getLastRng())) {\r\n          return;\r\n        }\r\n        if (hasContentType(clipboardContent, 'text/html')) {\r\n          e.preventDefault();\r\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/html'], plainTextMode, true);\r\n        } else if (hasContentType(clipboardContent, 'text/plain') && hasContentType(clipboardContent, 'text/uri-list')) {\r\n          e.preventDefault();\r\n          insertClipboardContent(editor, clipboardContent, clipboardContent['text/plain'], plainTextMode, true);\r\n        } else {\r\n          pasteBin.create();\r\n          Delay.setEditorTimeout(editor, () => {\r\n            const html = pasteBin.getHtml();\r\n            pasteBin.remove();\r\n            insertClipboardContent(editor, clipboardContent, html, plainTextMode, false);\r\n          }, 0);\r\n        }\r\n      });\r\n    };\r\n    const registerDataImageFilter = editor => {\r\n      const isWebKitFakeUrl = src => startsWith(src, 'webkit-fake-url');\r\n      const isDataUri = src => startsWith(src, 'data:');\r\n      const isPasteInsert = args => {\r\n        var _a;\r\n        return ((_a = args.data) === null || _a === void 0 ? void 0 : _a.paste) === true;\r\n      };\r\n      editor.parser.addNodeFilter('img', (nodes, name, args) => {\r\n        if (!shouldPasteDataImages(editor) && isPasteInsert(args)) {\r\n          for (const node of nodes) {\r\n            const src = node.attr('src');\r\n            if (isString(src) && !node.attr('data-mce-object') && src !== Env.transparentSrc) {\r\n              if (isWebKitFakeUrl(src)) {\r\n                node.remove();\r\n              } else if (!shouldAllowHtmlDataUrls(editor) && isDataUri(src)) {\r\n                node.remove();\r\n              }\r\n            }\r\n          }\r\n        }\r\n      });\r\n    };\r\n    const registerEventsAndFilters = (editor, pasteBin, pasteFormat) => {\r\n      registerEventHandlers(editor, pasteBin, pasteFormat);\r\n      registerDataImageFilter(editor);\r\n    };\r\n\r\n    const togglePlainTextPaste = (editor, pasteFormat) => {\r\n      if (pasteFormat.get() === 'text') {\r\n        pasteFormat.set('html');\r\n        firePastePlainTextToggle(editor, false);\r\n      } else {\r\n        pasteFormat.set('text');\r\n        firePastePlainTextToggle(editor, true);\r\n      }\r\n      editor.focus();\r\n    };\r\n    const register$1 = (editor, pasteFormat) => {\r\n      editor.addCommand('mceTogglePlainTextPaste', () => {\r\n        togglePlainTextPaste(editor, pasteFormat);\r\n      });\r\n      editor.addCommand('mceInsertClipboardContent', (ui, value) => {\r\n        if (value.html) {\r\n          pasteHtml(editor, value.html, value.internal, false);\r\n        }\r\n        if (value.text) {\r\n          pasteText(editor, value.text, false);\r\n        }\r\n      });\r\n    };\r\n\r\n    const setHtml5Clipboard = (clipboardData, html, text) => {\r\n      if (clipboardData) {\r\n        try {\r\n          clipboardData.clearData();\r\n          clipboardData.setData('text/html', html);\r\n          clipboardData.setData('text/plain', text);\r\n          clipboardData.setData(internalHtmlMime(), html);\r\n          return true;\r\n        } catch (e) {\r\n          return false;\r\n        }\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const setClipboardData = (evt, data, fallback, done) => {\r\n      if (setHtml5Clipboard(evt.clipboardData, data.html, data.text)) {\r\n        evt.preventDefault();\r\n        done();\r\n      } else {\r\n        fallback(data.html, done);\r\n      }\r\n    };\r\n    const fallback = editor => (html, done) => {\r\n      const {dom, selection} = editor;\r\n      const outer = dom.create('div', {\r\n        'contenteditable': 'false',\r\n        'data-mce-bogus': 'all'\r\n      });\r\n      const inner = dom.create('div', { contenteditable: 'true' }, html);\r\n      dom.setStyles(outer, {\r\n        position: 'fixed',\r\n        top: '0',\r\n        left: '-3000px',\r\n        width: '1000px',\r\n        overflow: 'hidden'\r\n      });\r\n      outer.appendChild(inner);\r\n      dom.add(editor.getBody(), outer);\r\n      const range = selection.getRng();\r\n      inner.focus();\r\n      const offscreenRange = dom.createRng();\r\n      offscreenRange.selectNodeContents(inner);\r\n      selection.setRng(offscreenRange);\r\n      Delay.setEditorTimeout(editor, () => {\r\n        selection.setRng(range);\r\n        dom.remove(outer);\r\n        done();\r\n      }, 0);\r\n    };\r\n    const getData = editor => ({\r\n      html: mark(editor.selection.getContent({ contextual: true })),\r\n      text: editor.selection.getContent({ format: 'text' })\r\n    });\r\n    const isTableSelection = editor => !!editor.dom.getParent(editor.selection.getStart(), 'td[data-mce-selected],th[data-mce-selected]', editor.getBody());\r\n    const hasSelectedContent = editor => !editor.selection.isCollapsed() || isTableSelection(editor);\r\n    const cut = editor => evt => {\r\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor) && editor.selection.isEditable()) {\r\n        setClipboardData(evt, getData(editor), fallback(editor), () => {\r\n          if (Env.browser.isChromium() || Env.browser.isFirefox()) {\r\n            const rng = editor.selection.getRng();\r\n            Delay.setEditorTimeout(editor, () => {\r\n              editor.selection.setRng(rng);\r\n              editor.execCommand('Delete');\r\n            }, 0);\r\n          } else {\r\n            editor.execCommand('Delete');\r\n          }\r\n        });\r\n      }\r\n    };\r\n    const copy = editor => evt => {\r\n      if (!evt.isDefaultPrevented() && hasSelectedContent(editor)) {\r\n        setClipboardData(evt, getData(editor), fallback(editor), noop);\r\n      }\r\n    };\r\n    const register = editor => {\r\n      editor.on('cut', cut(editor));\r\n      editor.on('copy', copy(editor));\r\n    };\r\n\r\n    const getCaretRangeFromEvent = (editor, e) => {\r\n      var _a, _b;\r\n      return RangeUtils.getCaretRangeFromPoint((_a = e.clientX) !== null && _a !== void 0 ? _a : 0, (_b = e.clientY) !== null && _b !== void 0 ? _b : 0, editor.getDoc());\r\n    };\r\n    const isPlainTextFileUrl = content => {\r\n      const plainTextContent = content['text/plain'];\r\n      return plainTextContent ? plainTextContent.indexOf('file://') === 0 : false;\r\n    };\r\n    const setFocusedRange = (editor, rng) => {\r\n      editor.focus();\r\n      if (rng) {\r\n        editor.selection.setRng(rng);\r\n      }\r\n    };\r\n    const hasImage = dataTransfer => exists(dataTransfer.files, file => /^image\\//.test(file.type));\r\n    const needsCustomInternalDrop = (dom, schema, target, dropContent) => {\r\n      const parentTransparent = dom.getParent(target, node => isTransparentBlock(schema, node));\r\n      const inSummary = !isNull(dom.getParent(target, 'summary'));\r\n      if (inSummary) {\r\n        return true;\r\n      } else if (parentTransparent && has$2(dropContent, 'text/html')) {\r\n        const fragment = new DOMParser().parseFromString(dropContent['text/html'], 'text/html').body;\r\n        return !isNull(fragment.querySelector(parentTransparent.nodeName.toLowerCase()));\r\n      } else {\r\n        return false;\r\n      }\r\n    };\r\n    const setupSummaryDeleteByDragFix = editor => {\r\n      editor.on('input', e => {\r\n        const hasNoSummary = el => isNull(el.querySelector('summary'));\r\n        if (e.inputType === 'deleteByDrag') {\r\n          const brokenDetailElements = filter$5(editor.dom.select('details'), hasNoSummary);\r\n          each$e(brokenDetailElements, details => {\r\n            if (isBr$6(details.firstChild)) {\r\n              details.firstChild.remove();\r\n            }\r\n            const summary = editor.dom.create('summary');\r\n            summary.appendChild(createPaddingBr().dom);\r\n            details.prepend(summary);\r\n          });\r\n        }\r\n      });\r\n    };\r\n    const setup$a = (editor, draggingInternallyState) => {\r\n      if (shouldPasteBlockDrop(editor)) {\r\n        editor.on('dragend dragover draggesture dragdrop drop drag', e => {\r\n          e.preventDefault();\r\n          e.stopPropagation();\r\n        });\r\n      }\r\n      if (!shouldPasteDataImages(editor)) {\r\n        editor.on('drop', e => {\r\n          const dataTransfer = e.dataTransfer;\r\n          if (dataTransfer && hasImage(dataTransfer)) {\r\n            e.preventDefault();\r\n          }\r\n        });\r\n      }\r\n      editor.on('drop', e => {\r\n        if (e.isDefaultPrevented()) {\r\n          return;\r\n        }\r\n        const rng = getCaretRangeFromEvent(editor, e);\r\n        if (isNullable(rng)) {\r\n          return;\r\n        }\r\n        const dropContent = getDataTransferItems(e.dataTransfer);\r\n        const internal = hasContentType(dropContent, internalHtmlMime());\r\n        if ((!hasHtmlOrText(dropContent) || isPlainTextFileUrl(dropContent)) && pasteImageData(editor, e, rng)) {\r\n          return;\r\n        }\r\n        const internalContent = dropContent[internalHtmlMime()];\r\n        const content = internalContent || dropContent['text/html'] || dropContent['text/plain'];\r\n        const needsInternalDrop = needsCustomInternalDrop(editor.dom, editor.schema, rng.startContainer, dropContent);\r\n        const isInternalDrop = draggingInternallyState.get();\r\n        if (isInternalDrop && !needsInternalDrop) {\r\n          return;\r\n        }\r\n        if (content) {\r\n          e.preventDefault();\r\n          Delay.setEditorTimeout(editor, () => {\r\n            editor.undoManager.transact(() => {\r\n              if (internalContent || isInternalDrop && needsInternalDrop) {\r\n                editor.execCommand('Delete');\r\n              }\r\n              setFocusedRange(editor, rng);\r\n              const trimmedContent = trimHtml(content);\r\n              if (dropContent['text/html']) {\r\n                pasteHtml(editor, trimmedContent, internal, true);\r\n              } else {\r\n                pasteText(editor, trimmedContent, true);\r\n              }\r\n            });\r\n          });\r\n        }\r\n      });\r\n      editor.on('dragstart', _e => {\r\n        draggingInternallyState.set(true);\r\n      });\r\n      editor.on('dragover dragend', e => {\r\n        if (shouldPasteDataImages(editor) && !draggingInternallyState.get()) {\r\n          e.preventDefault();\r\n          setFocusedRange(editor, getCaretRangeFromEvent(editor, e));\r\n        }\r\n        if (e.type === 'dragend') {\r\n          draggingInternallyState.set(false);\r\n        }\r\n      });\r\n      setupSummaryDeleteByDragFix(editor);\r\n    };\r\n\r\n    const setup$9 = editor => {\r\n      const processEvent = f => e => {\r\n        f(editor, e);\r\n      };\r\n      const preProcess = getPastePreProcess(editor);\r\n      if (isFunction(preProcess)) {\r\n        editor.on('PastePreProcess', processEvent(preProcess));\r\n      }\r\n      const postProcess = getPastePostProcess(editor);\r\n      if (isFunction(postProcess)) {\r\n        editor.on('PastePostProcess', processEvent(postProcess));\r\n      }\r\n    };\r\n\r\n    const addPreProcessFilter = (editor, filterFunc) => {\r\n      editor.on('PastePreProcess', e => {\r\n        e.content = filterFunc(editor, e.content, e.internal);\r\n      });\r\n    };\r\n    const rgbRegExp = /rgb\\s*\\(\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*,\\s*([0-9]+)\\s*\\)/gi;\r\n    const rgbToHex = value => Tools.trim(value).replace(rgbRegExp, rgbaToHexString).toLowerCase();\r\n    const removeWebKitStyles = (editor, content, internal) => {\r\n      const webKitStylesOption = getPasteWebkitStyles(editor);\r\n      if (internal || webKitStylesOption === 'all' || !shouldPasteRemoveWebKitStyles(editor)) {\r\n        return content;\r\n      }\r\n      const webKitStyles = webKitStylesOption ? webKitStylesOption.split(/[, ]/) : [];\r\n      if (webKitStyles && webKitStylesOption !== 'none') {\r\n        const dom = editor.dom, node = editor.selection.getNode();\r\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, (all, before, value, after) => {\r\n          const inputStyles = dom.parseStyle(dom.decode(value));\r\n          const outputStyles = {};\r\n          for (let i = 0; i < webKitStyles.length; i++) {\r\n            const inputValue = inputStyles[webKitStyles[i]];\r\n            let compareInput = inputValue;\r\n            let currentValue = dom.getStyle(node, webKitStyles[i], true);\r\n            if (/color/.test(webKitStyles[i])) {\r\n              compareInput = rgbToHex(compareInput);\r\n              currentValue = rgbToHex(currentValue);\r\n            }\r\n            if (currentValue !== compareInput) {\r\n              outputStyles[webKitStyles[i]] = inputValue;\r\n            }\r\n          }\r\n          const outputStyle = dom.serializeStyle(outputStyles, 'span');\r\n          if (outputStyle) {\r\n            return before + ' style=\"' + outputStyle + '\"' + after;\r\n          }\r\n          return before + after;\r\n        });\r\n      } else {\r\n        content = content.replace(/(<[^>]+) style=\"([^\"]*)\"([^>]*>)/gi, '$1$3');\r\n      }\r\n      content = content.replace(/(<[^>]+) data-mce-style=\"([^\"]+)\"([^>]*>)/gi, (all, before, value, after) => {\r\n        return before + ' style=\"' + value + '\"' + after;\r\n      });\r\n      return content;\r\n    };\r\n    const setup$8 = editor => {\r\n      if (Env.browser.isChromium() || Env.browser.isSafari()) {\r\n        addPreProcessFilter(editor, removeWebKitStyles);\r\n      }\r\n    };\r\n\r\n    const setup$7 = editor => {\r\n      const draggingInternallyState = Cell(false);\r\n      const pasteFormat = Cell(isPasteAsTextEnabled(editor) ? 'text' : 'html');\r\n      const pasteBin = PasteBin(editor);\r\n      setup$8(editor);\r\n      register$1(editor, pasteFormat);\r\n      setup$9(editor);\r\n      editor.on('PreInit', () => {\r\n        register(editor);\r\n        setup$a(editor, draggingInternallyState);\r\n        registerEventsAndFilters(editor, pasteBin, pasteFormat);\r\n      });\r\n    };\r\n\r\n    const preventSummaryToggle = editor => {\r\n      editor.on('click', e => {\r\n        if (editor.dom.getParent(e.target, 'details')) {\r\n          e.preventDefault();\r\n        }\r\n      });\r\n    };\r\n    const filterDetails = editor => {\r\n      editor.parser.addNodeFilter('details', elms => {\r\n        const initialStateOption = getDetailsInitialState(editor);\r\n        each$e(elms, details => {\r\n          if (initialStateOption === 'expanded') {\r\n            details.attr('open', 'open');\r\n          } else if (initialStateOption === 'collapsed') {\r\n            details.attr('open', null);\r\n          }\r\n        });\r\n      });\r\n      editor.serializer.addNodeFilter('details', elms => {\r\n        const serializedStateOption = getDetailsSerializedState(editor);\r\n        each$e(elms, details => {\r\n          if (serializedStateOption === 'expanded') {\r\n            details.attr('open', 'open');\r\n          } else if (serializedStateOption === 'collapsed') {\r\n            details.attr('open', null);\r\n          }\r\n        });\r\n      });\r\n    };\r\n    const setup$6 = editor => {\r\n      preventSummaryToggle(editor);\r\n      filterDetails(editor);\r\n    };\r\n\r\n    const isBr = isBr$6;\r\n    const isText = isText$a;\r\n    const isContentEditableFalse$2 = elm => isContentEditableFalse$b(elm.dom);\r\n    const isContentEditableTrue = elm => isContentEditableTrue$3(elm.dom);\r\n    const isRoot = rootNode => elm => eq(SugarElement.fromDom(rootNode), elm);\r\n    const getClosestScope = (node, rootNode, schema) => closest$4(SugarElement.fromDom(node), elm => isContentEditableTrue(elm) || schema.isBlock(name(elm)), isRoot(rootNode)).getOr(SugarElement.fromDom(rootNode)).dom;\r\n    const getClosestCef = (node, rootNode) => closest$4(SugarElement.fromDom(node), isContentEditableFalse$2, isRoot(rootNode));\r\n    const findEdgeCaretCandidate = (startNode, scope, forward) => {\r\n      const walker = new DomTreeWalker(startNode, scope);\r\n      const next = forward ? walker.next.bind(walker) : walker.prev.bind(walker);\r\n      let result = startNode;\r\n      for (let current = forward ? startNode : next(); current && !isBr(current); current = next()) {\r\n        if (isCaretCandidate$3(current)) {\r\n          result = current;\r\n        }\r\n      }\r\n      return result;\r\n    };\r\n    const findClosestBlockRange = (startRng, rootNode, schema) => {\r\n      const startPos = CaretPosition.fromRangeStart(startRng);\r\n      const clickNode = startPos.getNode();\r\n      const scope = getClosestScope(clickNode, rootNode, schema);\r\n      const startNode = findEdgeCaretCandidate(clickNode, scope, false);\r\n      const endNode = findEdgeCaretCandidate(clickNode, scope, true);\r\n      const rng = document.createRange();\r\n      getClosestCef(startNode, scope).fold(() => {\r\n        if (isText(startNode)) {\r\n          rng.setStart(startNode, 0);\r\n        } else {\r\n          rng.setStartBefore(startNode);\r\n        }\r\n      }, cef => rng.setStartBefore(cef.dom));\r\n      getClosestCef(endNode, scope).fold(() => {\r\n        if (isText(endNode)) {\r\n          rng.setEnd(endNode, endNode.data.length);\r\n        } else {\r\n          rng.setEndAfter(endNode);\r\n        }\r\n      }, cef => rng.setEndAfter(cef.dom));\r\n      return rng;\r\n    };\r\n    const onTripleClickSelect = editor => {\r\n      const rng = findClosestBlockRange(editor.selection.getRng(), editor.getBody(), editor.schema);\r\n      editor.selection.setRng(normalize(rng));\r\n    };\r\n    const setup$5 = editor => {\r\n      editor.on('mousedown', e => {\r\n        if (e.detail >= 3) {\r\n          e.preventDefault();\r\n          onTripleClickSelect(editor);\r\n        }\r\n      });\r\n    };\r\n\r\n    var FakeCaretPosition;\r\n    (function (FakeCaretPosition) {\r\n      FakeCaretPosition['Before'] = 'before';\r\n      FakeCaretPosition['After'] = 'after';\r\n    }(FakeCaretPosition || (FakeCaretPosition = {})));\r\n    const distanceToRectLeft = (clientRect, clientX) => Math.abs(clientRect.left - clientX);\r\n    const distanceToRectRight = (clientRect, clientX) => Math.abs(clientRect.right - clientX);\r\n    const isInsideY = (clientY, clientRect) => clientY >= clientRect.top && clientY <= clientRect.bottom;\r\n    const collidesY = (r1, r2) => r1.top < r2.bottom && r1.bottom > r2.top;\r\n    const isOverlapping = (r1, r2) => {\r\n      const overlap = overlapY(r1, r2) / Math.min(r1.height, r2.height);\r\n      return collidesY(r1, r2) && overlap > 0.5;\r\n    };\r\n    const splitRectsPerAxis = (rects, y) => {\r\n      const intersectingRects = filter$5(rects, rect => isInsideY(y, rect));\r\n      return boundingClientRectFromRects(intersectingRects).fold(() => [\r\n        [],\r\n        rects\r\n      ], boundingRect => {\r\n        const {\r\n          pass: horizontal,\r\n          fail: vertical\r\n        } = partition$2(rects, rect => isOverlapping(rect, boundingRect));\r\n        return [\r\n          horizontal,\r\n          vertical\r\n        ];\r\n      });\r\n    };\r\n    const clientInfo = (rect, clientX) => {\r\n      return {\r\n        node: rect.node,\r\n        position: distanceToRectLeft(rect, clientX) < distanceToRectRight(rect, clientX) ? FakeCaretPosition.Before : FakeCaretPosition.After\r\n      };\r\n    };\r\n    const horizontalDistance = (rect, x, _y) => x > rect.left && x < rect.right ? 0 : Math.min(Math.abs(rect.left - x), Math.abs(rect.right - x));\r\n    const closestChildCaretCandidateNodeRect = (children, clientX, clientY, findCloserTextNode) => {\r\n      const caretCandidateRect = rect => {\r\n        if (isCaretCandidate$3(rect.node)) {\r\n          return Optional.some(rect);\r\n        } else if (isElement$6(rect.node)) {\r\n          return closestChildCaretCandidateNodeRect(from(rect.node.childNodes), clientX, clientY, false);\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      };\r\n      const tryFindSecondBestTextNode = (closest, sndClosest, distance) => {\r\n        return caretCandidateRect(sndClosest).filter(rect => {\r\n          const deltaDistance = Math.abs(distance(closest, clientX, clientY) - distance(rect, clientX, clientY));\r\n          return deltaDistance < 2 && isText$a(rect.node);\r\n        });\r\n      };\r\n      const findClosestCaretCandidateNodeRect = (rects, distance) => {\r\n        const sortedRects = sort(rects, (r1, r2) => distance(r1, clientX, clientY) - distance(r2, clientX, clientY));\r\n        return findMap(sortedRects, caretCandidateRect).map(closest => {\r\n          if (findCloserTextNode && !isText$a(closest.node) && sortedRects.length > 1) {\r\n            return tryFindSecondBestTextNode(closest, sortedRects[1], distance).getOr(closest);\r\n          } else {\r\n            return closest;\r\n          }\r\n        });\r\n      };\r\n      const [horizontalRects, verticalRects] = splitRectsPerAxis(getClientRects(children), clientY);\r\n      const {\r\n        pass: above,\r\n        fail: below\r\n      } = partition$2(verticalRects, rect => rect.top < clientY);\r\n      return findClosestCaretCandidateNodeRect(horizontalRects, horizontalDistance).orThunk(() => findClosestCaretCandidateNodeRect(below, distanceToRectEdgeFromXY)).orThunk(() => findClosestCaretCandidateNodeRect(above, distanceToRectEdgeFromXY));\r\n    };\r\n    const traverseUp = (rootElm, scope, clientX, clientY) => {\r\n      const helper = (scope, prevScope) => {\r\n        const isDragGhostContainer = node => isElement$6(node) && node.classList.contains('mce-drag-container');\r\n        const childNodesWithoutGhost = filter$5(scope.dom.childNodes, not(isDragGhostContainer));\r\n        return prevScope.fold(() => closestChildCaretCandidateNodeRect(childNodesWithoutGhost, clientX, clientY, true), prevScope => {\r\n          const uncheckedChildren = filter$5(childNodesWithoutGhost, node => node !== prevScope.dom);\r\n          return closestChildCaretCandidateNodeRect(uncheckedChildren, clientX, clientY, true);\r\n        }).orThunk(() => {\r\n          const parent = eq(scope, rootElm) ? Optional.none() : parentElement(scope);\r\n          return parent.bind(newScope => helper(newScope, Optional.some(scope)));\r\n        });\r\n      };\r\n      return helper(scope, Optional.none());\r\n    };\r\n    const closestCaretCandidateNodeRect = (root, clientX, clientY) => {\r\n      const rootElm = SugarElement.fromDom(root);\r\n      const ownerDoc = documentOrOwner(rootElm);\r\n      const elementAtPoint = SugarElement.fromPoint(ownerDoc, clientX, clientY).filter(elm => contains(rootElm, elm));\r\n      const element = elementAtPoint.getOr(rootElm);\r\n      return traverseUp(rootElm, element, clientX, clientY);\r\n    };\r\n    const closestFakeCaretCandidate = (root, clientX, clientY) => closestCaretCandidateNodeRect(root, clientX, clientY).filter(rect => isFakeCaretTarget(rect.node)).map(rect => clientInfo(rect, clientX));\r\n\r\n    const getAbsolutePosition = elm => {\r\n      var _a, _b;\r\n      const clientRect = elm.getBoundingClientRect();\r\n      const doc = elm.ownerDocument;\r\n      const docElem = doc.documentElement;\r\n      const win = doc.defaultView;\r\n      return {\r\n        top: clientRect.top + ((_a = win === null || win === void 0 ? void 0 : win.scrollY) !== null && _a !== void 0 ? _a : 0) - docElem.clientTop,\r\n        left: clientRect.left + ((_b = win === null || win === void 0 ? void 0 : win.scrollX) !== null && _b !== void 0 ? _b : 0) - docElem.clientLeft\r\n      };\r\n    };\r\n    const getBodyPosition = editor => editor.inline ? getAbsolutePosition(editor.getBody()) : {\r\n      left: 0,\r\n      top: 0\r\n    };\r\n    const getScrollPosition = editor => {\r\n      const body = editor.getBody();\r\n      return editor.inline ? {\r\n        left: body.scrollLeft,\r\n        top: body.scrollTop\r\n      } : {\r\n        left: 0,\r\n        top: 0\r\n      };\r\n    };\r\n    const getBodyScroll = editor => {\r\n      const body = editor.getBody(), docElm = editor.getDoc().documentElement;\r\n      const inlineScroll = {\r\n        left: body.scrollLeft,\r\n        top: body.scrollTop\r\n      };\r\n      const iframeScroll = {\r\n        left: body.scrollLeft || docElm.scrollLeft,\r\n        top: body.scrollTop || docElm.scrollTop\r\n      };\r\n      return editor.inline ? inlineScroll : iframeScroll;\r\n    };\r\n    const getMousePosition = (editor, event) => {\r\n      if (event.target.ownerDocument !== editor.getDoc()) {\r\n        const iframePosition = getAbsolutePosition(editor.getContentAreaContainer());\r\n        const scrollPosition = getBodyScroll(editor);\r\n        return {\r\n          left: event.pageX - iframePosition.left + scrollPosition.left,\r\n          top: event.pageY - iframePosition.top + scrollPosition.top\r\n        };\r\n      }\r\n      return {\r\n        left: event.pageX,\r\n        top: event.pageY\r\n      };\r\n    };\r\n    const calculatePosition = (bodyPosition, scrollPosition, mousePosition) => ({\r\n      pageX: mousePosition.left - bodyPosition.left + scrollPosition.left,\r\n      pageY: mousePosition.top - bodyPosition.top + scrollPosition.top\r\n    });\r\n    const calc = (editor, event) => calculatePosition(getBodyPosition(editor), getScrollPosition(editor), getMousePosition(editor, event));\r\n\r\n    const getTargetProps = target => ({\r\n      target,\r\n      srcElement: target\r\n    });\r\n    const makeDndEventFromMouseEvent = (type, mouseEvent, target, dataTransfer) => ({\r\n      ...mouseEvent,\r\n      dataTransfer,\r\n      type,\r\n      ...getTargetProps(target)\r\n    });\r\n    const makeDndEvent = (type, target, dataTransfer) => {\r\n      const fail = die('Function not supported on simulated event.');\r\n      const event = {\r\n        bubbles: true,\r\n        cancelBubble: false,\r\n        cancelable: true,\r\n        composed: false,\r\n        currentTarget: null,\r\n        defaultPrevented: false,\r\n        eventPhase: 0,\r\n        isTrusted: true,\r\n        returnValue: false,\r\n        timeStamp: 0,\r\n        type,\r\n        composedPath: fail,\r\n        initEvent: fail,\r\n        preventDefault: noop,\r\n        stopImmediatePropagation: noop,\r\n        stopPropagation: noop,\r\n        AT_TARGET: window.Event.AT_TARGET,\r\n        BUBBLING_PHASE: window.Event.BUBBLING_PHASE,\r\n        CAPTURING_PHASE: window.Event.CAPTURING_PHASE,\r\n        NONE: window.Event.NONE,\r\n        altKey: false,\r\n        button: 0,\r\n        buttons: 0,\r\n        clientX: 0,\r\n        clientY: 0,\r\n        ctrlKey: false,\r\n        metaKey: false,\r\n        movementX: 0,\r\n        movementY: 0,\r\n        offsetX: 0,\r\n        offsetY: 0,\r\n        pageX: 0,\r\n        pageY: 0,\r\n        relatedTarget: null,\r\n        screenX: 0,\r\n        screenY: 0,\r\n        shiftKey: false,\r\n        x: 0,\r\n        y: 0,\r\n        detail: 0,\r\n        view: null,\r\n        which: 0,\r\n        initUIEvent: fail,\r\n        initMouseEvent: fail,\r\n        getModifierState: fail,\r\n        dataTransfer,\r\n        ...getTargetProps(target)\r\n      };\r\n      return event;\r\n    };\r\n    const makeDataTransferCopyForDragEvent = (dataTransfer, eventType) => {\r\n      const copy = cloneDataTransfer(dataTransfer);\r\n      if (eventType === 'dragstart') {\r\n        setDragstartEvent(copy);\r\n        setReadWriteMode(copy);\r\n      } else if (eventType === 'drop') {\r\n        setDropEvent(copy);\r\n        setReadOnlyMode(copy);\r\n      } else {\r\n        setDragendEvent(copy);\r\n        setProtectedMode(copy);\r\n      }\r\n      return copy;\r\n    };\r\n    const makeDragEvent = (type, target, dataTransfer, mouseEvent) => {\r\n      const dataTransferForDispatch = makeDataTransferCopyForDragEvent(dataTransfer, type);\r\n      return isUndefined(mouseEvent) ? makeDndEvent(type, target, dataTransferForDispatch) : makeDndEventFromMouseEvent(type, mouseEvent, target, dataTransferForDispatch);\r\n    };\r\n\r\n    const scrollPixelsPerInterval = 32;\r\n    const scrollIntervalValue = 100;\r\n    const mouseRangeToTriggerScrollInsideEditor = 8;\r\n    const mouseRangeToTriggerScrollOutsideEditor = 16;\r\n    const isContentEditableFalse$1 = isContentEditableFalse$b;\r\n    const isContentEditable = or(isContentEditableFalse$1, isContentEditableTrue$3);\r\n    const isDraggable = (dom, rootElm, elm) => isContentEditableFalse$1(elm) && elm !== rootElm && dom.isEditable(elm.parentElement);\r\n    const isValidDropTarget = (editor, targetElement, dragElement) => {\r\n      if (isNullable(targetElement)) {\r\n        return false;\r\n      } else if (targetElement === dragElement || editor.dom.isChildOf(targetElement, dragElement)) {\r\n        return false;\r\n      } else {\r\n        return editor.dom.isEditable(targetElement);\r\n      }\r\n    };\r\n    const createGhost = (editor, elm, width, height) => {\r\n      const dom = editor.dom;\r\n      const clonedElm = elm.cloneNode(true);\r\n      dom.setStyles(clonedElm, {\r\n        width,\r\n        height\r\n      });\r\n      dom.setAttrib(clonedElm, 'data-mce-selected', null);\r\n      const ghostElm = dom.create('div', {\r\n        'class': 'mce-drag-container',\r\n        'data-mce-bogus': 'all',\r\n        'unselectable': 'on',\r\n        'contenteditable': 'false'\r\n      });\r\n      dom.setStyles(ghostElm, {\r\n        position: 'absolute',\r\n        opacity: 0.5,\r\n        overflow: 'hidden',\r\n        border: 0,\r\n        padding: 0,\r\n        margin: 0,\r\n        width,\r\n        height\r\n      });\r\n      dom.setStyles(clonedElm, {\r\n        margin: 0,\r\n        boxSizing: 'border-box'\r\n      });\r\n      ghostElm.appendChild(clonedElm);\r\n      return ghostElm;\r\n    };\r\n    const appendGhostToBody = (ghostElm, bodyElm) => {\r\n      if (ghostElm.parentNode !== bodyElm) {\r\n        bodyElm.appendChild(ghostElm);\r\n      }\r\n    };\r\n    const scrollEditor = (direction, amount) => win => () => {\r\n      const current = direction === 'left' ? win.scrollX : win.scrollY;\r\n      win.scroll({\r\n        [direction]: current + amount,\r\n        behavior: 'smooth'\r\n      });\r\n    };\r\n    const scrollLeft = scrollEditor('left', -scrollPixelsPerInterval);\r\n    const scrollRight = scrollEditor('left', scrollPixelsPerInterval);\r\n    const scrollUp = scrollEditor('top', -scrollPixelsPerInterval);\r\n    const scrollDown = scrollEditor('top', scrollPixelsPerInterval);\r\n    const moveGhost = (ghostElm, position, width, height, maxX, maxY, mouseY, mouseX, contentAreaContainer, win, state, mouseEventOriginatedFromWithinTheEditor) => {\r\n      let overflowX = 0, overflowY = 0;\r\n      ghostElm.style.left = position.pageX + 'px';\r\n      ghostElm.style.top = position.pageY + 'px';\r\n      if (position.pageX + width > maxX) {\r\n        overflowX = position.pageX + width - maxX;\r\n      }\r\n      if (position.pageY + height > maxY) {\r\n        overflowY = position.pageY + height - maxY;\r\n      }\r\n      ghostElm.style.width = width - overflowX + 'px';\r\n      ghostElm.style.height = height - overflowY + 'px';\r\n      const clientHeight = contentAreaContainer.clientHeight;\r\n      const clientWidth = contentAreaContainer.clientWidth;\r\n      const outerMouseY = mouseY + contentAreaContainer.getBoundingClientRect().top;\r\n      const outerMouseX = mouseX + contentAreaContainer.getBoundingClientRect().left;\r\n      state.on(state => {\r\n        state.intervalId.clear();\r\n        if (state.dragging && mouseEventOriginatedFromWithinTheEditor) {\r\n          if (mouseY + mouseRangeToTriggerScrollInsideEditor >= clientHeight) {\r\n            state.intervalId.set(scrollDown(win));\r\n          } else if (mouseY - mouseRangeToTriggerScrollInsideEditor <= 0) {\r\n            state.intervalId.set(scrollUp(win));\r\n          } else if (mouseX + mouseRangeToTriggerScrollInsideEditor >= clientWidth) {\r\n            state.intervalId.set(scrollRight(win));\r\n          } else if (mouseX - mouseRangeToTriggerScrollInsideEditor <= 0) {\r\n            state.intervalId.set(scrollLeft(win));\r\n          } else if (outerMouseY + mouseRangeToTriggerScrollOutsideEditor >= window.innerHeight) {\r\n            state.intervalId.set(scrollDown(window));\r\n          } else if (outerMouseY - mouseRangeToTriggerScrollOutsideEditor <= 0) {\r\n            state.intervalId.set(scrollUp(window));\r\n          } else if (outerMouseX + mouseRangeToTriggerScrollOutsideEditor >= window.innerWidth) {\r\n            state.intervalId.set(scrollRight(window));\r\n          } else if (outerMouseX - mouseRangeToTriggerScrollOutsideEditor <= 0) {\r\n            state.intervalId.set(scrollLeft(window));\r\n          }\r\n        }\r\n      });\r\n    };\r\n    const removeElement = elm => {\r\n      if (elm && elm.parentNode) {\r\n        elm.parentNode.removeChild(elm);\r\n      }\r\n    };\r\n    const removeElementWithPadding = (dom, elm) => {\r\n      const parentBlock = dom.getParent(elm.parentNode, dom.isBlock);\r\n      removeElement(elm);\r\n      if (parentBlock && parentBlock !== dom.getRoot() && dom.isEmpty(parentBlock)) {\r\n        fillWithPaddingBr(SugarElement.fromDom(parentBlock));\r\n      }\r\n    };\r\n    const isLeftMouseButtonPressed = e => e.button === 0;\r\n    const applyRelPos = (state, position) => ({\r\n      pageX: position.pageX - state.relX,\r\n      pageY: position.pageY + 5\r\n    });\r\n    const start = (state, editor) => e => {\r\n      if (isLeftMouseButtonPressed(e)) {\r\n        const ceElm = find$2(editor.dom.getParents(e.target), isContentEditable).getOr(null);\r\n        if (isNonNullable(ceElm) && isDraggable(editor.dom, editor.getBody(), ceElm)) {\r\n          const elmPos = editor.dom.getPos(ceElm);\r\n          const bodyElm = editor.getBody();\r\n          const docElm = editor.getDoc().documentElement;\r\n          state.set({\r\n            element: ceElm,\r\n            dataTransfer: createDataTransfer(),\r\n            dragging: false,\r\n            screenX: e.screenX,\r\n            screenY: e.screenY,\r\n            maxX: (editor.inline ? bodyElm.scrollWidth : docElm.offsetWidth) - 2,\r\n            maxY: (editor.inline ? bodyElm.scrollHeight : docElm.offsetHeight) - 2,\r\n            relX: e.pageX - elmPos.x,\r\n            relY: e.pageY - elmPos.y,\r\n            width: ceElm.offsetWidth,\r\n            height: ceElm.offsetHeight,\r\n            ghost: createGhost(editor, ceElm, ceElm.offsetWidth, ceElm.offsetHeight),\r\n            intervalId: repeatable(scrollIntervalValue)\r\n          });\r\n        }\r\n      }\r\n    };\r\n    const placeCaretAt = (editor, clientX, clientY) => {\r\n      editor._selectionOverrides.hideFakeCaret();\r\n      closestFakeCaretCandidate(editor.getBody(), clientX, clientY).fold(() => editor.selection.placeCaretAt(clientX, clientY), caretInfo => {\r\n        const range = editor._selectionOverrides.showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\r\n        if (range) {\r\n          editor.selection.setRng(range);\r\n        } else {\r\n          editor.selection.placeCaretAt(clientX, clientY);\r\n        }\r\n      });\r\n    };\r\n    const dispatchDragEvent = (editor, type, target, dataTransfer, mouseEvent) => {\r\n      if (type === 'dragstart') {\r\n        setHtmlData(dataTransfer, editor.dom.getOuterHTML(target));\r\n      }\r\n      const event = makeDragEvent(type, target, dataTransfer, mouseEvent);\r\n      const args = editor.dispatch(type, event);\r\n      return args;\r\n    };\r\n    const move = (state, editor) => {\r\n      const throttledPlaceCaretAt = first$1((clientX, clientY) => placeCaretAt(editor, clientX, clientY), 0);\r\n      editor.on('remove', throttledPlaceCaretAt.cancel);\r\n      const state_ = state;\r\n      return e => state.on(state => {\r\n        const movement = Math.max(Math.abs(e.screenX - state.screenX), Math.abs(e.screenY - state.screenY));\r\n        if (!state.dragging && movement > 10) {\r\n          const args = dispatchDragEvent(editor, 'dragstart', state.element, state.dataTransfer, e);\r\n          if (isNonNullable(args.dataTransfer)) {\r\n            state.dataTransfer = args.dataTransfer;\r\n          }\r\n          if (args.isDefaultPrevented()) {\r\n            return;\r\n          }\r\n          state.dragging = true;\r\n          editor.focus();\r\n        }\r\n        if (state.dragging) {\r\n          const mouseEventOriginatedFromWithinTheEditor = e.currentTarget === editor.getDoc().documentElement;\r\n          const targetPos = applyRelPos(state, calc(editor, e));\r\n          appendGhostToBody(state.ghost, editor.getBody());\r\n          moveGhost(state.ghost, targetPos, state.width, state.height, state.maxX, state.maxY, e.clientY, e.clientX, editor.getContentAreaContainer(), editor.getWin(), state_, mouseEventOriginatedFromWithinTheEditor);\r\n          throttledPlaceCaretAt.throttle(e.clientX, e.clientY);\r\n        }\r\n      });\r\n    };\r\n    const getRawTarget = selection => {\r\n      const sel = selection.getSel();\r\n      if (isNonNullable(sel)) {\r\n        const rng = sel.getRangeAt(0);\r\n        const startContainer = rng.startContainer;\r\n        return isText$a(startContainer) ? startContainer.parentNode : startContainer;\r\n      } else {\r\n        return null;\r\n      }\r\n    };\r\n    const drop = (state, editor) => e => {\r\n      state.on(state => {\r\n        var _a;\r\n        state.intervalId.clear();\r\n        if (state.dragging) {\r\n          if (isValidDropTarget(editor, getRawTarget(editor.selection), state.element)) {\r\n            const dropTarget = (_a = editor.getDoc().elementFromPoint(e.clientX, e.clientY)) !== null && _a !== void 0 ? _a : editor.getBody();\r\n            const args = dispatchDragEvent(editor, 'drop', dropTarget, state.dataTransfer, e);\r\n            if (!args.isDefaultPrevented()) {\r\n              editor.undoManager.transact(() => {\r\n                removeElementWithPadding(editor.dom, state.element);\r\n                getHtmlData(state.dataTransfer).each(content => editor.insertContent(content));\r\n                editor._selectionOverrides.hideFakeCaret();\r\n              });\r\n            }\r\n          }\r\n          dispatchDragEvent(editor, 'dragend', editor.getBody(), state.dataTransfer, e);\r\n        }\r\n      });\r\n      removeDragState(state);\r\n    };\r\n    const stopDragging = (state, editor, e) => {\r\n      state.on(state => {\r\n        state.intervalId.clear();\r\n        if (state.dragging) {\r\n          e.fold(() => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer), mouseEvent => dispatchDragEvent(editor, 'dragend', state.element, state.dataTransfer, mouseEvent));\r\n        }\r\n      });\r\n      removeDragState(state);\r\n    };\r\n    const stop = (state, editor) => e => stopDragging(state, editor, Optional.some(e));\r\n    const removeDragState = state => {\r\n      state.on(state => {\r\n        state.intervalId.clear();\r\n        removeElement(state.ghost);\r\n      });\r\n      state.clear();\r\n    };\r\n    const bindFakeDragEvents = editor => {\r\n      const state = value$2();\r\n      const pageDom = DOMUtils.DOM;\r\n      const rootDocument = document;\r\n      const dragStartHandler = start(state, editor);\r\n      const dragHandler = move(state, editor);\r\n      const dropHandler = drop(state, editor);\r\n      const dragEndHandler = stop(state, editor);\r\n      editor.on('mousedown', dragStartHandler);\r\n      editor.on('mousemove', dragHandler);\r\n      editor.on('mouseup', dropHandler);\r\n      pageDom.bind(rootDocument, 'mousemove', dragHandler);\r\n      pageDom.bind(rootDocument, 'mouseup', dragEndHandler);\r\n      editor.on('remove', () => {\r\n        pageDom.unbind(rootDocument, 'mousemove', dragHandler);\r\n        pageDom.unbind(rootDocument, 'mouseup', dragEndHandler);\r\n      });\r\n      editor.on('keydown', e => {\r\n        if (e.keyCode === VK.ESC) {\r\n          stopDragging(state, editor, Optional.none());\r\n        }\r\n      });\r\n    };\r\n    const blockUnsupportedFileDrop = editor => {\r\n      const preventFileDrop = e => {\r\n        if (!e.isDefaultPrevented()) {\r\n          const dataTransfer = e.dataTransfer;\r\n          if (dataTransfer && (contains$2(dataTransfer.types, 'Files') || dataTransfer.files.length > 0)) {\r\n            e.preventDefault();\r\n            if (e.type === 'drop') {\r\n              displayError(editor, 'Dropped file type is not supported');\r\n            }\r\n          }\r\n        }\r\n      };\r\n      const preventFileDropIfUIElement = e => {\r\n        if (isUIElement(editor, e.target)) {\r\n          preventFileDrop(e);\r\n        }\r\n      };\r\n      const setup = () => {\r\n        const pageDom = DOMUtils.DOM;\r\n        const dom = editor.dom;\r\n        const doc = document;\r\n        const editorRoot = editor.inline ? editor.getBody() : editor.getDoc();\r\n        const eventNames = [\r\n          'drop',\r\n          'dragover'\r\n        ];\r\n        each$e(eventNames, name => {\r\n          pageDom.bind(doc, name, preventFileDropIfUIElement);\r\n          dom.bind(editorRoot, name, preventFileDrop);\r\n        });\r\n        editor.on('remove', () => {\r\n          each$e(eventNames, name => {\r\n            pageDom.unbind(doc, name, preventFileDropIfUIElement);\r\n            dom.unbind(editorRoot, name, preventFileDrop);\r\n          });\r\n        });\r\n      };\r\n      editor.on('init', () => {\r\n        Delay.setEditorTimeout(editor, setup, 0);\r\n      });\r\n    };\r\n    const init$2 = editor => {\r\n      bindFakeDragEvents(editor);\r\n      if (shouldBlockUnsupportedDrop(editor)) {\r\n        blockUnsupportedFileDrop(editor);\r\n      }\r\n    };\r\n\r\n    const setup$4 = editor => {\r\n      const renderFocusCaret = first$1(() => {\r\n        if (!editor.removed && editor.getBody().contains(document.activeElement)) {\r\n          const rng = editor.selection.getRng();\r\n          if (rng.collapsed) {\r\n            const caretRange = renderRangeCaret(editor, rng, false);\r\n            editor.selection.setRng(caretRange);\r\n          }\r\n        }\r\n      }, 0);\r\n      editor.on('focus', () => {\r\n        renderFocusCaret.throttle();\r\n      });\r\n      editor.on('blur', () => {\r\n        renderFocusCaret.cancel();\r\n      });\r\n    };\r\n\r\n    const setup$3 = editor => {\r\n      editor.on('init', () => {\r\n        editor.on('focusin', e => {\r\n          const target = e.target;\r\n          if (isMedia$2(target)) {\r\n            const ceRoot = getContentEditableRoot$1(editor.getBody(), target);\r\n            const node = isContentEditableFalse$b(ceRoot) ? ceRoot : target;\r\n            if (editor.selection.getNode() !== node) {\r\n              selectNode(editor, node).each(rng => editor.selection.setRng(rng));\r\n            }\r\n          }\r\n        });\r\n      });\r\n    };\r\n\r\n    const isContentEditableFalse = isContentEditableFalse$b;\r\n    const getContentEditableRoot = (editor, node) => getContentEditableRoot$1(editor.getBody(), node);\r\n    const SelectionOverrides = editor => {\r\n      const selection = editor.selection, dom = editor.dom;\r\n      const rootNode = editor.getBody();\r\n      const fakeCaret = FakeCaret(editor, rootNode, dom.isBlock, () => hasFocus(editor));\r\n      const realSelectionId = 'sel-' + dom.uniqueId();\r\n      const elementSelectionAttr = 'data-mce-selected';\r\n      let selectedElement;\r\n      const isFakeSelectionElement = node => isNonNullable(node) && dom.hasClass(node, 'mce-offscreen-selection');\r\n      const isFakeSelectionTargetElement = node => node !== rootNode && (isContentEditableFalse(node) || isMedia$2(node)) && dom.isChildOf(node, rootNode) && dom.isEditable(node.parentNode);\r\n      const setRange = range => {\r\n        if (range) {\r\n          selection.setRng(range);\r\n        }\r\n      };\r\n      const showCaret = (direction, node, before, scrollIntoView = true) => {\r\n        const e = editor.dispatch('ShowCaret', {\r\n          target: node,\r\n          direction,\r\n          before\r\n        });\r\n        if (e.isDefaultPrevented()) {\r\n          return null;\r\n        }\r\n        if (scrollIntoView) {\r\n          selection.scrollIntoView(node, direction === -1);\r\n        }\r\n        return fakeCaret.show(before, node);\r\n      };\r\n      const showBlockCaretContainer = blockCaretContainer => {\r\n        if (blockCaretContainer.hasAttribute('data-mce-caret')) {\r\n          showCaretContainerBlock(blockCaretContainer);\r\n          selection.scrollIntoView(blockCaretContainer);\r\n        }\r\n      };\r\n      const registerEvents = () => {\r\n        editor.on('click', e => {\r\n          if (!dom.isEditable(e.target)) {\r\n            e.preventDefault();\r\n            editor.focus();\r\n          }\r\n        });\r\n        editor.on('blur NewBlock', removeElementSelection);\r\n        editor.on('ResizeWindow FullscreenStateChanged', fakeCaret.reposition);\r\n        editor.on('tap', e => {\r\n          const targetElm = e.target;\r\n          const contentEditableRoot = getContentEditableRoot(editor, targetElm);\r\n          if (isContentEditableFalse(contentEditableRoot)) {\r\n            e.preventDefault();\r\n            selectNode(editor, contentEditableRoot).each(setElementSelection);\r\n          } else if (isFakeSelectionTargetElement(targetElm)) {\r\n            selectNode(editor, targetElm).each(setElementSelection);\r\n          }\r\n        }, true);\r\n        editor.on('mousedown', e => {\r\n          const targetElm = e.target;\r\n          if (targetElm !== rootNode && targetElm.nodeName !== 'HTML' && !dom.isChildOf(targetElm, rootNode)) {\r\n            return;\r\n          }\r\n          if (!isXYInContentArea(editor, e.clientX, e.clientY)) {\r\n            return;\r\n          }\r\n          removeElementSelection();\r\n          hideFakeCaret();\r\n          const closestContentEditable = getContentEditableRoot(editor, targetElm);\r\n          if (isContentEditableFalse(closestContentEditable)) {\r\n            e.preventDefault();\r\n            selectNode(editor, closestContentEditable).each(setElementSelection);\r\n          } else {\r\n            closestFakeCaretCandidate(rootNode, e.clientX, e.clientY).each(caretInfo => {\r\n              e.preventDefault();\r\n              const range = showCaret(1, caretInfo.node, caretInfo.position === FakeCaretPosition.Before, false);\r\n              setRange(range);\r\n              if (isHTMLElement(closestContentEditable)) {\r\n                closestContentEditable.focus();\r\n              } else {\r\n                editor.getBody().focus();\r\n              }\r\n            });\r\n          }\r\n        });\r\n        editor.on('keypress', e => {\r\n          if (VK.modifierPressed(e)) {\r\n            return;\r\n          }\r\n          if (isContentEditableFalse(selection.getNode())) {\r\n            e.preventDefault();\r\n          }\r\n        });\r\n        editor.on('GetSelectionRange', e => {\r\n          let rng = e.range;\r\n          if (selectedElement) {\r\n            if (!selectedElement.parentNode) {\r\n              selectedElement = null;\r\n              return;\r\n            }\r\n            rng = rng.cloneRange();\r\n            rng.selectNode(selectedElement);\r\n            e.range = rng;\r\n          }\r\n        });\r\n        editor.on('SetSelectionRange', e => {\r\n          e.range = normalizeVoidElementSelection(e.range);\r\n          const rng = setElementSelection(e.range, e.forward);\r\n          if (rng) {\r\n            e.range = rng;\r\n          }\r\n        });\r\n        const isPasteBin = node => isElement$6(node) && node.id === 'mcepastebin';\r\n        editor.on('AfterSetSelectionRange', e => {\r\n          const rng = e.range;\r\n          const parent = rng.startContainer.parentElement;\r\n          if (!isRangeInCaretContainer(rng) && !isPasteBin(parent)) {\r\n            hideFakeCaret();\r\n          }\r\n          if (!isFakeSelectionElement(parent)) {\r\n            removeElementSelection();\r\n          }\r\n        });\r\n        init$2(editor);\r\n        setup$4(editor);\r\n        setup$3(editor);\r\n      };\r\n      const isWithinCaretContainer = node => isCaretContainer$2(node) || startsWithCaretContainer$1(node) || endsWithCaretContainer$1(node);\r\n      const isRangeInCaretContainer = rng => isWithinCaretContainer(rng.startContainer) || isWithinCaretContainer(rng.endContainer);\r\n      const normalizeVoidElementSelection = rng => {\r\n        const voidElements = editor.schema.getVoidElements();\r\n        const newRng = dom.createRng();\r\n        const startContainer = rng.startContainer;\r\n        const startOffset = rng.startOffset;\r\n        const endContainer = rng.endContainer;\r\n        const endOffset = rng.endOffset;\r\n        if (has$2(voidElements, startContainer.nodeName.toLowerCase())) {\r\n          if (startOffset === 0) {\r\n            newRng.setStartBefore(startContainer);\r\n          } else {\r\n            newRng.setStartAfter(startContainer);\r\n          }\r\n        } else {\r\n          newRng.setStart(startContainer, startOffset);\r\n        }\r\n        if (has$2(voidElements, endContainer.nodeName.toLowerCase())) {\r\n          if (endOffset === 0) {\r\n            newRng.setEndBefore(endContainer);\r\n          } else {\r\n            newRng.setEndAfter(endContainer);\r\n          }\r\n        } else {\r\n          newRng.setEnd(endContainer, endOffset);\r\n        }\r\n        return newRng;\r\n      };\r\n      const setupOffscreenSelection = (node, targetClone) => {\r\n        const body = SugarElement.fromDom(editor.getBody());\r\n        const doc = editor.getDoc();\r\n        const realSelectionContainer = descendant$1(body, '#' + realSelectionId).getOrThunk(() => {\r\n          const newContainer = SugarElement.fromHtml('<div data-mce-bogus=\"all\" class=\"mce-offscreen-selection\"></div>', doc);\r\n          set$3(newContainer, 'id', realSelectionId);\r\n          append$1(body, newContainer);\r\n          return newContainer;\r\n        });\r\n        const newRange = dom.createRng();\r\n        empty(realSelectionContainer);\r\n        append(realSelectionContainer, [\r\n          SugarElement.fromText(nbsp, doc),\r\n          SugarElement.fromDom(targetClone),\r\n          SugarElement.fromText(nbsp, doc)\r\n        ]);\r\n        newRange.setStart(realSelectionContainer.dom.firstChild, 1);\r\n        newRange.setEnd(realSelectionContainer.dom.lastChild, 0);\r\n        setAll(realSelectionContainer, { top: dom.getPos(node, editor.getBody()).y + 'px' });\r\n        focus$1(realSelectionContainer);\r\n        const sel = selection.getSel();\r\n        if (sel) {\r\n          sel.removeAllRanges();\r\n          sel.addRange(newRange);\r\n        }\r\n        return newRange;\r\n      };\r\n      const selectElement = elm => {\r\n        const targetClone = elm.cloneNode(true);\r\n        const e = editor.dispatch('ObjectSelected', {\r\n          target: elm,\r\n          targetClone\r\n        });\r\n        if (e.isDefaultPrevented()) {\r\n          return null;\r\n        }\r\n        const range = setupOffscreenSelection(elm, e.targetClone);\r\n        const nodeElm = SugarElement.fromDom(elm);\r\n        each$e(descendants(SugarElement.fromDom(editor.getBody()), `*[${ elementSelectionAttr }]`), elm => {\r\n          if (!eq(nodeElm, elm)) {\r\n            remove$a(elm, elementSelectionAttr);\r\n          }\r\n        });\r\n        if (!dom.getAttrib(elm, elementSelectionAttr)) {\r\n          elm.setAttribute(elementSelectionAttr, '1');\r\n        }\r\n        selectedElement = elm;\r\n        hideFakeCaret();\r\n        return range;\r\n      };\r\n      const setElementSelection = (range, forward) => {\r\n        if (!range) {\r\n          return null;\r\n        }\r\n        if (range.collapsed) {\r\n          if (!isRangeInCaretContainer(range)) {\r\n            const dir = forward ? 1 : -1;\r\n            const caretPosition = getNormalizedRangeEndPoint(dir, rootNode, range);\r\n            const beforeNode = caretPosition.getNode(!forward);\r\n            if (isNonNullable(beforeNode)) {\r\n              if (isFakeCaretTarget(beforeNode)) {\r\n                return showCaret(dir, beforeNode, forward ? !caretPosition.isAtEnd() : false, false);\r\n              }\r\n              if (isCaretContainerInline(beforeNode) && isContentEditableFalse$b(beforeNode.nextSibling)) {\r\n                const rng = dom.createRng();\r\n                rng.setStart(beforeNode, 0);\r\n                rng.setEnd(beforeNode, 0);\r\n                return rng;\r\n              }\r\n            }\r\n            const afterNode = caretPosition.getNode(forward);\r\n            if (isNonNullable(afterNode)) {\r\n              if (isFakeCaretTarget(afterNode)) {\r\n                return showCaret(dir, afterNode, forward ? false : !caretPosition.isAtEnd(), false);\r\n              }\r\n              if (isCaretContainerInline(afterNode) && isContentEditableFalse$b(afterNode.previousSibling)) {\r\n                const rng = dom.createRng();\r\n                rng.setStart(afterNode, 1);\r\n                rng.setEnd(afterNode, 1);\r\n                return rng;\r\n              }\r\n            }\r\n          }\r\n          return null;\r\n        }\r\n        let startContainer = range.startContainer;\r\n        let startOffset = range.startOffset;\r\n        const endOffset = range.endOffset;\r\n        if (isText$a(startContainer) && startOffset === 0 && isContentEditableFalse(startContainer.parentNode)) {\r\n          startContainer = startContainer.parentNode;\r\n          startOffset = dom.nodeIndex(startContainer);\r\n          startContainer = startContainer.parentNode;\r\n        }\r\n        if (!isElement$6(startContainer)) {\r\n          return null;\r\n        }\r\n        if (endOffset === startOffset + 1 && startContainer === range.endContainer) {\r\n          const node = startContainer.childNodes[startOffset];\r\n          if (isFakeSelectionTargetElement(node)) {\r\n            return selectElement(node);\r\n          }\r\n        }\r\n        return null;\r\n      };\r\n      const removeElementSelection = () => {\r\n        if (selectedElement) {\r\n          selectedElement.removeAttribute(elementSelectionAttr);\r\n        }\r\n        descendant$1(SugarElement.fromDom(editor.getBody()), '#' + realSelectionId).each(remove$5);\r\n        selectedElement = null;\r\n      };\r\n      const destroy = () => {\r\n        fakeCaret.destroy();\r\n        selectedElement = null;\r\n      };\r\n      const hideFakeCaret = () => {\r\n        fakeCaret.hide();\r\n      };\r\n      if (!isRtc(editor)) {\r\n        registerEvents();\r\n      }\r\n      return {\r\n        showCaret,\r\n        showBlockCaretContainer,\r\n        hideFakeCaret,\r\n        destroy\r\n      };\r\n    };\r\n\r\n    const getNormalizedTextOffset = (container, offset) => {\r\n      let normalizedOffset = offset;\r\n      for (let node = container.previousSibling; isText$a(node); node = node.previousSibling) {\r\n        normalizedOffset += node.data.length;\r\n      }\r\n      return normalizedOffset;\r\n    };\r\n    const generatePath = (dom, root, node, offset, normalized) => {\r\n      if (isText$a(node) && (offset < 0 || offset > node.data.length)) {\r\n        return [];\r\n      }\r\n      const p = normalized && isText$a(node) ? [getNormalizedTextOffset(node, offset)] : [offset];\r\n      let current = node;\r\n      while (current !== root && current.parentNode) {\r\n        p.push(dom.nodeIndex(current, normalized));\r\n        current = current.parentNode;\r\n      }\r\n      return current === root ? p.reverse() : [];\r\n    };\r\n    const generatePathRange = (dom, root, startNode, startOffset, endNode, endOffset, normalized = false) => {\r\n      const start = generatePath(dom, root, startNode, startOffset, normalized);\r\n      const end = generatePath(dom, root, endNode, endOffset, normalized);\r\n      return {\r\n        start,\r\n        end\r\n      };\r\n    };\r\n    const resolvePath = (root, path) => {\r\n      const nodePath = path.slice();\r\n      const offset = nodePath.pop();\r\n      if (!isNumber(offset)) {\r\n        return Optional.none();\r\n      } else {\r\n        const resolvedNode = foldl(nodePath, (optNode, index) => optNode.bind(node => Optional.from(node.childNodes[index])), Optional.some(root));\r\n        return resolvedNode.bind(node => {\r\n          if (isText$a(node) && (offset < 0 || offset > node.data.length)) {\r\n            return Optional.none();\r\n          } else {\r\n            return Optional.some({\r\n              node,\r\n              offset\r\n            });\r\n          }\r\n        });\r\n      }\r\n    };\r\n    const resolvePathRange = (root, range) => resolvePath(root, range.start).bind(({\r\n      node: startNode,\r\n      offset: startOffset\r\n    }) => resolvePath(root, range.end).map(({\r\n      node: endNode,\r\n      offset: endOffset\r\n    }) => {\r\n      const rng = document.createRange();\r\n      rng.setStart(startNode, startOffset);\r\n      rng.setEnd(endNode, endOffset);\r\n      return rng;\r\n    }));\r\n    const generatePathRangeFromRange = (dom, root, range, normalized = false) => generatePathRange(dom, root, range.startContainer, range.startOffset, range.endContainer, range.endOffset, normalized);\r\n\r\n    const cleanEmptyNodes = (dom, node, isRoot) => {\r\n      if (node && dom.isEmpty(node) && !isRoot(node)) {\r\n        const parent = node.parentNode;\r\n        dom.remove(node, isText$a(node.firstChild) && isWhitespaceText(node.firstChild.data));\r\n        cleanEmptyNodes(dom, parent, isRoot);\r\n      }\r\n    };\r\n    const deleteRng = (dom, rng, isRoot, clean = true) => {\r\n      const startParent = rng.startContainer.parentNode;\r\n      const endParent = rng.endContainer.parentNode;\r\n      rng.deleteContents();\r\n      if (clean && !isRoot(rng.startContainer)) {\r\n        if (isText$a(rng.startContainer) && rng.startContainer.data.length === 0) {\r\n          dom.remove(rng.startContainer);\r\n        }\r\n        if (isText$a(rng.endContainer) && rng.endContainer.data.length === 0) {\r\n          dom.remove(rng.endContainer);\r\n        }\r\n        cleanEmptyNodes(dom, startParent, isRoot);\r\n        if (startParent !== endParent) {\r\n          cleanEmptyNodes(dom, endParent, isRoot);\r\n        }\r\n      }\r\n    };\r\n    const getParentBlock = (editor, rng) => Optional.from(editor.dom.getParent(rng.startContainer, editor.dom.isBlock));\r\n    const resolveFromDynamicPatterns = (patternSet, block, beforeText) => {\r\n      const dynamicPatterns = patternSet.dynamicPatternsLookup({\r\n        text: beforeText,\r\n        block\r\n      });\r\n      return {\r\n        ...patternSet,\r\n        blockPatterns: getBlockPatterns(dynamicPatterns).concat(patternSet.blockPatterns),\r\n        inlinePatterns: getInlinePatterns(dynamicPatterns).concat(patternSet.inlinePatterns)\r\n      };\r\n    };\r\n    const getBeforeText = (dom, block, node, offset) => {\r\n      const rng = dom.createRng();\r\n      rng.setStart(block, 0);\r\n      rng.setEnd(node, offset);\r\n      return rng.toString();\r\n    };\r\n\r\n    const startsWithSingleSpace = s => /^\\s[^\\s]/.test(s);\r\n    const stripPattern = (dom, block, pattern) => {\r\n      const firstTextNode = textAfter(block, 0, block);\r\n      firstTextNode.each(spot => {\r\n        const node = spot.container;\r\n        scanRight(node, pattern.start.length, block).each(end => {\r\n          const rng = dom.createRng();\r\n          rng.setStart(node, 0);\r\n          rng.setEnd(end.container, end.offset);\r\n          deleteRng(dom, rng, e => e === block);\r\n        });\r\n        const text = SugarElement.fromDom(node);\r\n        const textContent = get$3(text);\r\n        if (startsWithSingleSpace(textContent)) {\r\n          set(text, textContent.slice(1));\r\n        }\r\n      });\r\n    };\r\n    const applyPattern$1 = (editor, match) => {\r\n      const dom = editor.dom;\r\n      const pattern = match.pattern;\r\n      const rng = resolvePathRange(dom.getRoot(), match.range).getOrDie('Unable to resolve path range');\r\n      const isBlockFormatName = (name, formatter) => {\r\n        const formatSet = formatter.get(name);\r\n        return isArray$1(formatSet) && head(formatSet).exists(format => has$2(format, 'block'));\r\n      };\r\n      getParentBlock(editor, rng).each(block => {\r\n        if (pattern.type === 'block-format') {\r\n          if (isBlockFormatName(pattern.format, editor.formatter)) {\r\n            editor.undoManager.transact(() => {\r\n              stripPattern(editor.dom, block, pattern);\r\n              editor.formatter.apply(pattern.format);\r\n            });\r\n          }\r\n        } else if (pattern.type === 'block-command') {\r\n          editor.undoManager.transact(() => {\r\n            stripPattern(editor.dom, block, pattern);\r\n            editor.execCommand(pattern.cmd, false, pattern.value);\r\n          });\r\n        }\r\n      });\r\n      return true;\r\n    };\r\n    const sortPatterns$1 = patterns => sort(patterns, (a, b) => b.start.length - a.start.length);\r\n    const findPattern$1 = (patterns, text) => {\r\n      const sortedPatterns = sortPatterns$1(patterns);\r\n      const nuText = text.replace(nbsp, ' ');\r\n      return find$2(sortedPatterns, pattern => text.indexOf(pattern.start) === 0 || nuText.indexOf(pattern.start) === 0);\r\n    };\r\n    const findPatterns$1 = (editor, block, patternSet, normalizedMatches) => {\r\n      var _a;\r\n      const dom = editor.dom;\r\n      const forcedRootBlock = getForcedRootBlock(editor);\r\n      if (!dom.is(block, forcedRootBlock)) {\r\n        return [];\r\n      }\r\n      const blockText = (_a = block.textContent) !== null && _a !== void 0 ? _a : '';\r\n      return findPattern$1(patternSet.blockPatterns, blockText).map(pattern => {\r\n        if (Tools.trim(blockText).length === pattern.start.length) {\r\n          return [];\r\n        }\r\n        return [{\r\n            pattern,\r\n            range: generatePathRange(dom, dom.getRoot(), block, 0, block, 0, normalizedMatches)\r\n          }];\r\n      }).getOr([]);\r\n    };\r\n    const applyMatches$1 = (editor, matches) => {\r\n      if (matches.length === 0) {\r\n        return;\r\n      }\r\n      const bookmark = editor.selection.getBookmark();\r\n      each$e(matches, match => applyPattern$1(editor, match));\r\n      editor.selection.moveToBookmark(bookmark);\r\n    };\r\n\r\n    const newMarker = (dom, id) => dom.create('span', {\r\n      'data-mce-type': 'bookmark',\r\n      id\r\n    });\r\n    const rangeFromMarker = (dom, marker) => {\r\n      const rng = dom.createRng();\r\n      rng.setStartAfter(marker.start);\r\n      rng.setEndBefore(marker.end);\r\n      return rng;\r\n    };\r\n    const createMarker = (dom, markerPrefix, pathRange) => {\r\n      const rng = resolvePathRange(dom.getRoot(), pathRange).getOrDie('Unable to resolve path range');\r\n      const startNode = rng.startContainer;\r\n      const endNode = rng.endContainer;\r\n      const textEnd = rng.endOffset === 0 ? endNode : endNode.splitText(rng.endOffset);\r\n      const textStart = rng.startOffset === 0 ? startNode : startNode.splitText(rng.startOffset);\r\n      const startParentNode = textStart.parentNode;\r\n      const endParentNode = textEnd.parentNode;\r\n      return {\r\n        prefix: markerPrefix,\r\n        end: endParentNode.insertBefore(newMarker(dom, markerPrefix + '-end'), textEnd),\r\n        start: startParentNode.insertBefore(newMarker(dom, markerPrefix + '-start'), textStart)\r\n      };\r\n    };\r\n    const removeMarker = (dom, marker, isRoot) => {\r\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-end'), isRoot);\r\n      cleanEmptyNodes(dom, dom.get(marker.prefix + '-start'), isRoot);\r\n    };\r\n\r\n    const isReplacementPattern = pattern => pattern.start.length === 0;\r\n    const matchesPattern = patternContent => (element, offset) => {\r\n      const text = element.data;\r\n      const searchText = text.substring(0, offset);\r\n      const startEndIndex = searchText.lastIndexOf(patternContent.charAt(patternContent.length - 1));\r\n      const startIndex = searchText.lastIndexOf(patternContent);\r\n      if (startIndex !== -1) {\r\n        return startIndex + patternContent.length;\r\n      } else if (startEndIndex !== -1) {\r\n        return startEndIndex + 1;\r\n      } else {\r\n        return -1;\r\n      }\r\n    };\r\n    const findPatternStartFromSpot = (dom, pattern, block, spot) => {\r\n      const startPattern = pattern.start;\r\n      const startSpot = repeatLeft(dom, spot.container, spot.offset, matchesPattern(startPattern), block);\r\n      return startSpot.bind(spot => {\r\n        var _a, _b;\r\n        const startPatternIndex = (_b = (_a = block.textContent) === null || _a === void 0 ? void 0 : _a.indexOf(startPattern)) !== null && _b !== void 0 ? _b : -1;\r\n        const isCompleteMatch = startPatternIndex !== -1 && spot.offset >= startPatternIndex + startPattern.length;\r\n        if (isCompleteMatch) {\r\n          const rng = dom.createRng();\r\n          rng.setStart(spot.container, spot.offset - startPattern.length);\r\n          rng.setEnd(spot.container, spot.offset);\r\n          return Optional.some(rng);\r\n        } else {\r\n          const offset = spot.offset - startPattern.length;\r\n          return scanLeft(spot.container, offset, block).map(nextSpot => {\r\n            const rng = dom.createRng();\r\n            rng.setStart(nextSpot.container, nextSpot.offset);\r\n            rng.setEnd(spot.container, spot.offset);\r\n            return rng;\r\n          }).filter(rng => rng.toString() === startPattern).orThunk(() => findPatternStartFromSpot(dom, pattern, block, point(spot.container, 0)));\r\n        }\r\n      });\r\n    };\r\n    const findPatternStart = (dom, pattern, node, offset, block, requireGap = false) => {\r\n      if (pattern.start.length === 0 && !requireGap) {\r\n        const rng = dom.createRng();\r\n        rng.setStart(node, offset);\r\n        rng.setEnd(node, offset);\r\n        return Optional.some(rng);\r\n      }\r\n      return textBefore(node, offset, block).bind(spot => {\r\n        const start = findPatternStartFromSpot(dom, pattern, block, spot);\r\n        return start.bind(startRange => {\r\n          var _a;\r\n          if (requireGap) {\r\n            if (startRange.endContainer === spot.container && startRange.endOffset === spot.offset) {\r\n              return Optional.none();\r\n            } else if (spot.offset === 0 && ((_a = startRange.endContainer.textContent) === null || _a === void 0 ? void 0 : _a.length) === startRange.endOffset) {\r\n              return Optional.none();\r\n            }\r\n          }\r\n          return Optional.some(startRange);\r\n        });\r\n      });\r\n    };\r\n    const findPattern = (editor, block, details, normalizedMatches) => {\r\n      const dom = editor.dom;\r\n      const root = dom.getRoot();\r\n      const pattern = details.pattern;\r\n      const endNode = details.position.container;\r\n      const endOffset = details.position.offset;\r\n      return scanLeft(endNode, endOffset - details.pattern.end.length, block).bind(spot => {\r\n        const endPathRng = generatePathRange(dom, root, spot.container, spot.offset, endNode, endOffset, normalizedMatches);\r\n        if (isReplacementPattern(pattern)) {\r\n          return Optional.some({\r\n            matches: [{\r\n                pattern,\r\n                startRng: endPathRng,\r\n                endRng: endPathRng\r\n              }],\r\n            position: spot\r\n          });\r\n        } else {\r\n          const resultsOpt = findPatternsRec(editor, details.remainingPatterns, spot.container, spot.offset, block, normalizedMatches);\r\n          const results = resultsOpt.getOr({\r\n            matches: [],\r\n            position: spot\r\n          });\r\n          const pos = results.position;\r\n          const start = findPatternStart(dom, pattern, pos.container, pos.offset, block, resultsOpt.isNone());\r\n          return start.map(startRng => {\r\n            const startPathRng = generatePathRangeFromRange(dom, root, startRng, normalizedMatches);\r\n            return {\r\n              matches: results.matches.concat([{\r\n                  pattern,\r\n                  startRng: startPathRng,\r\n                  endRng: endPathRng\r\n                }]),\r\n              position: point(startRng.startContainer, startRng.startOffset)\r\n            };\r\n          });\r\n        }\r\n      });\r\n    };\r\n    const findPatternsRec = (editor, patterns, node, offset, block, normalizedMatches) => {\r\n      const dom = editor.dom;\r\n      return textBefore(node, offset, dom.getRoot()).bind(endSpot => {\r\n        const text = getBeforeText(dom, block, node, offset);\r\n        for (let i = 0; i < patterns.length; i++) {\r\n          const pattern = patterns[i];\r\n          if (!endsWith(text, pattern.end)) {\r\n            continue;\r\n          }\r\n          const patternsWithoutCurrent = patterns.slice();\r\n          patternsWithoutCurrent.splice(i, 1);\r\n          const result = findPattern(editor, block, {\r\n            pattern,\r\n            remainingPatterns: patternsWithoutCurrent,\r\n            position: endSpot\r\n          }, normalizedMatches);\r\n          if (result.isNone() && offset > 0) {\r\n            return findPatternsRec(editor, patterns, node, offset - 1, block, normalizedMatches);\r\n          }\r\n          if (result.isSome()) {\r\n            return result;\r\n          }\r\n        }\r\n        return Optional.none();\r\n      });\r\n    };\r\n    const applyPattern = (editor, pattern, patternRange) => {\r\n      editor.selection.setRng(patternRange);\r\n      if (pattern.type === 'inline-format') {\r\n        each$e(pattern.format, format => {\r\n          editor.formatter.apply(format);\r\n        });\r\n      } else {\r\n        editor.execCommand(pattern.cmd, false, pattern.value);\r\n      }\r\n    };\r\n    const applyReplacementPattern = (editor, pattern, marker, isRoot) => {\r\n      const markerRange = rangeFromMarker(editor.dom, marker);\r\n      deleteRng(editor.dom, markerRange, isRoot);\r\n      applyPattern(editor, pattern, markerRange);\r\n    };\r\n    const applyPatternWithContent = (editor, pattern, startMarker, endMarker, isRoot) => {\r\n      const dom = editor.dom;\r\n      const markerEndRange = rangeFromMarker(dom, endMarker);\r\n      const markerStartRange = rangeFromMarker(dom, startMarker);\r\n      deleteRng(dom, markerStartRange, isRoot);\r\n      deleteRng(dom, markerEndRange, isRoot);\r\n      const patternMarker = {\r\n        prefix: startMarker.prefix,\r\n        start: startMarker.end,\r\n        end: endMarker.start\r\n      };\r\n      const patternRange = rangeFromMarker(dom, patternMarker);\r\n      applyPattern(editor, pattern, patternRange);\r\n    };\r\n    const addMarkers = (dom, matches) => {\r\n      const markerPrefix = generate$1('mce_textpattern');\r\n      const matchesWithEnds = foldr(matches, (acc, match) => {\r\n        const endMarker = createMarker(dom, markerPrefix + `_end${ acc.length }`, match.endRng);\r\n        return acc.concat([{\r\n            ...match,\r\n            endMarker\r\n          }]);\r\n      }, []);\r\n      return foldr(matchesWithEnds, (acc, match) => {\r\n        const idx = matchesWithEnds.length - acc.length - 1;\r\n        const startMarker = isReplacementPattern(match.pattern) ? match.endMarker : createMarker(dom, markerPrefix + `_start${ idx }`, match.startRng);\r\n        return acc.concat([{\r\n            ...match,\r\n            startMarker\r\n          }]);\r\n      }, []);\r\n    };\r\n    const sortPatterns = patterns => sort(patterns, (a, b) => b.end.length - a.end.length);\r\n    const getBestMatches = (matches, matchesWithSortedPatterns) => {\r\n      const hasSameMatches = forall(matches, match => exists(matchesWithSortedPatterns, sortedMatch => match.pattern.start === sortedMatch.pattern.start && match.pattern.end === sortedMatch.pattern.end));\r\n      if (matches.length === matchesWithSortedPatterns.length) {\r\n        if (hasSameMatches) {\r\n          return matches;\r\n        } else {\r\n          return matchesWithSortedPatterns;\r\n        }\r\n      }\r\n      return matches.length > matchesWithSortedPatterns.length ? matches : matchesWithSortedPatterns;\r\n    };\r\n    const findPatterns = (editor, block, node, offset, patternSet, normalizedMatches) => {\r\n      const matches = findPatternsRec(editor, patternSet.inlinePatterns, node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\r\n      const matchesWithSortedPatterns = findPatternsRec(editor, sortPatterns(patternSet.inlinePatterns), node, offset, block, normalizedMatches).fold(() => [], result => result.matches);\r\n      return getBestMatches(matches, matchesWithSortedPatterns);\r\n    };\r\n    const applyMatches = (editor, matches) => {\r\n      if (matches.length === 0) {\r\n        return;\r\n      }\r\n      const dom = editor.dom;\r\n      const bookmark = editor.selection.getBookmark();\r\n      const matchesWithMarkers = addMarkers(dom, matches);\r\n      each$e(matchesWithMarkers, match => {\r\n        const block = dom.getParent(match.startMarker.start, dom.isBlock);\r\n        const isRoot = node => node === block;\r\n        if (isReplacementPattern(match.pattern)) {\r\n          applyReplacementPattern(editor, match.pattern, match.endMarker, isRoot);\r\n        } else {\r\n          applyPatternWithContent(editor, match.pattern, match.startMarker, match.endMarker, isRoot);\r\n        }\r\n        removeMarker(dom, match.endMarker, isRoot);\r\n        removeMarker(dom, match.startMarker, isRoot);\r\n      });\r\n      editor.selection.moveToBookmark(bookmark);\r\n    };\r\n\r\n    const handleEnter = (editor, patternSet) => {\r\n      const rng = editor.selection.getRng();\r\n      return getParentBlock(editor, rng).map(block => {\r\n        var _a;\r\n        const offset = Math.max(0, rng.startOffset);\r\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, (_a = block.textContent) !== null && _a !== void 0 ? _a : '');\r\n        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, true);\r\n        const blockMatches = findPatterns$1(editor, block, dynamicPatternSet, true);\r\n        if (blockMatches.length > 0 || inlineMatches.length > 0) {\r\n          editor.undoManager.add();\r\n          editor.undoManager.extra(() => {\r\n            editor.execCommand('mceInsertNewLine');\r\n          }, () => {\r\n            insert$5(editor);\r\n            applyMatches(editor, inlineMatches);\r\n            applyMatches$1(editor, blockMatches);\r\n            const range = editor.selection.getRng();\r\n            const spot = textBefore(range.startContainer, range.startOffset, editor.dom.getRoot());\r\n            editor.execCommand('mceInsertNewLine');\r\n            spot.each(s => {\r\n              const node = s.container;\r\n              if (node.data.charAt(s.offset - 1) === zeroWidth) {\r\n                node.deleteData(s.offset - 1, 1);\r\n                cleanEmptyNodes(editor.dom, node.parentNode, e => e === editor.dom.getRoot());\r\n              }\r\n            });\r\n          });\r\n          return true;\r\n        }\r\n        return false;\r\n      }).getOr(false);\r\n    };\r\n    const handleInlineKey = (editor, patternSet) => {\r\n      const rng = editor.selection.getRng();\r\n      getParentBlock(editor, rng).map(block => {\r\n        const offset = Math.max(0, rng.startOffset - 1);\r\n        const beforeText = getBeforeText(editor.dom, block, rng.startContainer, offset);\r\n        const dynamicPatternSet = resolveFromDynamicPatterns(patternSet, block, beforeText);\r\n        const inlineMatches = findPatterns(editor, block, rng.startContainer, offset, dynamicPatternSet, false);\r\n        if (inlineMatches.length > 0) {\r\n          editor.undoManager.transact(() => {\r\n            applyMatches(editor, inlineMatches);\r\n          });\r\n        }\r\n      });\r\n    };\r\n    const checkKeyEvent = (codes, event, predicate) => {\r\n      for (let i = 0; i < codes.length; i++) {\r\n        if (predicate(codes[i], event)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    };\r\n    const checkKeyCode = (codes, event) => checkKeyEvent(codes, event, (code, event) => {\r\n      return code === event.keyCode && !VK.modifierPressed(event);\r\n    });\r\n    const checkCharCode = (chars, event) => checkKeyEvent(chars, event, (chr, event) => {\r\n      return chr.charCodeAt(0) === event.charCode;\r\n    });\r\n\r\n    const setup$2 = editor => {\r\n      const charCodes = [\r\n        ',',\r\n        '.',\r\n        ';',\r\n        ':',\r\n        '!',\r\n        '?'\r\n      ];\r\n      const keyCodes = [32];\r\n      const getPatternSet = () => createPatternSet(getTextPatterns(editor), getTextPatternsLookup(editor));\r\n      const hasDynamicPatterns = () => hasTextPatternsLookup(editor);\r\n      editor.on('keydown', e => {\r\n        if (e.keyCode === 13 && !VK.modifierPressed(e) && editor.selection.isCollapsed()) {\r\n          const patternSet = getPatternSet();\r\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || patternSet.blockPatterns.length > 0 || hasDynamicPatterns();\r\n          if (hasPatterns && handleEnter(editor, patternSet)) {\r\n            e.preventDefault();\r\n          }\r\n        }\r\n      }, true);\r\n      const handleInlineTrigger = () => {\r\n        if (editor.selection.isCollapsed()) {\r\n          const patternSet = getPatternSet();\r\n          const hasPatterns = patternSet.inlinePatterns.length > 0 || hasDynamicPatterns();\r\n          if (hasPatterns) {\r\n            handleInlineKey(editor, patternSet);\r\n          }\r\n        }\r\n      };\r\n      editor.on('keyup', e => {\r\n        if (checkKeyCode(keyCodes, e)) {\r\n          handleInlineTrigger();\r\n        }\r\n      });\r\n      editor.on('keypress', e => {\r\n        if (checkCharCode(charCodes, e)) {\r\n          Delay.setEditorTimeout(editor, handleInlineTrigger);\r\n        }\r\n      });\r\n    };\r\n\r\n    const setup$1 = editor => {\r\n      setup$2(editor);\r\n    };\r\n\r\n    const Quirks = editor => {\r\n      const each = Tools.each;\r\n      const BACKSPACE = VK.BACKSPACE, DELETE = VK.DELETE, dom = editor.dom, selection = editor.selection, parser = editor.parser;\r\n      const browser = Env.browser;\r\n      const isGecko = browser.isFirefox();\r\n      const isWebKit = browser.isChromium() || browser.isSafari();\r\n      const isiOS = Env.deviceType.isiPhone() || Env.deviceType.isiPad();\r\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\r\n      const setEditorCommandState = (cmd, state) => {\r\n        try {\r\n          editor.getDoc().execCommand(cmd, false, String(state));\r\n        } catch (ex) {\r\n        }\r\n      };\r\n      const isDefaultPrevented = e => {\r\n        return e.isDefaultPrevented();\r\n      };\r\n      const emptyEditorWhenDeleting = () => {\r\n        const serializeRng = rng => {\r\n          const body = dom.create('body');\r\n          const contents = rng.cloneContents();\r\n          body.appendChild(contents);\r\n          return selection.serializer.serialize(body, { format: 'html' });\r\n        };\r\n        const allContentsSelected = rng => {\r\n          const selection = serializeRng(rng);\r\n          const allRng = dom.createRng();\r\n          allRng.selectNode(editor.getBody());\r\n          const allSelection = serializeRng(allRng);\r\n          return selection === allSelection;\r\n        };\r\n        editor.on('keydown', e => {\r\n          const keyCode = e.keyCode;\r\n          if (!isDefaultPrevented(e) && (keyCode === DELETE || keyCode === BACKSPACE) && editor.selection.isEditable()) {\r\n            const isCollapsed = editor.selection.isCollapsed();\r\n            const body = editor.getBody();\r\n            if (isCollapsed && !isEmpty$2(SugarElement.fromDom(body))) {\r\n              return;\r\n            }\r\n            if (!isCollapsed && !allContentsSelected(editor.selection.getRng())) {\r\n              return;\r\n            }\r\n            e.preventDefault();\r\n            editor.setContent('');\r\n            if (body.firstChild && dom.isBlock(body.firstChild)) {\r\n              editor.selection.setCursorLocation(body.firstChild, 0);\r\n            } else {\r\n              editor.selection.setCursorLocation(body, 0);\r\n            }\r\n            editor.nodeChanged();\r\n          }\r\n        });\r\n      };\r\n      const selectAll = () => {\r\n        editor.shortcuts.add('meta+a', null, 'SelectAll');\r\n      };\r\n      const documentElementEditingFocus = () => {\r\n        if (!editor.inline) {\r\n          dom.bind(editor.getDoc(), 'mousedown mouseup', e => {\r\n            let rng;\r\n            if (e.target === editor.getDoc().documentElement) {\r\n              rng = selection.getRng();\r\n              editor.getBody().focus();\r\n              if (e.type === 'mousedown') {\r\n                if (isCaretContainer$2(rng.startContainer)) {\r\n                  return;\r\n                }\r\n                selection.placeCaretAt(e.clientX, e.clientY);\r\n              } else {\r\n                selection.setRng(rng);\r\n              }\r\n            }\r\n          });\r\n        }\r\n      };\r\n      const removeHrOnBackspace = () => {\r\n        editor.on('keydown', e => {\r\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\r\n            if (!editor.getBody().getElementsByTagName('hr').length) {\r\n              return;\r\n            }\r\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\r\n              const node = selection.getNode();\r\n              const previousSibling = node.previousSibling;\r\n              if (node.nodeName === 'HR') {\r\n                dom.remove(node);\r\n                e.preventDefault();\r\n                return;\r\n              }\r\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'hr') {\r\n                dom.remove(previousSibling);\r\n                e.preventDefault();\r\n              }\r\n            }\r\n          }\r\n        });\r\n      };\r\n      const focusBody = () => {\r\n        if (!Range.prototype.getClientRects) {\r\n          editor.on('mousedown', e => {\r\n            if (!isDefaultPrevented(e) && e.target.nodeName === 'HTML') {\r\n              const body = editor.getBody();\r\n              body.blur();\r\n              Delay.setEditorTimeout(editor, () => {\r\n                body.focus();\r\n              });\r\n            }\r\n          });\r\n        }\r\n      };\r\n      const selectControlElements = () => {\r\n        const visualAidsAnchorClass = getVisualAidsAnchorClass(editor);\r\n        editor.on('click', e => {\r\n          const target = e.target;\r\n          if (/^(IMG|HR)$/.test(target.nodeName) && dom.isEditable(target)) {\r\n            e.preventDefault();\r\n            editor.selection.select(target);\r\n            editor.nodeChanged();\r\n          }\r\n          if (target.nodeName === 'A' && dom.hasClass(target, visualAidsAnchorClass) && target.childNodes.length === 0 && dom.isEditable(target.parentNode)) {\r\n            e.preventDefault();\r\n            selection.select(target);\r\n          }\r\n        });\r\n      };\r\n      const removeStylesWhenDeletingAcrossBlockElements = () => {\r\n        const getAttributeApplyFunction = () => {\r\n          const template = dom.getAttribs(selection.getStart().cloneNode(false));\r\n          return () => {\r\n            const target = selection.getStart();\r\n            if (target !== editor.getBody()) {\r\n              dom.setAttrib(target, 'style', null);\r\n              each(template, attr => {\r\n                target.setAttributeNode(attr.cloneNode(true));\r\n              });\r\n            }\r\n          };\r\n        };\r\n        const isSelectionAcrossElements = () => {\r\n          return !selection.isCollapsed() && dom.getParent(selection.getStart(), dom.isBlock) !== dom.getParent(selection.getEnd(), dom.isBlock);\r\n        };\r\n        editor.on('keypress', e => {\r\n          let applyAttributes;\r\n          if (!isDefaultPrevented(e) && (e.keyCode === 8 || e.keyCode === 46) && isSelectionAcrossElements()) {\r\n            applyAttributes = getAttributeApplyFunction();\r\n            editor.getDoc().execCommand('delete', false);\r\n            applyAttributes();\r\n            e.preventDefault();\r\n            return false;\r\n          } else {\r\n            return true;\r\n          }\r\n        });\r\n        dom.bind(editor.getDoc(), 'cut', e => {\r\n          if (!isDefaultPrevented(e) && isSelectionAcrossElements()) {\r\n            const applyAttributes = getAttributeApplyFunction();\r\n            Delay.setEditorTimeout(editor, () => {\r\n              applyAttributes();\r\n            });\r\n          }\r\n        });\r\n      };\r\n      const disableBackspaceIntoATable = () => {\r\n        editor.on('keydown', e => {\r\n          if (!isDefaultPrevented(e) && e.keyCode === BACKSPACE) {\r\n            if (selection.isCollapsed() && selection.getRng().startOffset === 0) {\r\n              const previousSibling = selection.getNode().previousSibling;\r\n              if (previousSibling && previousSibling.nodeName && previousSibling.nodeName.toLowerCase() === 'table') {\r\n                e.preventDefault();\r\n                return false;\r\n              }\r\n            }\r\n          }\r\n          return true;\r\n        });\r\n      };\r\n      const removeBlockQuoteOnBackSpace = () => {\r\n        editor.on('keydown', e => {\r\n          if (isDefaultPrevented(e) || e.keyCode !== VK.BACKSPACE) {\r\n            return;\r\n          }\r\n          let rng = selection.getRng();\r\n          const container = rng.startContainer;\r\n          const offset = rng.startOffset;\r\n          const root = dom.getRoot();\r\n          let parent = container;\r\n          if (!rng.collapsed || offset !== 0) {\r\n            return;\r\n          }\r\n          while (parent.parentNode && parent.parentNode.firstChild === parent && parent.parentNode !== root) {\r\n            parent = parent.parentNode;\r\n          }\r\n          if (parent.nodeName === 'BLOCKQUOTE') {\r\n            editor.formatter.toggle('blockquote', undefined, parent);\r\n            rng = dom.createRng();\r\n            rng.setStart(container, 0);\r\n            rng.setEnd(container, 0);\r\n            selection.setRng(rng);\r\n          }\r\n        });\r\n      };\r\n      const setGeckoEditingOptions = () => {\r\n        const setOpts = () => {\r\n          setEditorCommandState('StyleWithCSS', false);\r\n          setEditorCommandState('enableInlineTableEditing', false);\r\n          if (!getObjectResizing(editor)) {\r\n            setEditorCommandState('enableObjectResizing', false);\r\n          }\r\n        };\r\n        if (!isReadOnly$1(editor)) {\r\n          editor.on('BeforeExecCommand mousedown', setOpts);\r\n        }\r\n      };\r\n      const addBrAfterLastLinks = () => {\r\n        const fixLinks = () => {\r\n          each(dom.select('a:not([data-mce-block])'), node => {\r\n            var _a;\r\n            let parentNode = node.parentNode;\r\n            const root = dom.getRoot();\r\n            if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.lastChild) === node) {\r\n              while (parentNode && !dom.isBlock(parentNode)) {\r\n                if (((_a = parentNode.parentNode) === null || _a === void 0 ? void 0 : _a.lastChild) !== parentNode || parentNode === root) {\r\n                  return;\r\n                }\r\n                parentNode = parentNode.parentNode;\r\n              }\r\n              dom.add(parentNode, 'br', { 'data-mce-bogus': 1 });\r\n            }\r\n          });\r\n        };\r\n        editor.on('SetContent ExecCommand', e => {\r\n          if (e.type === 'setcontent' || e.command === 'mceInsertLink') {\r\n            fixLinks();\r\n          }\r\n        });\r\n      };\r\n      const setDefaultBlockType = () => {\r\n        editor.on('init', () => {\r\n          setEditorCommandState('DefaultParagraphSeparator', getForcedRootBlock(editor));\r\n        });\r\n      };\r\n      const isAllContentSelected = editor => {\r\n        const body = editor.getBody();\r\n        const rng = editor.selection.getRng();\r\n        return rng.startContainer === rng.endContainer && rng.startContainer === body && rng.startOffset === 0 && rng.endOffset === body.childNodes.length;\r\n      };\r\n      const normalizeSelection = () => {\r\n        editor.on('keyup focusin mouseup', e => {\r\n          if (!VK.modifierPressed(e) && !isAllContentSelected(editor)) {\r\n            selection.normalize();\r\n          }\r\n        }, true);\r\n      };\r\n      const showBrokenImageIcon = () => {\r\n        editor.contentStyles.push('img:-moz-broken {' + '-moz-force-broken-image-icon:1;' + 'min-width:24px;' + 'min-height:24px' + '}');\r\n      };\r\n      const restoreFocusOnKeyDown = () => {\r\n        if (!editor.inline) {\r\n          editor.on('keydown', () => {\r\n            if (document.activeElement === document.body) {\r\n              editor.getWin().focus();\r\n            }\r\n          });\r\n        }\r\n      };\r\n      const bodyHeight = () => {\r\n        if (!editor.inline) {\r\n          editor.contentStyles.push('body {min-height: 150px}');\r\n          editor.on('click', e => {\r\n            let rng;\r\n            if (e.target.nodeName === 'HTML') {\r\n              rng = editor.selection.getRng();\r\n              editor.getBody().focus();\r\n              editor.selection.setRng(rng);\r\n              editor.selection.normalize();\r\n              editor.nodeChanged();\r\n            }\r\n          });\r\n        }\r\n      };\r\n      const blockCmdArrowNavigation = () => {\r\n        if (isMac) {\r\n          editor.on('keydown', e => {\r\n            if (VK.metaKeyPressed(e) && !e.shiftKey && (e.keyCode === 37 || e.keyCode === 39)) {\r\n              e.preventDefault();\r\n              const selection = editor.selection.getSel();\r\n              selection.modify('move', e.keyCode === 37 ? 'backward' : 'forward', 'lineboundary');\r\n            }\r\n          });\r\n        }\r\n      };\r\n      const tapLinksAndImages = () => {\r\n        editor.on('click', e => {\r\n          let elm = e.target;\r\n          do {\r\n            if (elm.tagName === 'A') {\r\n              e.preventDefault();\r\n              return;\r\n            }\r\n          } while (elm = elm.parentNode);\r\n        });\r\n        editor.contentStyles.push('.mce-content-body {-webkit-touch-callout: none}');\r\n      };\r\n      const blockFormSubmitInsideEditor = () => {\r\n        editor.on('init', () => {\r\n          editor.dom.bind(editor.getBody(), 'submit', e => {\r\n            e.preventDefault();\r\n          });\r\n        });\r\n      };\r\n      const removeAppleInterchangeBrs = () => {\r\n        parser.addNodeFilter('br', nodes => {\r\n          let i = nodes.length;\r\n          while (i--) {\r\n            if (nodes[i].attr('class') === 'Apple-interchange-newline') {\r\n              nodes[i].remove();\r\n            }\r\n          }\r\n        });\r\n      };\r\n      const refreshContentEditable = noop;\r\n      const isHidden = () => {\r\n        if (!isGecko || editor.removed) {\r\n          return false;\r\n        }\r\n        const sel = editor.selection.getSel();\r\n        return !sel || !sel.rangeCount || sel.rangeCount === 0;\r\n      };\r\n      const setupRtc = () => {\r\n        if (isWebKit) {\r\n          documentElementEditingFocus();\r\n          selectControlElements();\r\n          blockFormSubmitInsideEditor();\r\n          selectAll();\r\n          if (isiOS) {\r\n            restoreFocusOnKeyDown();\r\n            bodyHeight();\r\n            tapLinksAndImages();\r\n          }\r\n        }\r\n        if (isGecko) {\r\n          focusBody();\r\n          setGeckoEditingOptions();\r\n          showBrokenImageIcon();\r\n          blockCmdArrowNavigation();\r\n        }\r\n      };\r\n      const dropDragEndEvent = () => {\r\n        editor.on('drop', event => {\r\n          var _a;\r\n          const data = (_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.getData('text/html');\r\n          if (isString(data) && /^<img[^>]*>$/.test(data)) {\r\n            editor.dispatch('dragend', new window.DragEvent('dragend', event));\r\n          }\r\n        });\r\n      };\r\n      const setup = () => {\r\n        removeBlockQuoteOnBackSpace();\r\n        emptyEditorWhenDeleting();\r\n        if (!Env.windowsPhone) {\r\n          normalizeSelection();\r\n        }\r\n        if (isWebKit) {\r\n          documentElementEditingFocus();\r\n          selectControlElements();\r\n          setDefaultBlockType();\r\n          blockFormSubmitInsideEditor();\r\n          disableBackspaceIntoATable();\r\n          removeAppleInterchangeBrs();\r\n          if (isiOS) {\r\n            restoreFocusOnKeyDown();\r\n            bodyHeight();\r\n            tapLinksAndImages();\r\n          } else {\r\n            selectAll();\r\n          }\r\n        }\r\n        if (isGecko) {\r\n          removeHrOnBackspace();\r\n          focusBody();\r\n          removeStylesWhenDeletingAcrossBlockElements();\r\n          setGeckoEditingOptions();\r\n          addBrAfterLastLinks();\r\n          showBrokenImageIcon();\r\n          blockCmdArrowNavigation();\r\n          disableBackspaceIntoATable();\r\n          dropDragEndEvent();\r\n        }\r\n      };\r\n      if (isRtc(editor)) {\r\n        setupRtc();\r\n      } else {\r\n        setup();\r\n      }\r\n      return {\r\n        refreshContentEditable,\r\n        isHidden\r\n      };\r\n    };\r\n\r\n    const DOM$6 = DOMUtils.DOM;\r\n    const appendStyle = (editor, text) => {\r\n      const body = SugarElement.fromDom(editor.getBody());\r\n      const container = getStyleContainer(getRootNode(body));\r\n      const style = SugarElement.fromTag('style');\r\n      set$3(style, 'type', 'text/css');\r\n      append$1(style, SugarElement.fromText(text));\r\n      append$1(container, style);\r\n      editor.on('remove', () => {\r\n        remove$5(style);\r\n      });\r\n    };\r\n    const getRootName = editor => editor.inline ? editor.getElement().nodeName.toLowerCase() : undefined;\r\n    const removeUndefined = obj => filter$4(obj, v => isUndefined(v) === false);\r\n    const mkParserSettings = editor => {\r\n      const getOption = editor.options.get;\r\n      const blobCache = editor.editorUpload.blobCache;\r\n      return removeUndefined({\r\n        allow_conditional_comments: getOption('allow_conditional_comments'),\r\n        allow_html_data_urls: getOption('allow_html_data_urls'),\r\n        allow_svg_data_urls: getOption('allow_svg_data_urls'),\r\n        allow_html_in_named_anchor: getOption('allow_html_in_named_anchor'),\r\n        allow_script_urls: getOption('allow_script_urls'),\r\n        allow_unsafe_link_target: getOption('allow_unsafe_link_target'),\r\n        convert_unsafe_embeds: getOption('convert_unsafe_embeds'),\r\n        convert_fonts_to_spans: getOption('convert_fonts_to_spans'),\r\n        fix_list_elements: getOption('fix_list_elements'),\r\n        font_size_legacy_values: getOption('font_size_legacy_values'),\r\n        forced_root_block: getOption('forced_root_block'),\r\n        forced_root_block_attrs: getOption('forced_root_block_attrs'),\r\n        preserve_cdata: getOption('preserve_cdata'),\r\n        inline_styles: getOption('inline_styles'),\r\n        root_name: getRootName(editor),\r\n        sandbox_iframes: getOption('sandbox_iframes'),\r\n        sanitize: getOption('xss_sanitization'),\r\n        validate: true,\r\n        blob_cache: blobCache,\r\n        document: editor.getDoc()\r\n      });\r\n    };\r\n    const mkSchemaSettings = editor => {\r\n      const getOption = editor.options.get;\r\n      return removeUndefined({\r\n        custom_elements: getOption('custom_elements'),\r\n        extended_valid_elements: getOption('extended_valid_elements'),\r\n        invalid_elements: getOption('invalid_elements'),\r\n        invalid_styles: getOption('invalid_styles'),\r\n        schema: getOption('schema'),\r\n        valid_children: getOption('valid_children'),\r\n        valid_classes: getOption('valid_classes'),\r\n        valid_elements: getOption('valid_elements'),\r\n        valid_styles: getOption('valid_styles'),\r\n        verify_html: getOption('verify_html'),\r\n        padd_empty_block_inline_children: getOption('format_empty_lines')\r\n      });\r\n    };\r\n    const mkSerializerSettings = editor => {\r\n      const getOption = editor.options.get;\r\n      return {\r\n        ...mkParserSettings(editor),\r\n        ...mkSchemaSettings(editor),\r\n        ...removeUndefined({\r\n          remove_trailing_brs: getOption('remove_trailing_brs'),\r\n          pad_empty_with_br: getOption('pad_empty_with_br'),\r\n          url_converter: getOption('url_converter'),\r\n          url_converter_scope: getOption('url_converter_scope'),\r\n          element_format: getOption('element_format'),\r\n          entities: getOption('entities'),\r\n          entity_encoding: getOption('entity_encoding'),\r\n          indent: getOption('indent'),\r\n          indent_after: getOption('indent_after'),\r\n          indent_before: getOption('indent_before')\r\n        })\r\n      };\r\n    };\r\n    const createParser = editor => {\r\n      const parser = DomParser(mkParserSettings(editor), editor.schema);\r\n      parser.addAttributeFilter('src,href,style,tabindex', (nodes, name) => {\r\n        const dom = editor.dom;\r\n        const internalName = 'data-mce-' + name;\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          let value = node.attr(name);\r\n          if (value && !node.attr(internalName)) {\r\n            if (value.indexOf('data:') === 0 || value.indexOf('blob:') === 0) {\r\n              continue;\r\n            }\r\n            if (name === 'style') {\r\n              value = dom.serializeStyle(dom.parseStyle(value), node.name);\r\n              if (!value.length) {\r\n                value = null;\r\n              }\r\n              node.attr(internalName, value);\r\n              node.attr(name, value);\r\n            } else if (name === 'tabindex') {\r\n              node.attr(internalName, value);\r\n              node.attr(name, null);\r\n            } else {\r\n              node.attr(internalName, editor.convertURL(value, name, node.name));\r\n            }\r\n          }\r\n        }\r\n      });\r\n      parser.addNodeFilter('script', nodes => {\r\n        let i = nodes.length;\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          const type = node.attr('type') || 'no/type';\r\n          if (type.indexOf('mce-') !== 0) {\r\n            node.attr('type', 'mce-' + type);\r\n          }\r\n        }\r\n      });\r\n      if (shouldPreserveCData(editor)) {\r\n        parser.addNodeFilter('#cdata', nodes => {\r\n          var _a;\r\n          let i = nodes.length;\r\n          while (i--) {\r\n            const node = nodes[i];\r\n            node.type = 8;\r\n            node.name = '#comment';\r\n            node.value = '[CDATA[' + editor.dom.encode((_a = node.value) !== null && _a !== void 0 ? _a : '') + ']]';\r\n          }\r\n        });\r\n      }\r\n      parser.addNodeFilter('p,h1,h2,h3,h4,h5,h6,div', nodes => {\r\n        let i = nodes.length;\r\n        const nonEmptyElements = editor.schema.getNonEmptyElements();\r\n        while (i--) {\r\n          const node = nodes[i];\r\n          if (node.isEmpty(nonEmptyElements) && node.getAll('br').length === 0) {\r\n            node.append(new AstNode('br', 1));\r\n          }\r\n        }\r\n      });\r\n      return parser;\r\n    };\r\n    const autoFocus = editor => {\r\n      const autoFocus = getAutoFocus(editor);\r\n      if (autoFocus) {\r\n        Delay.setEditorTimeout(editor, () => {\r\n          let focusEditor;\r\n          if (autoFocus === true) {\r\n            focusEditor = editor;\r\n          } else {\r\n            focusEditor = editor.editorManager.get(autoFocus);\r\n          }\r\n          if (focusEditor && !focusEditor.destroyed) {\r\n            focusEditor.focus();\r\n            focusEditor.selection.scrollIntoView();\r\n          }\r\n        }, 100);\r\n      }\r\n    };\r\n    const moveSelectionToFirstCaretPosition = editor => {\r\n      const root = editor.dom.getRoot();\r\n      if (!editor.inline && (!hasAnyRanges(editor) || editor.selection.getStart(true) === root)) {\r\n        firstPositionIn(root).each(pos => {\r\n          const node = pos.getNode();\r\n          const caretPos = isTable$2(node) ? firstPositionIn(node).getOr(pos) : pos;\r\n          editor.selection.setRng(caretPos.toRange());\r\n        });\r\n      }\r\n    };\r\n    const initEditor = editor => {\r\n      editor.bindPendingEventDelegates();\r\n      editor.initialized = true;\r\n      fireInit(editor);\r\n      editor.focus(true);\r\n      moveSelectionToFirstCaretPosition(editor);\r\n      editor.nodeChanged({ initial: true });\r\n      const initInstanceCallback = getInitInstanceCallback(editor);\r\n      if (isFunction(initInstanceCallback)) {\r\n        initInstanceCallback.call(editor, editor);\r\n      }\r\n      autoFocus(editor);\r\n    };\r\n    const getStyleSheetLoader$1 = editor => editor.inline ? editor.ui.styleSheetLoader : editor.dom.styleSheetLoader;\r\n    const makeStylesheetLoadingPromises = (editor, css, framedFonts) => {\r\n      const {\r\n        pass: bundledCss,\r\n        fail: normalCss\r\n      } = partition$2(css, name => tinymce.Resource.has(toContentSkinResourceName(name)));\r\n      const bundledPromises = bundledCss.map(url => {\r\n        const css = tinymce.Resource.get(toContentSkinResourceName(url));\r\n        if (isString(css)) {\r\n          return Promise.resolve(getStyleSheetLoader$1(editor).loadRawCss(url, css));\r\n        }\r\n        return Promise.resolve();\r\n      });\r\n      const promises = [\r\n        ...bundledPromises,\r\n        getStyleSheetLoader$1(editor).loadAll(normalCss)\r\n      ];\r\n      if (editor.inline) {\r\n        return promises;\r\n      } else {\r\n        return promises.concat([editor.ui.styleSheetLoader.loadAll(framedFonts)]);\r\n      }\r\n    };\r\n    const loadContentCss = editor => {\r\n      const styleSheetLoader = getStyleSheetLoader$1(editor);\r\n      const fontCss = getFontCss(editor);\r\n      const css = editor.contentCSS;\r\n      const removeCss = () => {\r\n        styleSheetLoader.unloadAll(css);\r\n        if (!editor.inline) {\r\n          editor.ui.styleSheetLoader.unloadAll(fontCss);\r\n        }\r\n      };\r\n      const loaded = () => {\r\n        if (editor.removed) {\r\n          removeCss();\r\n        } else {\r\n          editor.on('remove', removeCss);\r\n        }\r\n      };\r\n      if (editor.contentStyles.length > 0) {\r\n        let contentCssText = '';\r\n        Tools.each(editor.contentStyles, style => {\r\n          contentCssText += style + '\\r\\n';\r\n        });\r\n        editor.dom.addStyle(contentCssText);\r\n      }\r\n      const allStylesheets = Promise.all(makeStylesheetLoadingPromises(editor, css, fontCss)).then(loaded).catch(loaded);\r\n      const contentStyle = getContentStyle(editor);\r\n      if (contentStyle) {\r\n        appendStyle(editor, contentStyle);\r\n      }\r\n      return allStylesheets;\r\n    };\r\n    const preInit = editor => {\r\n      const doc = editor.getDoc(), body = editor.getBody();\r\n      firePreInit(editor);\r\n      if (!shouldBrowserSpellcheck(editor)) {\r\n        doc.body.spellcheck = false;\r\n        DOM$6.setAttrib(body, 'spellcheck', 'false');\r\n      }\r\n      editor.quirks = Quirks(editor);\r\n      firePostRender(editor);\r\n      const directionality = getDirectionality(editor);\r\n      if (directionality !== undefined) {\r\n        body.dir = directionality;\r\n      }\r\n      const protect = getProtect(editor);\r\n      if (protect) {\r\n        editor.on('BeforeSetContent', e => {\r\n          Tools.each(protect, pattern => {\r\n            e.content = e.content.replace(pattern, str => {\r\n              return '<!--mce:protected ' + escape(str) + '-->';\r\n            });\r\n          });\r\n        });\r\n      }\r\n      editor.on('SetContent', () => {\r\n        editor.addVisual(editor.getBody());\r\n      });\r\n      editor.on('compositionstart compositionend', e => {\r\n        editor.composing = e.type === 'compositionstart';\r\n      });\r\n    };\r\n    const loadInitialContent = editor => {\r\n      if (!isRtc(editor)) {\r\n        editor.load({\r\n          initial: true,\r\n          format: 'html'\r\n        });\r\n      }\r\n      editor.startContent = editor.getContent({ format: 'raw' });\r\n    };\r\n    const initEditorWithInitialContent = editor => {\r\n      if (editor.removed !== true) {\r\n        loadInitialContent(editor);\r\n        initEditor(editor);\r\n      }\r\n    };\r\n    const startProgress = editor => {\r\n      let canceled = false;\r\n      const progressTimeout = setTimeout(() => {\r\n        if (!canceled) {\r\n          editor.setProgressState(true);\r\n        }\r\n      }, 500);\r\n      return () => {\r\n        clearTimeout(progressTimeout);\r\n        canceled = true;\r\n        editor.setProgressState(false);\r\n      };\r\n    };\r\n    const contentBodyLoaded = editor => {\r\n      const targetElm = editor.getElement();\r\n      let doc = editor.getDoc();\r\n      if (editor.inline) {\r\n        DOM$6.addClass(targetElm, 'mce-content-body');\r\n        editor.contentDocument = doc = document;\r\n        editor.contentWindow = window;\r\n        editor.bodyElement = targetElm;\r\n        editor.contentAreaContainer = targetElm;\r\n      }\r\n      const body = editor.getBody();\r\n      body.disabled = true;\r\n      editor.readonly = isReadOnly$1(editor);\r\n      editor._editableRoot = hasEditableRoot$1(editor);\r\n      if (!editor.readonly && editor.hasEditableRoot()) {\r\n        if (editor.inline && DOM$6.getStyle(body, 'position', true) === 'static') {\r\n          body.style.position = 'relative';\r\n        }\r\n        body.contentEditable = 'true';\r\n      }\r\n      body.disabled = false;\r\n      editor.editorUpload = EditorUpload(editor);\r\n      editor.schema = Schema(mkSchemaSettings(editor));\r\n      editor.dom = DOMUtils(doc, {\r\n        keep_values: true,\r\n        url_converter: editor.convertURL,\r\n        url_converter_scope: editor,\r\n        update_styles: true,\r\n        root_element: editor.inline ? editor.getBody() : null,\r\n        collect: editor.inline,\r\n        schema: editor.schema,\r\n        contentCssCors: shouldUseContentCssCors(editor),\r\n        referrerPolicy: getReferrerPolicy(editor),\r\n        onSetAttrib: e => {\r\n          editor.dispatch('SetAttrib', e);\r\n        },\r\n        force_hex_color: shouldForceHexColor(editor)\r\n      });\r\n      editor.parser = createParser(editor);\r\n      editor.serializer = DomSerializer(mkSerializerSettings(editor), editor);\r\n      editor.selection = EditorSelection(editor.dom, editor.getWin(), editor.serializer, editor);\r\n      editor.annotator = Annotator(editor);\r\n      editor.formatter = Formatter(editor);\r\n      editor.undoManager = UndoManager(editor);\r\n      editor._nodeChangeDispatcher = new NodeChange(editor);\r\n      editor._selectionOverrides = SelectionOverrides(editor);\r\n      setup$p(editor);\r\n      setup$6(editor);\r\n      setup$n(editor);\r\n      if (!isRtc(editor)) {\r\n        setup$5(editor);\r\n        setup$1(editor);\r\n      }\r\n      const caret = setup$b(editor);\r\n      setup$q(editor, caret);\r\n      setup$o(editor);\r\n      setup$r(editor);\r\n      setup$7(editor);\r\n      const setupRtcThunk = setup$t(editor);\r\n      preInit(editor);\r\n      setupRtcThunk.fold(() => {\r\n        const cancelProgress = startProgress(editor);\r\n        loadContentCss(editor).then(() => {\r\n          initEditorWithInitialContent(editor);\r\n          cancelProgress();\r\n        });\r\n      }, setupRtc => {\r\n        editor.setProgressState(true);\r\n        loadContentCss(editor).then(() => {\r\n          setupRtc().then(_rtcMode => {\r\n            editor.setProgressState(false);\r\n            initEditorWithInitialContent(editor);\r\n            bindEvents(editor);\r\n          }, err => {\r\n            editor.notificationManager.open({\r\n              type: 'error',\r\n              text: String(err)\r\n            });\r\n            initEditorWithInitialContent(editor);\r\n            bindEvents(editor);\r\n          });\r\n        });\r\n      });\r\n    };\r\n\r\n    const filter = always;\r\n    const bind = (element, event, handler) => bind$2(element, event, filter, handler);\r\n\r\n    const DOM$5 = DOMUtils.DOM;\r\n    const createIframeElement = (id, title, customAttrs, tabindex) => {\r\n      const iframe = SugarElement.fromTag('iframe');\r\n      tabindex.each(t => set$3(iframe, 'tabindex', t));\r\n      setAll$1(iframe, customAttrs);\r\n      setAll$1(iframe, {\r\n        id: id + '_ifr',\r\n        frameBorder: '0',\r\n        allowTransparency: 'true',\r\n        title\r\n      });\r\n      add$2(iframe, 'tox-edit-area__iframe');\r\n      return iframe;\r\n    };\r\n    const getIframeHtml = editor => {\r\n      let iframeHTML = getDocType(editor) + '<html><head>';\r\n      if (getDocumentBaseUrl(editor) !== editor.documentBaseUrl) {\r\n        iframeHTML += '<base href=\"' + editor.documentBaseURI.getURI() + '\" />';\r\n      }\r\n      iframeHTML += '<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />';\r\n      const bodyId = getBodyId(editor);\r\n      const bodyClass = getBodyClass(editor);\r\n      const translatedAriaText = editor.translate(getIframeAriaText(editor));\r\n      if (getContentSecurityPolicy(editor)) {\r\n        iframeHTML += '<meta http-equiv=\"Content-Security-Policy\" content=\"' + getContentSecurityPolicy(editor) + '\" />';\r\n      }\r\n      iframeHTML += '</head>' + `<body id=\"${ bodyId }\" class=\"mce-content-body ${ bodyClass }\" data-id=\"${ editor.id }\" aria-label=\"${ translatedAriaText }\">` + '<br>' + '</body></html>';\r\n      return iframeHTML;\r\n    };\r\n    const createIframe = (editor, boxInfo) => {\r\n      const iframeTitle = editor.translate('Rich Text Area');\r\n      const tabindex = getOpt(SugarElement.fromDom(editor.getElement()), 'tabindex').bind(toInt);\r\n      const ifr = createIframeElement(editor.id, iframeTitle, getIframeAttrs(editor), tabindex).dom;\r\n      ifr.onload = () => {\r\n        ifr.onload = null;\r\n        editor.dispatch('load');\r\n      };\r\n      editor.contentAreaContainer = boxInfo.iframeContainer;\r\n      editor.iframeElement = ifr;\r\n      editor.iframeHTML = getIframeHtml(editor);\r\n      DOM$5.add(boxInfo.iframeContainer, ifr);\r\n    };\r\n    const setupIframeBody = editor => {\r\n      const iframe = editor.iframeElement;\r\n      const ready = () => {\r\n        editor.contentDocument = iframe.contentDocument;\r\n        contentBodyLoaded(editor);\r\n      };\r\n      if (shouldUseDocumentWrite(editor) || Env.browser.isFirefox()) {\r\n        const doc = editor.getDoc();\r\n        doc.open();\r\n        doc.write(editor.iframeHTML);\r\n        doc.close();\r\n        ready();\r\n      } else {\r\n        const binder = bind(SugarElement.fromDom(iframe), 'load', () => {\r\n          binder.unbind();\r\n          ready();\r\n        });\r\n        iframe.srcdoc = editor.iframeHTML;\r\n      }\r\n    };\r\n    const init$1 = (editor, boxInfo) => {\r\n      createIframe(editor, boxInfo);\r\n      if (boxInfo.editorContainer) {\r\n        boxInfo.editorContainer.style.display = editor.orgDisplay;\r\n        editor.hidden = DOM$5.isHidden(boxInfo.editorContainer);\r\n      }\r\n      editor.getElement().style.display = 'none';\r\n      DOM$5.setAttrib(editor.id, 'aria-hidden', 'true');\r\n      editor.getElement().style.visibility = editor.orgVisibility;\r\n      setupIframeBody(editor);\r\n    };\r\n\r\n    const DOM$4 = DOMUtils.DOM;\r\n    const initPlugin = (editor, initializedPlugins, plugin) => {\r\n      const Plugin = PluginManager.get(plugin);\r\n      const pluginUrl = PluginManager.urls[plugin] || editor.documentBaseUrl.replace(/\\/$/, '');\r\n      plugin = Tools.trim(plugin);\r\n      if (Plugin && Tools.inArray(initializedPlugins, plugin) === -1) {\r\n        if (editor.plugins[plugin]) {\r\n          return;\r\n        }\r\n        try {\r\n          const pluginInstance = Plugin(editor, pluginUrl) || {};\r\n          editor.plugins[plugin] = pluginInstance;\r\n          if (isFunction(pluginInstance.init)) {\r\n            pluginInstance.init(editor, pluginUrl);\r\n            initializedPlugins.push(plugin);\r\n          }\r\n        } catch (e) {\r\n          pluginInitError(editor, plugin, e);\r\n        }\r\n      }\r\n    };\r\n    const trimLegacyPrefix = name => {\r\n      return name.replace(/^\\-/, '');\r\n    };\r\n    const initPlugins = editor => {\r\n      const initializedPlugins = [];\r\n      each$e(getPlugins(editor), name => {\r\n        initPlugin(editor, initializedPlugins, trimLegacyPrefix(name));\r\n      });\r\n    };\r\n    const initIcons = editor => {\r\n      const iconPackName = Tools.trim(getIconPackName(editor));\r\n      const currentIcons = editor.ui.registry.getAll().icons;\r\n      const loadIcons = {\r\n        ...IconManager.get('default').icons,\r\n        ...IconManager.get(iconPackName).icons\r\n      };\r\n      each$d(loadIcons, (svgData, icon) => {\r\n        if (!has$2(currentIcons, icon)) {\r\n          editor.ui.registry.addIcon(icon, svgData);\r\n        }\r\n      });\r\n    };\r\n    const initTheme = editor => {\r\n      const theme = getTheme(editor);\r\n      if (isString(theme)) {\r\n        const Theme = ThemeManager.get(theme);\r\n        editor.theme = Theme(editor, ThemeManager.urls[theme]) || {};\r\n        if (isFunction(editor.theme.init)) {\r\n          editor.theme.init(editor, ThemeManager.urls[theme] || editor.documentBaseUrl.replace(/\\/$/, ''));\r\n        }\r\n      } else {\r\n        editor.theme = {};\r\n      }\r\n    };\r\n    const initModel = editor => {\r\n      const model = getModel(editor);\r\n      const Model = ModelManager.get(model);\r\n      editor.model = Model(editor, ModelManager.urls[model]);\r\n    };\r\n    const renderFromLoadedTheme = editor => {\r\n      const render = editor.theme.renderUI;\r\n      return render ? render() : renderThemeFalse(editor);\r\n    };\r\n    const renderFromThemeFunc = editor => {\r\n      const elm = editor.getElement();\r\n      const theme = getTheme(editor);\r\n      const info = theme(editor, elm);\r\n      if (info.editorContainer.nodeType) {\r\n        info.editorContainer.id = info.editorContainer.id || editor.id + '_parent';\r\n      }\r\n      if (info.iframeContainer && info.iframeContainer.nodeType) {\r\n        info.iframeContainer.id = info.iframeContainer.id || editor.id + '_iframecontainer';\r\n      }\r\n      info.height = info.iframeHeight ? info.iframeHeight : elm.offsetHeight;\r\n      return info;\r\n    };\r\n    const createThemeFalseResult = (element, iframe) => {\r\n      return {\r\n        editorContainer: element,\r\n        iframeContainer: iframe,\r\n        api: {}\r\n      };\r\n    };\r\n    const renderThemeFalseIframe = targetElement => {\r\n      const iframeContainer = DOM$4.create('div');\r\n      DOM$4.insertAfter(iframeContainer, targetElement);\r\n      return createThemeFalseResult(iframeContainer, iframeContainer);\r\n    };\r\n    const renderThemeFalse = editor => {\r\n      const targetElement = editor.getElement();\r\n      return editor.inline ? createThemeFalseResult(null) : renderThemeFalseIframe(targetElement);\r\n    };\r\n    const renderThemeUi = editor => {\r\n      const elm = editor.getElement();\r\n      editor.orgDisplay = elm.style.display;\r\n      if (isString(getTheme(editor))) {\r\n        return renderFromLoadedTheme(editor);\r\n      } else if (isFunction(getTheme(editor))) {\r\n        return renderFromThemeFunc(editor);\r\n      } else {\r\n        return renderThemeFalse(editor);\r\n      }\r\n    };\r\n    const augmentEditorUiApi = (editor, api) => {\r\n      const uiApiFacade = {\r\n        show: Optional.from(api.show).getOr(noop),\r\n        hide: Optional.from(api.hide).getOr(noop),\r\n        isEnabled: Optional.from(api.isEnabled).getOr(always),\r\n        setEnabled: state => {\r\n          if (!editor.mode.isReadOnly()) {\r\n            Optional.from(api.setEnabled).each(f => f(state));\r\n          }\r\n        }\r\n      };\r\n      editor.ui = {\r\n        ...editor.ui,\r\n        ...uiApiFacade\r\n      };\r\n    };\r\n    const init = async editor => {\r\n      editor.dispatch('ScriptsLoaded');\r\n      initIcons(editor);\r\n      initTheme(editor);\r\n      initModel(editor);\r\n      initPlugins(editor);\r\n      const renderInfo = await renderThemeUi(editor);\r\n      augmentEditorUiApi(editor, Optional.from(renderInfo.api).getOr({}));\r\n      editor.editorContainer = renderInfo.editorContainer;\r\n      appendContentCssFromSettings(editor);\r\n      if (editor.inline) {\r\n        contentBodyLoaded(editor);\r\n      } else {\r\n        init$1(editor, {\r\n          editorContainer: renderInfo.editorContainer,\r\n          iframeContainer: renderInfo.iframeContainer\r\n        });\r\n      }\r\n    };\r\n\r\n    const DOM$3 = DOMUtils.DOM;\r\n    const hasSkipLoadPrefix = name => name.charAt(0) === '-';\r\n    const loadLanguage = (scriptLoader, editor) => {\r\n      const languageCode = getLanguageCode(editor);\r\n      const languageUrl = getLanguageUrl(editor);\r\n      if (!I18n.hasCode(languageCode) && languageCode !== 'en') {\r\n        const url = isNotEmpty(languageUrl) ? languageUrl : `${ editor.editorManager.baseURL }/langs/${ languageCode }.js`;\r\n        scriptLoader.add(url).catch(() => {\r\n          languageLoadError(editor, url, languageCode);\r\n        });\r\n      }\r\n    };\r\n    const loadTheme = (editor, suffix) => {\r\n      const theme = getTheme(editor);\r\n      if (isString(theme) && !hasSkipLoadPrefix(theme) && !has$2(ThemeManager.urls, theme)) {\r\n        const themeUrl = getThemeUrl(editor);\r\n        const url = themeUrl ? editor.documentBaseURI.toAbsolute(themeUrl) : `themes/${ theme }/theme${ suffix }.js`;\r\n        ThemeManager.load(theme, url).catch(() => {\r\n          themeLoadError(editor, url, theme);\r\n        });\r\n      }\r\n    };\r\n    const loadModel = (editor, suffix) => {\r\n      const model = getModel(editor);\r\n      if (model !== 'plugin' && !has$2(ModelManager.urls, model)) {\r\n        const modelUrl = getModelUrl(editor);\r\n        const url = isString(modelUrl) ? editor.documentBaseURI.toAbsolute(modelUrl) : `models/${ model }/model${ suffix }.js`;\r\n        ModelManager.load(model, url).catch(() => {\r\n          modelLoadError(editor, url, model);\r\n        });\r\n      }\r\n    };\r\n    const getIconsUrlMetaFromUrl = editor => Optional.from(getIconsUrl(editor)).filter(isNotEmpty).map(url => ({\r\n      url,\r\n      name: Optional.none()\r\n    }));\r\n    const getIconsUrlMetaFromName = (editor, name, suffix) => Optional.from(name).filter(name => isNotEmpty(name) && !IconManager.has(name)).map(name => ({\r\n      url: `${ editor.editorManager.baseURL }/icons/${ name }/icons${ suffix }.js`,\r\n      name: Optional.some(name)\r\n    }));\r\n    const loadIcons = (scriptLoader, editor, suffix) => {\r\n      const defaultIconsUrl = getIconsUrlMetaFromName(editor, 'default', suffix);\r\n      const customIconsUrl = getIconsUrlMetaFromUrl(editor).orThunk(() => getIconsUrlMetaFromName(editor, getIconPackName(editor), ''));\r\n      each$e(cat([\r\n        defaultIconsUrl,\r\n        customIconsUrl\r\n      ]), urlMeta => {\r\n        scriptLoader.add(urlMeta.url).catch(() => {\r\n          iconsLoadError(editor, urlMeta.url, urlMeta.name.getOrUndefined());\r\n        });\r\n      });\r\n    };\r\n    const loadPlugins = (editor, suffix) => {\r\n      const loadPlugin = (name, url) => {\r\n        PluginManager.load(name, url).catch(() => {\r\n          pluginLoadError(editor, url, name);\r\n        });\r\n      };\r\n      each$d(getExternalPlugins$1(editor), (url, name) => {\r\n        loadPlugin(name, url);\r\n        editor.options.set('plugins', getPlugins(editor).concat(name));\r\n      });\r\n      each$e(getPlugins(editor), plugin => {\r\n        plugin = Tools.trim(plugin);\r\n        if (plugin && !PluginManager.urls[plugin] && !hasSkipLoadPrefix(plugin)) {\r\n          loadPlugin(plugin, `plugins/${ plugin }/plugin${ suffix }.js`);\r\n        }\r\n      });\r\n    };\r\n    const isThemeLoaded = editor => {\r\n      const theme = getTheme(editor);\r\n      return !isString(theme) || isNonNullable(ThemeManager.get(theme));\r\n    };\r\n    const isModelLoaded = editor => {\r\n      const model = getModel(editor);\r\n      return isNonNullable(ModelManager.get(model));\r\n    };\r\n    const loadScripts = (editor, suffix) => {\r\n      const scriptLoader = ScriptLoader.ScriptLoader;\r\n      const initEditor = () => {\r\n        if (!editor.removed && isThemeLoaded(editor) && isModelLoaded(editor)) {\r\n          init(editor);\r\n        }\r\n      };\r\n      loadTheme(editor, suffix);\r\n      loadModel(editor, suffix);\r\n      loadLanguage(scriptLoader, editor);\r\n      loadIcons(scriptLoader, editor, suffix);\r\n      loadPlugins(editor, suffix);\r\n      scriptLoader.loadQueue().then(initEditor, initEditor);\r\n    };\r\n    const getStyleSheetLoader = (element, editor) => instance.forElement(element, {\r\n      contentCssCors: hasContentCssCors(editor),\r\n      referrerPolicy: getReferrerPolicy(editor)\r\n    });\r\n    const render = editor => {\r\n      const id = editor.id;\r\n      I18n.setCode(getLanguageCode(editor));\r\n      const readyHandler = () => {\r\n        DOM$3.unbind(window, 'ready', readyHandler);\r\n        editor.render();\r\n      };\r\n      if (!EventUtils.Event.domLoaded) {\r\n        DOM$3.bind(window, 'ready', readyHandler);\r\n        return;\r\n      }\r\n      if (!editor.getElement()) {\r\n        return;\r\n      }\r\n      const element = SugarElement.fromDom(editor.getElement());\r\n      const snapshot = clone$4(element);\r\n      editor.on('remove', () => {\r\n        eachr(element.dom.attributes, attr => remove$a(element, attr.name));\r\n        setAll$1(element, snapshot);\r\n      });\r\n      editor.ui.styleSheetLoader = getStyleSheetLoader(element, editor);\r\n      if (!isInline$1(editor)) {\r\n        editor.orgVisibility = editor.getElement().style.visibility;\r\n        editor.getElement().style.visibility = 'hidden';\r\n      } else {\r\n        editor.inline = true;\r\n      }\r\n      const form = editor.getElement().form || DOM$3.getParent(id, 'form');\r\n      if (form) {\r\n        editor.formElement = form;\r\n        if (hasHiddenInput(editor) && !isTextareaOrInput(editor.getElement())) {\r\n          DOM$3.insertAfter(DOM$3.create('input', {\r\n            type: 'hidden',\r\n            name: id\r\n          }), id);\r\n          editor.hasHiddenInput = true;\r\n        }\r\n        editor.formEventDelegate = e => {\r\n          editor.dispatch(e.type, e);\r\n        };\r\n        DOM$3.bind(form, 'submit reset', editor.formEventDelegate);\r\n        editor.on('reset', () => {\r\n          editor.resetContent();\r\n        });\r\n        if (shouldPatchSubmit(editor) && !form.submit.nodeType && !form.submit.length && !form._mceOldSubmit) {\r\n          form._mceOldSubmit = form.submit;\r\n          form.submit = () => {\r\n            editor.editorManager.triggerSave();\r\n            editor.setDirty(false);\r\n            return form._mceOldSubmit(form);\r\n          };\r\n        }\r\n      }\r\n      editor.windowManager = WindowManager(editor);\r\n      editor.notificationManager = NotificationManager(editor);\r\n      if (isEncodingXml(editor)) {\r\n        editor.on('GetContent', e => {\r\n          if (e.save) {\r\n            e.content = DOM$3.encode(e.content);\r\n          }\r\n        });\r\n      }\r\n      if (shouldAddFormSubmitTrigger(editor)) {\r\n        editor.on('submit', () => {\r\n          if (editor.initialized) {\r\n            editor.save();\r\n          }\r\n        });\r\n      }\r\n      if (shouldAddUnloadTrigger(editor)) {\r\n        editor._beforeUnload = () => {\r\n          if (editor.initialized && !editor.destroyed && !editor.isHidden()) {\r\n            editor.save({\r\n              format: 'raw',\r\n              no_events: true,\r\n              set_dirty: false\r\n            });\r\n          }\r\n        };\r\n        editor.editorManager.on('BeforeUnload', editor._beforeUnload);\r\n      }\r\n      editor.editorManager.add(editor);\r\n      loadScripts(editor, editor.suffix);\r\n    };\r\n\r\n    const setEditableRoot = (editor, state) => {\r\n      if (editor._editableRoot !== state) {\r\n        editor._editableRoot = state;\r\n        if (!editor.readonly) {\r\n          editor.getBody().contentEditable = String(editor.hasEditableRoot());\r\n          editor.nodeChanged();\r\n        }\r\n        fireEditableRootStateChange(editor, state);\r\n      }\r\n    };\r\n    const hasEditableRoot = editor => editor._editableRoot;\r\n\r\n    const sectionResult = (sections, settings) => ({\r\n      sections: constant(sections),\r\n      options: constant(settings)\r\n    });\r\n    const deviceDetection = detect$2().deviceType;\r\n    const isPhone = deviceDetection.isPhone();\r\n    const isTablet = deviceDetection.isTablet();\r\n    const normalizePlugins = plugins => {\r\n      if (isNullable(plugins)) {\r\n        return [];\r\n      } else {\r\n        const pluginNames = isArray$1(plugins) ? plugins : plugins.split(/[ ,]/);\r\n        const trimmedPlugins = map$3(pluginNames, trim$4);\r\n        return filter$5(trimmedPlugins, isNotEmpty);\r\n      }\r\n    };\r\n    const extractSections = (keys, options) => {\r\n      const result = bifilter(options, (value, key) => {\r\n        return contains$2(keys, key);\r\n      });\r\n      return sectionResult(result.t, result.f);\r\n    };\r\n    const getSection = (sectionResult, name, defaults = {}) => {\r\n      const sections = sectionResult.sections();\r\n      const sectionOptions = get$a(sections, name).getOr({});\r\n      return Tools.extend({}, defaults, sectionOptions);\r\n    };\r\n    const hasSection = (sectionResult, name) => {\r\n      return has$2(sectionResult.sections(), name);\r\n    };\r\n    const getSectionConfig = (sectionResult, name) => {\r\n      return hasSection(sectionResult, name) ? sectionResult.sections()[name] : {};\r\n    };\r\n    const getMobileOverrideOptions = (mobileOptions, isPhone) => {\r\n      const defaultMobileOptions = {\r\n        table_grid: false,\r\n        object_resizing: false,\r\n        resize: false,\r\n        toolbar_mode: get$a(mobileOptions, 'toolbar_mode').getOr('scrolling'),\r\n        toolbar_sticky: false\r\n      };\r\n      const defaultPhoneOptions = { menubar: false };\r\n      return {\r\n        ...defaultMobileOptions,\r\n        ...isPhone ? defaultPhoneOptions : {}\r\n      };\r\n    };\r\n    const getExternalPlugins = (overrideOptions, options) => {\r\n      var _a;\r\n      const userDefinedExternalPlugins = (_a = options.external_plugins) !== null && _a !== void 0 ? _a : {};\r\n      if (overrideOptions && overrideOptions.external_plugins) {\r\n        return Tools.extend({}, overrideOptions.external_plugins, userDefinedExternalPlugins);\r\n      } else {\r\n        return userDefinedExternalPlugins;\r\n      }\r\n    };\r\n    const combinePlugins = (forcedPlugins, plugins) => [\r\n      ...normalizePlugins(forcedPlugins),\r\n      ...normalizePlugins(plugins)\r\n    ];\r\n    const getPlatformPlugins = (isMobileDevice, sectionResult, desktopPlugins, mobilePlugins) => {\r\n      if (isMobileDevice && hasSection(sectionResult, 'mobile')) {\r\n        return mobilePlugins;\r\n      } else {\r\n        return desktopPlugins;\r\n      }\r\n    };\r\n    const processPlugins = (isMobileDevice, sectionResult, defaultOverrideOptions, options) => {\r\n      const forcedPlugins = normalizePlugins(defaultOverrideOptions.forced_plugins);\r\n      const desktopPlugins = normalizePlugins(options.plugins);\r\n      const mobileConfig = getSectionConfig(sectionResult, 'mobile');\r\n      const mobilePlugins = mobileConfig.plugins ? normalizePlugins(mobileConfig.plugins) : desktopPlugins;\r\n      const platformPlugins = getPlatformPlugins(isMobileDevice, sectionResult, desktopPlugins, mobilePlugins);\r\n      const combinedPlugins = combinePlugins(forcedPlugins, platformPlugins);\r\n      return Tools.extend(options, {\r\n        forced_plugins: forcedPlugins,\r\n        plugins: combinedPlugins\r\n      });\r\n    };\r\n    const isOnMobile = (isMobileDevice, sectionResult) => {\r\n      return isMobileDevice && hasSection(sectionResult, 'mobile');\r\n    };\r\n    const combineOptions = (isMobileDevice, isPhone, defaultOptions, defaultOverrideOptions, options) => {\r\n      var _a;\r\n      const deviceOverrideOptions = isMobileDevice ? { mobile: getMobileOverrideOptions((_a = options.mobile) !== null && _a !== void 0 ? _a : {}, isPhone) } : {};\r\n      const sectionResult = extractSections(['mobile'], deepMerge(deviceOverrideOptions, options));\r\n      const extendedOptions = Tools.extend(defaultOptions, defaultOverrideOptions, sectionResult.options(), isOnMobile(isMobileDevice, sectionResult) ? getSection(sectionResult, 'mobile') : {}, { external_plugins: getExternalPlugins(defaultOverrideOptions, sectionResult.options()) });\r\n      return processPlugins(isMobileDevice, sectionResult, defaultOverrideOptions, extendedOptions);\r\n    };\r\n    const normalizeOptions = (defaultOverrideOptions, options) => combineOptions(isPhone || isTablet, isPhone, options, defaultOverrideOptions, options);\r\n\r\n    const addVisual = (editor, elm) => addVisual$1(editor, elm);\r\n\r\n    const registerExecCommands$3 = editor => {\r\n      const toggleFormat = (name, value) => {\r\n        editor.formatter.toggle(name, value);\r\n        editor.nodeChanged();\r\n      };\r\n      const toggleAlign = align => () => {\r\n        each$e('left,center,right,justify'.split(','), name => {\r\n          if (align !== name) {\r\n            editor.formatter.remove('align' + name);\r\n          }\r\n        });\r\n        if (align !== 'none') {\r\n          toggleFormat('align' + align);\r\n        }\r\n      };\r\n      editor.editorCommands.addCommands({\r\n        JustifyLeft: toggleAlign('left'),\r\n        JustifyCenter: toggleAlign('center'),\r\n        JustifyRight: toggleAlign('right'),\r\n        JustifyFull: toggleAlign('justify'),\r\n        JustifyNone: toggleAlign('none')\r\n      });\r\n    };\r\n    const registerQueryStateCommands$1 = editor => {\r\n      const alignStates = name => () => {\r\n        const selection = editor.selection;\r\n        const nodes = selection.isCollapsed() ? [editor.dom.getParent(selection.getNode(), editor.dom.isBlock)] : selection.getSelectedBlocks();\r\n        return exists(nodes, node => isNonNullable(editor.formatter.matchNode(node, name)));\r\n      };\r\n      editor.editorCommands.addCommands({\r\n        JustifyLeft: alignStates('alignleft'),\r\n        JustifyCenter: alignStates('aligncenter'),\r\n        JustifyRight: alignStates('alignright'),\r\n        JustifyFull: alignStates('alignjustify')\r\n      }, 'state');\r\n    };\r\n    const registerCommands$b = editor => {\r\n      registerExecCommands$3(editor);\r\n      registerQueryStateCommands$1(editor);\r\n    };\r\n\r\n    const registerCommands$a = editor => {\r\n      editor.editorCommands.addCommands({\r\n        'Cut,Copy,Paste': command => {\r\n          const doc = editor.getDoc();\r\n          let failed;\r\n          try {\r\n            doc.execCommand(command);\r\n          } catch (ex) {\r\n            failed = true;\r\n          }\r\n          if (command === 'paste' && !doc.queryCommandEnabled(command)) {\r\n            failed = true;\r\n          }\r\n          if (failed || !doc.queryCommandSupported(command)) {\r\n            let msg = editor.translate(`Your browser doesn't support direct access to the clipboard. ` + 'Please use the Ctrl+X/C/V keyboard shortcuts instead.');\r\n            if (Env.os.isMacOS() || Env.os.isiOS()) {\r\n              msg = msg.replace(/Ctrl\\+/g, '\\u2318+');\r\n            }\r\n            editor.notificationManager.open({\r\n              text: msg,\r\n              type: 'error'\r\n            });\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    const trimOrPadLeftRight = (dom, rng, html, schema) => {\r\n      const root = SugarElement.fromDom(dom.getRoot());\r\n      if (needsToBeNbspLeft(root, CaretPosition.fromRangeStart(rng), schema)) {\r\n        html = html.replace(/^ /, '&nbsp;');\r\n      } else {\r\n        html = html.replace(/^&nbsp;/, ' ');\r\n      }\r\n      if (needsToBeNbspRight(root, CaretPosition.fromRangeEnd(rng), schema)) {\r\n        html = html.replace(/(&nbsp;| )(<br( \\/)>)?$/, '&nbsp;');\r\n      } else {\r\n        html = html.replace(/&nbsp;(<br( \\/)?>)?$/, ' ');\r\n      }\r\n      return html;\r\n    };\r\n\r\n    const processValue$1 = value => {\r\n      if (typeof value !== 'string') {\r\n        const details = Tools.extend({\r\n          paste: value.paste,\r\n          data: { paste: value.paste }\r\n        }, value);\r\n        return {\r\n          content: value.content,\r\n          details\r\n        };\r\n      }\r\n      return {\r\n        content: value,\r\n        details: {}\r\n      };\r\n    };\r\n    const trimOrPad = (editor, value) => {\r\n      const selection = editor.selection;\r\n      const dom = editor.dom;\r\n      if (/^ | $/.test(value)) {\r\n        return trimOrPadLeftRight(dom, selection.getRng(), value, editor.schema);\r\n      } else {\r\n        return value;\r\n      }\r\n    };\r\n    const insertAtCaret = (editor, value) => {\r\n      if (editor.selection.isEditable()) {\r\n        const {content, details} = processValue$1(value);\r\n        preProcessSetContent(editor, {\r\n          ...details,\r\n          content: trimOrPad(editor, content),\r\n          format: 'html',\r\n          set: false,\r\n          selection: true\r\n        }).each(args => {\r\n          const insertedContent = insertContent$1(editor, args.content, details);\r\n          postProcessSetContent(editor, insertedContent, args);\r\n          editor.addVisual();\r\n        });\r\n      }\r\n    };\r\n\r\n    const registerCommands$9 = editor => {\r\n      editor.editorCommands.addCommands({\r\n        mceCleanup: () => {\r\n          const bm = editor.selection.getBookmark();\r\n          editor.setContent(editor.getContent());\r\n          editor.selection.moveToBookmark(bm);\r\n        },\r\n        insertImage: (_command, _ui, value) => {\r\n          insertAtCaret(editor, editor.dom.createHTML('img', { src: value }));\r\n        },\r\n        insertHorizontalRule: () => {\r\n          editor.execCommand('mceInsertContent', false, '<hr>');\r\n        },\r\n        insertText: (_command, _ui, value) => {\r\n          insertAtCaret(editor, editor.dom.encode(value));\r\n        },\r\n        insertHTML: (_command, _ui, value) => {\r\n          insertAtCaret(editor, value);\r\n        },\r\n        mceInsertContent: (_command, _ui, value) => {\r\n          insertAtCaret(editor, value);\r\n        },\r\n        mceSetContent: (_command, _ui, value) => {\r\n          editor.setContent(value);\r\n        },\r\n        mceReplaceContent: (_command, _ui, value) => {\r\n          editor.execCommand('mceInsertContent', false, value.replace(/\\{\\$selection\\}/g, editor.selection.getContent({ format: 'text' })));\r\n        },\r\n        mceNewDocument: () => {\r\n          editor.setContent(getNewDocumentContent(editor));\r\n        }\r\n      });\r\n    };\r\n\r\n    const legacyPropNames = {\r\n      'font-size': 'size',\r\n      'font-family': 'face'\r\n    };\r\n    const isFont = isTag('font');\r\n    const getSpecifiedFontProp = (propName, rootElm, elm) => {\r\n      const getProperty = elm => getRaw(elm, propName).orThunk(() => {\r\n        if (isFont(elm)) {\r\n          return get$a(legacyPropNames, propName).bind(legacyPropName => getOpt(elm, legacyPropName));\r\n        } else {\r\n          return Optional.none();\r\n        }\r\n      });\r\n      const isRoot = elm => eq(SugarElement.fromDom(rootElm), elm);\r\n      return closest$1(SugarElement.fromDom(elm), elm => getProperty(elm), isRoot);\r\n    };\r\n    const normalizeFontFamily = fontFamily => fontFamily.replace(/[\\'\\\"\\\\]/g, '').replace(/,\\s+/g, ',');\r\n    const getComputedFontProp = (propName, elm) => Optional.from(DOMUtils.DOM.getStyle(elm, propName, true));\r\n    const getFontProp = propName => (rootElm, elm) => Optional.from(elm).map(SugarElement.fromDom).filter(isElement$7).bind(element => getSpecifiedFontProp(propName, rootElm, element.dom).or(getComputedFontProp(propName, element.dom))).getOr('');\r\n    const getFontSize = getFontProp('font-size');\r\n    const getFontFamily = compose(normalizeFontFamily, getFontProp('font-family'));\r\n\r\n    const findFirstCaretElement = editor => firstPositionIn(editor.getBody()).bind(caret => {\r\n      const container = caret.container();\r\n      return Optional.from(isText$a(container) ? container.parentNode : container);\r\n    });\r\n    const getCaretElement = editor => Optional.from(editor.selection.getRng()).bind(rng => {\r\n      const root = editor.getBody();\r\n      const atStartOfNode = rng.startContainer === root && rng.startOffset === 0;\r\n      return atStartOfNode ? Optional.none() : Optional.from(editor.selection.getStart(true));\r\n    });\r\n    const bindRange = (editor, binder) => getCaretElement(editor).orThunk(curry(findFirstCaretElement, editor)).map(SugarElement.fromDom).filter(isElement$7).bind(binder);\r\n    const mapRange = (editor, mapper) => bindRange(editor, compose1(Optional.some, mapper));\r\n\r\n    const fromFontSizeNumber = (editor, value) => {\r\n      if (/^[0-9.]+$/.test(value)) {\r\n        const fontSizeNumber = parseInt(value, 10);\r\n        if (fontSizeNumber >= 1 && fontSizeNumber <= 7) {\r\n          const fontSizes = getFontStyleValues(editor);\r\n          const fontClasses = getFontSizeClasses(editor);\r\n          if (fontClasses.length > 0) {\r\n            return fontClasses[fontSizeNumber - 1] || value;\r\n          } else {\r\n            return fontSizes[fontSizeNumber - 1] || value;\r\n          }\r\n        } else {\r\n          return value;\r\n        }\r\n      } else {\r\n        return value;\r\n      }\r\n    };\r\n    const normalizeFontNames = font => {\r\n      const fonts = font.split(/\\s*,\\s*/);\r\n      return map$3(fonts, font => {\r\n        if (font.indexOf(' ') !== -1 && !(startsWith(font, '\"') || startsWith(font, `'`))) {\r\n          return `'${ font }'`;\r\n        } else {\r\n          return font;\r\n        }\r\n      }).join(',');\r\n    };\r\n    const fontNameAction = (editor, value) => {\r\n      const font = fromFontSizeNumber(editor, value);\r\n      editor.formatter.toggle('fontname', { value: normalizeFontNames(font) });\r\n      editor.nodeChanged();\r\n    };\r\n    const fontNameQuery = editor => mapRange(editor, elm => getFontFamily(editor.getBody(), elm.dom)).getOr('');\r\n    const fontSizeAction = (editor, value) => {\r\n      editor.formatter.toggle('fontsize', { value: fromFontSizeNumber(editor, value) });\r\n      editor.nodeChanged();\r\n    };\r\n    const fontSizeQuery = editor => mapRange(editor, elm => getFontSize(editor.getBody(), elm.dom)).getOr('');\r\n\r\n    const lineHeightQuery = editor => mapRange(editor, elm => {\r\n      const root = SugarElement.fromDom(editor.getBody());\r\n      const specifiedStyle = closest$1(elm, elm => getRaw(elm, 'line-height'), curry(eq, root));\r\n      const computedStyle = () => {\r\n        const lineHeight = parseFloat(get$7(elm, 'line-height'));\r\n        const fontSize = parseFloat(get$7(elm, 'font-size'));\r\n        return String(lineHeight / fontSize);\r\n      };\r\n      return specifiedStyle.getOrThunk(computedStyle);\r\n    }).getOr('');\r\n    const lineHeightAction = (editor, lineHeight) => {\r\n      editor.formatter.toggle('lineheight', { value: String(lineHeight) });\r\n      editor.nodeChanged();\r\n    };\r\n\r\n    const registerExecCommands$2 = editor => {\r\n      const toggleFormat = (name, value) => {\r\n        editor.formatter.toggle(name, value);\r\n        editor.nodeChanged();\r\n      };\r\n      editor.editorCommands.addCommands({\r\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => {\r\n          toggleFormat(command);\r\n        },\r\n        'ForeColor,HiliteColor': (command, _ui, value) => {\r\n          toggleFormat(command, { value });\r\n        },\r\n        'BackColor': (_command, _ui, value) => {\r\n          toggleFormat('hilitecolor', { value });\r\n        },\r\n        'FontName': (_command, _ui, value) => {\r\n          fontNameAction(editor, value);\r\n        },\r\n        'FontSize': (_command, _ui, value) => {\r\n          fontSizeAction(editor, value);\r\n        },\r\n        'LineHeight': (_command, _ui, value) => {\r\n          lineHeightAction(editor, value);\r\n        },\r\n        'Lang': (command, _ui, lang) => {\r\n          var _a;\r\n          toggleFormat(command, {\r\n            value: lang.code,\r\n            customValue: (_a = lang.customCode) !== null && _a !== void 0 ? _a : null\r\n          });\r\n        },\r\n        'RemoveFormat': command => {\r\n          editor.formatter.remove(command);\r\n        },\r\n        'mceBlockQuote': () => {\r\n          toggleFormat('blockquote');\r\n        },\r\n        'FormatBlock': (_command, _ui, value) => {\r\n          toggleFormat(isString(value) ? value : 'p');\r\n        },\r\n        'mceToggleFormat': (_command, _ui, value) => {\r\n          toggleFormat(value);\r\n        }\r\n      });\r\n    };\r\n    const registerQueryValueCommands = editor => {\r\n      const isFormatMatch = name => editor.formatter.match(name);\r\n      editor.editorCommands.addCommands({\r\n        'Bold,Italic,Underline,Strikethrough,Superscript,Subscript': command => isFormatMatch(command),\r\n        'mceBlockQuote': () => isFormatMatch('blockquote')\r\n      }, 'state');\r\n      editor.editorCommands.addQueryValueHandler('FontName', () => fontNameQuery(editor));\r\n      editor.editorCommands.addQueryValueHandler('FontSize', () => fontSizeQuery(editor));\r\n      editor.editorCommands.addQueryValueHandler('LineHeight', () => lineHeightQuery(editor));\r\n    };\r\n    const registerCommands$8 = editor => {\r\n      registerExecCommands$2(editor);\r\n      registerQueryValueCommands(editor);\r\n    };\r\n\r\n    const registerCommands$7 = editor => {\r\n      editor.editorCommands.addCommands({\r\n        mceAddUndoLevel: () => {\r\n          editor.undoManager.add();\r\n        },\r\n        mceEndUndoLevel: () => {\r\n          editor.undoManager.add();\r\n        },\r\n        Undo: () => {\r\n          editor.undoManager.undo();\r\n        },\r\n        Redo: () => {\r\n          editor.undoManager.redo();\r\n        }\r\n      });\r\n    };\r\n\r\n    const registerCommands$6 = editor => {\r\n      editor.editorCommands.addCommands({\r\n        Indent: () => {\r\n          indent(editor);\r\n        },\r\n        Outdent: () => {\r\n          outdent(editor);\r\n        }\r\n      });\r\n      editor.editorCommands.addCommands({ Outdent: () => canOutdent(editor) }, 'state');\r\n    };\r\n\r\n    const registerCommands$5 = editor => {\r\n      const applyLinkToSelection = (_command, _ui, value) => {\r\n        const linkDetails = isString(value) ? { href: value } : value;\r\n        const anchor = editor.dom.getParent(editor.selection.getNode(), 'a');\r\n        if (isObject(linkDetails) && isString(linkDetails.href)) {\r\n          linkDetails.href = linkDetails.href.replace(/ /g, '%20');\r\n          if (!anchor || !linkDetails.href) {\r\n            editor.formatter.remove('link');\r\n          }\r\n          if (linkDetails.href) {\r\n            editor.formatter.apply('link', linkDetails, anchor);\r\n          }\r\n        }\r\n      };\r\n      editor.editorCommands.addCommands({\r\n        unlink: () => {\r\n          if (editor.selection.isEditable()) {\r\n            if (editor.selection.isCollapsed()) {\r\n              const elm = editor.dom.getParent(editor.selection.getStart(), 'a');\r\n              if (elm) {\r\n                editor.dom.remove(elm, true);\r\n              }\r\n              return;\r\n            }\r\n            editor.formatter.remove('link');\r\n          }\r\n        },\r\n        mceInsertLink: applyLinkToSelection,\r\n        createLink: applyLinkToSelection\r\n      });\r\n    };\r\n\r\n    const registerExecCommands$1 = editor => {\r\n      editor.editorCommands.addCommands({\r\n        'InsertUnorderedList,InsertOrderedList': command => {\r\n          editor.getDoc().execCommand(command);\r\n          const listElm = editor.dom.getParent(editor.selection.getNode(), 'ol,ul');\r\n          if (listElm) {\r\n            const listParent = listElm.parentNode;\r\n            if (listParent && /^(H[1-6]|P|ADDRESS|PRE)$/.test(listParent.nodeName)) {\r\n              const bm = editor.selection.getBookmark();\r\n              editor.dom.split(listParent, listElm);\r\n              editor.selection.moveToBookmark(bm);\r\n            }\r\n          }\r\n        }\r\n      });\r\n    };\r\n    const registerQueryStateCommands = editor => {\r\n      editor.editorCommands.addCommands({\r\n        'InsertUnorderedList,InsertOrderedList': command => {\r\n          const list = editor.dom.getParent(editor.selection.getNode(), 'ul,ol');\r\n          return list && (command === 'insertunorderedlist' && list.tagName === 'UL' || command === 'insertorderedlist' && list.tagName === 'OL');\r\n        }\r\n      }, 'state');\r\n    };\r\n    const registerCommands$4 = editor => {\r\n      registerExecCommands$1(editor);\r\n      registerQueryStateCommands(editor);\r\n    };\r\n\r\n    const getTopParentBlock = (editor, node, root, container) => {\r\n      const dom = editor.dom;\r\n      const selector = node => dom.isBlock(node) && node.parentElement === root;\r\n      const topParentBlock = selector(node) ? node : dom.getParent(container, selector, root);\r\n      return Optional.from(topParentBlock).map(SugarElement.fromDom);\r\n    };\r\n    const insert = (editor, before) => {\r\n      const dom = editor.dom;\r\n      const rng = editor.selection.getRng();\r\n      const node = before ? editor.selection.getStart() : editor.selection.getEnd();\r\n      const container = before ? rng.startContainer : rng.endContainer;\r\n      const root = getEditableRoot(dom, container);\r\n      if (!root || !root.isContentEditable) {\r\n        return;\r\n      }\r\n      const insertFn = before ? before$3 : after$4;\r\n      const newBlockName = getForcedRootBlock(editor);\r\n      getTopParentBlock(editor, node, root, container).each(parentBlock => {\r\n        const newBlock = createNewBlock(editor, container, parentBlock.dom, root, false, newBlockName);\r\n        insertFn(parentBlock, SugarElement.fromDom(newBlock));\r\n        editor.selection.setCursorLocation(newBlock, 0);\r\n        editor.dispatch('NewBlock', { newBlock });\r\n        fireInputEvent(editor, 'insertParagraph');\r\n      });\r\n    };\r\n    const insertBefore = editor => insert(editor, true);\r\n    const insertAfter = editor => insert(editor, false);\r\n\r\n    const registerCommands$3 = editor => {\r\n      editor.editorCommands.addCommands({\r\n        InsertNewBlockBefore: () => {\r\n          insertBefore(editor);\r\n        },\r\n        InsertNewBlockAfter: () => {\r\n          insertAfter(editor);\r\n        }\r\n      });\r\n    };\r\n\r\n    const registerCommands$2 = editor => {\r\n      editor.editorCommands.addCommands({\r\n        insertParagraph: () => {\r\n          insertBreak(blockbreak, editor);\r\n        },\r\n        mceInsertNewLine: (_command, _ui, value) => {\r\n          insert$1(editor, value);\r\n        },\r\n        InsertLineBreak: (_command, _ui, _value) => {\r\n          insertBreak(linebreak, editor);\r\n        }\r\n      });\r\n    };\r\n\r\n    const registerCommands$1 = editor => {\r\n      editor.editorCommands.addCommands({\r\n        mceSelectNodeDepth: (_command, _ui, value) => {\r\n          let counter = 0;\r\n          editor.dom.getParent(editor.selection.getNode(), node => {\r\n            if (isElement$6(node) && counter++ === value) {\r\n              editor.selection.select(node);\r\n              return false;\r\n            } else {\r\n              return true;\r\n            }\r\n          }, editor.getBody());\r\n        },\r\n        mceSelectNode: (_command, _ui, value) => {\r\n          editor.selection.select(value);\r\n        },\r\n        selectAll: () => {\r\n          const editingHost = editor.dom.getParent(editor.selection.getStart(), isContentEditableTrue$3);\r\n          if (editingHost) {\r\n            const rng = editor.dom.createRng();\r\n            rng.selectNodeContents(editingHost);\r\n            editor.selection.setRng(rng);\r\n          }\r\n        }\r\n      });\r\n    };\r\n\r\n    const registerExecCommands = editor => {\r\n      editor.editorCommands.addCommands({\r\n        mceRemoveNode: (_command, _ui, value) => {\r\n          const node = value !== null && value !== void 0 ? value : editor.selection.getNode();\r\n          if (node !== editor.getBody()) {\r\n            const bm = editor.selection.getBookmark();\r\n            editor.dom.remove(node, true);\r\n            editor.selection.moveToBookmark(bm);\r\n          }\r\n        },\r\n        mcePrint: () => {\r\n          editor.getWin().print();\r\n        },\r\n        mceFocus: (_command, _ui, value) => {\r\n          focus(editor, value === true);\r\n        },\r\n        mceToggleVisualAid: () => {\r\n          editor.hasVisual = !editor.hasVisual;\r\n          editor.addVisual();\r\n        }\r\n      });\r\n    };\r\n    const registerCommands = editor => {\r\n      registerCommands$b(editor);\r\n      registerCommands$a(editor);\r\n      registerCommands$7(editor);\r\n      registerCommands$1(editor);\r\n      registerCommands$9(editor);\r\n      registerCommands$5(editor);\r\n      registerCommands$6(editor);\r\n      registerCommands$3(editor);\r\n      registerCommands$2(editor);\r\n      registerCommands$4(editor);\r\n      registerCommands$8(editor);\r\n      registerExecCommands(editor);\r\n    };\r\n\r\n    const selectionSafeCommands = ['toggleview'];\r\n    const isSelectionSafeCommand = command => contains$2(selectionSafeCommands, command.toLowerCase());\r\n    class EditorCommands {\r\n      constructor(editor) {\r\n        this.commands = {\r\n          state: {},\r\n          exec: {},\r\n          value: {}\r\n        };\r\n        this.editor = editor;\r\n      }\r\n      execCommand(command, ui = false, value, args) {\r\n        const editor = this.editor;\r\n        const lowerCaseCommand = command.toLowerCase();\r\n        const skipFocus = args === null || args === void 0 ? void 0 : args.skip_focus;\r\n        if (editor.removed) {\r\n          return false;\r\n        }\r\n        if (lowerCaseCommand !== 'mcefocus') {\r\n          if (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(lowerCaseCommand) && !skipFocus) {\r\n            editor.focus();\r\n          } else {\r\n            restore(editor);\r\n          }\r\n        }\r\n        const eventArgs = editor.dispatch('BeforeExecCommand', {\r\n          command,\r\n          ui,\r\n          value\r\n        });\r\n        if (eventArgs.isDefaultPrevented()) {\r\n          return false;\r\n        }\r\n        const func = this.commands.exec[lowerCaseCommand];\r\n        if (isFunction(func)) {\r\n          func(lowerCaseCommand, ui, value);\r\n          editor.dispatch('ExecCommand', {\r\n            command,\r\n            ui,\r\n            value\r\n          });\r\n          return true;\r\n        }\r\n        return false;\r\n      }\r\n      queryCommandState(command) {\r\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\r\n          return false;\r\n        }\r\n        const lowerCaseCommand = command.toLowerCase();\r\n        const func = this.commands.state[lowerCaseCommand];\r\n        if (isFunction(func)) {\r\n          return func(lowerCaseCommand);\r\n        }\r\n        return false;\r\n      }\r\n      queryCommandValue(command) {\r\n        if (!isSelectionSafeCommand(command) && this.editor.quirks.isHidden() || this.editor.removed) {\r\n          return '';\r\n        }\r\n        const lowerCaseCommand = command.toLowerCase();\r\n        const func = this.commands.value[lowerCaseCommand];\r\n        if (isFunction(func)) {\r\n          return func(lowerCaseCommand);\r\n        }\r\n        return '';\r\n      }\r\n      addCommands(commandList, type = 'exec') {\r\n        const commands = this.commands;\r\n        each$d(commandList, (callback, command) => {\r\n          each$e(command.toLowerCase().split(','), command => {\r\n            commands[type][command] = callback;\r\n          });\r\n        });\r\n      }\r\n      addCommand(command, callback, scope) {\r\n        const lowerCaseCommand = command.toLowerCase();\r\n        this.commands.exec[lowerCaseCommand] = (_command, ui, value) => callback.call(scope !== null && scope !== void 0 ? scope : this.editor, ui, value);\r\n      }\r\n      queryCommandSupported(command) {\r\n        const lowerCaseCommand = command.toLowerCase();\r\n        if (this.commands.exec[lowerCaseCommand]) {\r\n          return true;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      addQueryStateHandler(command, callback, scope) {\r\n        this.commands.state[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\r\n      }\r\n      addQueryValueHandler(command, callback, scope) {\r\n        this.commands.value[command.toLowerCase()] = () => callback.call(scope !== null && scope !== void 0 ? scope : this.editor);\r\n      }\r\n    }\r\n\r\n    const internalContentEditableAttr = 'data-mce-contenteditable';\r\n    const toggleClass = (elm, cls, state) => {\r\n      if (has(elm, cls) && !state) {\r\n        remove$7(elm, cls);\r\n      } else if (state) {\r\n        add$2(elm, cls);\r\n      }\r\n    };\r\n    const setEditorCommandState = (editor, cmd, state) => {\r\n      try {\r\n        editor.getDoc().execCommand(cmd, false, String(state));\r\n      } catch (ex) {\r\n      }\r\n    };\r\n    const setContentEditable = (elm, state) => {\r\n      elm.dom.contentEditable = state ? 'true' : 'false';\r\n    };\r\n    const switchOffContentEditableTrue = elm => {\r\n      each$e(descendants(elm, '*[contenteditable=\"true\"]'), elm => {\r\n        set$3(elm, internalContentEditableAttr, 'true');\r\n        setContentEditable(elm, false);\r\n      });\r\n    };\r\n    const switchOnContentEditableTrue = elm => {\r\n      each$e(descendants(elm, `*[${ internalContentEditableAttr }=\"true\"]`), elm => {\r\n        remove$a(elm, internalContentEditableAttr);\r\n        setContentEditable(elm, true);\r\n      });\r\n    };\r\n    const removeFakeSelection = editor => {\r\n      Optional.from(editor.selection.getNode()).each(elm => {\r\n        elm.removeAttribute('data-mce-selected');\r\n      });\r\n    };\r\n    const restoreFakeSelection = editor => {\r\n      editor.selection.setRng(editor.selection.getRng());\r\n    };\r\n    const toggleReadOnly = (editor, state) => {\r\n      const body = SugarElement.fromDom(editor.getBody());\r\n      toggleClass(body, 'mce-content-readonly', state);\r\n      if (state) {\r\n        editor.selection.controlSelection.hideResizeRect();\r\n        editor._selectionOverrides.hideFakeCaret();\r\n        removeFakeSelection(editor);\r\n        editor.readonly = true;\r\n        setContentEditable(body, false);\r\n        switchOffContentEditableTrue(body);\r\n      } else {\r\n        editor.readonly = false;\r\n        if (editor.hasEditableRoot()) {\r\n          setContentEditable(body, true);\r\n        }\r\n        switchOnContentEditableTrue(body);\r\n        setEditorCommandState(editor, 'StyleWithCSS', false);\r\n        setEditorCommandState(editor, 'enableInlineTableEditing', false);\r\n        setEditorCommandState(editor, 'enableObjectResizing', false);\r\n        if (hasEditorOrUiFocus(editor)) {\r\n          editor.focus();\r\n        }\r\n        restoreFakeSelection(editor);\r\n        editor.nodeChanged();\r\n      }\r\n    };\r\n    const isReadOnly = editor => editor.readonly;\r\n    const registerFilters = editor => {\r\n      editor.parser.addAttributeFilter('contenteditable', nodes => {\r\n        if (isReadOnly(editor)) {\r\n          each$e(nodes, node => {\r\n            node.attr(internalContentEditableAttr, node.attr('contenteditable'));\r\n            node.attr('contenteditable', 'false');\r\n          });\r\n        }\r\n      });\r\n      editor.serializer.addAttributeFilter(internalContentEditableAttr, nodes => {\r\n        if (isReadOnly(editor)) {\r\n          each$e(nodes, node => {\r\n            node.attr('contenteditable', node.attr(internalContentEditableAttr));\r\n          });\r\n        }\r\n      });\r\n      editor.serializer.addTempAttr(internalContentEditableAttr);\r\n    };\r\n    const registerReadOnlyContentFilters = editor => {\r\n      if (editor.serializer) {\r\n        registerFilters(editor);\r\n      } else {\r\n        editor.on('PreInit', () => {\r\n          registerFilters(editor);\r\n        });\r\n      }\r\n    };\r\n    const isClickEvent = e => e.type === 'click';\r\n    const allowedEvents = ['copy'];\r\n    const isReadOnlyAllowedEvent = e => contains$2(allowedEvents, e.type);\r\n    const getAnchorHrefOpt = (editor, elm) => {\r\n      const isRoot = elm => eq(elm, SugarElement.fromDom(editor.getBody()));\r\n      return closest$3(elm, 'a', isRoot).bind(a => getOpt(a, 'href'));\r\n    };\r\n    const processReadonlyEvents = (editor, e) => {\r\n      if (isClickEvent(e) && !VK.metaKeyPressed(e)) {\r\n        const elm = SugarElement.fromDom(e.target);\r\n        getAnchorHrefOpt(editor, elm).each(href => {\r\n          e.preventDefault();\r\n          if (/^#/.test(href)) {\r\n            const targetEl = editor.dom.select(`${ href },[name=\"${ removeLeading(href, '#') }\"]`);\r\n            if (targetEl.length) {\r\n              editor.selection.scrollIntoView(targetEl[0], true);\r\n            }\r\n          } else {\r\n            window.open(href, '_blank', 'rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes');\r\n          }\r\n        });\r\n      } else if (isReadOnlyAllowedEvent(e)) {\r\n        editor.dispatch(e.type, e);\r\n      }\r\n    };\r\n    const registerReadOnlySelectionBlockers = editor => {\r\n      editor.on('ShowCaret', e => {\r\n        if (isReadOnly(editor)) {\r\n          e.preventDefault();\r\n        }\r\n      });\r\n      editor.on('ObjectSelected', e => {\r\n        if (isReadOnly(editor)) {\r\n          e.preventDefault();\r\n        }\r\n      });\r\n    };\r\n\r\n    const nativeEvents = Tools.makeMap('focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange ' + 'mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover ' + 'draggesture dragdrop drop drag submit ' + 'compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel', ' ');\r\n    class EventDispatcher {\r\n      static isNative(name) {\r\n        return !!nativeEvents[name.toLowerCase()];\r\n      }\r\n      constructor(settings) {\r\n        this.bindings = {};\r\n        this.settings = settings || {};\r\n        this.scope = this.settings.scope || this;\r\n        this.toggleEvent = this.settings.toggleEvent || never;\r\n      }\r\n      fire(name, args) {\r\n        return this.dispatch(name, args);\r\n      }\r\n      dispatch(name, args) {\r\n        const lcName = name.toLowerCase();\r\n        const event = normalize$3(lcName, args !== null && args !== void 0 ? args : {}, this.scope);\r\n        if (this.settings.beforeFire) {\r\n          this.settings.beforeFire(event);\r\n        }\r\n        const handlers = this.bindings[lcName];\r\n        if (handlers) {\r\n          for (let i = 0, l = handlers.length; i < l; i++) {\r\n            const callback = handlers[i];\r\n            if (callback.removed) {\r\n              continue;\r\n            }\r\n            if (callback.once) {\r\n              this.off(lcName, callback.func);\r\n            }\r\n            if (event.isImmediatePropagationStopped()) {\r\n              return event;\r\n            }\r\n            if (callback.func.call(this.scope, event) === false) {\r\n              event.preventDefault();\r\n              return event;\r\n            }\r\n          }\r\n        }\r\n        return event;\r\n      }\r\n      on(name, callback, prepend, extra) {\r\n        if (callback === false) {\r\n          callback = never;\r\n        }\r\n        if (callback) {\r\n          const wrappedCallback = {\r\n            func: callback,\r\n            removed: false\r\n          };\r\n          if (extra) {\r\n            Tools.extend(wrappedCallback, extra);\r\n          }\r\n          const names = name.toLowerCase().split(' ');\r\n          let i = names.length;\r\n          while (i--) {\r\n            const currentName = names[i];\r\n            let handlers = this.bindings[currentName];\r\n            if (!handlers) {\r\n              handlers = [];\r\n              this.toggleEvent(currentName, true);\r\n            }\r\n            if (prepend) {\r\n              handlers = [\r\n                wrappedCallback,\r\n                ...handlers\r\n              ];\r\n            } else {\r\n              handlers = [\r\n                ...handlers,\r\n                wrappedCallback\r\n              ];\r\n            }\r\n            this.bindings[currentName] = handlers;\r\n          }\r\n        }\r\n        return this;\r\n      }\r\n      off(name, callback) {\r\n        if (name) {\r\n          const names = name.toLowerCase().split(' ');\r\n          let i = names.length;\r\n          while (i--) {\r\n            const currentName = names[i];\r\n            let handlers = this.bindings[currentName];\r\n            if (!currentName) {\r\n              each$d(this.bindings, (_value, bindingName) => {\r\n                this.toggleEvent(bindingName, false);\r\n                delete this.bindings[bindingName];\r\n              });\r\n              return this;\r\n            }\r\n            if (handlers) {\r\n              if (!callback) {\r\n                handlers.length = 0;\r\n              } else {\r\n                const filteredHandlers = partition$2(handlers, handler => handler.func === callback);\r\n                handlers = filteredHandlers.fail;\r\n                this.bindings[currentName] = handlers;\r\n                each$e(filteredHandlers.pass, handler => {\r\n                  handler.removed = true;\r\n                });\r\n              }\r\n              if (!handlers.length) {\r\n                this.toggleEvent(name, false);\r\n                delete this.bindings[currentName];\r\n              }\r\n            }\r\n          }\r\n        } else {\r\n          each$d(this.bindings, (_value, name) => {\r\n            this.toggleEvent(name, false);\r\n          });\r\n          this.bindings = {};\r\n        }\r\n        return this;\r\n      }\r\n      once(name, callback, prepend) {\r\n        return this.on(name, callback, prepend, { once: true });\r\n      }\r\n      has(name) {\r\n        name = name.toLowerCase();\r\n        const binding = this.bindings[name];\r\n        return !(!binding || binding.length === 0);\r\n      }\r\n    }\r\n\r\n    const getEventDispatcher = obj => {\r\n      if (!obj._eventDispatcher) {\r\n        obj._eventDispatcher = new EventDispatcher({\r\n          scope: obj,\r\n          toggleEvent: (name, state) => {\r\n            if (EventDispatcher.isNative(name) && obj.toggleNativeEvent) {\r\n              obj.toggleNativeEvent(name, state);\r\n            }\r\n          }\r\n        });\r\n      }\r\n      return obj._eventDispatcher;\r\n    };\r\n    const Observable = {\r\n      fire(name, args, bubble) {\r\n        return this.dispatch(name, args, bubble);\r\n      },\r\n      dispatch(name, args, bubble) {\r\n        const self = this;\r\n        if (self.removed && name !== 'remove' && name !== 'detach') {\r\n          return normalize$3(name.toLowerCase(), args !== null && args !== void 0 ? args : {}, self);\r\n        }\r\n        const dispatcherArgs = getEventDispatcher(self).dispatch(name, args);\r\n        if (bubble !== false && self.parent) {\r\n          let parent = self.parent();\r\n          while (parent && !dispatcherArgs.isPropagationStopped()) {\r\n            parent.dispatch(name, dispatcherArgs, false);\r\n            parent = parent.parent ? parent.parent() : undefined;\r\n          }\r\n        }\r\n        return dispatcherArgs;\r\n      },\r\n      on(name, callback, prepend) {\r\n        return getEventDispatcher(this).on(name, callback, prepend);\r\n      },\r\n      off(name, callback) {\r\n        return getEventDispatcher(this).off(name, callback);\r\n      },\r\n      once(name, callback) {\r\n        return getEventDispatcher(this).once(name, callback);\r\n      },\r\n      hasEventListeners(name) {\r\n        return getEventDispatcher(this).has(name);\r\n      }\r\n    };\r\n\r\n    const DOM$2 = DOMUtils.DOM;\r\n    let customEventRootDelegates;\r\n    const getEventTarget = (editor, eventName) => {\r\n      if (eventName === 'selectionchange') {\r\n        return editor.getDoc();\r\n      }\r\n      if (!editor.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(eventName)) {\r\n        return editor.getDoc().documentElement;\r\n      }\r\n      const eventRoot = getEventRoot(editor);\r\n      if (eventRoot) {\r\n        if (!editor.eventRoot) {\r\n          editor.eventRoot = DOM$2.select(eventRoot)[0];\r\n        }\r\n        return editor.eventRoot;\r\n      }\r\n      return editor.getBody();\r\n    };\r\n    const isListening = editor => !editor.hidden && !isReadOnly(editor);\r\n    const fireEvent = (editor, eventName, e) => {\r\n      if (isListening(editor)) {\r\n        editor.dispatch(eventName, e);\r\n      } else if (isReadOnly(editor)) {\r\n        processReadonlyEvents(editor, e);\r\n      }\r\n    };\r\n    const bindEventDelegate = (editor, eventName) => {\r\n      if (!editor.delegates) {\r\n        editor.delegates = {};\r\n      }\r\n      if (editor.delegates[eventName] || editor.removed) {\r\n        return;\r\n      }\r\n      const eventRootElm = getEventTarget(editor, eventName);\r\n      if (getEventRoot(editor)) {\r\n        if (!customEventRootDelegates) {\r\n          customEventRootDelegates = {};\r\n          editor.editorManager.on('removeEditor', () => {\r\n            if (!editor.editorManager.activeEditor) {\r\n              if (customEventRootDelegates) {\r\n                each$d(customEventRootDelegates, (_value, name) => {\r\n                  editor.dom.unbind(getEventTarget(editor, name));\r\n                });\r\n                customEventRootDelegates = null;\r\n              }\r\n            }\r\n          });\r\n        }\r\n        if (customEventRootDelegates[eventName]) {\r\n          return;\r\n        }\r\n        const delegate = e => {\r\n          const target = e.target;\r\n          const editors = editor.editorManager.get();\r\n          let i = editors.length;\r\n          while (i--) {\r\n            const body = editors[i].getBody();\r\n            if (body === target || DOM$2.isChildOf(target, body)) {\r\n              fireEvent(editors[i], eventName, e);\r\n            }\r\n          }\r\n        };\r\n        customEventRootDelegates[eventName] = delegate;\r\n        DOM$2.bind(eventRootElm, eventName, delegate);\r\n      } else {\r\n        const delegate = e => {\r\n          fireEvent(editor, eventName, e);\r\n        };\r\n        DOM$2.bind(eventRootElm, eventName, delegate);\r\n        editor.delegates[eventName] = delegate;\r\n      }\r\n    };\r\n    const EditorObservable = {\r\n      ...Observable,\r\n      bindPendingEventDelegates() {\r\n        const self = this;\r\n        Tools.each(self._pendingNativeEvents, name => {\r\n          bindEventDelegate(self, name);\r\n        });\r\n      },\r\n      toggleNativeEvent(name, state) {\r\n        const self = this;\r\n        if (name === 'focus' || name === 'blur') {\r\n          return;\r\n        }\r\n        if (self.removed) {\r\n          return;\r\n        }\r\n        if (state) {\r\n          if (self.initialized) {\r\n            bindEventDelegate(self, name);\r\n          } else {\r\n            if (!self._pendingNativeEvents) {\r\n              self._pendingNativeEvents = [name];\r\n            } else {\r\n              self._pendingNativeEvents.push(name);\r\n            }\r\n          }\r\n        } else if (self.initialized && self.delegates) {\r\n          self.dom.unbind(getEventTarget(self, name), name, self.delegates[name]);\r\n          delete self.delegates[name];\r\n        }\r\n      },\r\n      unbindAllNativeEvents() {\r\n        const self = this;\r\n        const body = self.getBody();\r\n        const dom = self.dom;\r\n        if (self.delegates) {\r\n          each$d(self.delegates, (value, name) => {\r\n            self.dom.unbind(getEventTarget(self, name), name, value);\r\n          });\r\n          delete self.delegates;\r\n        }\r\n        if (!self.inline && body && dom) {\r\n          body.onload = null;\r\n          dom.unbind(self.getWin());\r\n          dom.unbind(self.getDoc());\r\n        }\r\n        if (dom) {\r\n          dom.unbind(body);\r\n          dom.unbind(self.getContainer());\r\n        }\r\n      }\r\n    };\r\n\r\n    const stringListProcessor = value => {\r\n      if (isString(value)) {\r\n        return {\r\n          value: value.split(/[ ,]/),\r\n          valid: true\r\n        };\r\n      } else if (isArrayOf(value, isString)) {\r\n        return {\r\n          value,\r\n          valid: true\r\n        };\r\n      } else {\r\n        return {\r\n          valid: false,\r\n          message: `The value must be a string[] or a comma/space separated string.`\r\n        };\r\n      }\r\n    };\r\n    const getBuiltInProcessor = type => {\r\n      const validator = (() => {\r\n        switch (type) {\r\n        case 'array':\r\n          return isArray$1;\r\n        case 'boolean':\r\n          return isBoolean;\r\n        case 'function':\r\n          return isFunction;\r\n        case 'number':\r\n          return isNumber;\r\n        case 'object':\r\n          return isObject;\r\n        case 'string':\r\n          return isString;\r\n        case 'string[]':\r\n          return stringListProcessor;\r\n        case 'object[]':\r\n          return val => isArrayOf(val, isObject);\r\n        case 'regexp':\r\n          return val => is$4(val, RegExp);\r\n        default:\r\n          return always;\r\n        }\r\n      })();\r\n      return value => processValue(value, validator, `The value must be a ${ type }.`);\r\n    };\r\n    const isBuiltInSpec = spec => isString(spec.processor);\r\n    const getErrorMessage = (message, result) => {\r\n      const additionalText = isEmpty$3(result.message) ? '' : `. ${ result.message }`;\r\n      return message + additionalText;\r\n    };\r\n    const isValidResult = result => result.valid;\r\n    const processValue = (value, processor, message = '') => {\r\n      const result = processor(value);\r\n      if (isBoolean(result)) {\r\n        return result ? {\r\n          value: value,\r\n          valid: true\r\n        } : {\r\n          valid: false,\r\n          message\r\n        };\r\n      } else {\r\n        return result;\r\n      }\r\n    };\r\n    const processDefaultValue = (name, defaultValue, processor) => {\r\n      if (!isUndefined(defaultValue)) {\r\n        const result = processValue(defaultValue, processor);\r\n        if (isValidResult(result)) {\r\n          return result.value;\r\n        } else {\r\n          console.error(getErrorMessage(`Invalid default value passed for the \"${ name }\" option`, result));\r\n        }\r\n      }\r\n      return undefined;\r\n    };\r\n    const create$5 = (editor, initialOptions) => {\r\n      const registry = {};\r\n      const values = {};\r\n      const setValue = (name, value, processor) => {\r\n        const result = processValue(value, processor);\r\n        if (isValidResult(result)) {\r\n          values[name] = result.value;\r\n          return true;\r\n        } else {\r\n          console.warn(getErrorMessage(`Invalid value passed for the ${ name } option`, result));\r\n          return false;\r\n        }\r\n      };\r\n      const register = (name, spec) => {\r\n        const processor = isBuiltInSpec(spec) ? getBuiltInProcessor(spec.processor) : spec.processor;\r\n        const defaultValue = processDefaultValue(name, spec.default, processor);\r\n        registry[name] = {\r\n          ...spec,\r\n          default: defaultValue,\r\n          processor\r\n        };\r\n        const initValue = get$a(values, name).orThunk(() => get$a(initialOptions, name));\r\n        initValue.each(value => setValue(name, value, processor));\r\n      };\r\n      const isRegistered = name => has$2(registry, name);\r\n      const get = name => get$a(values, name).orThunk(() => get$a(registry, name).map(spec => spec.default)).getOrUndefined();\r\n      const set = (name, value) => {\r\n        if (!isRegistered(name)) {\r\n          console.warn(`\"${ name }\" is not a registered option. Ensure the option has been registered before setting a value.`);\r\n          return false;\r\n        } else {\r\n          const spec = registry[name];\r\n          if (spec.immutable) {\r\n            console.error(`\"${ name }\" is an immutable option and cannot be updated`);\r\n            return false;\r\n          } else {\r\n            return setValue(name, value, spec.processor);\r\n          }\r\n        }\r\n      };\r\n      const unset = name => {\r\n        const registered = isRegistered(name);\r\n        if (registered) {\r\n          delete values[name];\r\n        }\r\n        return registered;\r\n      };\r\n      const isSet = name => has$2(values, name);\r\n      return {\r\n        register,\r\n        isRegistered,\r\n        get,\r\n        set,\r\n        unset,\r\n        isSet\r\n      };\r\n    };\r\n\r\n    const defaultModes = [\r\n      'design',\r\n      'readonly'\r\n    ];\r\n    const switchToMode = (editor, activeMode, availableModes, mode) => {\r\n      const oldMode = availableModes[activeMode.get()];\r\n      const newMode = availableModes[mode];\r\n      try {\r\n        newMode.activate();\r\n      } catch (e) {\r\n        console.error(`problem while activating editor mode ${ mode }:`, e);\r\n        return;\r\n      }\r\n      oldMode.deactivate();\r\n      if (oldMode.editorReadOnly !== newMode.editorReadOnly) {\r\n        toggleReadOnly(editor, newMode.editorReadOnly);\r\n      }\r\n      activeMode.set(mode);\r\n      fireSwitchMode(editor, mode);\r\n    };\r\n    const setMode = (editor, availableModes, activeMode, mode) => {\r\n      if (mode === activeMode.get()) {\r\n        return;\r\n      } else if (!has$2(availableModes, mode)) {\r\n        throw new Error(`Editor mode '${ mode }' is invalid`);\r\n      }\r\n      if (editor.initialized) {\r\n        switchToMode(editor, activeMode, availableModes, mode);\r\n      } else {\r\n        editor.on('init', () => switchToMode(editor, activeMode, availableModes, mode));\r\n      }\r\n    };\r\n    const registerMode = (availableModes, mode, api) => {\r\n      if (contains$2(defaultModes, mode)) {\r\n        throw new Error(`Cannot override default mode ${ mode }`);\r\n      }\r\n      return {\r\n        ...availableModes,\r\n        [mode]: {\r\n          ...api,\r\n          deactivate: () => {\r\n            try {\r\n              api.deactivate();\r\n            } catch (e) {\r\n              console.error(`problem while deactivating editor mode ${ mode }:`, e);\r\n            }\r\n          }\r\n        }\r\n      };\r\n    };\r\n\r\n    const create$4 = editor => {\r\n      const activeMode = Cell('design');\r\n      const availableModes = Cell({\r\n        design: {\r\n          activate: noop,\r\n          deactivate: noop,\r\n          editorReadOnly: false\r\n        },\r\n        readonly: {\r\n          activate: noop,\r\n          deactivate: noop,\r\n          editorReadOnly: true\r\n        }\r\n      });\r\n      registerReadOnlyContentFilters(editor);\r\n      registerReadOnlySelectionBlockers(editor);\r\n      return {\r\n        isReadOnly: () => isReadOnly(editor),\r\n        set: mode => setMode(editor, availableModes.get(), activeMode, mode),\r\n        get: () => activeMode.get(),\r\n        register: (mode, api) => {\r\n          availableModes.set(registerMode(availableModes.get(), mode, api));\r\n        }\r\n      };\r\n    };\r\n\r\n    const each$2 = Tools.each, explode = Tools.explode;\r\n    const keyCodeLookup = {\r\n      f1: 112,\r\n      f2: 113,\r\n      f3: 114,\r\n      f4: 115,\r\n      f5: 116,\r\n      f6: 117,\r\n      f7: 118,\r\n      f8: 119,\r\n      f9: 120,\r\n      f10: 121,\r\n      f11: 122,\r\n      f12: 123\r\n    };\r\n    const modifierNames = Tools.makeMap('alt,ctrl,shift,meta,access');\r\n    const isModifier = key => key in modifierNames;\r\n    const parseShortcut = pattern => {\r\n      const shortcut = {};\r\n      const isMac = Env.os.isMacOS() || Env.os.isiOS();\r\n      each$2(explode(pattern.toLowerCase(), '+'), value => {\r\n        if (isModifier(value)) {\r\n          shortcut[value] = true;\r\n        } else {\r\n          if (/^[0-9]{2,}$/.test(value)) {\r\n            shortcut.keyCode = parseInt(value, 10);\r\n          } else {\r\n            shortcut.charCode = value.charCodeAt(0);\r\n            shortcut.keyCode = keyCodeLookup[value] || value.toUpperCase().charCodeAt(0);\r\n          }\r\n        }\r\n      });\r\n      const id = [shortcut.keyCode];\r\n      let key;\r\n      for (key in modifierNames) {\r\n        if (shortcut[key]) {\r\n          id.push(key);\r\n        } else {\r\n          shortcut[key] = false;\r\n        }\r\n      }\r\n      shortcut.id = id.join(',');\r\n      if (shortcut.access) {\r\n        shortcut.alt = true;\r\n        if (isMac) {\r\n          shortcut.ctrl = true;\r\n        } else {\r\n          shortcut.shift = true;\r\n        }\r\n      }\r\n      if (shortcut.meta) {\r\n        if (isMac) {\r\n          shortcut.meta = true;\r\n        } else {\r\n          shortcut.ctrl = true;\r\n          shortcut.meta = false;\r\n        }\r\n      }\r\n      return shortcut;\r\n    };\r\n    class Shortcuts {\r\n      constructor(editor) {\r\n        this.shortcuts = {};\r\n        this.pendingPatterns = [];\r\n        this.editor = editor;\r\n        const self = this;\r\n        editor.on('keyup keypress keydown', e => {\r\n          if ((self.hasModifier(e) || self.isFunctionKey(e)) && !e.isDefaultPrevented()) {\r\n            each$2(self.shortcuts, shortcut => {\r\n              if (self.matchShortcut(e, shortcut)) {\r\n                self.pendingPatterns = shortcut.subpatterns.slice(0);\r\n                if (e.type === 'keydown') {\r\n                  self.executeShortcutAction(shortcut);\r\n                }\r\n              }\r\n            });\r\n            if (self.matchShortcut(e, self.pendingPatterns[0])) {\r\n              if (self.pendingPatterns.length === 1) {\r\n                if (e.type === 'keydown') {\r\n                  self.executeShortcutAction(self.pendingPatterns[0]);\r\n                }\r\n              }\r\n              self.pendingPatterns.shift();\r\n            }\r\n          }\r\n        });\r\n      }\r\n      add(pattern, desc, cmdFunc, scope) {\r\n        const self = this;\r\n        const func = self.normalizeCommandFunc(cmdFunc);\r\n        each$2(explode(Tools.trim(pattern)), pattern => {\r\n          const shortcut = self.createShortcut(pattern, desc, func, scope);\r\n          self.shortcuts[shortcut.id] = shortcut;\r\n        });\r\n        return true;\r\n      }\r\n      remove(pattern) {\r\n        const shortcut = this.createShortcut(pattern);\r\n        if (this.shortcuts[shortcut.id]) {\r\n          delete this.shortcuts[shortcut.id];\r\n          return true;\r\n        }\r\n        return false;\r\n      }\r\n      normalizeCommandFunc(cmdFunc) {\r\n        const self = this;\r\n        const cmd = cmdFunc;\r\n        if (typeof cmd === 'string') {\r\n          return () => {\r\n            self.editor.execCommand(cmd, false, null);\r\n          };\r\n        } else if (Tools.isArray(cmd)) {\r\n          return () => {\r\n            self.editor.execCommand(cmd[0], cmd[1], cmd[2]);\r\n          };\r\n        } else {\r\n          return cmd;\r\n        }\r\n      }\r\n      createShortcut(pattern, desc, cmdFunc, scope) {\r\n        const shortcuts = Tools.map(explode(pattern, '>'), parseShortcut);\r\n        shortcuts[shortcuts.length - 1] = Tools.extend(shortcuts[shortcuts.length - 1], {\r\n          func: cmdFunc,\r\n          scope: scope || this.editor\r\n        });\r\n        return Tools.extend(shortcuts[0], {\r\n          desc: this.editor.translate(desc),\r\n          subpatterns: shortcuts.slice(1)\r\n        });\r\n      }\r\n      hasModifier(e) {\r\n        return e.altKey || e.ctrlKey || e.metaKey;\r\n      }\r\n      isFunctionKey(e) {\r\n        return e.type === 'keydown' && e.keyCode >= 112 && e.keyCode <= 123;\r\n      }\r\n      matchShortcut(e, shortcut) {\r\n        if (!shortcut) {\r\n          return false;\r\n        }\r\n        if (shortcut.ctrl !== e.ctrlKey || shortcut.meta !== e.metaKey) {\r\n          return false;\r\n        }\r\n        if (shortcut.alt !== e.altKey || shortcut.shift !== e.shiftKey) {\r\n          return false;\r\n        }\r\n        if (e.keyCode === shortcut.keyCode || e.charCode && e.charCode === shortcut.charCode) {\r\n          e.preventDefault();\r\n          return true;\r\n        }\r\n        return false;\r\n      }\r\n      executeShortcutAction(shortcut) {\r\n        return shortcut.func ? shortcut.func.call(shortcut.scope) : null;\r\n      }\r\n    }\r\n\r\n    const create$3 = () => {\r\n      const buttons = {};\r\n      const menuItems = {};\r\n      const popups = {};\r\n      const icons = {};\r\n      const contextMenus = {};\r\n      const contextToolbars = {};\r\n      const sidebars = {};\r\n      const views = {};\r\n      const add = (collection, type) => (name, spec) => {\r\n        collection[name.toLowerCase()] = {\r\n          ...spec,\r\n          type\r\n        };\r\n      };\r\n      const addIcon = (name, svgData) => icons[name.toLowerCase()] = svgData;\r\n      return {\r\n        addButton: add(buttons, 'button'),\r\n        addGroupToolbarButton: add(buttons, 'grouptoolbarbutton'),\r\n        addToggleButton: add(buttons, 'togglebutton'),\r\n        addMenuButton: add(buttons, 'menubutton'),\r\n        addSplitButton: add(buttons, 'splitbutton'),\r\n        addMenuItem: add(menuItems, 'menuitem'),\r\n        addNestedMenuItem: add(menuItems, 'nestedmenuitem'),\r\n        addToggleMenuItem: add(menuItems, 'togglemenuitem'),\r\n        addAutocompleter: add(popups, 'autocompleter'),\r\n        addContextMenu: add(contextMenus, 'contextmenu'),\r\n        addContextToolbar: add(contextToolbars, 'contexttoolbar'),\r\n        addContextForm: add(contextToolbars, 'contextform'),\r\n        addSidebar: add(sidebars, 'sidebar'),\r\n        addView: add(views, 'views'),\r\n        addIcon,\r\n        getAll: () => ({\r\n          buttons,\r\n          menuItems,\r\n          icons,\r\n          popups,\r\n          contextMenus,\r\n          contextToolbars,\r\n          sidebars,\r\n          views\r\n        })\r\n      };\r\n    };\r\n\r\n    const registry = () => {\r\n      const bridge = create$3();\r\n      return {\r\n        addAutocompleter: bridge.addAutocompleter,\r\n        addButton: bridge.addButton,\r\n        addContextForm: bridge.addContextForm,\r\n        addContextMenu: bridge.addContextMenu,\r\n        addContextToolbar: bridge.addContextToolbar,\r\n        addIcon: bridge.addIcon,\r\n        addMenuButton: bridge.addMenuButton,\r\n        addMenuItem: bridge.addMenuItem,\r\n        addNestedMenuItem: bridge.addNestedMenuItem,\r\n        addSidebar: bridge.addSidebar,\r\n        addSplitButton: bridge.addSplitButton,\r\n        addToggleButton: bridge.addToggleButton,\r\n        addGroupToolbarButton: bridge.addGroupToolbarButton,\r\n        addToggleMenuItem: bridge.addToggleMenuItem,\r\n        addView: bridge.addView,\r\n        getAll: bridge.getAll\r\n      };\r\n    };\r\n\r\n    const DOM$1 = DOMUtils.DOM;\r\n    const extend = Tools.extend, each$1 = Tools.each;\r\n    class Editor {\r\n      constructor(id, options, editorManager) {\r\n        this.plugins = {};\r\n        this.contentCSS = [];\r\n        this.contentStyles = [];\r\n        this.loadedCSS = {};\r\n        this.isNotDirty = false;\r\n        this.composing = false;\r\n        this.destroyed = false;\r\n        this.hasHiddenInput = false;\r\n        this.iframeElement = null;\r\n        this.initialized = false;\r\n        this.readonly = false;\r\n        this.removed = false;\r\n        this.startContent = '';\r\n        this._pendingNativeEvents = [];\r\n        this._skinLoaded = false;\r\n        this._editableRoot = true;\r\n        this.editorManager = editorManager;\r\n        this.documentBaseUrl = editorManager.documentBaseURL;\r\n        extend(this, EditorObservable);\r\n        const self = this;\r\n        this.id = id;\r\n        this.hidden = false;\r\n        const normalizedOptions = normalizeOptions(editorManager.defaultOptions, options);\r\n        this.options = create$5(self, normalizedOptions);\r\n        register$7(self);\r\n        const getOption = this.options.get;\r\n        if (getOption('deprecation_warnings')) {\r\n          logWarnings(options, normalizedOptions);\r\n        }\r\n        const suffix = getOption('suffix');\r\n        if (suffix) {\r\n          editorManager.suffix = suffix;\r\n        }\r\n        this.suffix = editorManager.suffix;\r\n        const baseUrl = getOption('base_url');\r\n        if (baseUrl) {\r\n          editorManager._setBaseUrl(baseUrl);\r\n        }\r\n        this.baseUri = editorManager.baseURI;\r\n        const referrerPolicy = getReferrerPolicy(self);\r\n        if (referrerPolicy) {\r\n          ScriptLoader.ScriptLoader._setReferrerPolicy(referrerPolicy);\r\n          DOMUtils.DOM.styleSheetLoader._setReferrerPolicy(referrerPolicy);\r\n        }\r\n        const contentCssCors = hasContentCssCors(self);\r\n        if (isNonNullable(contentCssCors)) {\r\n          DOMUtils.DOM.styleSheetLoader._setContentCssCors(contentCssCors);\r\n        }\r\n        AddOnManager.languageLoad = getOption('language_load');\r\n        AddOnManager.baseURL = editorManager.baseURL;\r\n        this.setDirty(false);\r\n        this.documentBaseURI = new URI(getDocumentBaseUrl(self), { base_uri: this.baseUri });\r\n        this.baseURI = this.baseUri;\r\n        this.inline = isInline$1(self);\r\n        this.hasVisual = isVisualAidsEnabled(self);\r\n        this.shortcuts = new Shortcuts(this);\r\n        this.editorCommands = new EditorCommands(this);\r\n        registerCommands(this);\r\n        const cacheSuffix = getOption('cache_suffix');\r\n        if (cacheSuffix) {\r\n          Env.cacheSuffix = cacheSuffix.replace(/^[\\?\\&]+/, '');\r\n        }\r\n        this.ui = {\r\n          registry: registry(),\r\n          styleSheetLoader: undefined,\r\n          show: noop,\r\n          hide: noop,\r\n          setEnabled: noop,\r\n          isEnabled: always\r\n        };\r\n        this.mode = create$4(self);\r\n        editorManager.dispatch('SetupEditor', { editor: this });\r\n        const setupCallback = getSetupCallback(self);\r\n        if (isFunction(setupCallback)) {\r\n          setupCallback.call(self, self);\r\n        }\r\n      }\r\n      render() {\r\n        render(this);\r\n      }\r\n      focus(skipFocus) {\r\n        this.execCommand('mceFocus', false, skipFocus);\r\n      }\r\n      hasFocus() {\r\n        return hasFocus(this);\r\n      }\r\n      translate(text) {\r\n        return I18n.translate(text);\r\n      }\r\n      getParam(name, defaultVal, type) {\r\n        const options = this.options;\r\n        if (!options.isRegistered(name)) {\r\n          if (isNonNullable(type)) {\r\n            options.register(name, {\r\n              processor: type,\r\n              default: defaultVal\r\n            });\r\n          } else {\r\n            options.register(name, {\r\n              processor: always,\r\n              default: defaultVal\r\n            });\r\n          }\r\n        }\r\n        return !options.isSet(name) && !isUndefined(defaultVal) ? defaultVal : options.get(name);\r\n      }\r\n      hasPlugin(name, loaded) {\r\n        const hasPlugin = contains$2(getPlugins(this), name);\r\n        if (hasPlugin) {\r\n          return loaded ? PluginManager.get(name) !== undefined : true;\r\n        } else {\r\n          return false;\r\n        }\r\n      }\r\n      nodeChanged(args) {\r\n        this._nodeChangeDispatcher.nodeChanged(args);\r\n      }\r\n      addCommand(name, callback, scope) {\r\n        this.editorCommands.addCommand(name, callback, scope);\r\n      }\r\n      addQueryStateHandler(name, callback, scope) {\r\n        this.editorCommands.addQueryStateHandler(name, callback, scope);\r\n      }\r\n      addQueryValueHandler(name, callback, scope) {\r\n        this.editorCommands.addQueryValueHandler(name, callback, scope);\r\n      }\r\n      addShortcut(pattern, desc, cmdFunc, scope) {\r\n        this.shortcuts.add(pattern, desc, cmdFunc, scope);\r\n      }\r\n      execCommand(cmd, ui, value, args) {\r\n        return this.editorCommands.execCommand(cmd, ui, value, args);\r\n      }\r\n      queryCommandState(cmd) {\r\n        return this.editorCommands.queryCommandState(cmd);\r\n      }\r\n      queryCommandValue(cmd) {\r\n        return this.editorCommands.queryCommandValue(cmd);\r\n      }\r\n      queryCommandSupported(cmd) {\r\n        return this.editorCommands.queryCommandSupported(cmd);\r\n      }\r\n      show() {\r\n        const self = this;\r\n        if (self.hidden) {\r\n          self.hidden = false;\r\n          if (self.inline) {\r\n            self.getBody().contentEditable = 'true';\r\n          } else {\r\n            DOM$1.show(self.getContainer());\r\n            DOM$1.hide(self.id);\r\n          }\r\n          self.load();\r\n          self.dispatch('show');\r\n        }\r\n      }\r\n      hide() {\r\n        const self = this;\r\n        if (!self.hidden) {\r\n          self.save();\r\n          if (self.inline) {\r\n            self.getBody().contentEditable = 'false';\r\n            if (self === self.editorManager.focusedEditor) {\r\n              self.editorManager.focusedEditor = null;\r\n            }\r\n          } else {\r\n            DOM$1.hide(self.getContainer());\r\n            DOM$1.setStyle(self.id, 'display', self.orgDisplay);\r\n          }\r\n          self.hidden = true;\r\n          self.dispatch('hide');\r\n        }\r\n      }\r\n      isHidden() {\r\n        return this.hidden;\r\n      }\r\n      setProgressState(state, time) {\r\n        this.dispatch('ProgressState', {\r\n          state,\r\n          time\r\n        });\r\n      }\r\n      load(args = {}) {\r\n        const self = this;\r\n        const elm = self.getElement();\r\n        if (self.removed) {\r\n          return '';\r\n        }\r\n        if (elm) {\r\n          const loadArgs = {\r\n            ...args,\r\n            load: true\r\n          };\r\n          const value = isTextareaOrInput(elm) ? elm.value : elm.innerHTML;\r\n          const html = self.setContent(value, loadArgs);\r\n          if (!loadArgs.no_events) {\r\n            self.dispatch('LoadContent', {\r\n              ...loadArgs,\r\n              element: elm\r\n            });\r\n          }\r\n          return html;\r\n        } else {\r\n          return '';\r\n        }\r\n      }\r\n      save(args = {}) {\r\n        const self = this;\r\n        let elm = self.getElement();\r\n        if (!elm || !self.initialized || self.removed) {\r\n          return '';\r\n        }\r\n        const getArgs = {\r\n          ...args,\r\n          save: true,\r\n          element: elm\r\n        };\r\n        let html = self.getContent(getArgs);\r\n        const saveArgs = {\r\n          ...getArgs,\r\n          content: html\r\n        };\r\n        if (!saveArgs.no_events) {\r\n          self.dispatch('SaveContent', saveArgs);\r\n        }\r\n        if (saveArgs.format === 'raw') {\r\n          self.dispatch('RawSaveContent', saveArgs);\r\n        }\r\n        html = saveArgs.content;\r\n        if (!isTextareaOrInput(elm)) {\r\n          if (args.is_removing || !self.inline) {\r\n            elm.innerHTML = html;\r\n          }\r\n          const form = DOM$1.getParent(self.id, 'form');\r\n          if (form) {\r\n            each$1(form.elements, elm => {\r\n              if (elm.name === self.id) {\r\n                elm.value = html;\r\n                return false;\r\n              } else {\r\n                return true;\r\n              }\r\n            });\r\n          }\r\n        } else {\r\n          elm.value = html;\r\n        }\r\n        saveArgs.element = getArgs.element = elm = null;\r\n        if (saveArgs.set_dirty !== false) {\r\n          self.setDirty(false);\r\n        }\r\n        return html;\r\n      }\r\n      setContent(content, args) {\r\n        return setContent(this, content, args);\r\n      }\r\n      getContent(args) {\r\n        return getContent(this, args);\r\n      }\r\n      insertContent(content, args) {\r\n        if (args) {\r\n          content = extend({ content }, args);\r\n        }\r\n        this.execCommand('mceInsertContent', false, content);\r\n      }\r\n      resetContent(initialContent) {\r\n        if (initialContent === undefined) {\r\n          setContent(this, this.startContent, { format: 'raw' });\r\n        } else {\r\n          setContent(this, initialContent);\r\n        }\r\n        this.undoManager.reset();\r\n        this.setDirty(false);\r\n        this.nodeChanged();\r\n      }\r\n      isDirty() {\r\n        return !this.isNotDirty;\r\n      }\r\n      setDirty(state) {\r\n        const oldState = !this.isNotDirty;\r\n        this.isNotDirty = !state;\r\n        if (state && state !== oldState) {\r\n          this.dispatch('dirty');\r\n        }\r\n      }\r\n      getContainer() {\r\n        const self = this;\r\n        if (!self.container) {\r\n          self.container = self.editorContainer || DOM$1.get(self.id + '_parent');\r\n        }\r\n        return self.container;\r\n      }\r\n      getContentAreaContainer() {\r\n        return this.contentAreaContainer;\r\n      }\r\n      getElement() {\r\n        if (!this.targetElm) {\r\n          this.targetElm = DOM$1.get(this.id);\r\n        }\r\n        return this.targetElm;\r\n      }\r\n      getWin() {\r\n        const self = this;\r\n        if (!self.contentWindow) {\r\n          const elm = self.iframeElement;\r\n          if (elm) {\r\n            self.contentWindow = elm.contentWindow;\r\n          }\r\n        }\r\n        return self.contentWindow;\r\n      }\r\n      getDoc() {\r\n        const self = this;\r\n        if (!self.contentDocument) {\r\n          const win = self.getWin();\r\n          if (win) {\r\n            self.contentDocument = win.document;\r\n          }\r\n        }\r\n        return self.contentDocument;\r\n      }\r\n      getBody() {\r\n        var _a, _b;\r\n        const doc = this.getDoc();\r\n        return (_b = (_a = this.bodyElement) !== null && _a !== void 0 ? _a : doc === null || doc === void 0 ? void 0 : doc.body) !== null && _b !== void 0 ? _b : null;\r\n      }\r\n      convertURL(url, name, elm) {\r\n        const self = this, getOption = self.options.get;\r\n        const urlConverterCallback = getUrlConverterCallback(self);\r\n        if (isFunction(urlConverterCallback)) {\r\n          return urlConverterCallback.call(self, url, elm, true, name);\r\n        }\r\n        if (!getOption('convert_urls') || elm === 'link' || isObject(elm) && elm.nodeName === 'LINK' || url.indexOf('file:') === 0 || url.length === 0) {\r\n          return url;\r\n        }\r\n        const urlObject = new URI(url);\r\n        if (urlObject.protocol !== 'http' && urlObject.protocol !== 'https' && urlObject.protocol !== '') {\r\n          return url;\r\n        }\r\n        if (getOption('relative_urls')) {\r\n          return self.documentBaseURI.toRelative(url);\r\n        }\r\n        url = self.documentBaseURI.toAbsolute(url, getOption('remove_script_host'));\r\n        return url;\r\n      }\r\n      addVisual(elm) {\r\n        addVisual(this, elm);\r\n      }\r\n      setEditableRoot(state) {\r\n        setEditableRoot(this, state);\r\n      }\r\n      hasEditableRoot() {\r\n        return hasEditableRoot(this);\r\n      }\r\n      remove() {\r\n        remove$1(this);\r\n      }\r\n      destroy(automatic) {\r\n        destroy(this, automatic);\r\n      }\r\n      uploadImages() {\r\n        return this.editorUpload.uploadImages();\r\n      }\r\n      _scanForImages() {\r\n        return this.editorUpload.scanForImages();\r\n      }\r\n    }\r\n\r\n    const DOM = DOMUtils.DOM;\r\n    const each = Tools.each;\r\n    let boundGlobalEvents = false;\r\n    let beforeUnloadDelegate;\r\n    let editors = [];\r\n    const globalEventDelegate = e => {\r\n      const type = e.type;\r\n      each(EditorManager.get(), editor => {\r\n        switch (type) {\r\n        case 'scroll':\r\n          editor.dispatch('ScrollWindow', e);\r\n          break;\r\n        case 'resize':\r\n          editor.dispatch('ResizeWindow', e);\r\n          break;\r\n        }\r\n      });\r\n    };\r\n    const toggleGlobalEvents = state => {\r\n      if (state !== boundGlobalEvents) {\r\n        const DOM = DOMUtils.DOM;\r\n        if (state) {\r\n          DOM.bind(window, 'resize', globalEventDelegate);\r\n          DOM.bind(window, 'scroll', globalEventDelegate);\r\n        } else {\r\n          DOM.unbind(window, 'resize', globalEventDelegate);\r\n          DOM.unbind(window, 'scroll', globalEventDelegate);\r\n        }\r\n        boundGlobalEvents = state;\r\n      }\r\n    };\r\n    const removeEditorFromList = targetEditor => {\r\n      const oldEditors = editors;\r\n      editors = filter$5(editors, editor => {\r\n        return targetEditor !== editor;\r\n      });\r\n      if (EditorManager.activeEditor === targetEditor) {\r\n        EditorManager.activeEditor = editors.length > 0 ? editors[0] : null;\r\n      }\r\n      if (EditorManager.focusedEditor === targetEditor) {\r\n        EditorManager.focusedEditor = null;\r\n      }\r\n      return oldEditors.length !== editors.length;\r\n    };\r\n    const purgeDestroyedEditor = editor => {\r\n      if (editor && editor.initialized && !(editor.getContainer() || editor.getBody()).parentNode) {\r\n        removeEditorFromList(editor);\r\n        editor.unbindAllNativeEvents();\r\n        editor.destroy(true);\r\n        editor.removed = true;\r\n      }\r\n    };\r\n    const isQuirksMode = document.compatMode !== 'CSS1Compat';\r\n    const EditorManager = {\r\n      ...Observable,\r\n      baseURI: null,\r\n      baseURL: null,\r\n      defaultOptions: {},\r\n      documentBaseURL: null,\r\n      suffix: null,\r\n      majorVersion: '6',\r\n      minorVersion: '8.3',\r\n      releaseDate: '2024-02-08',\r\n      i18n: I18n,\r\n      activeEditor: null,\r\n      focusedEditor: null,\r\n      setup() {\r\n        const self = this;\r\n        let baseURL = '';\r\n        let suffix = '';\r\n        let documentBaseURL = URI.getDocumentBaseUrl(document.location);\r\n        if (/^[^:]+:\\/\\/\\/?[^\\/]+\\//.test(documentBaseURL)) {\r\n          documentBaseURL = documentBaseURL.replace(/[\\?#].*$/, '').replace(/[\\/\\\\][^\\/]+$/, '');\r\n          if (!/[\\/\\\\]$/.test(documentBaseURL)) {\r\n            documentBaseURL += '/';\r\n          }\r\n        }\r\n        const preInit = window.tinymce || window.tinyMCEPreInit;\r\n        if (preInit) {\r\n          baseURL = preInit.base || preInit.baseURL;\r\n          suffix = preInit.suffix;\r\n        } else {\r\n          const scripts = document.getElementsByTagName('script');\r\n          for (let i = 0; i < scripts.length; i++) {\r\n            const src = scripts[i].src || '';\r\n            if (src === '') {\r\n              continue;\r\n            }\r\n            const srcScript = src.substring(src.lastIndexOf('/'));\r\n            if (/tinymce(\\.full|\\.jquery|)(\\.min|\\.dev|)\\.js/.test(src)) {\r\n              if (srcScript.indexOf('.min') !== -1) {\r\n                suffix = '.min';\r\n              }\r\n              baseURL = src.substring(0, src.lastIndexOf('/'));\r\n              break;\r\n            }\r\n          }\r\n          if (!baseURL && document.currentScript) {\r\n            const src = document.currentScript.src;\r\n            if (src.indexOf('.min') !== -1) {\r\n              suffix = '.min';\r\n            }\r\n            baseURL = src.substring(0, src.lastIndexOf('/'));\r\n          }\r\n        }\r\n        self.baseURL = new URI(documentBaseURL).toAbsolute(baseURL);\r\n        self.documentBaseURL = documentBaseURL;\r\n        self.baseURI = new URI(self.baseURL);\r\n        self.suffix = suffix;\r\n        setup$w(self);\r\n      },\r\n      overrideDefaults(defaultOptions) {\r\n        const baseUrl = defaultOptions.base_url;\r\n        if (baseUrl) {\r\n          this._setBaseUrl(baseUrl);\r\n        }\r\n        const suffix = defaultOptions.suffix;\r\n        if (suffix) {\r\n          this.suffix = suffix;\r\n        }\r\n        this.defaultOptions = defaultOptions;\r\n        const pluginBaseUrls = defaultOptions.plugin_base_urls;\r\n        if (pluginBaseUrls !== undefined) {\r\n          each$d(pluginBaseUrls, (pluginBaseUrl, pluginName) => {\r\n            AddOnManager.PluginManager.urls[pluginName] = pluginBaseUrl;\r\n          });\r\n        }\r\n      },\r\n      init(options) {\r\n        const self = this;\r\n        let result;\r\n        const invalidInlineTargets = Tools.makeMap('area base basefont br col frame hr img input isindex link meta param embed source wbr track ' + 'colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu', ' ');\r\n        const isInvalidInlineTarget = (options, elm) => options.inline && elm.tagName.toLowerCase() in invalidInlineTargets;\r\n        const createId = elm => {\r\n          let id = elm.id;\r\n          if (!id) {\r\n            id = get$a(elm, 'name').filter(name => !DOM.get(name)).getOrThunk(DOM.uniqueId);\r\n            elm.setAttribute('id', id);\r\n          }\r\n          return id;\r\n        };\r\n        const execCallback = name => {\r\n          const callback = options[name];\r\n          if (!callback) {\r\n            return;\r\n          }\r\n          return callback.apply(self, []);\r\n        };\r\n        const findTargets = options => {\r\n          if (Env.browser.isIE() || Env.browser.isEdge()) {\r\n            initError('TinyMCE does not support the browser you are using. For a list of supported' + ' browsers please see: https://www.tiny.cloud/docs/tinymce/6/support/#supportedwebbrowsers');\r\n            return [];\r\n          } else if (isQuirksMode) {\r\n            initError('Failed to initialize the editor as the document is not in standards mode. ' + 'TinyMCE requires standards mode.');\r\n            return [];\r\n          } else if (isString(options.selector)) {\r\n            return DOM.select(options.selector);\r\n          } else if (isNonNullable(options.target)) {\r\n            return [options.target];\r\n          } else {\r\n            return [];\r\n          }\r\n        };\r\n        let provideResults = editors => {\r\n          result = editors;\r\n        };\r\n        const initEditors = () => {\r\n          let initCount = 0;\r\n          const editors = [];\r\n          let targets;\r\n          const createEditor = (id, options, targetElm) => {\r\n            const editor = new Editor(id, options, self);\r\n            editors.push(editor);\r\n            editor.on('init', () => {\r\n              if (++initCount === targets.length) {\r\n                provideResults(editors);\r\n              }\r\n            });\r\n            editor.targetElm = editor.targetElm || targetElm;\r\n            editor.render();\r\n          };\r\n          DOM.unbind(window, 'ready', initEditors);\r\n          execCallback('onpageload');\r\n          targets = unique$1(findTargets(options));\r\n          Tools.each(targets, elm => {\r\n            purgeDestroyedEditor(self.get(elm.id));\r\n          });\r\n          targets = Tools.grep(targets, elm => {\r\n            return !self.get(elm.id);\r\n          });\r\n          if (targets.length === 0) {\r\n            provideResults([]);\r\n          } else {\r\n            each(targets, elm => {\r\n              if (isInvalidInlineTarget(options, elm)) {\r\n                initError('Could not initialize inline editor on invalid inline target element', elm);\r\n              } else {\r\n                createEditor(createId(elm), options, elm);\r\n              }\r\n            });\r\n          }\r\n        };\r\n        DOM.bind(window, 'ready', initEditors);\r\n        return new Promise(resolve => {\r\n          if (result) {\r\n            resolve(result);\r\n          } else {\r\n            provideResults = editors => {\r\n              resolve(editors);\r\n            };\r\n          }\r\n        });\r\n      },\r\n      get(id) {\r\n        if (arguments.length === 0) {\r\n          return editors.slice(0);\r\n        } else if (isString(id)) {\r\n          return find$2(editors, editor => {\r\n            return editor.id === id;\r\n          }).getOr(null);\r\n        } else if (isNumber(id)) {\r\n          return editors[id] ? editors[id] : null;\r\n        } else {\r\n          return null;\r\n        }\r\n      },\r\n      add(editor) {\r\n        const self = this;\r\n        const existingEditor = self.get(editor.id);\r\n        if (existingEditor === editor) {\r\n          return editor;\r\n        }\r\n        if (existingEditor === null) {\r\n          editors.push(editor);\r\n        }\r\n        toggleGlobalEvents(true);\r\n        self.activeEditor = editor;\r\n        self.dispatch('AddEditor', { editor });\r\n        if (!beforeUnloadDelegate) {\r\n          beforeUnloadDelegate = e => {\r\n            const event = self.dispatch('BeforeUnload');\r\n            if (event.returnValue) {\r\n              e.preventDefault();\r\n              e.returnValue = event.returnValue;\r\n              return event.returnValue;\r\n            }\r\n          };\r\n          window.addEventListener('beforeunload', beforeUnloadDelegate);\r\n        }\r\n        return editor;\r\n      },\r\n      createEditor(id, options) {\r\n        return this.add(new Editor(id, options, this));\r\n      },\r\n      remove(selector) {\r\n        const self = this;\r\n        let editor;\r\n        if (!selector) {\r\n          for (let i = editors.length - 1; i >= 0; i--) {\r\n            self.remove(editors[i]);\r\n          }\r\n          return;\r\n        }\r\n        if (isString(selector)) {\r\n          each(DOM.select(selector), elm => {\r\n            editor = self.get(elm.id);\r\n            if (editor) {\r\n              self.remove(editor);\r\n            }\r\n          });\r\n          return;\r\n        }\r\n        editor = selector;\r\n        if (isNull(self.get(editor.id))) {\r\n          return null;\r\n        }\r\n        if (removeEditorFromList(editor)) {\r\n          self.dispatch('RemoveEditor', { editor });\r\n        }\r\n        if (editors.length === 0) {\r\n          window.removeEventListener('beforeunload', beforeUnloadDelegate);\r\n        }\r\n        editor.remove();\r\n        toggleGlobalEvents(editors.length > 0);\r\n        return editor;\r\n      },\r\n      execCommand(cmd, ui, value) {\r\n        var _a;\r\n        const self = this;\r\n        const editorId = isObject(value) ? (_a = value.id) !== null && _a !== void 0 ? _a : value.index : value;\r\n        switch (cmd) {\r\n        case 'mceAddEditor': {\r\n            if (!self.get(editorId)) {\r\n              const editorOptions = value.options;\r\n              new Editor(editorId, editorOptions, self).render();\r\n            }\r\n            return true;\r\n          }\r\n        case 'mceRemoveEditor': {\r\n            const editor = self.get(editorId);\r\n            if (editor) {\r\n              editor.remove();\r\n            }\r\n            return true;\r\n          }\r\n        case 'mceToggleEditor': {\r\n            const editor = self.get(editorId);\r\n            if (!editor) {\r\n              self.execCommand('mceAddEditor', false, value);\r\n              return true;\r\n            }\r\n            if (editor.isHidden()) {\r\n              editor.show();\r\n            } else {\r\n              editor.hide();\r\n            }\r\n            return true;\r\n          }\r\n        }\r\n        if (self.activeEditor) {\r\n          return self.activeEditor.execCommand(cmd, ui, value);\r\n        }\r\n        return false;\r\n      },\r\n      triggerSave: () => {\r\n        each(editors, editor => {\r\n          editor.save();\r\n        });\r\n      },\r\n      addI18n: (code, items) => {\r\n        I18n.add(code, items);\r\n      },\r\n      translate: text => {\r\n        return I18n.translate(text);\r\n      },\r\n      setActive(editor) {\r\n        const activeEditor = this.activeEditor;\r\n        if (this.activeEditor !== editor) {\r\n          if (activeEditor) {\r\n            activeEditor.dispatch('deactivate', { relatedTarget: editor });\r\n          }\r\n          editor.dispatch('activate', { relatedTarget: activeEditor });\r\n        }\r\n        this.activeEditor = editor;\r\n      },\r\n      _setBaseUrl(baseUrl) {\r\n        this.baseURL = new URI(this.documentBaseURL).toAbsolute(baseUrl.replace(/\\/+$/, ''));\r\n        this.baseURI = new URI(this.baseURL);\r\n      }\r\n    };\r\n    EditorManager.setup();\r\n\r\n    const setup = () => {\r\n      const dataValue = value$2();\r\n      const FakeClipboardItem = items => ({\r\n        items,\r\n        types: keys(items),\r\n        getType: type => get$a(items, type).getOrUndefined()\r\n      });\r\n      const write = data => {\r\n        dataValue.set(data);\r\n      };\r\n      const read = () => dataValue.get().getOrUndefined();\r\n      const clear = dataValue.clear;\r\n      return {\r\n        FakeClipboardItem,\r\n        write,\r\n        read,\r\n        clear\r\n      };\r\n    };\r\n    const FakeClipboard = setup();\r\n\r\n    const min = Math.min, max = Math.max, round = Math.round;\r\n    const relativePosition = (rect, targetRect, rel) => {\r\n      let x = targetRect.x;\r\n      let y = targetRect.y;\r\n      const w = rect.w;\r\n      const h = rect.h;\r\n      const targetW = targetRect.w;\r\n      const targetH = targetRect.h;\r\n      const relChars = (rel || '').split('');\r\n      if (relChars[0] === 'b') {\r\n        y += targetH;\r\n      }\r\n      if (relChars[1] === 'r') {\r\n        x += targetW;\r\n      }\r\n      if (relChars[0] === 'c') {\r\n        y += round(targetH / 2);\r\n      }\r\n      if (relChars[1] === 'c') {\r\n        x += round(targetW / 2);\r\n      }\r\n      if (relChars[3] === 'b') {\r\n        y -= h;\r\n      }\r\n      if (relChars[4] === 'r') {\r\n        x -= w;\r\n      }\r\n      if (relChars[3] === 'c') {\r\n        y -= round(h / 2);\r\n      }\r\n      if (relChars[4] === 'c') {\r\n        x -= round(w / 2);\r\n      }\r\n      return create$2(x, y, w, h);\r\n    };\r\n    const findBestRelativePosition = (rect, targetRect, constrainRect, rels) => {\r\n      for (let i = 0; i < rels.length; i++) {\r\n        const pos = relativePosition(rect, targetRect, rels[i]);\r\n        if (pos.x >= constrainRect.x && pos.x + pos.w <= constrainRect.w + constrainRect.x && pos.y >= constrainRect.y && pos.y + pos.h <= constrainRect.h + constrainRect.y) {\r\n          return rels[i];\r\n        }\r\n      }\r\n      return null;\r\n    };\r\n    const inflate = (rect, w, h) => {\r\n      return create$2(rect.x - w, rect.y - h, rect.w + w * 2, rect.h + h * 2);\r\n    };\r\n    const intersect = (rect, cropRect) => {\r\n      const x1 = max(rect.x, cropRect.x);\r\n      const y1 = max(rect.y, cropRect.y);\r\n      const x2 = min(rect.x + rect.w, cropRect.x + cropRect.w);\r\n      const y2 = min(rect.y + rect.h, cropRect.y + cropRect.h);\r\n      if (x2 - x1 < 0 || y2 - y1 < 0) {\r\n        return null;\r\n      }\r\n      return create$2(x1, y1, x2 - x1, y2 - y1);\r\n    };\r\n    const clamp = (rect, clampRect, fixedSize) => {\r\n      let x1 = rect.x;\r\n      let y1 = rect.y;\r\n      let x2 = rect.x + rect.w;\r\n      let y2 = rect.y + rect.h;\r\n      const cx2 = clampRect.x + clampRect.w;\r\n      const cy2 = clampRect.y + clampRect.h;\r\n      const underflowX1 = max(0, clampRect.x - x1);\r\n      const underflowY1 = max(0, clampRect.y - y1);\r\n      const overflowX2 = max(0, x2 - cx2);\r\n      const overflowY2 = max(0, y2 - cy2);\r\n      x1 += underflowX1;\r\n      y1 += underflowY1;\r\n      if (fixedSize) {\r\n        x2 += underflowX1;\r\n        y2 += underflowY1;\r\n        x1 -= overflowX2;\r\n        y1 -= overflowY2;\r\n      }\r\n      x2 -= overflowX2;\r\n      y2 -= overflowY2;\r\n      return create$2(x1, y1, x2 - x1, y2 - y1);\r\n    };\r\n    const create$2 = (x, y, w, h) => {\r\n      return {\r\n        x,\r\n        y,\r\n        w,\r\n        h\r\n      };\r\n    };\r\n    const fromClientRect = clientRect => {\r\n      return create$2(clientRect.left, clientRect.top, clientRect.width, clientRect.height);\r\n    };\r\n    const Rect = {\r\n      inflate,\r\n      relativePosition,\r\n      findBestRelativePosition,\r\n      intersect,\r\n      clamp,\r\n      create: create$2,\r\n      fromClientRect\r\n    };\r\n\r\n    const awaiter = (resolveCb, rejectCb, timeout = 1000) => {\r\n      let done = false;\r\n      let timer = null;\r\n      const complete = completer => (...args) => {\r\n        if (!done) {\r\n          done = true;\r\n          if (timer !== null) {\r\n            clearTimeout(timer);\r\n            timer = null;\r\n          }\r\n          completer.apply(null, args);\r\n        }\r\n      };\r\n      const resolve = complete(resolveCb);\r\n      const reject = complete(rejectCb);\r\n      const start = (...args) => {\r\n        if (!done && timer === null) {\r\n          timer = setTimeout(() => reject.apply(null, args), timeout);\r\n        }\r\n      };\r\n      return {\r\n        start,\r\n        resolve,\r\n        reject\r\n      };\r\n    };\r\n    const create$1 = () => {\r\n      const tasks = {};\r\n      const resultFns = {};\r\n      const resources = {};\r\n      const load = (id, url) => {\r\n        const loadErrMsg = `Script at URL \"${ url }\" failed to load`;\r\n        const runErrMsg = `Script at URL \"${ url }\" did not call \\`tinymce.Resource.add('${ id }', data)\\` within 1 second`;\r\n        if (tasks[id] !== undefined) {\r\n          return tasks[id];\r\n        } else {\r\n          const task = new Promise((resolve, reject) => {\r\n            const waiter = awaiter(resolve, reject);\r\n            resultFns[id] = waiter.resolve;\r\n            ScriptLoader.ScriptLoader.loadScript(url).then(() => waiter.start(runErrMsg), () => waiter.reject(loadErrMsg));\r\n          });\r\n          tasks[id] = task;\r\n          return task;\r\n        }\r\n      };\r\n      const add = (id, data) => {\r\n        if (resultFns[id] !== undefined) {\r\n          resultFns[id](data);\r\n          delete resultFns[id];\r\n        }\r\n        tasks[id] = Promise.resolve(data);\r\n        resources[id] = data;\r\n      };\r\n      const has = id => {\r\n        return id in resources;\r\n      };\r\n      const unload = id => {\r\n        delete tasks[id];\r\n      };\r\n      const get = id => resources[id];\r\n      return {\r\n        load,\r\n        add,\r\n        has,\r\n        get,\r\n        unload\r\n      };\r\n    };\r\n    const Resource = create$1();\r\n\r\n    const create = () => (() => {\r\n      let data = {};\r\n      let keys = [];\r\n      const storage = {\r\n        getItem: key => {\r\n          const item = data[key];\r\n          return item ? item : null;\r\n        },\r\n        setItem: (key, value) => {\r\n          keys.push(key);\r\n          data[key] = String(value);\r\n        },\r\n        key: index => {\r\n          return keys[index];\r\n        },\r\n        removeItem: key => {\r\n          keys = keys.filter(k => k === key);\r\n          delete data[key];\r\n        },\r\n        clear: () => {\r\n          keys = [];\r\n          data = {};\r\n        },\r\n        length: 0\r\n      };\r\n      Object.defineProperty(storage, 'length', {\r\n        get: () => keys.length,\r\n        configurable: false,\r\n        enumerable: false\r\n      });\r\n      return storage;\r\n    })();\r\n\r\n    let localStorage;\r\n    try {\r\n      const test = '__storage_test__';\r\n      localStorage = window.localStorage;\r\n      localStorage.setItem(test, test);\r\n      localStorage.removeItem(test);\r\n    } catch (e) {\r\n      localStorage = create();\r\n    }\r\n    var LocalStorage = localStorage;\r\n\r\n    const publicApi = {\r\n      geom: { Rect },\r\n      util: {\r\n        Delay,\r\n        Tools,\r\n        VK,\r\n        URI,\r\n        EventDispatcher,\r\n        Observable,\r\n        I18n,\r\n        LocalStorage,\r\n        ImageUploader\r\n      },\r\n      dom: {\r\n        EventUtils,\r\n        TreeWalker: DomTreeWalker,\r\n        TextSeeker,\r\n        DOMUtils,\r\n        ScriptLoader,\r\n        RangeUtils,\r\n        Serializer: DomSerializer,\r\n        StyleSheetLoader,\r\n        ControlSelection,\r\n        BookmarkManager,\r\n        Selection: EditorSelection,\r\n        Event: EventUtils.Event\r\n      },\r\n      html: {\r\n        Styles,\r\n        Entities,\r\n        Node: AstNode,\r\n        Schema,\r\n        DomParser,\r\n        Writer,\r\n        Serializer: HtmlSerializer\r\n      },\r\n      Env,\r\n      AddOnManager,\r\n      Annotator,\r\n      Formatter,\r\n      UndoManager,\r\n      EditorCommands,\r\n      WindowManager,\r\n      NotificationManager,\r\n      EditorObservable,\r\n      Shortcuts,\r\n      Editor,\r\n      FocusManager,\r\n      EditorManager,\r\n      DOM: DOMUtils.DOM,\r\n      ScriptLoader: ScriptLoader.ScriptLoader,\r\n      PluginManager,\r\n      ThemeManager,\r\n      ModelManager,\r\n      IconManager,\r\n      Resource,\r\n      FakeClipboard,\r\n      trim: Tools.trim,\r\n      isArray: Tools.isArray,\r\n      is: Tools.is,\r\n      toArray: Tools.toArray,\r\n      makeMap: Tools.makeMap,\r\n      each: Tools.each,\r\n      map: Tools.map,\r\n      grep: Tools.grep,\r\n      inArray: Tools.inArray,\r\n      extend: Tools.extend,\r\n      walk: Tools.walk,\r\n      resolve: Tools.resolve,\r\n      explode: Tools.explode,\r\n      _addCacheSuffix: Tools._addCacheSuffix\r\n    };\r\n    const tinymce$1 = Tools.extend(EditorManager, publicApi);\r\n\r\n    const exportToModuleLoaders = tinymce => {\r\n      if (typeof module === 'object') {\r\n        try {\r\n          module.exports = tinymce;\r\n        } catch (_) {\r\n        }\r\n      }\r\n    };\r\n    const exportToWindowGlobal = tinymce => {\r\n      window.tinymce = tinymce;\r\n      window.tinyMCE = tinymce;\r\n    };\r\n    exportToWindowGlobal(tinymce$1);\r\n    exportToModuleLoaders(tinymce$1);\r\n\r\n};\r\n\r\nexport default exportGlobal = () => {\r\n  tinymce();\r\n}\r\n"],"names":["tinymce","typeOf$1","x","undefined","t","Array","prototype","isPrototypeOf","constructor","name","String","eq$2","f","eq","eqString","y","eqArray","eqa","length","len","i","eqSortedArray","compareFn","contramap","xs","slice","call","sort","sort$1","eqRecord","kx","Object","keys","ky","q","eqAny","tx","indexOf","isEquatableType","getPrototypeOf$2","getPrototypeOf","hasProto","v","predicate","_a","isType$1","type","value","isArray","o","proto","typeOf","isSimpleType","eq$1","a","is$4","isObject","isString","isPlainObject","isArray$1","isNull","isBoolean","isUndefined","isNullable","isNonNullable","isFunction","isNumber","isArrayOf","pred","noop","compose","fa","fb","args","apply","compose1","fbc","fab","constant","identity","tripleEquals","b","curry","fn","initialArgs","restArgs","all","concat","not","die","msg","Error","apply$1","never","always","Optional","tag","singletonNone","fold","onNone","onSome","this","isSome","isNone","map","mapper","some","none","bind","binder","exists","forall","filter","getOr","replacement","or","getOrThunk","thunk","orThunk","getOrDie","message","getOrNull","getOrUndefined","each","worker","toArray","toString","nativeSlice","nativeIndexOf","nativePush","push","rawIndexOf","ts","contains$2","map$3","r","each$e","eachr","partition$2","pass","fail","filter$5","foldr","acc","foldl","findUntil$1","until","find$2","findIndex$2","flatten","bind$3","reverse","difference","a1","a2","mapToObject","comparator","copy","get$b","head","last$3","from","findMap","arr","hasOwnProperty$1","hasOwnProperty","each$d","obj","props","k","map$2","tupleMap","tuple","objAcc","internalFilter","onTrue","onFalse","filter$4","mapToArray","values","get$a","key","has$2","hasNonNullableKey","stringArray","isArrayLike","each$c","cb","s","n","l","map$1","array","callback","out","item","index","filter$3","reduce","collection","iteratee","accumulator","thisArg","findIndex$1","last$2","cached","called","unknown$2","nu$3","major","minor","Version","nu","detect","versionRegexes","agent","cleanedAgent","toLowerCase","regexes","test","firstMatch","group","Number","replace","find$1","unknown","detect$4","candidates","userAgent","candidate","search","checkRange","str","substr","start","removeLeading","prefix","startsWith","numChars","substring","removeFromStart","contains$1","end","idx","endsWith","suffix","blank","trim$4","lTrim","rTrim","isNotEmpty","isEmpty$3","repeat","count","join","toInt","radix","num","parseInt","isNaN","normalVersionRegex","checkContains","target","uastring","browsers","brand","oses","PlatformInfo","nu$2","info","current","version","isBrowser","isEdge","isChromium","isIE","isOpera","isFirefox","isSafari","Browser","edge","chromium","ie","opera","firefox","safari","nu$1","isOS","isWindows","isiOS","isAndroid","isMacOS","isLinux","isSolaris","isFreeBSD","isChromeOS","OperatingSystem","windows","ios","android","linux","macos","solaris","freebsd","chromeos","PlatformDetection","userAgentDataOpt","mediaMatch","browser","userAgentData","brands","uaBrand","lcBrand","detectBrowser$1","detectBrowser","os","detectOs","deviceType","isiPad","isiPhone","isMobile","isTouch","isTablet","isPhone","iOSwebview","isDesktop","isWebView","DeviceType","query","window","matchMedia","matches","platform$4","navigator","detect$2","platform$3","browser$3","os$1","windowsPhone","Env","transparentSrc","documentMode","document","cacheSuffix","container","canHaveCSP","whiteSpaceRegExp$1","trim$3","walk$4","Tools","trim","is","makeMap","items","delim","resolvedItems","split","grep","inArray","hasOwn","extend","ext","walk","resolve","path","explode","d","_addCacheSuffix","url","is$2","lhs","rhs","left","equals","lift2","oa","ob","someIf","Global","Function","resolve$2","p","scope","parts","actual","unsafe","getPrototypeOf$1","sandHTMLElement","element","dom","nodeName","type$1","nodeType","isType","isHTMLElement$1","isElement$7","isText$b","isDocument$2","isDocumentFragment$1","isTag","e","rawSet","console","error","setAttribute","set$3","setAll$1","attrs","get$9","getAttribute","getOpt","has$1","hasAttribute","remove$a","removeAttribute","clone$4","attributes","attr","read$4","supports","classList","get$8","add$3","clazz","id","add$4","remove$8","remove$9","add$2","add","cleanClass","remove$7","remove","toggle$1","result","toggle","toggle$2","has","contains","fromDom$2","node","SugarElement","fromHtml","html","div","createElement","innerHTML","hasChildNodes","childNodes","fromTag","fromText","text","createTextNode","fromDom","fromPoint","docElm","elementFromPoint","recurse","cur","is$1","selector","elem","msMatchesSelector","webkitMatchesSelector","mozMatchesSelector","bypassSelector","childElementCount","e1","e2","d1","d2","owner$1","ownerDocument","documentOrOwner","dos","defaultView","parent","parentNode","parentElement","parents$1","isRoot","stop","ret","rawParent","siblings","children$1","elements","prevSibling","previousSibling","nextSibling","prevSiblings","nextSiblings","child$1","cs","firstChild","lastChild","childNodesCount","isShadowRoot","host","supported","Element","attachShadow","Node","getRootNode","isSupported$1","getStyleContainer","doc","getHead","getShadowHost","getOriginalEventTarget","event","el","isOpenShadowHost","composed","composedPath","shadowRoot","inBody","getShadowRoot","body","ClosestOrAncestor","ancestor","ancestor$4","closest$4","child","descendant$2","descend","res","ancestor$3","descendant$1","base","querySelector","one","closest$3","closest$2","isEditable$2","assumeEditable","isContentEditable","editable","getRaw$1","contentEditable","isSupported","style","getPropertyValue","internalSet","property","setProperty","set$2","setAll","css","get$7","getComputedStyle","getUnsafeProperty","getRaw","raw","getAllRaw","ruleName","remove$6","removeProperty","internalRemove","before$3","marker","insertBefore","after$4","append$1","prepend","appendChild","wrap$2","wrapper","append","empty","textContent","rogue","remove$5","removeChild","unwrap","children","fromDom$1","nodes","get$6","set$1","content","docDom","fragment","createDocumentFragment","contentElements","getOuter","clone","cloneNode","handle$1","handler","rawEvent","stopPropagation","prevent","preventDefault","kill","mkEvent","clientX","clientY","fromRawEvent","bind$2","useCapture","wrapped","addEventListener","unbind","removeEventListener","top","translate","SugarPosition","firstDefinedOrZero","viewport","offsetLeft","offsetTop","box","getBoundingClientRect","boxPosition","get$5","_DOC","scrollLeft","documentElement","scrollTop","to","win","scrollTo","intoView","alignToTop","scrollIntoViewIfNeeded","scrollIntoView","bounds","width","height","right","bottom","getBounds","_win","scroll","visualViewport","get$4","clientWidth","clientHeight","Math","max","pageLeft","pageTop","descendants$1","descendants","querySelectorAll","ancestor$2","DomTreeWalker","startNode","rootNode","next","prev","prev2","shallow","findSibling","findPreviousNode","startName","siblingName","sibling","isNodeType","isRestrictedNode","isElement$6","isHTMLElement","isSVGElement","namespaceURI","matchNodeName","lowerCasedName","matchNodeNames","names","lowerCasedNames","matchStyleValues","computed","attrName","isBogus$2","isTable$2","tagName","hasContentEditableState","isTextareaOrInput","isText$a","isCData","isPi","isComment","isDocument$1","isDocumentFragment","isBr$6","isImg","isContentEditableTrue$3","isContentEditableFalse$b","isTableCell$3","isTableCellOrCaption","isMedia$2","isListItem$2","isDetails","isSummary$1","isZwsp$2","char","api$1","getOption","nodeValue","get","set","NodeValue","get$3","lazyLookup","lookup","isBr$5","isTextBlock$2","isList","isListItem$1","isTableSection","isTableCell$2","isWsPreserveElement","removeTrailingBr","elm","allBrs","brs","rawNode","getLastChildren$1","createPaddingBr","br","fillWithPaddingBr","isZwsp$1","trim$2","isElement$5","isText$9","isCaretContainerBlock$1","isCaretContainerInline","data","isCaretContainer$2","hasContent","isBeforeInline","pos","charAt","offset","isAtStart","isAfterInline","isAtEnd","startsWithCaretContainer$1","endsWithCaretContainer$1","showCaretContainerBlock","caretContainer","getElementsByTagName","lastBr","trimBogusBr","isRangeInCaretContainerBlock","range","startContainer","isContentEditableTrue$2","isContentEditableFalse$a","isBr$4","isText$8","isInvalidTextElement","isAtomicInline","isTable","isCaretContainer$1","isCaretCandidate$3","isNonUiContentEditableFalse","isUnselectable","isEditableCaretCandidate$1","root","tempNode","isInEditable","whiteSpaceRegExp","isWhitespaceText","isZwsp","c","isCollapsibleWhitespace$1","isNewLineChar","isNewline","normalize$4","tabSpaces","isStartOfContent","isEndOfContent","tabSpace","normalizedText","pcIsSpace","isWhitespace$1","rootElement","hasWhitespacePreserveParent","isContent$1","isNamedAnchor","isBookmark","isBogus$1","isBogusAll","attrValue","hasNonEditableParent","isEmptyNode","targetNode","skipBogus","brCount","walker","isEmpty$2","isNonHtmlElementRootName","isNonHtmlElementRoot","toScopeType","namespaceElements","makeSelectorFromSchemaMap","elementNames","ns","updateTransparent","blocksSelector","transparent","updateBlockStateOnChildren","schema","transparentSelector","getTransparentElements","getBlockElements","trimEdge","leftSide","childPropertyName","splitInvalidChildren","transparentBlocks","blocksElements","isBlock","transparentBlock","parentBlock","invalidChildren","isValidChild","stateScope","parentElm","splitElm","createRange","setStartBefore","setEndBefore","beforeFragment","extractContents","setStartAfter","setEndAfter","afterFragment","split$2","updateChildren","isTransparentBlock","block","isTransparentInline","unwrapInvalidChildren","updateElement","isTransparentElement","hasBlockAttr","isTransparentElementName","isTransparentAstBlock","browser$2","firstElement","hasChild","getPos","rootElm","clientLeft","clientTop","offsetParent","castOffsetParent","caption","bodyTop","captionTop","captionHeight","offsetHeight","getTableCaptionDeltaY","StyleSheetLoader","documentOrShadowRoot","settings","idCount","loadedStates","edos","_setReferrerPolicy","referrerPolicy","_setContentCssCors","contentCssCors","addStyle","removeStyle","styleContainer","getOrCreateState","passed","failed","load","Promise","success","failure","link","urlWithSuffix","state","callbacks","status","onload","onerror","linkElem","rel","loadRawCss","styleElem","loadAll","urls","allSettled","then","results","reject","reason","unload","unloadRawCss","unloadAll","instance","WeakMap","forElement","referenceElement","rootDom","sl","create$d","isInlineContent","isInline","isBookmarkNode$2","isSpan","isKeepTextNode","prevIsInline","nextIsInline","surroundedByInlineContent","trimNode","currentChildren","isDocument","isKeepElement","makeMap$3","attrsCharsRegExp","textCharsRegExp","rawCharsRegExp","entityRegExp","asciiMap","baseEntities","reverseEntities","buildEntitiesLookup","itemList","chr","fromCharCode","entity","namedEntities","encodeRaw","encodeNumeric","charCodeAt","encodeNamed","entities","resolveEntities","Entities","encodeAllRaw","getEncodeFunc","entitiesMap","encodeNamedAndNumeric","encodeCustomNamed","nameMap","named","numeric","decode","innerText","nativeDecode","split$1","patternToRegExp","RegExp","parseCustomElementsRules","customElementRegExp","rule","exec","inline","cloneName","makeSchema","globalAttributes","phrasingContent","flowContent","blockContent","getElementSetsAsStrings","addElement","attributesOrder","childNames","ni","allAttributes","addAttrs","schemaItem","video","audio","table","script","parseValidChildrenRules","childRuleRegExp","operation","prefixToOperation","validChildren","parseValidElementsRules","globalElement","validElements","elementRuleRegExp","elementName","outputName","attrsPrefix","attrData","cloneAttributesInto","paddEmpty","removeEmpty","removeEmptyAttrs","targetElement","attrRuleRegExp","hasPatternsRegExp","attrType","attrPrefix","attributesRequired","required","splice","attributesDefault","defaultValue","attributesForced","forcedValue","validValues","attrPattern","attributePatterns","pattern","parseValidElementsAttrDataIntoElement","aliasName","mapCache","makeMap$2","each$b","extend$2","explode$2","createMap","extendWith","toUpperCase","getTextRootBlockElements","getTextBlockElements","compileElementMap","mode","styles","Schema","patternElements","customElementsMap","specialElements","createLookupTable","option","newValue","schemaType","schemaItems","verify_html","valid_elements","validStyles","valid_styles","invalidStyles","invalid_styles","validClasses","valid_classes","whitespaceElementsMap","selfClosingElementsMap","voidElementsMap","boolAttrMap","nonEmptyOrMoveCaretBeforeOnEnter","nonEmptyElementsMap","moveCaretBeforeOnEnterElementsMap","headings","textBlockElementsMap","blockElementsMap","textInlineElementsMap","transparentElementsMap","wrapBlockElementsMap","addValidElements","_ref","patternElement","setValidElements","addCustomElements","customElements","text_block_elements","block_elements","_ref2","customRule","elmName","addValidChildren","_ref3","getElementRule","_val","padd_empty_block_inline_children","paddInEmptyBlock","svg","custom_elements","valid_children","extended_valid_elements","dd","dt","li","td","th","tr","tbody","thead","tfoot","legend","area","param","parents","parentsRequired","invalid_elements","getValidStyles","getInvalidStyles","getValidClasses","getBoolAttrs","getTextInlineElements","getVoidElements","seal","getSelfClosingElements","getNonEmptyElements","getMoveCaretBeforeOnEnterElements","getWhitespaceElements","getWrapBlockElements","getSpecialElements","isValid","attrPatterns","isWrapper","getCustomElements","normalizeHex","hex","toHex","component","fromRgba","rgbaColour","hexColour","red","green","blue","rgbRegex","rgbaRegex","alpha","fromStringValues","g","parseFloat","fromString","rgbaString","rgbMatch","rgbaMatch","rgba","rgbaToHexString","color","h","Styles","urlOrStrRegExp","styleRegExp","trimRightRegExp","encodingLookup","invisibleChar","encodingItems","self","parse","isEncoded","urlConverter","url_converter","urlConverterScope","url_converter_scope","compress","noJoin","canCompress","encode","keepSlashes","decodeSingleHexSequence","escSeq","decodeHexSequences","processUrl","match","url2","url3","str2","allow_script_urls","scriptUrl","allow_svg_data_urls","lastIndex","force_hex_color","border","serialize","serializeStyles","elemName","validStyleList","styleList","styleMap","deprecated","keyLocation","layerX","layerY","returnValue","webkitMovementX","webkitMovementY","keyIdentifier","mozPressure","needsNormalizing","Event","initEvent","isNativeEvent","clone$3","originalEvent","getModifierState","keyArg","getTargetRanges","normalize$3","fallbackTarget","srcElement","defaultPrevented","isDefaultPrevented","cancelBubble","isPropagationStopped","stopImmediatePropagation","isImmediatePropagationStopped","hasIsDefaultPrevented","mouseEventRe","addEvent","capture","removeEvent","fix","isMouseEvent","pageX","eventDoc","mouseEvent","pageY","bindOnReady","eventUtils","domLoaded","readyHandler","readyState","EventUtils","events","expando","Date","hasFocusIn","callbackList","defaultNativeHandler","evt","executeHandlers","namesList","nativeHandler","fakeName","func","eventMap","ci","newCallbackList","ex","fire","dispatch","parentWindow","clean","destroy","cancel","each$a","numericalCssMap","legacySetAttribute","camelCaseToHyphens","findNodeIndex","normalized","lastNodeType","updateInternalStyleAttr","rawValue","applyStyle$1","$elm","cssName","cssValue","normalizedName","convertStyleToString","setupAttrHooks","getContext","keepValues","keep_values","keepUrlHook","sugarElm","attrHooks","href","src","DOMUtils","addedStyles","files","counter","stdMode","boxModel","styleSheetLoader","boundEvents","ownEvents","getElementById","_get","getAttrib","defaultVal","hook","getAttribs","setAttrib","run","val","originalValue","onSetAttrib","attrElm","deep","getRoot","root_element","getViewPort","argWin","vp","w","getPos$1","setStyle","update_styles","setStyles","stylesArg","getStyle","getSize","offsetWidth","getRect","size","elms","getParents","collect","resolvedRoot","selectorVal","getParent","_findSib","getNext","getPrev","isParentNode","select","_b","context","setAttribs","setHTML","create","newElm","createHTML","outHtml","createFragment","frag","keepChildren","$node","removeAllAttribs","removeAttributeNode","parseStyle","cssText","serializeStyle","DOM","styleElm","styleSheet","loadCSS","catch","toggleClass","cls","classes","addClass","removeClass","hasClass","show","hide","isHidden","uniqueId","getOuterHTML","outerHTML","setOuterHTML","insertAfter","reference","referenceNode","oldElm","replacee","replaceChild","rename","attrNode","findCommonAncestor","ps","pe","isNonEmptyElement","isEmpty","options","whitespaceElements","nonEmptyElements","bogusVal","includeZwsp","createRng","replacementElm","setStart","setEnd","rv","boundTarget","boundName","boundFunc","getContentEditable","getContentEditableParent","isEditable","_","isChildOf","dumpRng","startOffset","endContainer","endOffset","nodeIndex","DOM$b","ScriptLoader","states","queue","scriptLoadedCallbacks","queueLoadedCallbacks","loading","loadScript","cleanup","isDone","markDone","loadQueue","loadScripts","scripts","execCallbacks","processResults","failures","_ref4","processQueue","nextQueuedItem","shift","uniqueScripts","Cell","initial","currentCode","getLanguageData","I18n","getData","setCode","newCode","getCode","code","langData","lcNames","translation","lcName","firstIndex","isDuplicated","getLangData","textStr","removeContext","isTokenised","$1","$2","isRtl","dir","hasCode","AddOnManager","_listeners","runListeners","matchedListeners","listener","isLoaded","isAdded","loadLanguagePack","languages","language","waitFor","requireLangPack","languageLoad","addOn","createUrl","baseUrl","dep","resource","addOnUrl","urlString","baseURL","lastIndexOf","done","PluginManager","ThemeManager","ModelManager","repeatable","delay","intervalId","revoke","clearInterval","clear","isSet","functionToRepeat","setInterval","value$2","subject","doRevoke","singleton","on","first$1","rate","timer","clearTimeout","throttle","setTimeout","last$1","annotation","dataAnnotation","dataAnnotationId","dataAnnotationActive","dataAnnotationClasses","dataAnnotationAttributes","isRoot$1","identify","editor","annotationName","rng","selection","getRng","getBody","an","newStart","uid","findMarkers","isBogusElement","descendant","findAll","markers","directory","m","nodesAlready","setup$y","registry","changeCallbacks","initData","listeners","previous","withCallbacks","updateCallbacks","callbackMap","outputData","toggleActiveAttr","onNodeChange","annotations","getNames","fireNoAnnotation","_ref5","fireCallbacks","addListener","unique","generate$1","time","getTime","random","floor","clone$2","original","isDeep","shallow$1","deep$1","mutate","shallowAs","TextWalker","isBoundary","direction","TextSeeker","isBlockBoundary","process","newOffset","backwards","forwards","round$2","round","clone$1","rect","collapse","toStart","isValidOverflow","overflowY","rect1","rect2","min","isAbove$1","halfHeight","isBelow$1","distanceToRectEdgeFromXY","cx","cy","sqrt","getSelectedNode","getNode$1","safeOffset","clamp$2","extendingChars","isExtendingChar","ch","isElement$4","isCaretCandidate$2","isBlock$2","isFloated","isValidElementCaretCandidate","and","isNotPre","isText$7","isBr$3","nodeIndex$1","resolveIndex$1","createRange$1","isWhiteSpace$1","isRange","isHiddenWhiteSpaceRange","isZeroRect","getBoundingClientRect$1","clientRect","clientRects","getClientRects","brNode","nbsp$1","getBrClientRect","sc","ec","so","eo","newRng","cloneRange","getBoundingClientRectWebKitText","collapseAndInflateWidth","newClientRect","getCaretPositionClientRects","caretPosition","addUniqueAndValidRect","addCharacterOffset","beforeNode","CaretPosition","toRange","isVisible","isEqual","getNode","before","fromRangeStart","fromRangeEnd","after","isAbove","pos1","pos2","isBelow","isTextPosition","isElementPosition","trimEmptyTextNode$1","rangeInsertNode","insertNode","insertFragment","isText$6","isBogus","normalizedParent","getChildNodes","equal","createPathItem","numTextFragments","normalizedNodeIndex","create$b","outputOffset","normalizedTextOffset","parentsUntil$1","resolve$1","paths","resolvePathItem","nodeOffset","targetOffset","dataLen","findTextPosition","isContentEditableFalse$9","getPoint","point","trimmedOffset","getNormalizedTextOffset$1","findIndex","moveEndPoint$1","normalizeTableCellSelection","getOffsetBookmark","findAdjacentContentEditableFalseElm","forward","isForward","fakeCaret","isFakeCaret","isCollapsed","getLocation","getCaretBookmark","getRangeBookmark","createBookmarkSpan","filled","getPersistentBookmark","collapsed","rng2","endBookmarkNode","startBookmarkNode","moveToBookmark","keep","getUndoBookmark","value$1","applyHelper","constHelper","outputHelper","output","inner","_onError","onValue","isValue","isError","Result","mapError","toOptional","onError","_onValue","fromOption","optional","err","Adt","cases","constructors","adt","acase","keys$1","argLength","branches","branchKeys","reqKey","foldArgs","log","label","params","bothErrors","firstError","secondError","bothValues","isInlinePattern","isBlockPattern","normalizePattern","formatOrCmd","onFormat","onCommand","format","formats","cmd","command","commandValue","getBlockPatterns","patterns","getInlinePatterns","fromRawPatterns","errors","partition$1","deviceDetection$1","DOM$a","getHash","isRegExp","stringOrObjectProcessor","bodyOptionProcessor","valid","bodyObj","getIframeAttrs","getDocType","getDocumentBaseUrl","getBodyId","getBodyClass","getContentSecurityPolicy","shouldPutBrInPre$1","getForcedRootBlock","getForcedRootBlockAttrs","getNewlineBehavior","getBrNewLineSelector","getNoNewLineSelector","shouldKeepStyles","shouldEndContainerOnEmptyBlock","isAutomaticUploadsEnabled","shouldReuseFileName","shouldReplaceBlobUris","getIconPackName","getIconsUrl","getImageUploadUrl","getImageUploadBasePath","getImagesUploadCredentials","getImagesUploadHandler","shouldUseContentCssCors","getReferrerPolicy","getLanguageCode","getLanguageUrl","shouldIndentUseMargin","getIndentation","getContentCss","getContentStyle","getFontCss","getDirectionality","getInlineBoundarySelector","getObjectResizing","getResizeImgProportional","getPlaceholder","getEventRoot","getServiceMessage","getTheme","getThemeUrl","getModel","getModelUrl","isInlineBoundariesEnabled","getFormats","getPreviewStyles","canFormatEmptyLines","getFormatNoneditableSelector","getCustomUiSelector","isInline$1","hasHiddenInput","shouldPatchSubmit","shouldAddFormSubmitTrigger","shouldAddUnloadTrigger","getCustomUndoRedoLevels","shouldDisableNodeChange","isReadOnly$1","hasEditableRoot$1","hasContentCssCors","getPlugins","getExternalPlugins$1","shouldBlockUnsupportedDrop","isVisualAidsEnabled","getVisualAidsTableClass","getVisualAidsAnchorClass","getIframeAriaText","getSetupCallback","getInitInstanceCallback","getUrlConverterCallback","getAutoFocus","shouldBrowserSpellcheck","getProtect","shouldPasteBlockDrop","shouldPasteDataImages","getPastePreProcess","getPastePostProcess","getNewDocumentContent","getPasteWebkitStyles","shouldPasteRemoveWebKitStyles","shouldPasteMergeFormats","isSmartPasteEnabled","isPasteAsTextEnabled","getPasteTabSpaces","shouldAllowHtmlDataUrls","getTextPatterns","getTextPatternsLookup","getNonEditableClass","getEditableClass","getNonEditableRegExps","shouldPreserveCData","shouldHighlightOnFocus","shouldSanitizeXss","shouldUseDocumentWrite","getAllowedImageFileTypes","hasTableTabNavigation","getDetailsInitialState","getDetailsSerializedState","shouldForceHexColor","shouldSandboxIframes","isElement$3","isText$5","removeNode$1","trimCount","trimmedText","deleteZwspChars","deleteData","removeUnchanged","remove$3","removeElementAndReposition","newPosition","indexOf$1","removeTextCaretContainer","removeTextAndReposition","removeAndReposition","removeElementCaretContainer","caretContainerNode","isContentEditableFalse$8","isMedia$1","isTableCell$1","getAbsoluteClientRect","scrollX","scrollY","rootRect","margin","FakeCaret","hasFocus","lastVisualCaret","cursorInterval","caretBlock","fakeCaretTargetNodes","trimInlineCaretContainers","caretState","caret","startBlink","textNode","splitText","insertInline$1","isInlineFakeCaretTarget","blockName","blockNode","insertBlock","getCss","reposition","isFakeCaretTableBrowser","isFakeCaretTarget","isContentEditableTrue$1","isContentEditableFalse$7","isMedia","isBlockLike","isCaretContainer","isCaretContainerBlock","isElement$2","isText$4","isCaretCandidate$1","isForwards","isBackwards","skipCaretContainers","findNode","predicateFn","isCefOrCaretContainer","getParentBlock$3","isInSameBlock","caretPosition1","caretPosition2","getChildNodeAtRelativeOffset","relativeOffset","beforeAfter","isNodesInSameBlock","node1","node2","lean","before$2","after$2","normalizeRange","leanLeft","leanRight","location","getRelativeCefElm","getNormalizedRangeEndPoint","normalizedRange","getElementFromPosition","getVisualCaretPosition","walkFn","isMoveInsideSameBlock","inSameBlock","HDirection","isContentEditableFalse$6","isText$3","isElement$1","isBr$2","isCaretCandidate","isAtomic","isAtomicContentEditableFalse","isEditableCaretCandidate","nodeAtIndex","getCaretCandidatePosition","findCaretPosition$1","startPos","nextNode","innerNode","Forwards","moveForwardFromBr","rootContentEditableFalseElm","getParents$3","CaretWalker","Backwards","isBeforeOrStart","position","isAfterOrEnd","isBeforeAfterSameElement","shouldSkipPosition","fromPosition","navigate","navigateIgnore","ignoreFilter","positionIn","walkToPositionIn","nextPosition","prevPosition","firstPositionIn","lastPositionIn","isCaretNode","getParentCaretContainer","currentNode","isIndexBookmark","bookmark","isPathBookmark","isForwardBookmark","addBogus","tryFindRangePosition","padEmptyCaretContainer","isEmpty$1","insertZwsp","setEndPoint","isValidTextNode","restoreEndPoint","markerParent","otherMarker","appendData","resolvePaths","isStringPathBookmark","endPos","resolveCaretPositionBookmark","isIdBookmark","spos","epos","resolveId","selectNode","resolveIndex","isRangeBookmark","getBookmark$1","getBookmark$2","_ref6","setRng","isBookmarkNode$1","isNbsp","expected","isWhiteSpace","isContent","getRanges$1","ranges","rangeCount","getRangeAt","getCellsFromRanges","getSelectedNodes","getCellsFromElementOrRanges","selectedCells","getCellsFromEditor","getSel","getClosestTable","cell","getFirstChildren","getLastChildren","hasAllContentsSelected","getStartNode","getEndNode","endNode","moveEndPoint","hasAnyRanges","sel","runOnRanges","executor","fakeSelectionNodes","fakeNodeRng","preserve","fillBookmark","isNode","isElementNode$1","preserveSelection","action","shouldMoveStart","selectedNodeBeforeAction","isSelectedBeforeNodeNoneditable","getStart","moveStartToNearestText","selectedAttr","isElementDirectlySelected","isWhiteSpaceNode$1","getNonWhiteSpaceSibling","inc","nextName","isTextBlock$1","ed","allowSpaces","isWrappableNoneditable","formatNoneditableSelector","isWrapNoneditableTarget","replaceVars","vars","isEq$5","str1","normalizeStyleValue","strValue","getTextDecoration","decoration","getParents$2","isFormatPredicate","formatName","formatter","areSimilarFormats","otherFormatName","validKeys","filterObj","validKey","fmt1","filteredFmt1","fmt2","filteredFmt2","equal$1","isBlockFormat","isSelectorFormat","isInlineFormat","shouldExpandToSelector","expand","isCaretContainerEmpty","getEmptyCaretContainers","isEmptyCaretFormatElement","isBookmarkNode","getParents$1","isWhiteSpaceNode","isTextBlock","findParentContentEditable","walkText","findSpace","findContent","findWordEndPoint","includeTrailingSpaces","lastTextNode","textSeeker","textOffset","findSelectorEndPoint","formatList","curFormat","findBlockEndPoint","scopeRoot","isAtBlockBoundary$1","findParentContainer","block_expand","isSelfOrParentBookmark","expandRng","includeTrailingSpace","_ref7","_ref8","walk$3","exclude","firstNode","lastNode","collectSiblings","findEndPoint","walkBoundary","startPoint","endPoint","validBlocks","wrapName","isZeroWidth","isAnnotation","applyAnnotation","masterUId","decorate","directAnnotation","otherData","attributeNames","removeDirectAnnotation","customAttrNames","customClasses","makeAnnotation","eDoc","master","annotate","newWrappers","getDoc","finishWrapper","processElements","elems","processElement","processNodes","annotateWithBookmark","undoManager","transact","initialRng","hasFakeSelection","masterUid","applyWordGrab","selectionRng","Annotator","register","create$c","dataAnnotation$1","identifyParserNode","newClassList","serializer","addTempAttr","addAttributeFilter","persistent","setup$x","changes","removeAnnotations","annotationChanged","_ref9","getBookmark","removeAll","getAll","BookmarkManager","isXYWithinRange","containsXY","fireError","errorType","fireFormatApply","fireFormatRemove","fireSetContent","fireGetContent","firePastePlainTextToggle","VK","BACKSPACE","DELETE","DOWN","ENTER","ESC","LEFT","RIGHT","SPACEBAR","TAB","UP","PAGE_UP","PAGE_DOWN","END","HOME","modifierPressed","shiftKey","ctrlKey","altKey","metaKeyPressed","metaKey","abs","round$1","resizeHandles","nw","ne","se","sw","ControlSelection","editableDoc","rootDocument","selectedElm","selectedElmGhost","resizeHelper","selectedHandle","resizeBackdrop","startX","startY","startW","startH","ratio","resizeStarted","startScrollWidth","startScrollHeight","isImage","contextMenuSelectImage","isTouchEvent","touch","touches","isEventOnImageOutsideRange","getResizeTargets","firstElementChild","isResizable","setSizeProp","targets","setGhostElmSize","ghostElm","resizeGhostElement","deltaX","deltaY","proportional","resizeHelperX","resizeHelperY","screenX","screenY","display","selectedElmX","selectedElmY","scrollWidth","scrollHeight","origin","fireObjectResizeStart","endGhostResize","wasResizeStarted","showResizeRect","fireObjectResized","nodeChanged","targetElm","unbindResizeHandleEvents","targetWidth","targetHeight","hideResizeRect","handle","startDrag","handleElm","throttledShowResizeRect","removeSelected","isChildOrEqual","updateResizeRect","removed","composing","controlElm","selectedValue","img","disableGeckoResize","startElm","getEnd","execCommand","relativeToNative","startSitu","finishSitu","situ","setFinish","exactToNative","soffset","finish","foffset","adt$3","ltr","rtl","fromRange","diagnose","domRange","relative","exact","getRanges","rev","doDiagnose","SimRange","caretPositionFromPoint","offsetNode","caretRangeFromPoint","availableSearch","adt$2","Situ","cata","onBefore","onOn","onAfter","adt$1","SimSelection","exactFromRange","simRange","getWin","_finishSitu","_soffset","_finish","_foffset","getStart$1","beforeSpecial","name$1","preprocessRelative","preprocessExact","fromElements","toNative","getDomRange","filtered","preprocess","getAtPoint","fromPoint$1","isEq$4","rng1","hasParent$1","findParent","hasParentWithName","isCeFalseCaretContainer","hasBrBeforeAfter","findTextNodeRelative","isAfterNode","lastInlineElement","parentBlockContainer","normalizeEndPoint","directionLeft","hasContentEditableFalseParent","isPrevNode","normalize$2","normRng","newContainer","RangeUtils","rangeLike","newRange","normalize","normalizedRng","compareRanges","getCaretRangeFromPoint","api","getOffset","aggregate","properties","cumulativeInclusions","Dimension","getDocument","walkUp","navigation","view","owner","rest","Navigation","freeze","__proto__","frameElement","find","frames","pathTo","loc","excludeFromDescend","markerInfo","cleanupFun","pageYOffset","pageXOffset","absolute","get$2","createMarker$1","last","span","withMarker","preserveWith","_s","_e","applyWithMarker","withScrollEvents","fireScrollIntoViewEvent","fireAfterScrollIntoViewEvent","withElement","elementMarker","startElement","endElement","scrollToMarker","viewHeight","intoWindowIfNeeded","viewportBottom","markerTop","markerBottom","largerThanViewport","intoWindow","innerHeight","intoFrame","frameViewHeight","op","viewportBounds","rangeIntoWindow","elementIntoWindow","rangeIntoFrame","elementIntoFrame","scrollRangeIntoView","focus$1","preventScroll","focus","hasFocus$1","activeElement","active$1","clamp$1","normalizeRng","isOrContains","isRngInRoot","nativeRangeToSelectionRange","getSelection","readRange","bookmarkToNativeRng","store","newBookmark","shouldStore","validate","FocusManager","isEditorUIElement","className","Delay","setEditorTimeout","wrappedSetTimeout","setEditorInterval","wrappedSetInterval","register$6","throttledStore","mouseUpPage","registerPageMouseUp","registerMouseUp","selectionChange","isManualNodeChange","registerEditorEvents","documentFocusInHandler","DOM$9","isEditorContentAreaElement","isUIElement","customSelector","getActiveElement","getElement","registerEvents$1","editorManager","toggleContentAreaOnFocus","getContainer","focusedEditor","setActive","blurredEditor","activeEditor","unregisterDocumentEvents","getFocusInElement","getCollapsedNode","normalizeSelection","caretPos","focusBody","hasElementFocus","rawBody","hasInlineFocus","iframeElement","hasIframeFocus","hasEditorOrUiFocus","hasUiFocus","activateEditor","skipFocus","quirks","refreshContentEditable","bookmarkRng","contentEditableHost","getContentEditableHost","focusEditor","isEditableRange","getEndpointElement","real","getEnd$1","skipEmptyTextNodes","orig","processRanges","elementsWithCursorPosition","isCursorPosition","hasCursorPosition","isContentEditableFalse$5","descendantRtl","create$9","findIn","setCursorLocation","detect$1","typeLookup","walk$2","isEmptyTextNode","AstNode","insert","selfAttrs","cloneAttrs","selfAttr","wrap","refNode","whitespace","unescapedTextParents","containsZwsp","includes","getTemporaryNodeSelector","tempAttrs","createZwspCommentWalker","createTreeWalker","NodeFilter","SHOW_COMMENT","FILTER_ACCEPT","FILTER_SKIP","createUnescapedZwspTextWalker","SHOW_TEXT","hasZwspComment","hasUnescapedZwspText","hasTemporaryNode","trimTemporaryNodes","getTemporaryNodes","emptyAllNodeValuesInWalker","curr","emptyZwspComments","emptyUnescapedZwspTexts","trim$1","conditionalTrims","condition","trimmed","cloned","_ref10","cleanupBogusElements","bogusElements","cleanupInputNames","inputs","input","getPlainTextContent","offscreenDiv","getContentContainer","getContentFromBody","getTempAttrs","emptyRegExp","trimEmptyContents","makeMap$1","Writer","indent","indentBefore","indent_before","indentAfter","indent_after","entity_encoding","htmlOutput","element_format","cdata","comment","pi","doctype","reset","getContent","HtmlSerializer","writer","handlers","sortedAttrs","elementRule","nonInheritableStyles","Set","shorthandStyleProps","getStyleProps","hasInheritableStyles","isNonInheritableStyle","hasStyleConflict","nodeStyleProps","parentNodeStyleProps","valueMismatch","prop","parentValue","nodeStyleProp","propExists","longhandProps","isChar","delta","isBeforeSpace","isAfterSpace","isEmptyText","matchesElementPosition","isImageBlock","isCefNode","isBogusAll$1","isBeforeImageBlock","isAfterImageBlock","isBeforeMedia","isAfterMedia","isBeforeTable","isAfterTable","isBeforeContentEditableFalse","isAfterContentEditableFalse","parentsUntil","parentsAndSelf","navigateIgnoreEmptyTextNodes","getClosestBlock$1","isBlock$1","isAtBeforeAfterBlockBoundary","newPos","fromBlock","isAtBlockBoundary","isAtStartOfBlock","isAtEndOfBlock","isBeforeBlock","isAfterBlock","isBr$1","findBr","parentBlocks","isBeforeBr$1","isAfterBr","getElementFromPrevPosition","findPreviousBr","findNextBr","isInMiddleOfText","getClosestBlock","hasSpaceBefore","hasSpaceAfter","isInPre","isPreValue","isAtLineBoundary","isAtBeginningOfBody","isAtEndOfBody","isSiblingCefBlock","needsToHaveNbsp","needsToBeNbspLeft","prevPos","isPrevCefBlock","isAfterCefBlock","needsToBeNbspRight","nextPos","isNextCefBlock","isBeforeCefBlock","needsToBeNbsp","isNbspAt","isWhiteSpaceAt","normalizeNbspAtStart","makeNbsp","firstPos","normalizeNbspInMiddleOfTextNode","newText","chars","normalizeNbspMiddle","normalizeNbspAtEnd","lastPos","normalizeNbsps","hasNbsp","normalize$1","replaceData","normalizeWhitespaceAfter","whitespaceCount","normalizeWhitespaceBefore","mergeTextNodes","prevNode","normalizeWhitespace","mergeToPrev","whitespaceOffset","newNode","removeNode","insertData","needsReposition","getPreviousSiblingCaretPosition","getNextSiblingCaretPosition","findCaretPositionBackwards","findCaretPositionBackwardsFromElm","findCaretPositionForward","findCaretPositionForwardsFromElm","findCaretPosOutsideElmAfterDelete","findCaretPosition","setSelection$1","eqRawNode","paddEmptyBlock","preserveEmptyCaret","deleteNormalized","afterDeletePosOpt","prevTextOpt","nextTextOpt","oc","isInlineElement","deleteElement$2","moveCaret","afterDeletePos","normalizedAfterDeletePos","setContent","paddPos","strongRtl","isInlineTarget","hasStrongRtl","findRootInline","findInlineParents","normalizePosition","normalizeForwards","normalizeBackwards","execCommandIgnoreInputEvents","inputBlocker","off","execNativeDeleteCommand","isTextBlockOrListItem","getParentBlock$2","isBeforeRoot","paddEmptyBody","moveSelection","no_selection","willDeleteLastPositionInElement","fromPos","normalizedFirstPos","normalizedLastPos","normalizedFromPos","freefallRtl","deleteRangeContents","deleteContents","lastBlock","additionalCleanupNodes","sibling$1","getTableCells","getTable$1","adjustQuirksInDetails","details","startTable","endTable","isStartTableParentOfEndTable","isEndTableParentOfStartTable","isSameTable","isMultiTable","selectionInTableWithNestedTable","tableCellRng","deleteAction","singleCellTable","fullTable","partialTable","multiTable","getClosestCell$1","isExpandedCellRng","cellRng","getTableFromCellRng","startParentTable","endParentTable","getTableSelectionFromCellRng","cells","tableSelection","getTableSelections","selectionDetails","sameTableSelection","startCell","endCell","startTableSelection","getCellRangeFromStartTable","endTableSelection","getCellRangeFromEndTable","getCellIndex","getSelectedCells","startIndex","endIndex","isSingleCellTableContentSelected","optCellRng","rows","isSingleCellTable","unselectCells","otherContentRng","getActionFromRange","isRootFromElement","getCellRng","isStartInTable","isEndInTable","getTableDetailsFromRange","_ref12","startTableSelectedCells","endTableSelectedCells","handleMultiTable","_ref11","handleSingleTable","cleanCells","deleteContentInsideCell","isFirstCellInSelection","insideTableRng","deleteCellContents","collapseAndRestoreCellSelection","selectedNode","emptySingleTableCells","outsideDetails","editorRng","cellsToClean","_ref13","outsideBlock","getOutsideBlock","startInTable","emptyBlock","handleEmptyBlock","endPointCell","emptyMultiTableCells","startTableCells","endTableCells","betweenRng","startTableCellsToClean","endTableCellsToClean","deleteTableElement","deleteTableRange","getParentCaption","deleteCellRange","emptyElement","deleteCaptionRange","getParentCell","deleteCaretInsideCaption","fromCaption","first","isDeleteOfLastCharPos","emptyCaretCaption","toCaption","validateCaretCaption","deleteCaretCells","fromCell","toCell","deleteBetweenCells","isNearTable","deleteCaret$3","isBeforeOrAfterTable","deleteCaretCaption","backspaceDelete$a","deleteRange$3","getContentEditableRoot$1","internalAttributesPrefixes","each$9","ElementUtils","internalAttributes","isAttributeInternal","attributeName","compare","attribs","compareObjects","obj1","obj2","isHeading","isSummary","matchNode$1","nodeFilters","attributeFilters","nl","ai","al","findMatchingNodes","traverse","childNode","runFilters","matchRecord","filteringAttributes","filter$2","paddEmptyNode","pad_empty_with_br","astNode","hasOnlyChild","isPadded","findClosestEditingHost","editableNode","removeOrUnwrapInvalidNode","originalNodeParent","cleanInvalidNodes","onCreate","textBlockElements","nonSplittableElements","fixed","isSplittableElement","newParent","isInvalid","hasClosest","parentName","normalizeBlockSelectionRange","commonAncestorContainer","newEndPos","isPaddedEmptyBlock","hasOnlyOneChild$1","isPaddingNode","isListFragment","isEmptyFragmentElement","isListItemPadded","isPadding","trimListItems","getParentLi","findLastOf","newCaretPos","insertBefore$2","findFirstIn","insertAtCaret$1","domFragment","cleanupDomFragment","toDomFragment","liTarget","liElms","isAt","caretWalker","newPosNode","insertAfter$2","beforeRng","afterRng","cloneContents","getSplit","insertMiddle","mergeableWrappedElements","isTableCell","trimBrsFromTableCell","lastChildPrevSibling","trimBlockTrailingBr","moveSelectionToMarker","_c","nextRng","parentEditableElm","isCell","isPartOfFragment","findNextCaretRng","deleteSelectedContent","isTableCellContentSelected","insertHtmlAtCaret","parser","merge","bookmarkHtml","preserve_zwsp","caretElement","canHaveChildren","parserArgs","paste","isParentBlockLi","isPastingSingleElement","isWrappedElement","isPastingInTheSameBlockTag","isPastingInContentEditable","shouldPasteContentOnly","markFragmentElements","_selectionOverrides","showBlockCaretContainer","invalid","notHeadingsInSummary","markerNode","findMarkerNode","editingHost","toExtract","getNodeFilters","getAttributeFilters","no_events","validInsertion","textInlineElements","elementUtils","reduceInlineTextElements","caretParent","updateCaret","isTreeNode","setEditorHtml","noSelection","setContentInternal","trimmedHtml","setContentTree","padd","forcedRootBlockName","isRootContent","setContentString","ensureIsRoot","closest$1","transform","transformed","isEq$3","matchesUnInheritedFormatSelector","inherit","matchParents","similar","matchedNode","matchNode","matchName","matchItems","itemName","matchAttributes","onmatch","expectedValue","isEmptyValue","match$2","closest","rawElm","matchAllOnNode","formatNames","matchSimilar","isVariableValue","field","fieldValues","isVariableFormatName","findFirstTextNode","createCaretContainer","fill","removeCaretContainerNode","trimZwspFromCaretContainer","removeCaretContainer","appendNode","insertFormatNodesIntoCaretContainer","formatNodes","innerMostFormatNode","formatNode","removeCaretFormat","hasContentAfter","expandedRng","parentsAfter","newCaretContainer","insertCaretContainerNode","cleanedFormatNode","validFormats","matchedFormats","fmtName","clonedFormatNode","cleanFormatNode","caretTextNode","setup$v","keyCode","disableCaretContainer","createCaretFormat","innerMost","replaceWithCaretFormat","isFormatElement","inlineElements","postProcessHooks","isPre","addPostProcessHook","blocks","getSelectedBlocks","preBlocks","pre","hasPreSibling","pre1","pre2","sPre2","joinPre","listItemStyles","findExpandedListItemFormat","fmt","hasListStyles","getExpandedListItemFormat","isRngStartAtStartOfElement","isRngEndAtEndOfElement","isEditableListItem","getFullySelectedListItems","middle","getFullySelectedBlocks","getPartiallySelectedListItems","each$8","isElementNode","findElementSibling","mergeSiblingsNodes","isPrevEditable","isNextEditable","tmpSibling","mergeSiblings","merge_siblings","processChildElements","hasStyle","applyStyle","unwrapEmptySpan","removeResult","MCE_ATTR_RE","each$7","isEq$2","isChildOfInlineParent","lastIdx","normalizeTableSelection","isTableCellOrRow","wrap$1","wrapWithSiblings","rootBlockElm","forcedRootBlock","list_block","isMixedFormat","processFormatAttrOrStyle","removeEmptyStyleAttributeIfNeeded","removeStyles","compareNode","stylesModified","styleName","styleValue","normalizedStyleValue","remove_similar","removeNodeFormatInternal","ceFalseOverride","links","isColorFormatAndAnchor","preserveAttributes","preserve_attributes","attrsToPreserve","currentValue","valueOut","removeNodeFormatFromClone","newName","removeFormatInternal","splitToFormatRoot","formatRoot","findFormatRoot","lastClone","firstClone","formatRootParent","mixed","wrapAndSplit","removeFormatOnNode","removeNodeFormat","currentNodeMatches","textDecoration","isRemoveBookmarkNode","removeRngStyle","liFmt","removeListStyleFormats","removeFormat$1","each$6","mergeWithChildren","clear_child_styles","_value","clearChildStyles","each$5","applyStyles","styleVal","applyFormatAction","setElementFormat","onformat","applyNodeStyle","found","createWrapElement","wrapElm","applyRngStyle","nodeSpecific","isMatchingWrappingBlock","isWrappingBlockFormat","canRenameBlock","isEditableDescendant","isValidBlockFormatForNode","isNonWrappingBlockFormat","currentWrapElm","lastContentEditable","isWrappableNoneditableElm","contentEditableValue","validBRParentElements","hasCaretNodeSibling","canFormatBR","isValidWrapNode","isCaret","isCorrectFormatForNode","canWrapNode","childCount","isEmptyTextNode$1","getChildCount","childElement","mergeStyles","merge_with_parents","mergeWithParents","backgroundColor","hasFontSize","mergeBackgroundColorAndFontSize","processTextDecorationsAndColor","parentTextDecoration","mergeTextDecorationsAndColor","inverseTagDescendants","mergeSubSup","wordcharRegex","importNode","applyCaretFormat","fake","postProcess$1","applyFormat$1","hasVars","fallbackElement","matchingNode","matchingFormat","updateAndFireChangeCallbacks","registeredCallbacks","runIfChanged","spec","withSimilar","withoutSimilar","withVars","formatChangedInternal","registeredFormatListeners","formatChangeItems","getCurrent","toAppendTo","addListeners","removeListeners","explode$1","create$8","filters","addFilter","getFilters","removeFilter","newCallbacks","addFontToSpansFilter","domParser","fontSizes","addNodeFilter","face","removeAttrs","addFilters","convert_fonts_to_spans","font_size_legacy_values","convertToSTag","addStrikeFilter","register$5","inline_styles","htmlParser","blockElements","prevName","lastParent","parseDataUri","uri","base64Encoded","extractedData","extractBase64Data","decodeURIComponent","buildBlob","atob","Uint8Array","Blob","uriToBlob","fetch","ok","blob","uriType","blobUriToBlob","_ref14","blobToDataUri","reader","FileReader","onloadend","readAsDataURL","count$1","processDataUri","dataUri","base64Only","generateBlobInfo","_ref15","base64","btoa","createBlobInfo$1","blobCache","blobInfo","dataUriToBlobInfo","getByData","imageToBlobInfo","imageSrc","invalidDataUri","getByUri","registerBase64ImageFilter","blob_cache","processImage","inputSrc","isInternalImageSource","isBogusImage","blobUri","isMimeType","mime","register$4","remove_trailing_brs","addNoOpener","newRel","appendRel","allow_unsafe_link_target","allow_html_in_named_anchor","fix_list_elements","classValue","validClassesMap","convert_unsafe_embeds","sandboxIframes","embed","createSafeEmbed","sandbox_iframes","entries","setPrototypeOf","isFrozen","getOwnPropertyDescriptor","create$7","construct","Reflect","fun","thisValue","Func","arrayForEach","unapply","forEach","arrayPop","pop","arrayPush","stringToLowerCase","stringToString","stringMatch","stringReplace","stringIndexOf","stringTrim","regExpTest","typeErrorCreate","TypeError","_len2","arguments","_key2","_len","_key","addToSet","transformCaseFunc","_transformCaseFunc","lcElement","object","newObject","lookupGetter","desc","warn","html$1","svg$1","svgFilters","svgDisallowed","mathMl$1","mathMlDisallowed","mathMl","xml","MUSTACHE_EXPR","ERB_EXPR","TMPLIT_EXPR","DATA_ATTR","ARIA_ATTR","IS_ALLOWED_URI","IS_SCRIPT_OR_DATA","ATTR_WHITESPACE","DOCTYPE_NAME","EXPRESSIONS","getGlobal","_createTrustedTypesPolicy","trustedTypes","purifyHostElement","createPolicy","policyName","createScriptURL","purify","createDOMPurify","DOMPurify","originalDocument","currentScript","DocumentFragment","HTMLTemplateElement","NamedNodeMap","MozNamedAttrMap","HTMLFormElement","DOMParser","ElementPrototype","getNextSibling","getParentNode","template","trustedTypesPolicy","emptyHTML","implementation","createNodeIterator","hooks","createHTMLDocument","IS_ALLOWED_URI$1","ALLOWED_TAGS","DEFAULT_ALLOWED_TAGS","ALLOWED_ATTR","DEFAULT_ALLOWED_ATTR","CUSTOM_ELEMENT_HANDLING","tagNameCheck","writable","configurable","enumerable","attributeNameCheck","allowCustomizedBuiltInElements","FORBID_TAGS","FORBID_ATTR","ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","ALLOW_SELF_CLOSE_IN_ATTR","SAFE_FOR_TEMPLATES","WHOLE_DOCUMENT","SET_CONFIG","FORCE_BODY","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_TRUSTED_TYPE","SANITIZE_DOM","SANITIZE_NAMED_PROPS","SANITIZE_NAMED_PROPS_PREFIX","KEEP_CONTENT","IN_PLACE","USE_PROFILES","FORBID_CONTENTS","DEFAULT_FORBID_CONTENTS","DATA_URI_TAGS","DEFAULT_DATA_URI_TAGS","URI_SAFE_ATTRIBUTES","DEFAULT_URI_SAFE_ATTRIBUTES","MATHML_NAMESPACE","SVG_NAMESPACE","HTML_NAMESPACE","NAMESPACE","IS_EMPTY_INPUT","ALLOWED_NAMESPACES","DEFAULT_ALLOWED_NAMESPACES","PARSER_MEDIA_TYPE","SUPPORTED_PARSER_MEDIA_TYPES","DEFAULT_PARSER_MEDIA_TYPE","CONFIG","formElement","isRegexOrFunction","testValue","_parseConfig","cfg","ADD_URI_SAFE_ATTR","ADD_DATA_URI_TAGS","ALLOWED_URI_REGEXP","ADD_TAGS","ADD_ATTR","TRUSTED_TYPES_POLICY","MATHML_TEXT_INTEGRATION_POINTS","HTML_INTEGRATION_POINTS","COMMON_SVG_AND_HTML_ELEMENTS","ALL_SVG_TAGS","ALL_MATHML_TAGS","_checkValidNamespace","parentTagName","Boolean","_forceRemove","_removeAttribute","attribute","getAttributeNode","_initDocument","dirty","leadingWhitespace","dirtyPayload","parseFromString","createDocument","_createIterator","SHOW_ELEMENT","_isClobbered","_isNode","_executeHook","entryPoint","_sanitizeElements","allowedTags","_basicCustomElementTest","_isValidAttribute","lcTag","_sanitizeAttributes","hookEvent","keepAttr","allowedAttributes","initValue","forceKeepAttr","getAttributeType","setAttributeNS","_sanitizeShadowDOM","shadowNode","shadowIterator","sanitize","importedNode","returnNode","nodeIterator","shadowroot","shadowrootmode","serializedHTML","setConfig","clearConfig","isValidAttribute","addHook","hookFunction","removeHook","removeHooks","removeAllHooks","each$4","queryParts","DEFAULT_PORTS","ftp","http","https","mailto","safeSvgDataUrlElements","isInvalidUri","decodedUri","encodedUri","unescape","decodeUri","allow_html_data_urls","allowSvgDataUrls","blockSvgDataUris","URI","uriComponents","protocol","pathname","baseUri","base_uri","source","isProtocolRelative","toAbsPath","urlMatch","part","userInfo","port","setPath","pathMatch","file","getURI","toRelative","relativeUri","tu","uu","toRelPath","anchor","toAbsolute","noHost","absoluteUri","isSameOrigin","defaultPort","breakPoint","normalizedBase","nb","normalizedPath","baseParts","pathParts","outPath","noProtoHost","filteredUrlAttrs","processNode","_d","allow_conditional_comments","lcTagName","isInternalElement","bogus","hasNone","shouldKeepAttribute","isRequiredAttributeOfInternalElement","ele","isBooleanAttribute","filterAttributes","setupPurify","namespaceTracker","purify$1","track","processAttr","sanitizeNamespaceElement","xlinkAttrs","config","getSanitizer","scopes","peek","currentScope","createNamespaceTracker","sanitizeHtmlElement","mimeType","getPurifyConfig","_mimeType","extend$1","transferChildren","nativeParent","nsSanitizer","isSpecial","nativeChild","walkTree","preprocessors","postprocessors","traverseOrder","postprocess","whitespaceCleaner","textRootBlockElements","allWhiteSpaceRegExp","startWhiteSpaceRegExp","endWhiteSpaceRegExp","hasWhitespaceParent","isAtEdgeOfBlock","neighbour","isLineBreakNode","isNodeEmpty","isTextRootBlockEmpty","isPaddedWithNbsp","getRootBlockName","forced_root_block","DomParser","nodeFilterRegistry","attributeFilterRegistry","defaultedSettings","root_name","sanitizer","parseAndSanitizeWithContext","rootName","isSpecialRoot","wrappedHtml","removeNodeFilter","removeAttributeFilter","findInvalidChildren","isWrappableNode","addRootBlocks","rootBlockName","rootBlockNode","rootBlock","forced_root_block_attrs","whitespacePre","whitespacePost","invalidFinder","matchFinder","topLevelChildren","otherChildren","exports","withSerializedContent","fireEvent","parserSettings","serializedContent","serializeContent","eventArgs","preProcessGetContent","fireBeforeGetContent","postProcessGetContent","processedEventArgs","preProcessSetContent","fireBeforeSetContent","postProcessSetContent","tableModel","tableRow","cellPosition","getSpan","cellExists","getWidth","row","findElementPos","extractRows","sx","sy","ey","newRows","tableElm","rowspan","colspan","y2","x2","fillout","skipCellsX","toDom","tableElement","tableBody","createDomTable","modelRowsToDomRows","subsection","subTable","getFullySelectedListWrappers","_li","findParentListContainer","listCont","listElm","listStyles","_style","getWrapElements","commonAnchorContainer","wrapElements","listWrappers","allWrappers","directListWrappers","emptyFragment","getFragmentFromRange","innerElm","getTableFragment","selectedTableCells","getParentTable","firstCell","lastCell","fullTableModel","sectionedTableModel","read$3","getSelectionFragment","isCollapsibleWhitespace","getInnerText","bin","extractSelectedContent","parentBlockOpt","contextNodeName","getContextNodeName","rangeContentClone","nonRenderedText","parentBlockText","textIndex","getTextContent","tmpElm","contextual","getSerializedContent","setupArgs$3","getInner","getOuterHtml","insertAt","write","fragments","diff","removeAt","applyDiff","vDown","vUp","buildScript","start1","end1","start2","end2","getMiddleSnake","diag","j","i2","buildSnake","snake","sum","lazyTempDocument","createFromEditor","hasIframes","trimZwsp","read$2","beforeBookmark","applyToEditor","level","getLevelContent","getCleanLevelContent","isEq$1","level1","level2","hasEqualContent","hasEqualCleanedContent","isUnlocked","locks","setTyping","typing","endTyping","makePlainAdaptor","init","bindEvents","beforeChange","beforeChange$1","currentLevel","newLevel","lastLevel","bm","customUndoRedoLevels","setDirty","addUndoLevel$1","undo","undo$1","redo","redo$1","clear$1","reset$1","hasUndo","hasUndo$1","hasRedo","hasRedo$1","ignore","transact$1","ignore$1","extra","callback1","callback2","extra$1","matchAll","matchedFormatNames","checkedMap","canApply","formatChanged","getContentInternal","insertContent","addVisual","matchedElm","hasVisual","addVisualInternal","defaultedArgs","updatedArgs","getSelectedContentInternal","autocompleter","addDecoration","removeDecoration","remove$2","isRtc","plugins","setup$t","editorCast","rtcPlugin","setup","getRtcSetup","rtcInstance","nul","makeNoopAdaptor","rtcEditor","defaultVars","_undoManager","_locks","_index","_node","_similar","_rfl","_details","_format","getRawModel","makeRtcAdaptor","rtc","isRemote","getRtcInstanceWithFallback","getRtcInstanceWithError","getContent$2","setContent$2","getSelectedContent","mergeAndNormalizeText","outerNode","outer","outerElm","oldLength","merge$1","innerTextNode","walkPastBookmark","normalizeTextIfRequired","rngSetContent","prevText","nextText","setupArgs$2","cleanContent","contextBlock","contextArgs","deleteFromCallbackMap","SelectorChanged","selectorChangedData","currentSelectors","findMatchingNode","selectorChangedWithUnbind","matchedSelectors","isAttachedToDom","EditorSelection","selectedRange","explicitRange","cleanedContent","createContextualFragment","setContent$1","getRng$1","tryCompareBoundaryPoints","how","sourceRange","destinationRange","compareBoundaryPoints","anchorNode","START_TO_START","END_TO_END","isValidRange","removeAllRanges","addRange","setBaseAndExtent","focusNode","anchorRange","focusRange","anchorOffset","focusOffset","getContent$1","bookmarkManager","compareEndPoints","fakeSelectedElements","setNode","endElm","selectedBlocks","selectorChanged","getScrollContainer","scrollContainer","scrollElementIntoView","placeCaretAt","controlSelection","process$1","hasEventListeners","shouldFireEvent","oldDoc","clonedNode","impl","firePreProcess","preProcess$1","getHtmlFromNode","parseHtml","isBr","brNode1","brNode2","trimTrailingBr","toHtml","serializeNode","outArgs","firePostProcess","postProcess","DomSerializerImpl","internalName","hasChildren","preserve_cdata","register$3","addRules","setRules","DomSerializer","domSerializer","setupArgs$1","setupArgs","removedOptions","deprecatedOptions","removedPlugins","deprecatedPlugins","replacedWith","getMatchingOptions","searchingFor","settingNames","setting","getRemovedOptions","getDeprecatedOptions","getMatchingPlugins","pluginNames","plugin","getRemovedPlugins","getDeprecatedPlugins","entry","getPluginDescription","logWarnings","rawOptions","normalizedOptions","hasRemovedPlugins","hasRemovedOptions","isLegacyMobileTheme","theme","listJoiner","themesMessage","pluginsMessage","optionsMessage","logRemovedWarnings","hasDeprecatedPlugins","hasDeprecatedOptions","logDeprecatedWarnings","DOM$8","safeDestroy","remove$1","editorUpload","save","is_removing","unbindAllNativeEvents","fireRemove","orgDisplay","restoreOriginalStyles","fireDetach","automatic","destroyed","_beforeUnload","form","_mceOldSubmit","submit","formEventDelegate","restoreForm","contentAreaContainer","editorContainer","bodyElement","contentDocument","contentWindow","clearDomReferences","IconManager","iconPack","icons","CreateIconManager","getProp","propName","getComputedSizeProp","getClientWidth","getClientHeight","getMarginTop","getMarginLeft","isXYInContentArea","bodyElm","transposedPoint","transpose","isInsideElementContentArea","isEditorAttachedToDom","rawContainer","getContentAreaContainer","NotificationManager","notifications","getImplementation","getNotificationManagerImpl","unimplemented","open","close","getArgs","NotificationManagerImpl","getTopNotification","progressBar","timeout","notification","addNotification","closeNotification","otherNotification","getEl","getNotifications","serviceMessage","requestAnimationFrame","registerEvents","WindowManager","dialogs","getWindowManagerImpl","openUrl","alert","confirm","WindowManagerImpl","funcBind","addDialog","dialog","fireOpenEvent","closeDialog","fireCloseEvent","otherDialog","storeSelectionAndOpenDialog","openDialog","ui","windowManagerImpl","displayNotification","notificationManager","displayError","_skinLoaded","logError","createLoadError","initError","toContentSkinResourceName","transformToUrls","cssLinks","skinUrl","contentCssFile","Resource","isBundledCssSkinName","isContentCssSkinName","documentBaseURI","appendContentCssFromSettings","contentCSS","getContentCssUrls","getFontCssUrls","getAllImages","UploadStatus","blobUriStatuses","createStatus","resultUri","hasBlobUri","getResultUri","isPending","isUploaded","markPending","markUploaded","removeFailed","uuid","rnd","seed","Uploader","uploadStatus","pendingPromises","defaultHandler","progress","xhr","XMLHttpRequest","withCredentials","credentials","upload","onprogress","loaded","total","json","JSON","responseText","path1","path2","basePath","formData","FormData","filename","send","uploadHandler","handlerSuccess","handlerFailure","resolvePending","uploadBlobs","blobInfos","openNotification","pendingUploadBlobInfo","percent","uploadBlobInfo","createUploader","addPaddingToEmpty","isEmptyForPadding","EditorUpload","cache","toBlobInfo","URL","createObjectURL","findFirst","cachedBlobInfo","removeByUri","revokeObjectURL","BlobCache","uploader","imageScanner","urlFilters","aliveGuard","replaceString","replaceImageUrl","targetUrl","replacementUrl","replacementString","replaceUrlInUndoStack","uploadImages","scanForImages","imageInfos","imageInfo","imagesToRemove","shouldDispatchChange","filteredResult","uploadInfo","image","convertURL","replaceImageUriInView","uploadError","uploadUri","sugarElement","parentOpt","dispatchChange","uploadImagesAuto","isValidDataUriImage","imgElm","cachedPromises","images","promises","newPromise","ImageScanner","resultItem","replaceBlobUris","source_view","genericBase","cellBase","cellFormats","tablecellbackgroundcolor","tablecellverticalalign","tablecellbordercolor","borderColor","tablecellclass","tableclass","tablecellborderstyle","borderStyle","tablecellborderwidth","borderWidth","FormatRegistry","valigntop","verticalAlign","valignmiddle","valignbottom","alignleft","preview","textAlign","float","marginLeft","marginRight","aligncenter","alignright","alignjustify","bold","fontWeight","italic","fontStyle","underline","strikethrough","strike","forecolor","hilitecolor","fontname","fontFamily","fontsize","fontSize","lineheight","lineHeight","fontsize_class","class","blockquote","subscript","superscript","_fmt","_itemName","lang","customValue","removeformat","get$1","unregister","each$3","isPreviewItem","parsedSelectorToHtml","ancestry","sItem","wrapInHtml","ancestors","parentCandidate","ancestorName","parentRequired","elmRule","getRequiredParent","siblingElm","parentSiblings","parseSelectorItem","$0","$3","$4","getCssText","previewCss","previewStyles","removeVars","previewFrag","previewElm","rawParentFontSize","parentFontSize","Formatter","formatChangeState","addShortcut","setup$s","nodeOrRange","setup$u","applyFormat","removeFormat","toggleFormat","matchFormat","closestFormat","matchAllFormats","matchNodeFormat","canApplyFormat","shouldIgnoreCommand","UndoManager","addUndoLevel","isFirstTypedCharacter","addNonTypingUndoLevel","isMeta","isDirty","modKey","inputType","isInsertFromPasteOrDrop","addKeyboardShortcuts","nonTypingKeycodes","isKeyboardEvent","isDeleteEvent","setup$r","placeholder","updatePlaceholder","isNonTypingKeyboardEvent","showPlaceholder","isTypingKeyboardEvent","isVisuallyEmpty","firePlaceholderToggle","blockBoundary","getBlockPosition","containerElm","blockPosition","getClosestHost","readFromRange","fromBlockPos","toBlockPos","blockPos","lastPositionInBlock","skipLastBr","isDifferentBlocks","hasSameHost","isEditable$1","isValidBlock","hasValidBlocks","extractChildren","getChildrenUntilBlockBoundary","removeEmptyRoot","nestedBlockMerge","toBlock","insertionPoint","sidelongBlockMerge","getInlineToBlockDescendants","helper","newFromBlockDescendants","getInsertionPoint","parentsAndSelf$1","findInsertionPoint","trimBr","mergeBlockInto","mergeBlocks","block1","block2","backspaceDelete$9","read$1","isRawNodeInTable","isEverythingSelected","noPrevious","noNext","isSelectionInTable","deleteRange$2","emptyEditor","deleteRangeMergeBlocks","backspaceDelete$8","_forward","showCaret","getNodeRange","renderRangeCaret","caretPositionNode","caretPositionBeforeNode","ceRoot","renderCaretAtRange","isBeforeBoundary","isAfterBoundary","deleteContentAndShowCaret","peekCaretPosition","caretRange","deleteRange","trimEmptyTextNode","backspaceDelete$7","getNextPosFn","isBeforeFn","nextCaretPosition","normalizedNextCaretPosition","deleteBoundaryText","getEdgeCefPosition","atStart","isCefAtEdgeSelected","DeleteAction","moveToElement","moveToPosition","deleteEmptyBlockOrMoveToCef","toCefElm","blockElm","findCefPosition","isDeleteFromCefDifferentBlocks","getContentEditableAction","caretLocation","isAtContentEditableBlockCaret","getContentEditableBlockAction","skipMoveToActionFromInlineCefToContent","getAncestorCe","backspaceDeleteCaret","read","hideFakeCaret","deleteElement$1","backspaceDeleteRange","paddEmptyElement","backspaceDelete$6","backspaceDelete$5","deleteCaret$2","isText$2","startsWithCaretContainer","endsWithCaretContainer","createZwsp","insertInline","insertBefore$1","insertAfter$1","insertInlineBefore","insertInlineAfter","insertInlinePos","isPosCaretContainer","caretNode","renderCaret","evaluateUntil","fns","Location","rescope$1","nPos","isNotInsideFormatCaretContainer","findInsideRootInline","start$1","isValidLocation","readLocation","getName","outside","inside","betweenInlines","fromInline","toInline","hasSameParentBlock","skipNoMovement","fromLocation","toLocation","location2","location1","findLocationSimple","findLocation$1","findLocationTraverse","moveRel","modify","moveByWord","hasSelectionModifyApi","BreakType","flip","positions","walk$1","getBreakType","currentPos","Br","Block","Wrap","getPositionsUntil","breakType","breakAt","Eol","getAdjacentLinePositions","getPositionsUntilBreak","findClosestHorizontalPositionFromPoint","lastRect","newRect","lastDist","findClosestHorizontalPosition","targetRect","getPositionsUntilPreviousLine","getPositionsUntilNextLine","getPositionsAbove","getPositionsBelow","isAtFirstLine","isAtLastLine","getClosestPositionAbove","getClosestPositionBelow","isContentEditableFalse$4","distanceToRectLeft$1","distanceToRectRight$1","findClosestClientRect","oldClientRect","oldDistance","newDistance","getNodeClientRects","toArrayWithNode","VDirection","walkUntil","isAboveFn","isBeflowFn","line","targetClientRect","findUntil","upUntil","Up","downUntil","Down","getLastClientRect","isAboveLine","lineNumber","aboveLineNumber","isLine","isLineNumber","moveToRange","renderRangeCaretOpt","moveHorizontally","isBefore","isAfter","isElement","rangeIsInContainerBlock","moveVertically","caretClientRect","linePositions","nextLinePositions","nextLineRect","dist1","dist2","caretPositions","isBelowFn","positionsUntil","closestNextLineRect","getLineEndPoint","lineInfo","moveToLineEndPoint$3","setCaretPosition","setSelected","renderCaretLocation","findLocation","getPositionFromRange","isInlineTarget$1","safeRemoveCaretContainer","caretValue","isAtZwsp","move$3","moveWord","_caret","setupSelectedState","inlineBoundaries","selectedInlines","targetInlines","toggleInlines","inlines","_inline","renderInsideInlineCaret","moveNextWord","movePrevWord","moveToLineEndPoint$2","linePoint","outsideLoc","setCaretLocation","deleteFromTo","rangeFromPositions","backspaceDeleteCollapsed","rescope","toPosition","hasOnlyTwoOrLessPositionsLeft","backspaceDelete$4","getParentsUntil","hasOnlyOneChild","getParentInlinesUntilMultichildInline","hasMultipleChildren","getFormatNodes","parentInlines","isFormatElement$1","getFormatNodesAtStart","getParentInlines","deleteCaret$1","deleteLastPosition","createCaretFormatAtStart","isBrInEmptyElement","createCaretFormatAtStart$1","rangeStartsAtTextContainer","rangeEndsAtEndOfStartContainer","startParent","endParent","isEqualNode","rangeStartAndEndHaveSameParent","rangeEndsAtEndOfEndContainer","requiresDeleteRangeOverride","rangeStartsAtStartOfTextContainer","rangeStartParentIsFormatElement","rangeEndsAfterEndOfStartContainer","rangeEndsAtOrAfterEndOfStartContainer","deleteRange$1","updateFormats","missingFormats","updateCaretFormat","backspaceDelete$3","hasAncestorInlineCaret","ancestor$1","requiresRefreshCaretOverride","hasAncestorInlineCaretAtStart","refreshCaret","deleteElement","backspaceDelete$2","isNearMedia","deleteCaret","parseIndentValue","getIndentStyleName","useMargin","canOutdent","getBlocksToIndent","isReadOnly","indentStyleName","intentValue","validateBlocks","isListComponent","parentIsListComponent","indentation","indentUnit","indentValue","unit","parsedValue","indentElement","outdent","backspaceDelete$1","findAction","forwardDeleteCommand","execNativeForwardDeleteCommand","setup$q","addCommand","deleteCommand","getTouch","setup$p","startData","longpressFired","debounceLongpress","distX","distY","isFarEnough","isBlockElement","isValidTarget","shouldRemoveTextNode","createRootBlock","rootNodeName","hasBlockParent","restoreSelection","insertEmptyLine","checkClassName","replaceMatchWithSpan","prevChar","findStartTagIndex","setup$n","editClass","nonEditClass","hasEditClass","hasNonEditClass","nonEditableRegExps","convertRegExpsToNonEditable","blockCaretContainer","handleBlockContainer","findBlockCaretContainer","isContentEditableFalse$3","exitPreBlock","getVisualCaretPosition$1","newBlock","textBlock","createTextBlock","getHorizontalRange","moveToCeFalseHorizontally","getVerticalRange","down","moveToCeFalseVertically","moveH$2","flipDirection","moveV$4","moveToLineEndPoint$1","selectToEndPoint","curRng","isTarget","moveCaretToNewEmptyLine","getClosestTargetBlock","isAtFirstOrLastLine","moveV$3","move$2","moveDown","summary","moveUp","moveV$2","baseKeyPattern","matchesEvent","match$1","defaultPatterns","matchDelayed","defaultDelayedPatterns","execute","executeWithDelayedAction","moveH$1","moveV$1","moveToLineEndPoint","CellLocation","filterFirstLayer","tags","isRootOrUpperTable","lookup$1","isEligible","newIndex","getClosestCell","getYAxisValue","isTargetCorner","corners","tds","deflate","getCorners","corner","newCorner","oldCorner","oldDist","newDist","findClosestCorner","getClosestCellAbove","getClosestCellBelow","findClosestPositionInAboveCell","findClosestPositionInBelowCell","isAtTableCellLine","startsWithWrapBreak","startsWithBrBreak","breakPos","hasNextBreak","isAtFirstTableCellLine","isAtLastTableCellLine","navigateHorizontally","_td","isCaretAtStartOrEndOfTable","getTable","insertFn","renderBlock","navigateVertically","getClosestAbovePosition","getClosestBelowPosition","move$1","mover","moveH","moveV","tabGo","_current","getCellFirstCursorPosition","tabForward","tabBackward","handleTab","rootElements","model","clearSelectedCells","setup$l","isMac","executeKeydownOverride$4","DOM$7","alwaysNext","textBefore","scanLeft","scanRight","repeatLeft","isValidTextRange","getText","isWhitespace","stripTrigger","trigger","findTrigger","firstChar","findStart","initRange","minChars","buffer","findTriggerIndex","spot","toLast","isText$1","toLeaf","isStartOfWord","leaf","_element","isPreviousCharContent","getDatabase","database","triggers","getTriggerContext","lookupWithContext","fetchOptions","startText","autocompleters","lookupByTrigger","lookupData","ac","maxResults","matchText","columns","onAction","highlightOn","SimpleResultType","fold$1","stype","serror","svalue","Value","SimpleResult","formatObj","stringify","getErrorInfo","chooseFrom","branch","missingBranch","extract","choose$1","missingKey","chosen","baseMerge","merger","curObject","deepMerge","old","defaulted$1","fallback","mergeErrors","ResultCombine","objects","partitions","ifField","ifCustom","newKey","presence","instantiator","validator","custom","anyValue$1","requiredAccess","bundle","missingRequired","fallbackAccess","extractField","av","bundleAsOption","optValue","ov","optionAccess","optionDefaultedAccess","objOf","fields","extractFields","fieldStrings","_okey","_presence","_instantiator","arrOf","asRaw","errs","extractValue","formatError","errInfo","es","formatErrors","choose","anyValue","typedValue","expectedType","actualType","number","string","boolean","functionProcessor","customField","validateEnum","valueOf","requiredOf","requiredString","requiredFunction","optionOf","optionString","defaultedOf","defaultedNumber","defaultedStringEnum","defaultedBoolean","defaultedFunction","fetch$1","onSetup","optionalText","optionalIcon","optionalTooltip","optionalLabel","active","enabled","primary","defaultedType","defaultedString","autocompleterSchema","defaulted","defaultedArrayOf","baseToolbarButtonFields","baseToolbarToggleButtonFields","contextBarFields","contextButtonFields","contextToggleButtonFields","launchButtonFields","launchToggleButtonFields","toggleOrNormal","contextformbutton","contextformtogglebutton","requiredArrayOf","register$2","popups","dataset","popup","createAutocompleter","datasetValues","dv","setup$k","activeAutocompleter","uiActive","isActive","cancelIfNecessary","removeAutocompleterDecoration","fireAutocompleterEnd","commenceIfNecessary","addAutocompleterDecoration","matchLength","getAutocompleters","newContext","doLookup","lookupInfo","fireAutocompleterUpdate","fireAutocompleterStart","_ui","update","which","setupEditorInput","emptyNodeContents","isEntireNodeSelected","getParentDetailsElementAtPos","isInDetailsElement","isCaretAtStartOfSummary","detailsElements","startSummary","isCaretInTheBeginningOf","isCaretAtEndOfSummary","isCaretInTheEndOf","setCaretToPosition","moveCaretToDetailsPos","shouldPreventDeleteIntoDetails","granularity","parentDetailsAtCaret","inEmptyParentBlock","isFirstBlock","isLastBlock","parentDetailsAtNewPos","shouldPreventDeleteSummaryAction","detailElements","startInSummary","endInSummary","isPartiallySelectedDetailsElements","startDetails","endDetails","isPartialDelete","isCaretInLastPositionInBody","isCaretInFirstPositionInBody","shouldPreventDeleteAction","getDetailsElements","handleDeleteActionSafari","applySelection","appendAllChildNodes","backspaceDelete","createAndFireInputEvent","eventType","specifics","overrides","bubbles","isComposing","detail","currentTarget","eventPhase","AT_TARGET","originalTarget","explicitOriginalTarget","isTrusted","cancelable","InputEvent","fireInputEvent","fireBeforeInputEvent","platform$2","isMacOSOriOS","setup$j","isBackspaceKeydown","unmodifiedGranularity","getModifiedGranularity","isWord","applyAction","executeKeydownOverride$3","executeKeyupOverride","moveToCaretPosition","firstNonWhiteSpaceNodeSibling","getEditableRoot","editableRoot","getParentBlock$1","setForcedBlockAttrs","forcedRootBlockAttrs","attrStyles","newStyles","attrClassesOpt","attrClasses","currentClassesOpt","currentClasses","filteredClasses","newClasses","appliedAttrs","remainingAttrs","applyAttributes","createNewBlock","keepStyles","newBlockName","parentBlockName","isLastEmptyBlockInDetails","isAtDetailsEdge","insertNewLine","getDetailsRoot","hasParent","isListBlock","isListItem","getContainerBlock","containerBlock","containerBlockParent","isFirstOrLastLi","getStyles","insert$4","containerParent","parentBlockStyles","isFirstChild","tmpRng","hasFirstChild","previousChildren","isEmptyAnchor","containerAndSiblingName","canSplitBlock","normalizeZwspOffset","blockbreak","isAfterLastNodeInContainer","isCef","collapsedAndCef","createNewBlock$1","isCaretAtStartOrEndOfBlock","normalizedOffset","insertNewBlockAfter","containerBlockName","optionValue","shouldEndContainer","parentList","isWithinNonEditableList","startNodeName","startNodeParent","wrapSelfAndSiblingsInDefaultBlock","parentBlockParent","isNearChildren","includeZwspInRange","trimLeadingLineBreaks","firstChilds","trimInlineElementsOnLeftSideOfBlock","addBrToBlockIfNeeded","fakeEventName","moveSelectionToBr","brElm","extraBr","insertBrAtCaret","isControlKey","hasRightSideContent","insertBrBefore","insertBrAfter","hasBrAfter","isAnchorLink","isInsideAnchor","insertBrOutsideAnchor","linebreak","anchorLocation","readInlineAnchorLocation","matchesSelector","newLineAction","shouldBlockNewLine","_shiftKey","shouldBlockNewLine$1","inListBlock","requiredState","isListItemParentBlock","inBlock","getParentBlockName","inCefBlock","inPreBlock","shouldPutBrInPre","inBrContext","shouldInsertBr","hasShiftKey","_editor","canInsertIntoEditableRoot","rootEditable","isInRootWithEmptyOrCEF","isCefOpt","predicates","insertBreak","execEditorDeleteCommand","insert$1","logicalAction","getAction","platform$1","isIOSSafari","handleEnterKeyEvent","setup$i","iOSSafariKeydownBookmark","koreanCharRegex","isCaretAfterKoreanCharacter","iOSSafariKeydownOverride","iOSSafariKeyupOverride","setup$h","executeKeydownOverride$2","setup$g","normalizeNbspsInEditor","platform","isPageUpDown","setNodeChangeBlocker","blocked","setup$f","executeKeyupAction","insertTextAtPosition","insertNbspAtPosition","insertSpaceAtPosition","setSelection","insertSpaceOrNbspAtSelection","locationToCaretPosition","checkPos","insertInlineBoundarySpaceOrNbsp","insertSpaceInSummaryAtSelectionOnFirefox","domUtils","insertSpaceOrNbspAtPosition","setup$d","executeKeydownOverride$1","tableTabNavigation","setup$c","executeKeydownOverride","setup$b","setup$e","setup$m","NodeChange","lastRng","lastPath","nativeRng","fakeRng","isSameElementPath","initialized","currentPath","imageId","eventId","mkSetEventFn","transfer","setDragstartEvent","setDropEvent","setDragendEvent","isInDragStartEvent","modeId","mkSetModeFn","setMode$1","setReadWriteMode","setReadOnlyMode","setProtectedMode","checkMode","expectedMode","isInReadWriteMode","isInProtectedMode","validDropEffects","validEffectAlloweds","createDataTransfer","dataTransferImpl","DataTransfer","dropEffect","effectAllowed","dataTransfer","effect","allowed","itemsImpl","normalizeItems","types","setDragImage","imageData","setData","clearData","cloneDataTransfer","originalMode","getMode","getDragImage","getEvent","setEvent","setHtmlData","internalHtmlMime","mark","isMarked","toBlockElements","rootTag","rootAttrs","tagOpen","openContainer","tagClose","paragraphs","isPasteBin","isDefaultPasteBinContent","PasteBin","lastRngCell","pasteBinElm","create$6","pasteBinClone","getHtml","copyAndRemove","toElm","fromElm","pasteBinClones","dirtyWrappers","cleanWrapper","getLastRng","filter$1","trimHtml","s1","s2","processResult","cancelled","filterContent","internal","preProcessArgs","firePastePreProcess","filteredContent","preProcess","tempBody","postProcessArgs","firePastePostProcess","postProcessFilter","pasteHtml$1","isAbsoluteUrl","linkSelection","pasteHtmlFn","createLink","insertImage","isImageUrl","createImage","pasteAsText","smartInsertContent","createIdGenerator","createPasteDataTransfer","doPaste","shouldSimulateInputEvent","doPasteAction","pasteHtml","internalFlag","unmark","pasteText","encodedText","getDataTransferItems","contentType","hasContentType","clipboardContent","hasHtmlOrText","createBlobInfo","useFileName","extractFilename","allowedExtensions","extension","lowerExt","mimeOverrides","jpg","jpe","jfi","jif","jfif","pjpeg","pjp","getImageMimeType","pasteImageData","clipboardData","kind","getAsFile","getImagesFromDataTransfer","fileResults","imageItem","_ref16","existingBlobInfo","pasteImage","insertClipboardContent","plainTextMode","isInternal","isPlainTextHtml","isPlainText","isAbsoluteUrl$1","voidElements","ignoreElements","registerEventHandlers","pasteBin","pasteFormat","keyboardPastePlainTextState","isKeyboardPasteEvent","isBrokenAndroidClipboardEvent","registerEventsAndFilters","isWebKitFakeUrl","isDataUri","isPasteInsert","registerDataImageFilter","register$1","togglePlainTextPaste","setClipboardData","setHtml5Clipboard","contenteditable","overflow","offscreenRange","selectNodeContents","hasSelectedContent","isTableSelection","cut","getCaretRangeFromEvent","setFocusedRange","setup$a","draggingInternallyState","hasImage","dropContent","plainTextContent","isPlainTextFileUrl","internalContent","needsInternalDrop","parentTransparent","needsCustomInternalDrop","isInternalDrop","trimmedContent","hasNoSummary","brokenDetailElements","setupSummaryDeleteByDragFix","rgbRegExp","rgbToHex","removeWebKitStyles","webKitStylesOption","webKitStyles","inputStyles","outputStyles","inputValue","compareInput","outputStyle","setup$7","filterFunc","addPreProcessFilter","setup$8","processEvent","setup$9","setup$6","preventSummaryToggle","initialStateOption","serializedStateOption","filterDetails","isText","isContentEditableFalse$2","getClosestScope","isContentEditableTrue","getClosestCef","findEdgeCaretCandidate","onTripleClickSelect","startRng","clickNode","cef","findClosestBlockRange","FakeCaretPosition","distanceToRectLeft","distanceToRectRight","isOverlapping","r1","r2","overlap","overlapY","collidesY","splitRectsPerAxis","rects","prevRect","boundingClientRectFromRects","isInsideY","boundingRect","horizontal","vertical","horizontalDistance","_y","closestChildCaretCandidateNodeRect","findCloserTextNode","caretCandidateRect","findClosestCaretCandidateNodeRect","distance","sortedRects","sndClosest","tryFindSecondBestTextNode","horizontalRects","verticalRects","above","below","closestCaretCandidateNodeRect","ownerDoc","prevScope","childNodesWithoutGhost","uncheckedChildren","newScope","traverseUp","closestFakeCaretCandidate","Before","After","clientInfo","getAbsolutePosition","docElem","calc","calculatePosition","bodyPosition","getBodyPosition","scrollPosition","getScrollPosition","mousePosition","iframePosition","inlineScroll","iframeScroll","getBodyScroll","getMousePosition","getTargetProps","makeDragEvent","dataTransferForDispatch","makeDataTransferCopyForDragEvent","timeStamp","BUBBLING_PHASE","CAPTURING_PHASE","NONE","button","buttons","movementX","movementY","offsetX","offsetY","relatedTarget","initUIEvent","initMouseEvent","makeDndEvent","makeDndEventFromMouseEvent","isContentEditableFalse$1","createGhost","clonedElm","opacity","padding","boxSizing","scrollEditor","amount","behavior","scrollRight","scrollUp","scrollDown","removeElement","isLeftMouseButtonPressed","ceElm","isDraggable","elmPos","dragging","maxX","maxY","relX","relY","ghost","dispatchDragEvent","move","throttledPlaceCaretAt","caretInfo","state_","movement","mouseEventOriginatedFromWithinTheEditor","targetPos","applyRelPos","mouseY","mouseX","overflowX","outerMouseY","outerMouseX","innerWidth","moveGhost","drop","dragElement","isValidDropTarget","getRawTarget","dropTarget","removeElementWithPadding","getHtmlData","removeDragState","stopDragging","bindFakeDragEvents","pageDom","dragStartHandler","dragHandler","dropHandler","dragEndHandler","init$2","preventFileDrop","preventFileDropIfUIElement","editorRoot","eventNames","blockUnsupportedFileDrop","isContentEditableFalse","getContentEditableRoot","SelectionOverrides","realSelectionId","selectedElement","isFakeSelectionTargetElement","removeElementSelection","contentEditableRoot","setElementSelection","closestContentEditable","setRange","normalizeVoidElementSelection","isRangeInCaretContainer","isFakeSelectionElement","renderFocusCaret","setup$4","setup$3","isWithinCaretContainer","selectElement","targetClone","realSelectionContainer","setupOffscreenSelection","nodeElm","afterNode","getNormalizedTextOffset","generatePath","generatePathRange","resolvePath","nodePath","optNode","resolvePathRange","_ref17","_ref18","cleanEmptyNodes","deleteRng","getParentBlock","resolveFromDynamicPatterns","patternSet","beforeText","dynamicPatterns","dynamicPatternsLookup","blockPatterns","inlinePatterns","getBeforeText","stripPattern","firstTextNode","textAfter","applyPattern$1","formatSet","isBlockFormatName","findPattern$1","sortedPatterns","sortPatterns$1","nuText","newMarker","rangeFromMarker","createMarker","markerPrefix","pathRange","textEnd","textStart","startParentNode","removeMarker","isReplacementPattern","findPatternStartFromSpot","startPattern","patternContent","searchText","startEndIndex","startPatternIndex","nextSpot","findPattern","normalizedMatches","endPathRng","endRng","resultsOpt","findPatternsRec","remainingPatterns","requireGap","startRange","findPatternStart","startPathRng","generatePathRangeFromRange","endSpot","patternsWithoutCurrent","applyPattern","patternRange","findPatterns","matchesWithSortedPatterns","hasSameMatches","sortedMatch","getBestMatches","applyMatches","matchesWithMarkers","matchesWithEnds","endMarker","startMarker","addMarkers","markerRange","applyReplacementPattern","markerEndRange","markerStartRange","patternMarker","applyPatternWithContent","handleEnter","dynamicPatternSet","inlineMatches","blockMatches","blockText","findPatterns$1","insert$5","applyMatches$1","checkKeyEvent","codes","setup$2","charCodes","keyCodes","getPatternSet","createPatternSet","hasDynamicPatterns","hasTextPatternsLookup","handleInlineTrigger","handleInlineKey","charCode","Quirks","isGecko","isWebKit","setEditorCommandState","emptyEditorWhenDeleting","serializeRng","contents","allRng","allContentsSelected","selectAll","shortcuts","documentElementEditingFocus","Range","blur","selectControlElements","visualAidsAnchorClass","disableBackspaceIntoATable","setGeckoEditingOptions","setOpts","addBrAfterLastLinks","showBrokenImageIcon","contentStyles","restoreFocusOnKeyDown","bodyHeight","blockCmdArrowNavigation","tapLinksAndImages","blockFormSubmitInsideEditor","isAllContentSelected","getAttributeApplyFunction","setAttributeNode","isSelectionAcrossElements","removeStylesWhenDeletingAcrossBlockElements","DragEvent","DOM$6","getRootName","removeUndefined","mkParserSettings","mkSchemaSettings","initEditor","bindPendingEventDelegates","fireInit","moveSelectionToFirstCaretPosition","initInstanceCallback","autoFocus","getStyleSheetLoader$1","loadContentCss","fontCss","removeCss","contentCssText","allStylesheets","framedFonts","bundledCss","normalCss","bundledPromises","makeStylesheetLoadingPromises","contentStyle","appendStyle","initEditorWithInitialContent","startContent","loadInitialContent","contentBodyLoaded","disabled","readonly","_editableRoot","hasEditableRoot","createParser","mkSerializerSettings","annotator","_nodeChangeDispatcher","setup$5","setup$1","setup$o","setupRtcThunk","firePreInit","spellcheck","firePostRender","directionality","protect","escape","preInit","cancelProgress","canceled","progressTimeout","setProgressState","startProgress","setupRtc","_rtcMode","DOM$5","createIframe","boxInfo","iframeTitle","tabindex","ifr","title","customAttrs","iframe","frameBorder","allowTransparency","createIframeElement","iframeContainer","iframeHTML","documentBaseUrl","bodyId","bodyClass","translatedAriaText","getIframeHtml","setupIframeBody","ready","srcdoc","DOM$4","initPlugin","initializedPlugins","Plugin","pluginUrl","pluginInstance","pluginInitError","createThemeFalseResult","renderThemeFalse","renderThemeFalseIframe","renderThemeUi","render","renderUI","renderFromLoadedTheme","iframeHeight","renderFromThemeFunc","async","iconPackName","currentIcons","loadIcons","svgData","icon","addIcon","initIcons","Theme","initTheme","Model","initModel","trimLegacyPrefix","initPlugins","renderInfo","uiApiFacade","isEnabled","setEnabled","augmentEditorUiApi","hidden","visibility","orgVisibility","init$1","DOM$3","hasSkipLoadPrefix","loadLanguage","scriptLoader","languageCode","languageUrl","languageLoadError","loadTheme","themeUrl","themeLoadError","loadModel","modelUrl","modelLoadError","getIconsUrlMetaFromName","defaultIconsUrl","customIconsUrl","getIconsUrlMetaFromUrl","cat","urlMeta","iconsLoadError","loadPlugins","loadPlugin","pluginLoadError","isThemeLoaded","isModelLoaded","snapshot","getStyleSheetLoader","resetContent","triggerSave","windowManager","isEncodingXml","set_dirty","deviceDetection","normalizePlugins","trimmedPlugins","extractSections","bifilter","sections","hasSection","sectionResult","getMobileOverrideOptions","mobileOptions","table_grid","object_resizing","resize","toolbar_mode","toolbar_sticky","menubar","getExternalPlugins","overrideOptions","userDefinedExternalPlugins","external_plugins","processPlugins","isMobileDevice","defaultOverrideOptions","forcedPlugins","forced_plugins","desktopPlugins","mobileConfig","getSectionConfig","platformPlugins","mobilePlugins","getPlatformPlugins","combinedPlugins","combinePlugins","combineOptions","defaultOptions","deviceOverrideOptions","mobile","extendedOptions","isOnMobile","defaults","sectionOptions","getSection","addVisual$1","registerExecCommands$3","toggleAlign","align","editorCommands","addCommands","JustifyLeft","JustifyCenter","JustifyRight","JustifyFull","JustifyNone","registerCommands$b","alignStates","registerQueryStateCommands$1","trimOrPad","trimOrPadLeftRight","insertAtCaret","processValue$1","insertedContent","insertContent$1","legacyPropNames","isFont","getSpecifiedFontProp","legacyPropName","getProperty","getFontProp","getComputedFontProp","getFontSize","getFontFamily","findFirstCaretElement","bindRange","getCaretElement","mapRange","fromFontSizeNumber","fontSizeNumber","getFontStyleValues","fontClasses","getFontSizeClasses","normalizeFontNames","font","fonts","registerExecCommands$2","_command","fontNameAction","fontSizeAction","lineHeightAction","customCode","registerQueryValueCommands","isFormatMatch","addQueryValueHandler","fontNameQuery","fontSizeQuery","specifiedStyle","lineHeightQuery","registerCommands$6","Indent","Outdent","topParentBlock","getTopParentBlock","registerCommands$3","InsertNewBlockBefore","InsertNewBlockAfter","registerCommands","queryCommandEnabled","queryCommandSupported","registerCommands$a","mceAddUndoLevel","mceEndUndoLevel","Undo","Redo","registerCommands$7","mceSelectNodeDepth","mceSelectNode","registerCommands$1","mceCleanup","insertHorizontalRule","insertText","insertHTML","mceInsertContent","mceSetContent","mceReplaceContent","mceNewDocument","registerCommands$9","applyLinkToSelection","linkDetails","unlink","mceInsertLink","registerCommands$5","insertParagraph","mceInsertNewLine","InsertLineBreak","registerCommands$2","listParent","registerExecCommands$1","list","registerQueryStateCommands","registerCommands$4","registerCommands$8","mceRemoveNode","mcePrint","print","mceFocus","mceToggleVisualAid","registerExecCommands","selectionSafeCommands","isSelectionSafeCommand","EditorCommands","commands","lowerCaseCommand","skip_focus","restore","queryCommandState","queryCommandValue","commandList","addQueryStateHandler","setContentEditable","toggleReadOnly","removeFakeSelection","switchOnContentEditableTrue","restoreFakeSelection","registerFilters","allowedEvents","processReadonlyEvents","isClickEvent","getAnchorHrefOpt","targetEl","isReadOnlyAllowedEvent","nativeEvents","EventDispatcher","bindings","toggleEvent","beforeFire","once","wrappedCallback","currentName","bindingName","filteredHandlers","binding","getEventDispatcher","_eventDispatcher","isNative","toggleNativeEvent","Observable","bubble","dispatcherArgs","DOM$2","customEventRootDelegates","getEventTarget","eventName","eventRoot","isListening","bindEventDelegate","delegates","eventRootElm","delegate","editors","EditorObservable","_pendingNativeEvents","stringListProcessor","getErrorMessage","isValidResult","processValue","processor","create$5","initialOptions","setValue","isRegistered","isBuiltInSpec","getBuiltInProcessor","processDefaultValue","default","immutable","unset","registered","defaultModes","switchToMode","activeMode","availableModes","oldMode","newMode","activate","deactivate","editorReadOnly","fireSwitchMode","create$4","design","registerReadOnlyContentFilters","registerReadOnlySelectionBlockers","setMode","registerMode","each$2","keyCodeLookup","f1","f2","f3","f4","f5","f6","f7","f8","f9","f10","f11","f12","modifierNames","parseShortcut","shortcut","isModifier","access","alt","ctrl","meta","Shortcuts","pendingPatterns","hasModifier","isFunctionKey","matchShortcut","subpatterns","executeShortcutAction","cmdFunc","normalizeCommandFunc","createShortcut","bridge","menuItems","contextMenus","contextToolbars","sidebars","views","addButton","addGroupToolbarButton","addToggleButton","addMenuButton","addSplitButton","addMenuItem","addNestedMenuItem","addToggleMenuItem","addAutocompleter","addContextMenu","addContextToolbar","addContextForm","addSidebar","addView","create$3","DOM$1","each$1","Editor","loadedCSS","isNotDirty","documentBaseURL","normalizeOptions","registerOption","hasPlugin","lookupFn","ctx","rawPatterns","_ctx","register$7","_setBaseUrl","baseURI","setupCallback","getParam","loadArgs","saveArgs","initialContent","oldState","urlConverterCallback","urlObject","setEditableRoot","fireEditableRootStateChange","_scanForImages","beforeUnloadDelegate","boundGlobalEvents","globalEventDelegate","EditorManager","toggleGlobalEvents","removeEditorFromList","targetEditor","oldEditors","isQuirksMode","compatMode","majorVersion","minorVersion","releaseDate","i18n","tinyMCEPreInit","srcScript","overrideDefaults","base_url","pluginBaseUrls","plugin_base_urls","pluginBaseUrl","pluginName","invalidInlineTargets","provideResults","initEditors","initCount","execCallback","unique$1","findTargets","isInvalidInlineTarget","createEditor","createId","existingEditor","editorId","editorOptions","addI18n","FakeClipboard","dataValue","FakeClipboardItem","getType","relativePosition","targetW","targetH","relChars","create$2","Rect","inflate","findBestRelativePosition","constrainRect","rels","intersect","cropRect","x1","y1","clamp","clampRect","fixedSize","cx2","cy2","underflowX1","underflowY1","overflowX2","overflowY2","fromClientRect","tasks","resultFns","resources","loadErrMsg","runErrMsg","task","waiter","resolveCb","rejectCb","complete","completer","awaiter","create$1","localStorage","setItem","removeItem","storage","getItem","defineProperty","publicApi","geom","util","LocalStorage","ImageUploader","showNotification","TreeWalker","Serializer","Selection","tinymce$1","tinyMCE","exportToWindowGlobal","module","exportToModuleLoaders","exportGlobal"],"mappings":"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ACA,MACA,OACA,KACA,WACA,SACA,SACA,IACA,UACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,UACA,SACA,SACA,QACA,SACA,SACA,OACA,SACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,WACA,QACA,KACA,QACA,OACA,KACA,QACA,KACA,IACA,KACA,MACA,QACA,QAEIk7B,MAAQl7B,OAAO,CACnB,MACA,IACA,WACA,cACA,eACA,eACA,gBACA,mBACA,SACA,WACA,OACA,OACA,UACA,SACA,OACA,IACA,QACA,WACA,QACA,QACA,OACA,iBACA,SACA,OACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,OACA,QACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,OACA,UAEIm7B,WAAan7B,OAAO,CACxB,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,eACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,iBAEIo7B,cAAgBp7B,OAAO,CAC3B,UACA,gBACA,SACA,UACA,YACA,mBACA,iBACA,gBACA,gBACA,gBACA,QACA,YACA,OACA,eACA,YACA,UACA,gBACA,SACA,MACA,aACA,UACA,QAEIq7B,SAAWr7B,OAAO,CACtB,OACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,gBACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,SACA,QACA,SACA,OACA,OACA,UACA,SACA,MACA,QACA,MACA,SACA,aACA,gBAEIs7B,iBAAmBt7B,OAAO,CAC9B,UACA,cACA,aACA,WACA,YACA,UACA,UACA,SACA,SACA,QACA,YACA,aACA,iBACA,cACA,SAEIt2D,KAAOs2D,OAAO,CAAC,UACf92D,KAAO82D,OAAO,CAClB,SACA,SACA,QACA,MACA,iBACA,eACA,uBACA,WACA,aACA,UACA,SACA,UACA,cACA,cACA,UACA,OACA,QACA,QACA,QACA,OACA,UACA,WACA,eACA,SACA,cACA,WACA,WACA,UACA,MACA,WACA,0BACA,wBACA,WACA,YACA,UACA,eACA,OACA,MACA,UACA,SACA,SACA,OACA,OACA,WACA,KACA,YACA,YACA,QACA,OACA,QACA,OACA,OACA,UACA,OACA,MACA,MACA,YACA,QACA,SACA,MACA,YACA,WACA,QACA,OACA,QACA,UACA,aACA,SACA,OACA,UACA,UACA,cACA,cACA,SACA,UACA,UACA,aACA,WACA,MACA,WACA,MACA,WACA,OACA,OACA,UACA,aACA,QACA,WACA,QACA,OACA,QACA,OACA,UACA,QACA,MACA,SACA,OACA,QACA,UACA,WACA,QACA,YACA,OACA,SACA,SACA,QACA,QACA,QACA,SAEI7vC,IAAM6vC,OAAO,CACjB,gBACA,aACA,WACA,qBACA,SACA,gBACA,gBACA,UACA,gBACA,iBACA,QACA,OACA,KACA,QACA,OACA,gBACA,YACA,YACA,QACA,sBACA,8BACA,gBACA,kBACA,KACA,KACA,IACA,KACA,KACA,kBACA,YACA,UACA,UACA,MACA,WACA,YACA,MACA,OACA,eACA,YACA,SACA,cACA,cACA,gBACA,cACA,YACA,mBACA,eACA,aACA,eACA,cACA,KACA,KACA,KACA,KACA,aACA,WACA,gBACA,oBACA,SACA,OACA,KACA,kBACA,KACA,MACA,IACA,KACA,KACA,KACA,KACA,UACA,YACA,aACA,WACA,OACA,eACA,iBACA,eACA,mBACA,iBACA,QACA,aACA,aACA,eACA,eACA,cACA,cACA,mBACA,YACA,MACA,OACA,QACA,SACA,OACA,MACA,OACA,aACA,SACA,WACA,UACA,QACA,SACA,cACA,SACA,WACA,cACA,OACA,aACA,sBACA,mBACA,eACA,SACA,gBACA,sBACA,iBACA,IACA,KACA,KACA,SACA,OACA,OACA,cACA,YACA,UACA,SACA,SACA,QACA,OACA,kBACA,mBACA,mBACA,eACA,cACA,eACA,cACA,aACA,eACA,mBACA,oBACA,iBACA,kBACA,oBACA,iBACA,SACA,eACA,QACA,eACA,iBACA,WACA,UACA,UACA,YACA,mBACA,cACA,kBACA,iBACA,aACA,OACA,KACA,KACA,UACA,SACA,UACA,aACA,UACA,aACA,gBACA,gBACA,QACA,eACA,OACA,eACA,mBACA,mBACA,IACA,KACA,KACA,QACA,IACA,KACA,KACA,IACA,eAEIu7B,OAASv7B,OAAO,CACpB,SACA,cACA,QACA,WACA,QACA,eACA,cACA,aACA,aACA,QACA,MACA,UACA,eACA,WACA,QACA,QACA,SACA,OACA,KACA,UACA,SACA,gBACA,SACA,SACA,iBACA,YACA,WACA,cACA,UACA,UACA,gBACA,WACA,WACA,OACA,WACA,WACA,aACA,UACA,SACA,SACA,cACA,gBACA,uBACA,YACA,YACA,aACA,WACA,iBACA,iBACA,YACA,UACA,QACA,UAEIw7B,IAAMx7B,OAAO,CACjB,aACA,SACA,cACA,YACA,gBAEIy7B,cAAgB7pE,KAAK,6BACrB8pE,SAAW9pE,KAAK,yBAChB+pE,YAAc/pE,KAAK,iBACnBgqE,UAAYhqE,KAAK,8BACjBiqE,UAAYjqE,KAAK,kBACjBkqE,eAAiBlqE,KAAK,6FACtBmqE,kBAAoBnqE,KAAK,yBACzBoqE,gBAAkBpqE,KAAK,+DACvBqqE,aAAerqE,KAAK,eACtBsqE,YAAc5sG,OAAO0wE,OAAO,CAC9BC,UAAW,KACXw7B,cAAeA,cACfC,SAAUA,SACVC,YAAaA,YACbC,UAAWA,UACXC,UAAWA,UACXC,eAAgBA,eAChBC,kBAAmBA,kBACnBC,gBAAiBA,gBACjBC,aAAcA,qBAEVE,UAAY,IAAwB,oBAAXn6F,OAAyB,KAAOA,OACzDo6F,0BAA4B,SAAmCC,aAAcC,sBACrD,iBAAjBD,cAAkE,mBAA9BA,aAAaE,oBACnD,SAEL3/F,OAAS,KAET0/F,mBAAqBA,kBAAkBn1F,aADzB,2BAEhBvK,OAAS0/F,kBAAkBt1F,aAFX,gCAIZw1F,WAAa,aAAe5/F,OAAS,IAAMA,OAAS,eAEjDy/F,aAAaE,aAAaC,WAAY,CAC3Cj9D,WAAWr2B,MACFA,KAETuzF,gBAAgB9mE,WACPA,YAGX,MAAOsN,UACPx8B,QAAQu0F,KAAK,uBAAyBwB,WAAa,0BAC5C,WAgwBPE,gBA7vBKC,sBACH36F,OAASo4F,UAAU3rG,OAAS,QAAsBf,IAAjB0sG,UAAU,GAAmBA,UAAU,GAAK+B,kBAC3ES,UAAY9/E,MAAQ6/E,gBAAgB7/E,SAC1C8/E,UAAUt+F,QAAU,QACpBs+F,UAAU/iC,QAAU,IACf73D,SAAWA,OAAOa,UAAyC,IAA7Bb,OAAOa,SAASkD,gBACjD62F,UAAUztF,aAAc,EACjBytF,gBAEHC,iBAAmB76F,OAAOa,SAC1Bi6F,cAAgBD,iBAAiBC,kBACnCj6F,SAACA,UAAYb,aACX+6F,iBAACA,iBAADC,oBAAmBA,oBAAnBnwF,KAAwCA,KAAxCF,QAA8CA,QAA9C48D,WAAuDA,WAAvD0zB,aAAmEA,aAAej7F,OAAOi7F,cAAgBj7F,OAAOk7F,gBAAhHC,gBAAiIA,gBAAjIC,UAAkJA,UAAlJf,aAA6JA,cAAgBr6F,OAC7Kq7F,iBAAmB1wF,QAAQ9e,UAC3BqkB,UAAY4oF,aAAauC,iBAAkB,aAC3CC,eAAiBxC,aAAauC,iBAAkB,eAChD1qD,cAAgBmoD,aAAauC,iBAAkB,cAC/CE,cAAgBzC,aAAauC,iBAAkB,iBAClB,mBAAxBL,oBAAoC,OACvCQ,SAAW36F,SAASuG,cAAc,YACpCo0F,SAAS7rF,SAAW6rF,SAAS7rF,QAAQ5G,gBACvClI,SAAW26F,SAAS7rF,QAAQ5G,mBAG5B0yF,mBACAC,UAAY,SACVC,eAACA,eAADC,mBAAiBA,mBAAjB9rF,uBAAqCA,uBAArC8J,qBAA6DA,sBAAwB/Y,UACrF+uF,WAACA,YAAciL,qBACjBgB,MAAQ,GACZjB,UAAUztF,YAAiC,mBAAZupF,SAAmD,mBAAlB6E,eAAgCI,qBAAwDjwG,IAAtCiwG,eAAeG,yBAC3HrC,cAACA,cAADC,SAAgBA,SAAhBC,YAA0BA,YAA1BC,UAAuCA,UAAvCC,UAAkDA,UAAlDE,kBAA6DA,kBAA7DC,gBAAgFA,iBAAmBE,gBACpGJ,eAAgBiC,kBAAoB7B,YACrC8B,aAAe,WACbC,qBAAuBzD,SAAS,GAAI,IACrCS,UACAC,SACAC,cACAE,YACA3xF,WAEDw0F,aAAe,WACbC,qBAAuB3D,SAAS,GAAI,IACrCtxF,QACAinB,OACAorE,UACAC,UAED4C,wBAA0B9uG,OAAOsiC,KAAKtiC,OAAO+vC,OAAO,KAAM,CAC5Dg/D,aAAc,CACZC,UAAU,EACVC,cAAc,EACdC,YAAY,EACZluG,MAAO,MAETmuG,mBAAoB,CAClBH,UAAU,EACVC,cAAc,EACdC,YAAY,EACZluG,MAAO,MAETouG,+BAAgC,CAC9BJ,UAAU,EACVC,cAAc,EACdC,YAAY,EACZluG,OAAO,MAGPquG,YAAc,KACdC,YAAc,KACdC,iBAAkB,EAClBC,iBAAkB,EAClBC,yBAA0B,EAC1BC,0BAA2B,EAC3BC,oBAAqB,EACrBC,gBAAiB,EACjBC,YAAa,EACbC,YAAa,EACbC,YAAa,EACbC,qBAAsB,EACtBC,qBAAsB,EACtBC,cAAe,EACfC,sBAAuB,QACrBC,4BAA8B,oBAChCC,cAAe,EACfC,UAAW,EACXC,aAAe,GACfC,gBAAkB,WAChBC,wBAA0BvF,SAAS,GAAI,CAC3C,iBACA,QACA,WACA,OACA,gBACA,OACA,SACA,OACA,KACA,KACA,KACA,KACA,QACA,UACA,WACA,WACA,YACA,SACA,QACA,MACA,WACA,QACA,QACA,QACA,YAEEwF,cAAgB,WACdC,sBAAwBzF,SAAS,GAAI,CACzC,QACA,QACA,MACA,SACA,QACA,cAEE0F,oBAAsB,WACpBC,4BAA8B3F,SAAS,GAAI,CAC/C,MACA,QACA,MACA,KACA,QACA,OACA,UACA,cACA,OACA,UACA,QACA,QACA,QACA,UAEI4F,iBAAmB,qCACnBC,cAAgB,6BAChBC,eAAiB,mCACnBC,UAAYD,eACZE,gBAAiB,EACjBC,mBAAqB,WACnBC,2BAA6BlG,SAAS,GAAI,CAC9C4F,iBACAC,cACAC,gBACC3G,oBACCgH,wBACEC,6BAA+B,CACnC,wBACA,aAEIC,0BAA4B,gBAC9BpG,kBACAqG,OAAS,WACPC,YAAcl+F,SAASuG,cAAc,QACrC43F,kBAAoB,SAA2BC,kB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"}